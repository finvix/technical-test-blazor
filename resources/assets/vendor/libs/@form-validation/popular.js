/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(self, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@form-validation/bundle/lib/cjs/popular.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@form-validation/bundle/lib/cjs/popular.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\n\nvar lib$B = {exports: {}};\n\nvar index_min$B = {};\n\n/** \n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n *\n * @license https://formvalidation.io/license\n * @package @form-validation/core\n * @version 2.4.0\n */\n\nvar hasRequiredIndex_min$B;\n\nfunction requireIndex_min$B () {\n\tif (hasRequiredIndex_min$B) return index_min$B;\n\thasRequiredIndex_min$B = 1;\nvar e={luhn:function(e){for(var t=e.length,i=[[0,1,2,3,4,5,6,7,8,9],[0,2,4,6,8,1,3,5,7,9]],r=0,n=0;t--;)n+=i[r][parseInt(e.charAt(t),10)],r=1-r;return n%10==0&&n>0},mod11And10:function(e){for(var t=e.length,i=5,r=0;r<t;r++)i=(2*(i||10)%11+parseInt(e.charAt(r),10))%10;return 1===i},mod37And36:function(e,t){void 0===t&&(t=\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\");for(var i=e.length,r=t.length,n=Math.floor(r/2),s=0;s<i;s++)n=(2*(n||r)%(r+1)+t.indexOf(e.charAt(s)))%r;return 1===n},mod97And10:function(e){for(var t=function(e){return e.split(\"\").map((function(e){var t=e.charCodeAt(0);return t>=65&&t<=90?t-55:e})).join(\"\").split(\"\").map((function(e){return parseInt(e,10)}))}(e),i=0,r=t.length,n=0;n<r-1;++n)i=10*(i+t[n])%97;return (i+=t[r-1])%97==1},verhoeff:function(e){for(var t=[[0,1,2,3,4,5,6,7,8,9],[1,2,3,4,0,6,7,8,9,5],[2,3,4,0,1,7,8,9,5,6],[3,4,0,1,2,8,9,5,6,7],[4,0,1,2,3,9,5,6,7,8],[5,9,8,7,6,0,4,3,2,1],[6,5,9,8,7,1,0,4,3,2],[7,6,5,9,8,2,1,0,4,3],[8,7,6,5,9,3,2,1,0,4],[9,8,7,6,5,4,3,2,1,0]],i=[[0,1,2,3,4,5,6,7,8,9],[1,5,7,6,2,8,3,0,9,4],[5,8,0,3,7,9,6,1,4,2],[8,9,1,6,0,4,3,5,2,7],[9,4,5,3,1,2,6,8,7,0],[4,2,8,6,5,7,3,9,0,1],[2,7,9,3,8,0,6,4,1,5],[7,0,4,6,9,1,3,2,5,8]],r=e.reverse(),n=0,s=0;s<r.length;s++)n=t[n][i[s%8][r[s]]];return 0===n}};var t=function(){function e(e,t){this.fields={},this.elements={},this.ee={fns:{},clear:function(){this.fns={};},emit:function(e){for(var t=[],i=1;i<arguments.length;i++)t[i-1]=arguments[i];(this.fns[e]||[]).map((function(e){return e.apply(e,t)}));},off:function(e,t){if(this.fns[e]){var i=this.fns[e].indexOf(t);i>=0&&this.fns[e].splice(i,1);}},on:function(e,t){(this.fns[e]=this.fns[e]||[]).push(t);}},this.filter={filters:{},add:function(e,t){(this.filters[e]=this.filters[e]||[]).push(t);},clear:function(){this.filters={};},execute:function(e,t,i){if(!this.filters[e]||!this.filters[e].length)return t;for(var r=t,n=this.filters[e],s=n.length,l=0;l<s;l++)r=n[l].apply(r,i);return r},remove:function(e,t){this.filters[e]&&(this.filters[e]=this.filters[e].filter((function(e){return e!==t})));}},this.plugins={},this.results=new Map,this.validators={},this.form=e,this.fields=t;}return e.prototype.on=function(e,t){return this.ee.on(e,t),this},e.prototype.off=function(e,t){return this.ee.off(e,t),this},e.prototype.emit=function(e){for(var t,i=[],r=1;r<arguments.length;r++)i[r-1]=arguments[r];return (t=this.ee).emit.apply(t,function(e,t,i){if(i||2===arguments.length)for(var r,n=0,s=t.length;n<s;n++)!r&&n in t||(r||(r=Array.prototype.slice.call(t,0,n)),r[n]=t[n]);return e.concat(r||Array.prototype.slice.call(t))}([e],i,!1)),this},e.prototype.registerPlugin=function(e,t){if(this.plugins[e])throw new Error(\"The plguin \".concat(e,\" is registered\"));return t.setCore(this),t.install(),this.plugins[e]=t,this},e.prototype.deregisterPlugin=function(e){var t=this.plugins[e];return t&&t.uninstall(),delete this.plugins[e],this},e.prototype.enablePlugin=function(e){var t=this.plugins[e];return t&&t.enable(),this},e.prototype.disablePlugin=function(e){var t=this.plugins[e];return t&&t.disable(),this},e.prototype.isPluginEnabled=function(e){var t=this.plugins[e];return !!t&&t.isPluginEnabled()},e.prototype.registerValidator=function(e,t){if(this.validators[e])throw new Error(\"The validator \".concat(e,\" is registered\"));return this.validators[e]=t,this},e.prototype.registerFilter=function(e,t){return this.filter.add(e,t),this},e.prototype.deregisterFilter=function(e,t){return this.filter.remove(e,t),this},e.prototype.executeFilter=function(e,t,i){return this.filter.execute(e,t,i)},e.prototype.addField=function(e,t){var i=Object.assign({},{selector:\"\",validators:{}},t);return this.fields[e]=this.fields[e]?{selector:i.selector||this.fields[e].selector,validators:Object.assign({},this.fields[e].validators,i.validators)}:i,this.elements[e]=this.queryElements(e),this.emit(\"core.field.added\",{elements:this.elements[e],field:e,options:this.fields[e]}),this},e.prototype.removeField=function(e){if(!this.fields[e])throw new Error(\"The field \".concat(e,\" validators are not defined. Please ensure the field is added first\"));var t=this.elements[e],i=this.fields[e];return delete this.elements[e],delete this.fields[e],this.emit(\"core.field.removed\",{elements:t,field:e,options:i}),this},e.prototype.validate=function(){var e=this;return this.emit(\"core.form.validating\",{formValidation:this}),this.filter.execute(\"validate-pre\",Promise.resolve(),[]).then((function(){return Promise.all(Object.keys(e.fields).map((function(t){return e.validateField(t)}))).then((function(t){switch(!0){case-1!==t.indexOf(\"Invalid\"):return e.emit(\"core.form.invalid\",{formValidation:e}),Promise.resolve(\"Invalid\");case-1!==t.indexOf(\"NotValidated\"):return e.emit(\"core.form.notvalidated\",{formValidation:e}),Promise.resolve(\"NotValidated\");default:return e.emit(\"core.form.valid\",{formValidation:e}),Promise.resolve(\"Valid\")}}))}))},e.prototype.validateField=function(e){var t=this,i=this.results.get(e);if(\"Valid\"===i||\"Invalid\"===i)return Promise.resolve(i);this.emit(\"core.field.validating\",e);var r=this.elements[e];if(0===r.length)return this.emit(\"core.field.valid\",e),Promise.resolve(\"Valid\");var n=r[0].getAttribute(\"type\");return \"radio\"===n||\"checkbox\"===n||1===r.length?this.validateElement(e,r[0]):Promise.all(r.map((function(i){return t.validateElement(e,i)}))).then((function(i){switch(!0){case-1!==i.indexOf(\"Invalid\"):return t.emit(\"core.field.invalid\",e),t.results.set(e,\"Invalid\"),Promise.resolve(\"Invalid\");case-1!==i.indexOf(\"NotValidated\"):return t.emit(\"core.field.notvalidated\",e),t.results.delete(e),Promise.resolve(\"NotValidated\");default:return t.emit(\"core.field.valid\",e),t.results.set(e,\"Valid\"),Promise.resolve(\"Valid\")}}))},e.prototype.validateElement=function(e,t){var i=this;this.results.delete(e);var r=this.elements[e];if(this.filter.execute(\"element-ignored\",!1,[e,t,r]))return this.emit(\"core.element.ignored\",{element:t,elements:r,field:e}),Promise.resolve(\"Ignored\");var n=this.fields[e].validators;this.emit(\"core.element.validating\",{element:t,elements:r,field:e});var s=Object.keys(n).map((function(r){return function(){return i.executeValidator(e,t,r,n[r])}}));return this.waterfall(s).then((function(n){var s=-1===n.indexOf(\"Invalid\");i.emit(\"core.element.validated\",{element:t,elements:r,field:e,valid:s});var l=t.getAttribute(\"type\");return \"radio\"!==l&&\"checkbox\"!==l&&1!==r.length||i.emit(s?\"core.field.valid\":\"core.field.invalid\",e),Promise.resolve(s?\"Valid\":\"Invalid\")})).catch((function(n){return i.emit(\"core.element.notvalidated\",{element:t,elements:r,field:e}),Promise.resolve(n)}))},e.prototype.executeValidator=function(e,t,i,r){var n=this,s=this.elements[e],l=this.filter.execute(\"validator-name\",i,[i,e]);if(r.message=this.filter.execute(\"validator-message\",r.message,[this.locale,e,l]),!this.validators[l]||!1===r.enabled)return this.emit(\"core.validator.validated\",{element:t,elements:s,field:e,result:this.normalizeResult(e,l,{valid:!0}),validator:l}),Promise.resolve(\"Valid\");var o=this.validators[l],a=this.getElementValue(e,t,l);if(!this.filter.execute(\"field-should-validate\",!0,[e,t,a,i]))return this.emit(\"core.validator.notvalidated\",{element:t,elements:s,field:e,validator:i}),Promise.resolve(\"NotValidated\");this.emit(\"core.validator.validating\",{element:t,elements:s,field:e,validator:i});var d=o().validate({element:t,elements:s,field:e,l10n:this.localization,options:r,value:a});if(\"function\"==typeof d.then)return d.then((function(r){var l=n.normalizeResult(e,i,r);return n.emit(\"core.validator.validated\",{element:t,elements:s,field:e,result:l,validator:i}),l.valid?\"Valid\":\"Invalid\"}));var c=this.normalizeResult(e,i,d);return this.emit(\"core.validator.validated\",{element:t,elements:s,field:e,result:c,validator:i}),Promise.resolve(c.valid?\"Valid\":\"Invalid\")},e.prototype.getElementValue=function(e,t,i){var r=function(e,t,i,r){var n=(i.getAttribute(\"type\")||\"\").toLowerCase(),s=i.tagName.toLowerCase();if(\"textarea\"===s)return i.value;if(\"select\"===s){var l=i,o=l.selectedIndex;return o>=0?l.options.item(o).value:\"\"}if(\"input\"===s){if(\"radio\"===n||\"checkbox\"===n){var a=r.filter((function(e){return e.checked})).length;return 0===a?\"\":a+\"\"}return i.value}return \"\"}(this.form,0,t,this.elements[e]);return this.filter.execute(\"field-value\",r,[r,e,t,i])},e.prototype.getElements=function(e){return this.elements[e]},e.prototype.getFields=function(){return this.fields},e.prototype.getFormElement=function(){return this.form},e.prototype.getLocale=function(){return this.locale},e.prototype.getPlugin=function(e){return this.plugins[e]},e.prototype.updateFieldStatus=function(e,t,i){var r=this,n=this.elements[e],s=n[0].getAttribute(\"type\");if((\"radio\"===s||\"checkbox\"===s?[n[0]]:n).forEach((function(n){return r.updateElementStatus(e,n,t,i)})),i)\"Invalid\"===t&&(this.emit(\"core.field.invalid\",e),this.results.set(e,\"Invalid\"));else switch(t){case\"NotValidated\":this.emit(\"core.field.notvalidated\",e),this.results.delete(e);break;case\"Validating\":this.emit(\"core.field.validating\",e),this.results.delete(e);break;case\"Valid\":this.emit(\"core.field.valid\",e),this.results.set(e,\"Valid\");break;case\"Invalid\":this.emit(\"core.field.invalid\",e),this.results.set(e,\"Invalid\");}return this},e.prototype.updateElementStatus=function(e,t,i,r){var n=this,s=this.elements[e],l=this.fields[e].validators,o=r?[r]:Object.keys(l);switch(i){case\"NotValidated\":o.forEach((function(i){return n.emit(\"core.validator.notvalidated\",{element:t,elements:s,field:e,validator:i})})),this.emit(\"core.element.notvalidated\",{element:t,elements:s,field:e});break;case\"Validating\":o.forEach((function(i){return n.emit(\"core.validator.validating\",{element:t,elements:s,field:e,validator:i})})),this.emit(\"core.element.validating\",{element:t,elements:s,field:e});break;case\"Valid\":o.forEach((function(i){return n.emit(\"core.validator.validated\",{element:t,elements:s,field:e,result:{message:l[i].message,valid:!0},validator:i})})),this.emit(\"core.element.validated\",{element:t,elements:s,field:e,valid:!0});break;case\"Invalid\":o.forEach((function(i){return n.emit(\"core.validator.validated\",{element:t,elements:s,field:e,result:{message:l[i].message,valid:!1},validator:i})})),this.emit(\"core.element.validated\",{element:t,elements:s,field:e,valid:!1});}return this},e.prototype.resetForm=function(e){var t=this;return Object.keys(this.fields).forEach((function(i){return t.resetField(i,e)})),this.emit(\"core.form.reset\",{formValidation:this,reset:e}),this},e.prototype.resetField=function(e,t){if(t){var i=this.elements[e],r=i[0].getAttribute(\"type\");i.forEach((function(e){\"radio\"===r||\"checkbox\"===r?(e.removeAttribute(\"selected\"),e.removeAttribute(\"checked\"),e.checked=!1):(e.setAttribute(\"value\",\"\"),(e instanceof HTMLInputElement||e instanceof HTMLTextAreaElement)&&(e.value=\"\"));}));}return this.updateFieldStatus(e,\"NotValidated\"),this.emit(\"core.field.reset\",{field:e,reset:t}),this},e.prototype.revalidateField=function(e){return this.fields[e]?(this.updateFieldStatus(e,\"NotValidated\"),this.validateField(e)):Promise.resolve(\"Ignored\")},e.prototype.disableValidator=function(e,t){if(!this.fields[e])return this;var i=this.elements[e];return this.toggleValidator(!1,e,t),this.emit(\"core.validator.disabled\",{elements:i,field:e,formValidation:this,validator:t}),this},e.prototype.enableValidator=function(e,t){if(!this.fields[e])return this;var i=this.elements[e];return this.toggleValidator(!0,e,t),this.emit(\"core.validator.enabled\",{elements:i,field:e,formValidation:this,validator:t}),this},e.prototype.updateValidatorOption=function(e,t,i,r){return this.fields[e]&&this.fields[e].validators&&this.fields[e].validators[t]&&(this.fields[e].validators[t][i]=r),this},e.prototype.setFieldOptions=function(e,t){return this.fields[e]=t,this},e.prototype.destroy=function(){var e=this;return Object.keys(this.plugins).forEach((function(t){return e.plugins[t].uninstall()})),this.ee.clear(),this.filter.clear(),this.results.clear(),this.plugins={},this},e.prototype.setLocale=function(e,t){return this.locale=e,this.localization=t,this},e.prototype.waterfall=function(e){return e.reduce((function(e,t){return e.then((function(e){return t().then((function(t){return e.push(t),e}))}))}),Promise.resolve([]))},e.prototype.queryElements=function(e){var t=this.fields[e].selector?\"#\"===this.fields[e].selector.charAt(0)?'[id=\"'.concat(this.fields[e].selector.substring(1),'\"]'):this.fields[e].selector:'[name=\"'.concat(e.replace(/\"/g,'\\\\\"'),'\"]');return [].slice.call(this.form.querySelectorAll(t))},e.prototype.normalizeResult=function(e,t,i){var r=this.fields[e].validators[t];return Object.assign({},i,{message:i.message||(r?r.message:\"\")||(this.localization&&this.localization[t]&&this.localization[t].default?this.localization[t].default:\"\")||\"The field \".concat(e,\" is not valid\")})},e.prototype.toggleValidator=function(e,t,i){var r=this,n=this.fields[t].validators;return i&&n&&n[i]?this.fields[t].validators[i].enabled=e:i||Object.keys(n).forEach((function(i){return r.fields[t].validators[i].enabled=e})),this.updateFieldStatus(t,\"NotValidated\",i)},e}();var i=function(){function e(e){this.opts=e,this.isEnabled=!0;}return e.prototype.setCore=function(e){return this.core=e,this},e.prototype.enable=function(){return this.isEnabled=!0,this.onEnabled(),this},e.prototype.disable=function(){return this.isEnabled=!1,this.onDisabled(),this},e.prototype.isPluginEnabled=function(){return this.isEnabled},e.prototype.onEnabled=function(){},e.prototype.onDisabled=function(){},e.prototype.install=function(){},e.prototype.uninstall=function(){},e}();var r=function(e,t){var i=e.matches||e.webkitMatchesSelector||e.mozMatchesSelector||e.msMatchesSelector;return i?i.call(e,t):[].slice.call(e.parentElement.querySelectorAll(t)).indexOf(e)>=0},n={call:function(e,t){if(\"function\"==typeof e)return e.apply(this,t);if(\"string\"==typeof e){var i=e;\"()\"===i.substring(i.length-2)&&(i=i.substring(0,i.length-2));for(var r=i.split(\".\"),n=r.pop(),s=window,l=0,o=r;l<o.length;l++){s=s[o[l]];}return void 0===s[n]?null:s[n].apply(this,t)}},classSet:function(e,t){var i=[],r=[];Object.keys(t).forEach((function(e){e&&(t[e]?i.push(e):r.push(e));})),r.forEach((function(t){return function(e,t){t.split(\" \").forEach((function(t){e.classList?e.classList.remove(t):e.className=e.className.replace(t,\"\");}));}(e,t)})),i.forEach((function(t){return function(e,t){t.split(\" \").forEach((function(t){e.classList?e.classList.add(t):\" \".concat(e.className,\" \").indexOf(\" \".concat(t,\" \"))&&(e.className+=\" \".concat(t));}));}(e,t)}));},closest:function(e,t){for(var i=e;i&&!r(i,t);)i=i.parentElement;return i},fetch:function(e,t){return new Promise((function(i,r){var n,s=Object.assign({},{crossDomain:!1,headers:{},method:\"GET\",params:{}},t),l=Object.keys(s.params).map((function(e){return \"\".concat(encodeURIComponent(e),\"=\").concat(encodeURIComponent(s.params[e]))})).join(\"&\"),o=e.indexOf(\"?\")>-1,a=\"GET\"===s.method?\"\".concat(e).concat(o?\"&\":\"?\").concat(l):e;if(s.crossDomain){var d=document.createElement(\"script\"),c=\"___FormValidationFetch_\".concat(Array(12).fill(\"\").map((function(e){return Math.random().toString(36).charAt(2)})).join(\"\"),\"___\");window[c]=function(e){delete window[c],i(e);},d.src=\"\".concat(a).concat(o?\"&\":\"?\",\"callback=\").concat(c),d.async=!0,d.addEventListener(\"load\",(function(){d.parentNode.removeChild(d);})),d.addEventListener(\"error\",(function(){return r})),document.head.appendChild(d);}else {var u=new XMLHttpRequest;u.open(s.method,a),u.setRequestHeader(\"X-Requested-With\",\"XMLHttpRequest\"),\"POST\"===s.method&&u.setRequestHeader(\"Content-Type\",\"application/x-www-form-urlencoded\"),Object.keys(s.headers).forEach((function(e){return u.setRequestHeader(e,s.headers[e])})),u.addEventListener(\"load\",(function(){i(JSON.parse(this.responseText));})),u.addEventListener(\"error\",(function(){return r})),u.send((n=s.params,Object.keys(n).map((function(e){return \"\".concat(encodeURIComponent(e),\"=\").concat(encodeURIComponent(n[e]))})).join(\"&\")));}}))},format:function(e,t){var i=Array.isArray(t)?t:[t],r=e;return i.forEach((function(e){r=r.replace(\"%s\",e);})),r},hasClass:function(e,t){return e.classList?e.classList.contains(t):new RegExp(\"(^| )\".concat(t,\"( |$)\"),\"gi\").test(e.className)},isValidDate:function(e,t,i,r){if(isNaN(e)||isNaN(t)||isNaN(i))return !1;if(e<1e3||e>9999||t<=0||t>12)return !1;if(i<=0||i>[31,e%400==0||e%100!=0&&e%4==0?29:28,31,30,31,30,31,31,30,31,30,31][t-1])return !1;if(!0===r){var n=new Date,s=n.getFullYear(),l=n.getMonth(),o=n.getDate();return e<s||e===s&&t-1<l||e===s&&t-1===l&&i<o}return !0},removeUndefined:function(e){return e?Object.entries(e).reduce((function(e,t){var i=t[0],r=t[1];return void 0===r||(e[i]=r),e}),{}):{}}};index_min$B.Plugin=i,index_min$B.algorithms=e,index_min$B.formValidation=function(e,i){var r=Object.assign({},{fields:{},locale:\"en_US\",plugins:{},init:function(e){}},i),n=new t(e,r.fields);return n.setLocale(r.locale,r.localization),Object.keys(r.plugins).forEach((function(e){return n.registerPlugin(e,r.plugins[e])})),r.init(n),Object.keys(r.fields).forEach((function(e){return n.addField(e,r.fields[e])})),n},index_min$B.utils=n;\n\treturn index_min$B;\n}\n\nvar cjs$B = {};\n\nvar hasRequiredCjs$B;\n\nfunction requireCjs$B () {\n\tif (hasRequiredCjs$B) return cjs$B;\n\thasRequiredCjs$B = 1;\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\t/**\n\t * Implement Luhn validation algorithm\n\t * Credit to https://gist.github.com/ShirtlessKirk/2134376\n\t *\n\t * @see http://en.wikipedia.org/wiki/Luhn\n\t * @param {string} value\n\t * @returns {boolean}\n\t */\n\tfunction luhn(value) {\n\t    var length = value.length;\n\t    var prodArr = [\n\t        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],\n\t        [0, 2, 4, 6, 8, 1, 3, 5, 7, 9],\n\t    ];\n\t    var mul = 0;\n\t    var sum = 0;\n\t    while (length--) {\n\t        sum += prodArr[mul][parseInt(value.charAt(length), 10)];\n\t        mul = 1 - mul;\n\t    }\n\t    return sum % 10 === 0 && sum > 0;\n\t}\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\t/**\n\t * Implement modulus 11, 10 (ISO 7064) algorithm\n\t *\n\t * @param {string} value\n\t * @returns {boolean}\n\t */\n\tfunction mod11And10(value) {\n\t    var length = value.length;\n\t    var check = 5;\n\t    for (var i = 0; i < length; i++) {\n\t        check = ((((check || 10) * 2) % 11) + parseInt(value.charAt(i), 10)) % 10;\n\t    }\n\t    return check === 1;\n\t}\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\t/**\n\t * Implements Mod 37, 36 (ISO 7064) algorithm\n\t *\n\t * @param {string} value\n\t * @param {string} [alphabet]\n\t * @returns {boolean}\n\t */\n\tfunction mod37And36(value, alphabet) {\n\t    if (alphabet === void 0) { alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; }\n\t    var length = value.length;\n\t    var modulus = alphabet.length;\n\t    var check = Math.floor(modulus / 2);\n\t    for (var i = 0; i < length; i++) {\n\t        check = ((((check || modulus) * 2) % (modulus + 1)) + alphabet.indexOf(value.charAt(i))) % modulus;\n\t    }\n\t    return check === 1;\n\t}\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\tfunction transform(input) {\n\t    return input\n\t        .split('')\n\t        .map(function (c) {\n\t        var code = c.charCodeAt(0);\n\t        // 65, 66, ..., 90 are the char code of A, B, ..., Z\n\t        return code >= 65 && code <= 90\n\t            ? // Replace A, B, C, ..., Z with 10, 11, ..., 35\n\t                code - 55\n\t            : c;\n\t    })\n\t        .join('')\n\t        .split('')\n\t        .map(function (c) { return parseInt(c, 10); });\n\t}\n\tfunction mod97And10(input) {\n\t    var digits = transform(input);\n\t    var temp = 0;\n\t    var length = digits.length;\n\t    for (var i = 0; i < length - 1; ++i) {\n\t        temp = ((temp + digits[i]) * 10) % 97;\n\t    }\n\t    temp += digits[length - 1];\n\t    return temp % 97 === 1;\n\t}\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\t/**\n\t * Implement Verhoeff validation algorithm\n\t * Credit to Sergey Petushkov, 2014\n\t *\n\t * @see https://en.wikipedia.org/wiki/Verhoeff_algorithm\n\t * @param {string} value\n\t * @returns {boolean}\n\t */\n\tfunction verhoeff(value) {\n\t    // Multiplication table d\n\t    var d = [\n\t        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],\n\t        [1, 2, 3, 4, 0, 6, 7, 8, 9, 5],\n\t        [2, 3, 4, 0, 1, 7, 8, 9, 5, 6],\n\t        [3, 4, 0, 1, 2, 8, 9, 5, 6, 7],\n\t        [4, 0, 1, 2, 3, 9, 5, 6, 7, 8],\n\t        [5, 9, 8, 7, 6, 0, 4, 3, 2, 1],\n\t        [6, 5, 9, 8, 7, 1, 0, 4, 3, 2],\n\t        [7, 6, 5, 9, 8, 2, 1, 0, 4, 3],\n\t        [8, 7, 6, 5, 9, 3, 2, 1, 0, 4],\n\t        [9, 8, 7, 6, 5, 4, 3, 2, 1, 0],\n\t    ];\n\t    // Permutation table p\n\t    var p = [\n\t        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],\n\t        [1, 5, 7, 6, 2, 8, 3, 0, 9, 4],\n\t        [5, 8, 0, 3, 7, 9, 6, 1, 4, 2],\n\t        [8, 9, 1, 6, 0, 4, 3, 5, 2, 7],\n\t        [9, 4, 5, 3, 1, 2, 6, 8, 7, 0],\n\t        [4, 2, 8, 6, 5, 7, 3, 9, 0, 1],\n\t        [2, 7, 9, 3, 8, 0, 6, 4, 1, 5],\n\t        [7, 0, 4, 6, 9, 1, 3, 2, 5, 8],\n\t    ];\n\t    // Inverse table inv\n\t    var invertedArray = value.reverse();\n\t    var c = 0;\n\t    for (var i = 0; i < invertedArray.length; i++) {\n\t        c = d[c][p[i % 8][invertedArray[i]]];\n\t    }\n\t    return c === 0;\n\t}\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\tvar index$1 = {\n\t    luhn: luhn,\n\t    mod11And10: mod11And10,\n\t    mod37And36: mod37And36,\n\t    mod97And10: mod97And10,\n\t    verhoeff: verhoeff,\n\t};\n\n\t/******************************************************************************\r\n\tCopyright (c) Microsoft Corporation.\r\n\r\n\tPermission to use, copy, modify, and/or distribute this software for any\r\n\tpurpose with or without fee is hereby granted.\r\n\r\n\tTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n\tREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n\tAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n\tINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n\tLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n\tOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n\tPERFORMANCE OF THIS SOFTWARE.\r\n\t***************************************************************************** */\r\n\t/* global Reflect, Promise */\r\n\r\n\r\n\tfunction __spreadArray(to, from, pack) {\r\n\t    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n\t        if (ar || !(i in from)) {\r\n\t            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n\t            ar[i] = from[i];\r\n\t        }\r\n\t    }\r\n\t    return to.concat(ar || Array.prototype.slice.call(from));\r\n\t}\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\t/**\n\t * @param {HTMLElement} form The form element\n\t * @param {string} field The field name\n\t * @param {HTMLElement} element The field element\n\t * @param {HTMLElement[]} elements The list of elements which have the same name as `field`\n\t * @return {string}\n\t */\n\tfunction getFieldValue(form, field, element, elements) {\n\t    var type = (element.getAttribute('type') || '').toLowerCase();\n\t    var tagName = element.tagName.toLowerCase();\n\t    if (tagName === 'textarea') {\n\t        return element.value;\n\t    }\n\t    if (tagName === 'select') {\n\t        var select = element;\n\t        var index = select.selectedIndex;\n\t        return index >= 0 ? select.options.item(index).value : '';\n\t    }\n\t    if (tagName === 'input') {\n\t        if ('radio' === type || 'checkbox' === type) {\n\t            var checked = elements.filter(function (ele) { return ele.checked; }).length;\n\t            return checked === 0 ? '' : checked + '';\n\t        }\n\t        else {\n\t            return element.value;\n\t        }\n\t    }\n\t    return '';\n\t}\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\tfunction emitter() {\n\t    return {\n\t        fns: {},\n\t        clear: function () {\n\t            this.fns = {};\n\t        },\n\t        emit: function (event) {\n\t            var args = [];\n\t            for (var _i = 1; _i < arguments.length; _i++) {\n\t                args[_i - 1] = arguments[_i];\n\t            }\n\t            (this.fns[event] || []).map(function (handler) { return handler.apply(handler, args); });\n\t        },\n\t        off: function (event, func) {\n\t            if (this.fns[event]) {\n\t                var index = this.fns[event].indexOf(func);\n\t                if (index >= 0) {\n\t                    this.fns[event].splice(index, 1);\n\t                }\n\t            }\n\t        },\n\t        on: function (event, func) {\n\t            (this.fns[event] = this.fns[event] || []).push(func);\n\t        },\n\t    };\n\t}\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\tfunction filter() {\n\t    return {\n\t        filters: {},\n\t        add: function (name, func) {\n\t            (this.filters[name] = this.filters[name] || []).push(func);\n\t        },\n\t        clear: function () {\n\t            this.filters = {};\n\t        },\n\t        execute: function (name, defaultValue, args) {\n\t            if (!this.filters[name] || !this.filters[name].length) {\n\t                return defaultValue;\n\t            }\n\t            var result = defaultValue;\n\t            var filters = this.filters[name];\n\t            var count = filters.length;\n\t            for (var i = 0; i < count; i++) {\n\t                result = filters[i].apply(result, args);\n\t            }\n\t            return result;\n\t        },\n\t        remove: function (name, func) {\n\t            if (this.filters[name]) {\n\t                this.filters[name] = this.filters[name].filter(function (f) { return f !== func; });\n\t            }\n\t        },\n\t    };\n\t}\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\tvar Core = /** @class */ (function () {\n\t    function Core(form, fields) {\n\t        this.fields = {};\n\t        this.elements = {};\n\t        this.ee = emitter();\n\t        this.filter = filter();\n\t        this.plugins = {};\n\t        // Store the result of validation for each field\n\t        this.results = new Map();\n\t        this.validators = {};\n\t        this.form = form;\n\t        this.fields = fields;\n\t    }\n\t    Core.prototype.on = function (event, func) {\n\t        this.ee.on(event, func);\n\t        return this;\n\t    };\n\t    Core.prototype.off = function (event, func) {\n\t        this.ee.off(event, func);\n\t        return this;\n\t    };\n\t    Core.prototype.emit = function (event) {\n\t        var _a;\n\t        var args = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            args[_i - 1] = arguments[_i];\n\t        }\n\t        (_a = this.ee).emit.apply(_a, __spreadArray([event], args, false));\n\t        return this;\n\t    };\n\t    Core.prototype.registerPlugin = function (name, plugin) {\n\t        // Check if whether the plugin is registered\n\t        if (this.plugins[name]) {\n\t            throw new Error(\"The plguin \".concat(name, \" is registered\"));\n\t        }\n\t        // Install the plugin\n\t        plugin.setCore(this);\n\t        plugin.install();\n\t        this.plugins[name] = plugin;\n\t        return this;\n\t    };\n\t    Core.prototype.deregisterPlugin = function (name) {\n\t        var plugin = this.plugins[name];\n\t        if (plugin) {\n\t            plugin.uninstall();\n\t        }\n\t        delete this.plugins[name];\n\t        return this;\n\t    };\n\t    Core.prototype.enablePlugin = function (name) {\n\t        var plugin = this.plugins[name];\n\t        if (plugin) {\n\t            plugin.enable();\n\t        }\n\t        return this;\n\t    };\n\t    Core.prototype.disablePlugin = function (name) {\n\t        var plugin = this.plugins[name];\n\t        if (plugin) {\n\t            plugin.disable();\n\t        }\n\t        return this;\n\t    };\n\t    Core.prototype.isPluginEnabled = function (name) {\n\t        var plugin = this.plugins[name];\n\t        return plugin ? plugin.isPluginEnabled() : false;\n\t    };\n\t    Core.prototype.registerValidator = function (name, func) {\n\t        if (this.validators[name]) {\n\t            throw new Error(\"The validator \".concat(name, \" is registered\"));\n\t        }\n\t        this.validators[name] = func;\n\t        return this;\n\t    };\n\t    /**\n\t     * Add a filter\n\t     *\n\t     * @param {string} name The name of filter\n\t     * @param {Function} func The filter function\n\t     * @return {Core}\n\t     */\n\t    Core.prototype.registerFilter = function (name, func) {\n\t        this.filter.add(name, func);\n\t        return this;\n\t    };\n\t    /**\n\t     * Remove a filter\n\t     *\n\t     * @param {string} name The name of filter\n\t     * @param {Function} func The filter function\n\t     * @return {Core}\n\t     */\n\t    Core.prototype.deregisterFilter = function (name, func) {\n\t        this.filter.remove(name, func);\n\t        return this;\n\t    };\n\t    /**\n\t     * Execute a filter\n\t     *\n\t     * @param {string} name The name of filter\n\t     * @param {T} defaultValue The default value returns by the filter\n\t     * @param {array} args The filter arguments\n\t     * @returns {T}\n\t     */\n\t    Core.prototype.executeFilter = function (name, defaultValue, args) {\n\t        return this.filter.execute(name, defaultValue, args);\n\t    };\n\t    /**\n\t     * Add a field\n\t     *\n\t     * @param {string} field The field name\n\t     * @param {FieldOptions} options The field options. The options will be merged with the original validator rules\n\t     * if the field is already defined\n\t     * @return {Core}\n\t     */\n\t    Core.prototype.addField = function (field, options) {\n\t        var opts = Object.assign({}, {\n\t            selector: '',\n\t            validators: {},\n\t        }, options);\n\t        // Merge the options\n\t        this.fields[field] = this.fields[field]\n\t            ? {\n\t                selector: opts.selector || this.fields[field].selector,\n\t                validators: Object.assign({}, this.fields[field].validators, opts.validators),\n\t            }\n\t            : opts;\n\t        this.elements[field] = this.queryElements(field);\n\t        this.emit('core.field.added', {\n\t            elements: this.elements[field],\n\t            field: field,\n\t            options: this.fields[field],\n\t        });\n\t        return this;\n\t    };\n\t    /**\n\t     * Remove given field by name\n\t     *\n\t     * @param {string} field The field name\n\t     * @return {Core}\n\t     */\n\t    Core.prototype.removeField = function (field) {\n\t        if (!this.fields[field]) {\n\t            throw new Error(\"The field \".concat(field, \" validators are not defined. Please ensure the field is added first\"));\n\t        }\n\t        var elements = this.elements[field];\n\t        var options = this.fields[field];\n\t        delete this.elements[field];\n\t        delete this.fields[field];\n\t        this.emit('core.field.removed', {\n\t            elements: elements,\n\t            field: field,\n\t            options: options,\n\t        });\n\t        return this;\n\t    };\n\t    /**\n\t     * Validate all fields\n\t     *\n\t     * @return {Promise<string>}\n\t     */\n\t    Core.prototype.validate = function () {\n\t        var _this = this;\n\t        this.emit('core.form.validating', {\n\t            formValidation: this,\n\t        });\n\t        return this.filter.execute('validate-pre', Promise.resolve(), []).then(function () {\n\t            return Promise.all(Object.keys(_this.fields).map(function (field) { return _this.validateField(field); })).then(function (results) {\n\t                // `results` is an array of `Valid`, `Invalid` and `NotValidated`\n\t                switch (true) {\n\t                    case results.indexOf('Invalid') !== -1:\n\t                        _this.emit('core.form.invalid', {\n\t                            formValidation: _this,\n\t                        });\n\t                        return Promise.resolve('Invalid');\n\t                    case results.indexOf('NotValidated') !== -1:\n\t                        _this.emit('core.form.notvalidated', {\n\t                            formValidation: _this,\n\t                        });\n\t                        return Promise.resolve('NotValidated');\n\t                    default:\n\t                        _this.emit('core.form.valid', {\n\t                            formValidation: _this,\n\t                        });\n\t                        return Promise.resolve('Valid');\n\t                }\n\t            });\n\t        });\n\t    };\n\t    /**\n\t     * Validate a particular field\n\t     *\n\t     * @param {string} field The field name\n\t     * @return {Promise<string>}\n\t     */\n\t    Core.prototype.validateField = function (field) {\n\t        var _this = this;\n\t        // Stop validation process if the field is already validated\n\t        var result = this.results.get(field);\n\t        if (result === 'Valid' || result === 'Invalid') {\n\t            return Promise.resolve(result);\n\t        }\n\t        this.emit('core.field.validating', field);\n\t        var elements = this.elements[field];\n\t        if (elements.length === 0) {\n\t            this.emit('core.field.valid', field);\n\t            return Promise.resolve('Valid');\n\t        }\n\t        var type = elements[0].getAttribute('type');\n\t        if ('radio' === type || 'checkbox' === type || elements.length === 1) {\n\t            return this.validateElement(field, elements[0]);\n\t        }\n\t        else {\n\t            return Promise.all(elements.map(function (ele) { return _this.validateElement(field, ele); })).then(function (results) {\n\t                // `results` is an array of `Valid`, `Invalid` and `NotValidated`\n\t                switch (true) {\n\t                    case results.indexOf('Invalid') !== -1:\n\t                        _this.emit('core.field.invalid', field);\n\t                        _this.results.set(field, 'Invalid');\n\t                        return Promise.resolve('Invalid');\n\t                    case results.indexOf('NotValidated') !== -1:\n\t                        _this.emit('core.field.notvalidated', field);\n\t                        _this.results.delete(field);\n\t                        return Promise.resolve('NotValidated');\n\t                    default:\n\t                        _this.emit('core.field.valid', field);\n\t                        _this.results.set(field, 'Valid');\n\t                        return Promise.resolve('Valid');\n\t                }\n\t            });\n\t        }\n\t    };\n\t    /**\n\t     * Validate particular element\n\t     *\n\t     * @param {string} field The field name\n\t     * @param {HTMLElement} ele The field element\n\t     * @return {Promise<string>}\n\t     */\n\t    Core.prototype.validateElement = function (field, ele) {\n\t        var _this = this;\n\t        // Reset validation result\n\t        this.results.delete(field);\n\t        var elements = this.elements[field];\n\t        var ignored = this.filter.execute('element-ignored', false, [field, ele, elements]);\n\t        if (ignored) {\n\t            this.emit('core.element.ignored', {\n\t                element: ele,\n\t                elements: elements,\n\t                field: field,\n\t            });\n\t            return Promise.resolve('Ignored');\n\t        }\n\t        var validatorList = this.fields[field].validators;\n\t        this.emit('core.element.validating', {\n\t            element: ele,\n\t            elements: elements,\n\t            field: field,\n\t        });\n\t        var promises = Object.keys(validatorList).map(function (v) {\n\t            return function () { return _this.executeValidator(field, ele, v, validatorList[v]); };\n\t        });\n\t        return this.waterfall(promises)\n\t            .then(function (results) {\n\t            // `results` is an array of `Valid` or `Invalid`\n\t            var isValid = results.indexOf('Invalid') === -1;\n\t            _this.emit('core.element.validated', {\n\t                element: ele,\n\t                elements: elements,\n\t                field: field,\n\t                valid: isValid,\n\t            });\n\t            var type = ele.getAttribute('type');\n\t            if ('radio' === type || 'checkbox' === type || elements.length === 1) {\n\t                _this.emit(isValid ? 'core.field.valid' : 'core.field.invalid', field);\n\t            }\n\t            return Promise.resolve(isValid ? 'Valid' : 'Invalid');\n\t        })\n\t            .catch(function (reason) {\n\t            // reason is `NotValidated`\n\t            _this.emit('core.element.notvalidated', {\n\t                element: ele,\n\t                elements: elements,\n\t                field: field,\n\t            });\n\t            return Promise.resolve(reason);\n\t        });\n\t    };\n\t    /**\n\t     * Perform given validator on field\n\t     *\n\t     * @param {string} field The field name\n\t     * @param {HTMLElement} ele The field element\n\t     * @param {string} v The validator name\n\t     * @param {ValidatorOptions} opts The validator options\n\t     * @return {Promise<string>}\n\t     */\n\t    Core.prototype.executeValidator = function (field, ele, v, opts) {\n\t        var _this = this;\n\t        var elements = this.elements[field];\n\t        var name = this.filter.execute('validator-name', v, [v, field]);\n\t        opts.message = this.filter.execute('validator-message', opts.message, [this.locale, field, name]);\n\t        // Simply pass the validator if\n\t        // - it isn't defined yet\n\t        // - or the associated validator isn't enabled\n\t        if (!this.validators[name] || opts.enabled === false) {\n\t            this.emit('core.validator.validated', {\n\t                element: ele,\n\t                elements: elements,\n\t                field: field,\n\t                result: this.normalizeResult(field, name, { valid: true }),\n\t                validator: name,\n\t            });\n\t            return Promise.resolve('Valid');\n\t        }\n\t        var validator = this.validators[name];\n\t        // Get the field value\n\t        var value = this.getElementValue(field, ele, name);\n\t        var willValidate = this.filter.execute('field-should-validate', true, [field, ele, value, v]);\n\t        if (!willValidate) {\n\t            this.emit('core.validator.notvalidated', {\n\t                element: ele,\n\t                elements: elements,\n\t                field: field,\n\t                validator: v,\n\t            });\n\t            return Promise.resolve('NotValidated');\n\t        }\n\t        this.emit('core.validator.validating', {\n\t            element: ele,\n\t            elements: elements,\n\t            field: field,\n\t            validator: v,\n\t        });\n\t        // Perform validation\n\t        var result = validator().validate({\n\t            element: ele,\n\t            elements: elements,\n\t            field: field,\n\t            l10n: this.localization,\n\t            options: opts,\n\t            value: value,\n\t        });\n\t        // Check whether the result is a `Promise`\n\t        var isPromise = 'function' === typeof result['then'];\n\t        if (isPromise) {\n\t            return result.then(function (r) {\n\t                var data = _this.normalizeResult(field, v, r);\n\t                _this.emit('core.validator.validated', {\n\t                    element: ele,\n\t                    elements: elements,\n\t                    field: field,\n\t                    result: data,\n\t                    validator: v,\n\t                });\n\t                return data.valid ? 'Valid' : 'Invalid';\n\t            });\n\t        }\n\t        else {\n\t            var data = this.normalizeResult(field, v, result);\n\t            this.emit('core.validator.validated', {\n\t                element: ele,\n\t                elements: elements,\n\t                field: field,\n\t                result: data,\n\t                validator: v,\n\t            });\n\t            return Promise.resolve(data.valid ? 'Valid' : 'Invalid');\n\t        }\n\t    };\n\t    Core.prototype.getElementValue = function (field, ele, validator) {\n\t        var defaultValue = getFieldValue(this.form, field, ele, this.elements[field]);\n\t        return this.filter.execute('field-value', defaultValue, [defaultValue, field, ele, validator]);\n\t    };\n\t    // Some getter methods\n\t    Core.prototype.getElements = function (field) {\n\t        return this.elements[field];\n\t    };\n\t    Core.prototype.getFields = function () {\n\t        return this.fields;\n\t    };\n\t    Core.prototype.getFormElement = function () {\n\t        return this.form;\n\t    };\n\t    Core.prototype.getLocale = function () {\n\t        return this.locale;\n\t    };\n\t    Core.prototype.getPlugin = function (name) {\n\t        return this.plugins[name];\n\t    };\n\t    /**\n\t     * Update the field status\n\t     *\n\t     * @param {string} field The field name\n\t     * @param {string} status The new status\n\t     * @param {string} [validator] The validator name. If it isn't specified, all validators will be updated\n\t     * @return {Core}\n\t     */\n\t    Core.prototype.updateFieldStatus = function (field, status, validator) {\n\t        var _this = this;\n\t        var elements = this.elements[field];\n\t        var type = elements[0].getAttribute('type');\n\t        var list = 'radio' === type || 'checkbox' === type ? [elements[0]] : elements;\n\t        list.forEach(function (ele) { return _this.updateElementStatus(field, ele, status, validator); });\n\t        if (!validator) {\n\t            switch (status) {\n\t                case 'NotValidated':\n\t                    this.emit('core.field.notvalidated', field);\n\t                    this.results.delete(field);\n\t                    break;\n\t                case 'Validating':\n\t                    this.emit('core.field.validating', field);\n\t                    this.results.delete(field);\n\t                    break;\n\t                case 'Valid':\n\t                    this.emit('core.field.valid', field);\n\t                    this.results.set(field, 'Valid');\n\t                    break;\n\t                case 'Invalid':\n\t                    this.emit('core.field.invalid', field);\n\t                    this.results.set(field, 'Invalid');\n\t                    break;\n\t            }\n\t        }\n\t        else if (status === 'Invalid') {\n\t            // We need to mark the field as invalid because it doesn't pass the `validator`\n\t            this.emit('core.field.invalid', field);\n\t            this.results.set(field, 'Invalid');\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t     * Update the element status\n\t     *\n\t     * @param {string} field The field name\n\t     * @param {HTMLElement} ele The field element\n\t     * @param {string} status The new status\n\t     * @param {string} [validator] The validator name. If it isn't specified, all validators will be updated\n\t     * @return {Core}\n\t     */\n\t    Core.prototype.updateElementStatus = function (field, ele, status, validator) {\n\t        var _this = this;\n\t        var elements = this.elements[field];\n\t        var fieldValidators = this.fields[field].validators;\n\t        var validatorArr = validator ? [validator] : Object.keys(fieldValidators);\n\t        switch (status) {\n\t            case 'NotValidated':\n\t                validatorArr.forEach(function (v) {\n\t                    return _this.emit('core.validator.notvalidated', {\n\t                        element: ele,\n\t                        elements: elements,\n\t                        field: field,\n\t                        validator: v,\n\t                    });\n\t                });\n\t                this.emit('core.element.notvalidated', {\n\t                    element: ele,\n\t                    elements: elements,\n\t                    field: field,\n\t                });\n\t                break;\n\t            case 'Validating':\n\t                validatorArr.forEach(function (v) {\n\t                    return _this.emit('core.validator.validating', {\n\t                        element: ele,\n\t                        elements: elements,\n\t                        field: field,\n\t                        validator: v,\n\t                    });\n\t                });\n\t                this.emit('core.element.validating', {\n\t                    element: ele,\n\t                    elements: elements,\n\t                    field: field,\n\t                });\n\t                break;\n\t            case 'Valid':\n\t                validatorArr.forEach(function (v) {\n\t                    return _this.emit('core.validator.validated', {\n\t                        element: ele,\n\t                        elements: elements,\n\t                        field: field,\n\t                        result: {\n\t                            message: fieldValidators[v].message,\n\t                            valid: true,\n\t                        },\n\t                        validator: v,\n\t                    });\n\t                });\n\t                this.emit('core.element.validated', {\n\t                    element: ele,\n\t                    elements: elements,\n\t                    field: field,\n\t                    valid: true,\n\t                });\n\t                break;\n\t            case 'Invalid':\n\t                validatorArr.forEach(function (v) {\n\t                    return _this.emit('core.validator.validated', {\n\t                        element: ele,\n\t                        elements: elements,\n\t                        field: field,\n\t                        result: {\n\t                            message: fieldValidators[v].message,\n\t                            valid: false,\n\t                        },\n\t                        validator: v,\n\t                    });\n\t                });\n\t                this.emit('core.element.validated', {\n\t                    element: ele,\n\t                    elements: elements,\n\t                    field: field,\n\t                    valid: false,\n\t                });\n\t                break;\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t     * Reset the form. It also clears all the messages, hide the feedback icons, etc.\n\t     *\n\t     * @param {boolean} reset If true, the method resets field value to empty\n\t     * or remove `checked`, `selected` attributes\n\t     * @return {Core}\n\t     */\n\t    Core.prototype.resetForm = function (reset) {\n\t        var _this = this;\n\t        Object.keys(this.fields).forEach(function (field) { return _this.resetField(field, reset); });\n\t        this.emit('core.form.reset', {\n\t            formValidation: this,\n\t            reset: reset,\n\t        });\n\t        return this;\n\t    };\n\t    /**\n\t     * Reset the field. It also clears all the messages, hide the feedback icons, etc.\n\t     *\n\t     * @param {string} field The field name\n\t     * @param {boolean} reset If true, the method resets field value to empty\n\t     * or remove `checked`, `selected` attributes\n\t     * @return {Core}\n\t     */\n\t    Core.prototype.resetField = function (field, reset) {\n\t        // Reset the field element value if needed\n\t        if (reset) {\n\t            var elements = this.elements[field];\n\t            var type_1 = elements[0].getAttribute('type');\n\t            elements.forEach(function (ele) {\n\t                if ('radio' === type_1 || 'checkbox' === type_1) {\n\t                    ele.removeAttribute('selected');\n\t                    ele.removeAttribute('checked');\n\t                    ele.checked = false;\n\t                }\n\t                else {\n\t                    ele.setAttribute('value', '');\n\t                    if (ele instanceof HTMLInputElement || ele instanceof HTMLTextAreaElement) {\n\t                        ele.value = '';\n\t                    }\n\t                }\n\t            });\n\t        }\n\t        // Mark the field as not validated yet\n\t        this.updateFieldStatus(field, 'NotValidated');\n\t        this.emit('core.field.reset', {\n\t            field: field,\n\t            reset: reset,\n\t        });\n\t        return this;\n\t    };\n\t    /**\n\t     * Revalidate a particular field. It's useful when the field value is effected by third parties\n\t     * (for example, attach another UI library to the field).\n\t     * Since there isn't an automatic way for FormValidation to know when the field value is modified in those cases,\n\t     * we need to revalidate the field manually.\n\t     *\n\t     * @param {string} field The field name\n\t     * @return {Promise<string>}\n\t     */\n\t    Core.prototype.revalidateField = function (field) {\n\t        if (!this.fields[field]) {\n\t            return Promise.resolve('Ignored');\n\t        }\n\t        this.updateFieldStatus(field, 'NotValidated');\n\t        return this.validateField(field);\n\t    };\n\t    /**\n\t     * Disable particular validator for given field\n\t     *\n\t     * @param {string} field The field name\n\t     * @param {string} validator The validator name. If it isn't specified, all validators will be disabled\n\t     * @return {Core}\n\t     */\n\t    Core.prototype.disableValidator = function (field, validator) {\n\t        if (!this.fields[field]) {\n\t            return this;\n\t        }\n\t        var elements = this.elements[field];\n\t        this.toggleValidator(false, field, validator);\n\t        this.emit('core.validator.disabled', {\n\t            elements: elements,\n\t            field: field,\n\t            formValidation: this,\n\t            validator: validator,\n\t        });\n\t        return this;\n\t    };\n\t    /**\n\t     * Enable particular validator for given field\n\t     *\n\t     * @param {string} field The field name\n\t     * @param {string} validator The validator name. If it isn't specified, all validators will be enabled\n\t     * @return {Core}\n\t     */\n\t    Core.prototype.enableValidator = function (field, validator) {\n\t        if (!this.fields[field]) {\n\t            return this;\n\t        }\n\t        var elements = this.elements[field];\n\t        this.toggleValidator(true, field, validator);\n\t        this.emit('core.validator.enabled', {\n\t            elements: elements,\n\t            field: field,\n\t            formValidation: this,\n\t            validator: validator,\n\t        });\n\t        return this;\n\t    };\n\t    /**\n\t     * Update option of particular validator for given field\n\t     *\n\t     * @param {string} field The field name\n\t     * @param {string} validator The validator name\n\t     * @param {string} name The option's name\n\t     * @param {unknown} value The option's value\n\t     * @return {Core}\n\t     */\n\t    Core.prototype.updateValidatorOption = function (field, validator, name, value) {\n\t        if (this.fields[field] && this.fields[field].validators && this.fields[field].validators[validator]) {\n\t            this.fields[field].validators[validator][name] = value;\n\t        }\n\t        return this;\n\t    };\n\t    Core.prototype.setFieldOptions = function (field, options) {\n\t        this.fields[field] = options;\n\t        return this;\n\t    };\n\t    Core.prototype.destroy = function () {\n\t        var _this = this;\n\t        // Remove plugins and filters\n\t        Object.keys(this.plugins).forEach(function (id) { return _this.plugins[id].uninstall(); });\n\t        this.ee.clear();\n\t        this.filter.clear();\n\t        this.results.clear();\n\t        this.plugins = {};\n\t        return this;\n\t    };\n\t    Core.prototype.setLocale = function (locale, localization) {\n\t        this.locale = locale;\n\t        this.localization = localization;\n\t        return this;\n\t    };\n\t    Core.prototype.waterfall = function (promises) {\n\t        return promises.reduce(function (p, c) {\n\t            return p.then(function (res) {\n\t                return c().then(function (result) {\n\t                    res.push(result);\n\t                    return res;\n\t                });\n\t            });\n\t        }, Promise.resolve([]));\n\t    };\n\t    Core.prototype.queryElements = function (field) {\n\t        var selector = this.fields[field].selector\n\t            ? // Check if the selector is an ID selector which starts with `#`\n\t                '#' === this.fields[field].selector.charAt(0)\n\t                    ? \"[id=\\\"\".concat(this.fields[field].selector.substring(1), \"\\\"]\")\n\t                    : this.fields[field].selector\n\t            : \"[name=\\\"\".concat(field.replace(/\"/g, '\\\\\"'), \"\\\"]\");\n\t        return [].slice.call(this.form.querySelectorAll(selector));\n\t    };\n\t    Core.prototype.normalizeResult = function (field, validator, result) {\n\t        var opts = this.fields[field].validators[validator];\n\t        return Object.assign({}, result, {\n\t            message: result.message ||\n\t                (opts ? opts.message : '') ||\n\t                (this.localization && this.localization[validator] && this.localization[validator]['default']\n\t                    ? this.localization[validator]['default']\n\t                    : '') ||\n\t                \"The field \".concat(field, \" is not valid\"),\n\t        });\n\t    };\n\t    Core.prototype.toggleValidator = function (enabled, field, validator) {\n\t        var _this = this;\n\t        var validatorArr = this.fields[field].validators;\n\t        if (validator && validatorArr && validatorArr[validator]) {\n\t            this.fields[field].validators[validator].enabled = enabled;\n\t        }\n\t        else if (!validator) {\n\t            Object.keys(validatorArr).forEach(function (v) { return (_this.fields[field].validators[v].enabled = enabled); });\n\t        }\n\t        return this.updateFieldStatus(field, 'NotValidated', validator);\n\t    };\n\t    return Core;\n\t}());\n\tfunction formValidation(form, options) {\n\t    var opts = Object.assign({}, {\n\t        fields: {},\n\t        locale: 'en_US',\n\t        plugins: {},\n\t        init: function (_) { },\n\t    }, options);\n\t    var core = new Core(form, opts.fields);\n\t    core.setLocale(opts.locale, opts.localization);\n\t    // Register plugins\n\t    Object.keys(opts.plugins).forEach(function (name) { return core.registerPlugin(name, opts.plugins[name]); });\n\t    // It's the single point that users can do a particular task before adding fields\n\t    // Some initialization tasks must be done at that point\n\t    opts.init(core);\n\t    // and add fields\n\t    Object.keys(opts.fields).forEach(function (field) { return core.addField(field, opts.fields[field]); });\n\t    return core;\n\t}\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\tvar Plugin = /** @class */ (function () {\n\t    function Plugin(opts) {\n\t        this.opts = opts;\n\t        this.isEnabled = true;\n\t    }\n\t    Plugin.prototype.setCore = function (core) {\n\t        this.core = core;\n\t        return this;\n\t    };\n\t    Plugin.prototype.enable = function () {\n\t        this.isEnabled = true;\n\t        this.onEnabled();\n\t        return this;\n\t    };\n\t    Plugin.prototype.disable = function () {\n\t        this.isEnabled = false;\n\t        this.onDisabled();\n\t        return this;\n\t    };\n\t    Plugin.prototype.isPluginEnabled = function () {\n\t        return this.isEnabled;\n\t    };\n\t    Plugin.prototype.onEnabled = function () { }; // eslint-disable-line @typescript-eslint/no-empty-function\n\t    Plugin.prototype.onDisabled = function () { }; // eslint-disable-line @typescript-eslint/no-empty-function\n\t    Plugin.prototype.install = function () { }; // eslint-disable-line @typescript-eslint/no-empty-function\n\t    Plugin.prototype.uninstall = function () { }; // eslint-disable-line @typescript-eslint/no-empty-function\n\t    return Plugin;\n\t}());\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\t/**\n\t * Execute a callback function\n\t *\n\t * @param {Function | string} functionName Can be\n\t * - name of global function\n\t * - name of namespace function (such as A.B.C)\n\t * - a function\n\t * @param {any[]} args The callback arguments\n\t * @return {any}\n\t */\n\tfunction call(functionName, args) {\n\t    if ('function' === typeof functionName) {\n\t        return functionName.apply(this, args);\n\t    }\n\t    else if ('string' === typeof functionName) {\n\t        // Node that it doesn't support node.js based environment because we are trying to access `window`\n\t        var name_1 = functionName;\n\t        if ('()' === name_1.substring(name_1.length - 2)) {\n\t            name_1 = name_1.substring(0, name_1.length - 2);\n\t        }\n\t        var ns = name_1.split('.');\n\t        var func = ns.pop();\n\t        var context_1 = window;\n\t        for (var _i = 0, ns_1 = ns; _i < ns_1.length; _i++) {\n\t            var t = ns_1[_i];\n\t            context_1 = context_1[t];\n\t        }\n\t        return typeof context_1[func] === 'undefined' ? null : context_1[func].apply(this, args);\n\t    }\n\t}\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\tvar addClass = function (element, classes) {\n\t    classes.split(' ').forEach(function (clazz) {\n\t        if (element.classList) {\n\t            element.classList.add(clazz);\n\t        }\n\t        else if (\" \".concat(element.className, \" \").indexOf(\" \".concat(clazz, \" \"))) {\n\t            element.className += \" \".concat(clazz);\n\t        }\n\t    });\n\t};\n\tvar removeClass = function (element, classes) {\n\t    classes.split(' ').forEach(function (clazz) {\n\t        element.classList\n\t            ? element.classList.remove(clazz)\n\t            : (element.className = element.className.replace(clazz, ''));\n\t    });\n\t};\n\tvar classSet = function (element, classes) {\n\t    var adding = [];\n\t    var removing = [];\n\t    Object.keys(classes).forEach(function (clazz) {\n\t        if (clazz) {\n\t            classes[clazz] ? adding.push(clazz) : removing.push(clazz);\n\t        }\n\t    });\n\t    // Always remove before adding class because there might be a class which belong to both sets.\n\t    // For example, the element will have class `a` after calling\n\t    //  ```\n\t    //  classSet(element, {\n\t    //      'a a1 a2': true,\n\t    //      'a b1 b2': false\n\t    //  })\n\t    //  ```\n\t    removing.forEach(function (clazz) { return removeClass(element, clazz); });\n\t    adding.forEach(function (clazz) { return addClass(element, clazz); });\n\t};\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\tvar matches = function (element, selector) {\n\t    var nativeMatches = element.matches ||\n\t        element.webkitMatchesSelector ||\n\t        element['mozMatchesSelector'] ||\n\t        element['msMatchesSelector'];\n\t    if (nativeMatches) {\n\t        return nativeMatches.call(element, selector);\n\t    }\n\t    // In case `matchesselector` isn't supported (such as IE10)\n\t    // See http://caniuse.com/matchesselector\n\t    var nodes = [].slice.call(element.parentElement.querySelectorAll(selector));\n\t    return nodes.indexOf(element) >= 0;\n\t};\n\tvar closest = function (element, selector) {\n\t    var ele = element;\n\t    while (ele) {\n\t        if (matches(ele, selector)) {\n\t            break;\n\t        }\n\t        ele = ele.parentElement;\n\t    }\n\t    return ele;\n\t};\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\tvar generateString = function (length) {\n\t    return Array(length)\n\t        .fill('')\n\t        .map(function (v) { return Math.random().toString(36).charAt(2); })\n\t        .join('');\n\t};\n\tvar fetch = function (url, options) {\n\t    var toQuery = function (obj) {\n\t        return Object.keys(obj)\n\t            .map(function (k) { return \"\".concat(encodeURIComponent(k), \"=\").concat(encodeURIComponent(obj[k])); })\n\t            .join('&');\n\t    };\n\t    return new Promise(function (resolve, reject) {\n\t        var opts = Object.assign({}, {\n\t            crossDomain: false,\n\t            headers: {},\n\t            method: 'GET',\n\t            params: {},\n\t        }, options);\n\t        // Build the params for GET request\n\t        var params = Object.keys(opts.params)\n\t            .map(function (k) { return \"\".concat(encodeURIComponent(k), \"=\").concat(encodeURIComponent(opts.params[k])); })\n\t            .join('&');\n\t        var hasQuery = url.indexOf('?') > -1;\n\t        var requestUrl = 'GET' === opts.method ? \"\".concat(url).concat(hasQuery ? '&' : '?').concat(params) : url;\n\t        if (opts.crossDomain) {\n\t            // User is making cross domain request\n\t            var script_1 = document.createElement('script');\n\t            // In some very fast systems, the different `Date.now()` invocations can return the same value\n\t            // which leads to the issue where there are multiple remove validators are used, for example.\n\t            // Appending it with a generated random string can fix the value\n\t            var callback_1 = \"___FormValidationFetch_\".concat(generateString(12), \"___\");\n\t            window[callback_1] = function (data) {\n\t                delete window[callback_1];\n\t                resolve(data);\n\t            };\n\t            script_1.src = \"\".concat(requestUrl).concat(hasQuery ? '&' : '?', \"callback=\").concat(callback_1);\n\t            script_1.async = true;\n\t            script_1.addEventListener('load', function () {\n\t                script_1.parentNode.removeChild(script_1);\n\t            });\n\t            script_1.addEventListener('error', function () { return reject; });\n\t            document.head.appendChild(script_1);\n\t        }\n\t        else {\n\t            var request_1 = new XMLHttpRequest();\n\t            request_1.open(opts.method, requestUrl);\n\t            // Set the headers\n\t            request_1.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n\t            if ('POST' === opts.method) {\n\t                request_1.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n\t            }\n\t            Object.keys(opts.headers).forEach(function (k) { return request_1.setRequestHeader(k, opts.headers[k]); });\n\t            request_1.addEventListener('load', function () {\n\t                // Cannot use arrow function here due to the `this` scope\n\t                resolve(JSON.parse(this.responseText));\n\t            });\n\t            request_1.addEventListener('error', function () { return reject; });\n\t            // GET request will ignore the passed data here\n\t            request_1.send(toQuery(opts.params));\n\t        }\n\t    });\n\t};\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\t/**\n\t * Format a string\n\t * It's used to format the error message\n\t * format('The field must between %s and %s', [10, 20]) = 'The field must between 10 and 20'\n\t *\n\t * @param {string} message\n\t * @param {string|string[]} parameters\n\t * @returns {string}\n\t */\n\tvar format = function (message, parameters) {\n\t    var params = Array.isArray(parameters) ? parameters : [parameters];\n\t    var output = message;\n\t    params.forEach(function (p) {\n\t        output = output.replace('%s', p);\n\t    });\n\t    return output;\n\t};\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\tvar hasClass = function (element, clazz) {\n\t    return element.classList\n\t        ? element.classList.contains(clazz)\n\t        : new RegExp(\"(^| )\".concat(clazz, \"( |$)\"), 'gi').test(element.className);\n\t};\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\t/**\n\t * Validate a date\n\t *\n\t * @param {string} year The full year in 4 digits\n\t * @param {string} month The month number\n\t * @param {string} day The day number\n\t * @param {boolean} [notInFuture] If true, the date must not be in the future\n\t * @returns {boolean}\n\t */\n\tvar isValidDate = function (year, month, day, notInFuture) {\n\t    if (isNaN(year) || isNaN(month) || isNaN(day)) {\n\t        return false;\n\t    }\n\t    if (year < 1000 || year > 9999 || month <= 0 || month > 12) {\n\t        return false;\n\t    }\n\t    var numDays = [\n\t        31,\n\t        // Update the number of days in Feb of leap year\n\t        year % 400 === 0 || (year % 100 !== 0 && year % 4 === 0) ? 29 : 28,\n\t        31,\n\t        30,\n\t        31,\n\t        30,\n\t        31,\n\t        31,\n\t        30,\n\t        31,\n\t        30,\n\t        31,\n\t    ];\n\t    // Check the day\n\t    if (day <= 0 || day > numDays[month - 1]) {\n\t        return false;\n\t    }\n\t    if (notInFuture === true) {\n\t        var currentDate = new Date();\n\t        var currentYear = currentDate.getFullYear();\n\t        var currentMonth = currentDate.getMonth();\n\t        var currentDay = currentDate.getDate();\n\t        return (year < currentYear ||\n\t            (year === currentYear && month - 1 < currentMonth) ||\n\t            (year === currentYear && month - 1 === currentMonth && day < currentDay));\n\t    }\n\t    return true;\n\t};\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\tvar removeUndefined = function (obj) {\n\t    return obj\n\t        ? Object.entries(obj).reduce(function (a, _a) {\n\t            var k = _a[0], v = _a[1];\n\t            return (v === undefined ? a : ((a[k] = v), a));\n\t        }, {})\n\t        : {};\n\t};\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\tvar index = {\n\t    call: call,\n\t    classSet: classSet,\n\t    closest: closest,\n\t    fetch: fetch,\n\t    format: format,\n\t    hasClass: hasClass,\n\t    isValidDate: isValidDate,\n\t    removeUndefined: removeUndefined,\n\t};\n\n\tcjs$B.Plugin = Plugin;\n\tcjs$B.algorithms = index$1;\n\tcjs$B.formValidation = formValidation;\n\tcjs$B.utils = index;\n\treturn cjs$B;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\nif (false) {} else {\n    lib$B.exports = requireCjs$B();\n}\n\nvar libExports$B = lib$B.exports;\n\nvar lib$A = {exports: {}};\n\nvar index_min$A = {};\n\n/** \n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n *\n * @license https://formvalidation.io/license\n * @package @form-validation/plugin-alias\n * @version 2.4.0\n */\n\nvar hasRequiredIndex_min$A;\n\nfunction requireIndex_min$A () {\n\tif (hasRequiredIndex_min$A) return index_min$A;\n\thasRequiredIndex_min$A = 1;\nvar t=libExports$B,r=function(t,o){return r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,r){t.__proto__=r;}||function(t,r){for(var o in r)Object.prototype.hasOwnProperty.call(r,o)&&(t[o]=r[o]);},r(t,o)};var o=function(t){function o(r){var o=t.call(this,r)||this;return o.opts=r||{},o.validatorNameFilter=o.getValidatorName.bind(o),o}return function(t,o){if(\"function\"!=typeof o&&null!==o)throw new TypeError(\"Class extends value \"+String(o)+\" is not a constructor or null\");function e(){this.constructor=t;}r(t,o),t.prototype=null===o?Object.create(o):(e.prototype=o.prototype,new e);}(o,t),o.prototype.install=function(){this.core.registerFilter(\"validator-name\",this.validatorNameFilter);},o.prototype.uninstall=function(){this.core.deregisterFilter(\"validator-name\",this.validatorNameFilter);},o.prototype.getValidatorName=function(t,r){return this.isEnabled&&this.opts[t]||t},o}(t.Plugin);index_min$A.Alias=o;\n\treturn index_min$A;\n}\n\nvar cjs$A = {};\n\nvar hasRequiredCjs$A;\n\nfunction requireCjs$A () {\n\tif (hasRequiredCjs$A) return cjs$A;\n\thasRequiredCjs$A = 1;\n\n\tvar core = libExports$B;\n\n\t/******************************************************************************\r\n\tCopyright (c) Microsoft Corporation.\r\n\r\n\tPermission to use, copy, modify, and/or distribute this software for any\r\n\tpurpose with or without fee is hereby granted.\r\n\r\n\tTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n\tREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n\tAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n\tINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n\tLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n\tOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n\tPERFORMANCE OF THIS SOFTWARE.\r\n\t***************************************************************************** */\r\n\t/* global Reflect, Promise */\r\n\r\n\tvar extendStatics = function(d, b) {\r\n\t    extendStatics = Object.setPrototypeOf ||\r\n\t        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n\t        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n\t    return extendStatics(d, b);\r\n\t};\r\n\r\n\tfunction __extends(d, b) {\r\n\t    if (typeof b !== \"function\" && b !== null)\r\n\t        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n\t    extendStatics(d, b);\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t}\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\t/**\n\t * This plugin allows to use multiple instances of the same validator by defining alias.\n\t * ```\n\t *  formValidation(form, {\n\t *      fields: {\n\t *          email: {\n\t *              validators: {\n\t *                  required: ...,\n\t *                  pattern: ...,\n\t *                  regexp: ...\n\t *              }\n\t *          }\n\t *      },\n\t *      plugins: {\n\t *          alias: new Alias({\n\t *              required: 'notEmpty',\n\t *              pattern: 'regexp'\n\t *          })\n\t *      }\n\t *  })\n\t * ```\n\t * Then, you can use the `required`, `pattern` as the same as `notEmpty`, `regexp` validators.\n\t */\n\tvar Alias = /** @class */ (function (_super) {\n\t    __extends(Alias, _super);\n\t    function Alias(opts) {\n\t        var _this = _super.call(this, opts) || this;\n\t        _this.opts = opts || {};\n\t        _this.validatorNameFilter = _this.getValidatorName.bind(_this);\n\t        return _this;\n\t    }\n\t    Alias.prototype.install = function () {\n\t        this.core.registerFilter('validator-name', this.validatorNameFilter);\n\t    };\n\t    Alias.prototype.uninstall = function () {\n\t        this.core.deregisterFilter('validator-name', this.validatorNameFilter);\n\t    };\n\t    Alias.prototype.getValidatorName = function (validatorName, _field) {\n\t        return this.isEnabled ? this.opts[validatorName] || validatorName : validatorName;\n\t    };\n\t    return Alias;\n\t}(core.Plugin));\n\n\tcjs$A.Alias = Alias;\n\treturn cjs$A;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\nif (false) {} else {\n    lib$A.exports = requireCjs$A();\n}\n\nvar libExports$A = lib$A.exports;\n\nvar lib$z = {exports: {}};\n\nvar index_min$z = {};\n\n/** \n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n *\n * @license https://formvalidation.io/license\n * @package @form-validation/plugin-aria\n * @version 2.4.0\n */\n\nvar hasRequiredIndex_min$z;\n\nfunction requireIndex_min$z () {\n\tif (hasRequiredIndex_min$z) return index_min$z;\n\thasRequiredIndex_min$z = 1;\nvar e=libExports$B,t=function(e,i){return t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t;}||function(e,t){for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i]);},t(e,i)};var i=function(e){function i(){var t=e.call(this,{})||this;return t.elementValidatedHandler=t.onElementValidated.bind(t),t.fieldValidHandler=t.onFieldValid.bind(t),t.fieldInvalidHandler=t.onFieldInvalid.bind(t),t.messageDisplayedHandler=t.onMessageDisplayed.bind(t),t}return function(e,i){if(\"function\"!=typeof i&&null!==i)throw new TypeError(\"Class extends value \"+String(i)+\" is not a constructor or null\");function n(){this.constructor=e;}t(e,i),e.prototype=null===i?Object.create(i):(n.prototype=i.prototype,new n);}(i,e),i.prototype.install=function(){this.core.on(\"core.field.valid\",this.fieldValidHandler).on(\"core.field.invalid\",this.fieldInvalidHandler).on(\"core.element.validated\",this.elementValidatedHandler).on(\"plugins.message.displayed\",this.messageDisplayedHandler);},i.prototype.uninstall=function(){this.core.off(\"core.field.valid\",this.fieldValidHandler).off(\"core.field.invalid\",this.fieldInvalidHandler).off(\"core.element.validated\",this.elementValidatedHandler).off(\"plugins.message.displayed\",this.messageDisplayedHandler);},i.prototype.onElementValidated=function(e){e.valid&&(e.element.setAttribute(\"aria-invalid\",\"false\"),e.element.removeAttribute(\"aria-describedby\"));},i.prototype.onFieldValid=function(e){var t=this.core.getElements(e);t&&t.forEach((function(e){e.setAttribute(\"aria-invalid\",\"false\"),e.removeAttribute(\"aria-describedby\");}));},i.prototype.onFieldInvalid=function(e){var t=this.core.getElements(e);t&&t.forEach((function(e){return e.setAttribute(\"aria-invalid\",\"true\")}));},i.prototype.onMessageDisplayed=function(e){e.messageElement.setAttribute(\"role\",\"alert\"),e.messageElement.setAttribute(\"aria-hidden\",\"false\");var t=this.core.getElements(e.field),i=t.indexOf(e.element),n=\"js-fv-\".concat(e.field,\"-\").concat(i,\"-\").concat(Date.now(),\"-message\");e.messageElement.setAttribute(\"id\",n),e.element.setAttribute(\"aria-describedby\",n);var a=e.element.getAttribute(\"type\");\"radio\"!==a&&\"checkbox\"!==a||t.forEach((function(e){return e.setAttribute(\"aria-describedby\",n)}));},i}(e.Plugin);index_min$z.Aria=i;\n\treturn index_min$z;\n}\n\nvar cjs$z = {};\n\nvar hasRequiredCjs$z;\n\nfunction requireCjs$z () {\n\tif (hasRequiredCjs$z) return cjs$z;\n\thasRequiredCjs$z = 1;\n\n\tvar core = libExports$B;\n\n\t/******************************************************************************\r\n\tCopyright (c) Microsoft Corporation.\r\n\r\n\tPermission to use, copy, modify, and/or distribute this software for any\r\n\tpurpose with or without fee is hereby granted.\r\n\r\n\tTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n\tREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n\tAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n\tINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n\tLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n\tOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n\tPERFORMANCE OF THIS SOFTWARE.\r\n\t***************************************************************************** */\r\n\t/* global Reflect, Promise */\r\n\r\n\tvar extendStatics = function(d, b) {\r\n\t    extendStatics = Object.setPrototypeOf ||\r\n\t        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n\t        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n\t    return extendStatics(d, b);\r\n\t};\r\n\r\n\tfunction __extends(d, b) {\r\n\t    if (typeof b !== \"function\" && b !== null)\r\n\t        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n\t    extendStatics(d, b);\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t}\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\t/**\n\t * This plugin adds ARIA attributes based on the field validity.\n\t * The list include:\n\t *  - `aria-invalid`, `aria-describedby` for field element\n\t *  - `aria-hidden`, `role` for associated message element\n\t * @see https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques\n\t */\n\tvar Aria = /** @class */ (function (_super) {\n\t    __extends(Aria, _super);\n\t    function Aria() {\n\t        var _this = _super.call(this, {}) || this;\n\t        _this.elementValidatedHandler = _this.onElementValidated.bind(_this);\n\t        _this.fieldValidHandler = _this.onFieldValid.bind(_this);\n\t        _this.fieldInvalidHandler = _this.onFieldInvalid.bind(_this);\n\t        _this.messageDisplayedHandler = _this.onMessageDisplayed.bind(_this);\n\t        return _this;\n\t    }\n\t    Aria.prototype.install = function () {\n\t        this.core\n\t            .on('core.field.valid', this.fieldValidHandler)\n\t            .on('core.field.invalid', this.fieldInvalidHandler)\n\t            .on('core.element.validated', this.elementValidatedHandler)\n\t            .on('plugins.message.displayed', this.messageDisplayedHandler);\n\t    };\n\t    Aria.prototype.uninstall = function () {\n\t        this.core\n\t            .off('core.field.valid', this.fieldValidHandler)\n\t            .off('core.field.invalid', this.fieldInvalidHandler)\n\t            .off('core.element.validated', this.elementValidatedHandler)\n\t            .off('plugins.message.displayed', this.messageDisplayedHandler);\n\t    };\n\t    Aria.prototype.onElementValidated = function (e) {\n\t        if (e.valid) {\n\t            e.element.setAttribute('aria-invalid', 'false');\n\t            e.element.removeAttribute('aria-describedby');\n\t        }\n\t    };\n\t    Aria.prototype.onFieldValid = function (field) {\n\t        var elements = this.core.getElements(field);\n\t        if (elements) {\n\t            elements.forEach(function (ele) {\n\t                ele.setAttribute('aria-invalid', 'false');\n\t                ele.removeAttribute('aria-describedby');\n\t            });\n\t        }\n\t    };\n\t    Aria.prototype.onFieldInvalid = function (field) {\n\t        var elements = this.core.getElements(field);\n\t        if (elements) {\n\t            elements.forEach(function (ele) { return ele.setAttribute('aria-invalid', 'true'); });\n\t        }\n\t    };\n\t    Aria.prototype.onMessageDisplayed = function (e) {\n\t        e.messageElement.setAttribute('role', 'alert');\n\t        e.messageElement.setAttribute('aria-hidden', 'false');\n\t        var elements = this.core.getElements(e.field);\n\t        var index = elements.indexOf(e.element);\n\t        var id = \"js-fv-\".concat(e.field, \"-\").concat(index, \"-\").concat(Date.now(), \"-message\");\n\t        e.messageElement.setAttribute('id', id);\n\t        e.element.setAttribute('aria-describedby', id);\n\t        var type = e.element.getAttribute('type');\n\t        if ('radio' === type || 'checkbox' === type) {\n\t            elements.forEach(function (ele) { return ele.setAttribute('aria-describedby', id); });\n\t        }\n\t    };\n\t    return Aria;\n\t}(core.Plugin));\n\n\tcjs$z.Aria = Aria;\n\treturn cjs$z;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\nif (false) {} else {\n    lib$z.exports = requireCjs$z();\n}\n\nvar libExports$z = lib$z.exports;\n\nvar lib$y = {exports: {}};\n\nvar index_min$y = {};\n\n/** \n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n *\n * @license https://formvalidation.io/license\n * @package @form-validation/plugin-declarative\n * @version 2.4.0\n */\n\nvar hasRequiredIndex_min$y;\n\nfunction requireIndex_min$y () {\n\tif (hasRequiredIndex_min$y) return index_min$y;\n\thasRequiredIndex_min$y = 1;\nvar e=libExports$B,t=function(e,a){return t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t;}||function(e,t){for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a]);},t(e,a)};var a=function(e){function a(t){var a=e.call(this,t)||this;return a.addedFields=new Map,a.opts=Object.assign({},{html5Input:!1,pluginPrefix:\"data-fvp-\",prefix:\"data-fv-\"},t),a.fieldAddedHandler=a.onFieldAdded.bind(a),a.fieldRemovedHandler=a.onFieldRemoved.bind(a),a}return function(e,a){if(\"function\"!=typeof a&&null!==a)throw new TypeError(\"Class extends value \"+String(a)+\" is not a constructor or null\");function r(){this.constructor=e;}t(e,a),e.prototype=null===a?Object.create(a):(r.prototype=a.prototype,new r);}(a,e),a.prototype.install=function(){var e=this;this.parsePlugins();var t=this.parseOptions();Object.keys(t).forEach((function(a){e.addedFields.has(a)||e.addedFields.set(a,!0),e.core.addField(a,t[a]);})),this.core.on(\"core.field.added\",this.fieldAddedHandler).on(\"core.field.removed\",this.fieldRemovedHandler);},a.prototype.uninstall=function(){this.addedFields.clear(),this.core.off(\"core.field.added\",this.fieldAddedHandler).off(\"core.field.removed\",this.fieldRemovedHandler);},a.prototype.onFieldAdded=function(e){var t=this,a=e.elements;a&&0!==a.length&&!this.addedFields.has(e.field)&&(this.addedFields.set(e.field,!0),a.forEach((function(a){var r=t.parseElement(a);if(!t.isEmptyOption(r)){var n={selector:e.options.selector,validators:Object.assign({},e.options.validators||{},r.validators)};t.core.setFieldOptions(e.field,n);}})));},a.prototype.onFieldRemoved=function(e){e.field&&this.addedFields.has(e.field)&&this.addedFields.delete(e.field);},a.prototype.parseOptions=function(){var e=this,t=this.opts.prefix,a={},r=this.core.getFields(),n=this.core.getFormElement();return [].slice.call(n.querySelectorAll(\"[name], [\".concat(t,\"field]\"))).forEach((function(r){var n=e.parseElement(r);if(!e.isEmptyOption(n)){var i=r.getAttribute(\"name\")||r.getAttribute(\"\".concat(t,\"field\"));a[i]=Object.assign({},a[i],n);}})),Object.keys(a).forEach((function(e){Object.keys(a[e].validators).forEach((function(t){a[e].validators[t].enabled=a[e].validators[t].enabled||!1,r[e]&&r[e].validators&&r[e].validators[t]&&Object.assign(a[e].validators[t],r[e].validators[t]);}));})),Object.assign({},r,a)},a.prototype.createPluginInstance=function(e,t){for(var a=e.split(\".\"),r=window||this,n=0,i=a.length;n<i;n++)r=r[a[n]];if(\"function\"!=typeof r)throw new Error(\"the plugin \".concat(e,\" doesn't exist\"));return new r(t)},a.prototype.parsePlugins=function(){for(var e,t=this,a=this.core.getFormElement(),r=new RegExp(\"^\".concat(this.opts.pluginPrefix,\"([a-z0-9-]+)(___)*([a-z0-9-]+)*$\")),n=a.attributes.length,i={},s=0;s<n;s++){var o=a.attributes[s].name,l=a.attributes[s].value,d=r.exec(o);if(d&&4===d.length){var c=this.toCamelCase(d[1]);i[c]=Object.assign({},d[3]?((e={})[this.toCamelCase(d[3])]=l,e):{enabled:\"\"===l||\"true\"===l},i[c]);}}Object.keys(i).forEach((function(e){var a=i[e],r=a.enabled,n=a.class;if(r&&n){delete a.enabled,delete a.clazz;var s=t.createPluginInstance(n,a);t.core.registerPlugin(e,s);}}));},a.prototype.isEmptyOption=function(e){var t=e.validators;return 0===Object.keys(t).length&&t.constructor===Object},a.prototype.parseElement=function(e){for(var t=new RegExp(\"^\".concat(this.opts.prefix,\"([a-z0-9-]+)(___)*([a-z0-9-]+)*$\")),a=e.attributes.length,r={},n=e.getAttribute(\"type\"),i=0;i<a;i++){var s=e.attributes[i].name,o=e.attributes[i].value;if(this.opts.html5Input)switch(!0){case\"minlength\"===s:r.stringLength=Object.assign({},{enabled:!0,min:parseInt(o,10)},r.stringLength);break;case\"maxlength\"===s:r.stringLength=Object.assign({},{enabled:!0,max:parseInt(o,10)},r.stringLength);break;case\"pattern\"===s:r.regexp=Object.assign({},{enabled:!0,regexp:o},r.regexp);break;case\"required\"===s:r.notEmpty=Object.assign({},{enabled:!0},r.notEmpty);break;case\"type\"===s&&\"color\"===o:r.color=Object.assign({},{enabled:!0,type:\"hex\"},r.color);break;case\"type\"===s&&\"email\"===o:r.emailAddress=Object.assign({},{enabled:!0},r.emailAddress);break;case\"type\"===s&&\"url\"===o:r.uri=Object.assign({},{enabled:!0},r.uri);break;case\"type\"===s&&\"range\"===o:r.between=Object.assign({},{enabled:!0,max:parseFloat(e.getAttribute(\"max\")),min:parseFloat(e.getAttribute(\"min\"))},r.between);break;case\"min\"===s&&\"date\"!==n&&\"range\"!==n:r.greaterThan=Object.assign({},{enabled:!0,min:parseFloat(o)},r.greaterThan);break;case\"max\"===s&&\"date\"!==n&&\"range\"!==n:r.lessThan=Object.assign({},{enabled:!0,max:parseFloat(o)},r.lessThan);}var l=t.exec(s);if(l&&4===l.length){var d=this.toCamelCase(l[1]);r[d]||(r[d]={}),l[3]?r[d][this.toCamelCase(l[3])]=this.normalizeValue(o):!0===r[d].enabled&&!1===r[d].enabled||(r[d].enabled=\"\"===o||\"true\"===o);}}return {validators:r}},a.prototype.normalizeValue=function(e){return \"true\"===e||\"\"===e||\"false\"!==e&&e},a.prototype.toUpperCase=function(e){return e.charAt(1).toUpperCase()},a.prototype.toCamelCase=function(e){return e.replace(/-./g,this.toUpperCase)},a}(e.Plugin);index_min$y.Declarative=a;\n\treturn index_min$y;\n}\n\nvar cjs$y = {};\n\nvar hasRequiredCjs$y;\n\nfunction requireCjs$y () {\n\tif (hasRequiredCjs$y) return cjs$y;\n\thasRequiredCjs$y = 1;\n\n\tvar core = libExports$B;\n\n\t/******************************************************************************\r\n\tCopyright (c) Microsoft Corporation.\r\n\r\n\tPermission to use, copy, modify, and/or distribute this software for any\r\n\tpurpose with or without fee is hereby granted.\r\n\r\n\tTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n\tREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n\tAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n\tINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n\tLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n\tOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n\tPERFORMANCE OF THIS SOFTWARE.\r\n\t***************************************************************************** */\r\n\t/* global Reflect, Promise */\r\n\r\n\tvar extendStatics = function(d, b) {\r\n\t    extendStatics = Object.setPrototypeOf ||\r\n\t        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n\t        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n\t    return extendStatics(d, b);\r\n\t};\r\n\r\n\tfunction __extends(d, b) {\r\n\t    if (typeof b !== \"function\" && b !== null)\r\n\t        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n\t    extendStatics(d, b);\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t}\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\t/**\n\t * This plugin provides the ability of declaring validator options via HTML attributes.\n\t * All attributes are declared in lowercase\n\t * ```\n\t *  <input\n\t *      data-fv-field=\"${fieldName}\"\n\t *      data-fv-{validator}=\"true\"\n\t *      data-fv-{validator}___{option}=\"...\" />\n\t * ```\n\t */\n\tvar Declarative = /** @class */ (function (_super) {\n\t    __extends(Declarative, _super);\n\t    function Declarative(opts) {\n\t        var _this = _super.call(this, opts) || this;\n\t        _this.addedFields = new Map();\n\t        _this.opts = Object.assign({}, {\n\t            html5Input: false,\n\t            pluginPrefix: 'data-fvp-',\n\t            prefix: 'data-fv-',\n\t        }, opts);\n\t        _this.fieldAddedHandler = _this.onFieldAdded.bind(_this);\n\t        _this.fieldRemovedHandler = _this.onFieldRemoved.bind(_this);\n\t        return _this;\n\t    }\n\t    Declarative.prototype.install = function () {\n\t        var _this = this;\n\t        // Parse the plugin options\n\t        this.parsePlugins();\n\t        var opts = this.parseOptions();\n\t        Object.keys(opts).forEach(function (field) {\n\t            if (!_this.addedFields.has(field)) {\n\t                _this.addedFields.set(field, true);\n\t            }\n\t            _this.core.addField(field, opts[field]);\n\t        });\n\t        this.core.on('core.field.added', this.fieldAddedHandler).on('core.field.removed', this.fieldRemovedHandler);\n\t    };\n\t    Declarative.prototype.uninstall = function () {\n\t        this.addedFields.clear();\n\t        this.core.off('core.field.added', this.fieldAddedHandler).off('core.field.removed', this.fieldRemovedHandler);\n\t    };\n\t    Declarative.prototype.onFieldAdded = function (e) {\n\t        var _this = this;\n\t        var elements = e.elements;\n\t        // Don't add the element which is already available in the field lists\n\t        // Otherwise, it can cause an infinite loop\n\t        if (!elements || elements.length === 0 || this.addedFields.has(e.field)) {\n\t            return;\n\t        }\n\t        this.addedFields.set(e.field, true);\n\t        elements.forEach(function (ele) {\n\t            var declarativeOptions = _this.parseElement(ele);\n\t            if (!_this.isEmptyOption(declarativeOptions)) {\n\t                // Update validator options\n\t                var mergeOptions = {\n\t                    selector: e.options.selector,\n\t                    validators: Object.assign({}, e.options.validators || {}, declarativeOptions.validators),\n\t                };\n\t                _this.core.setFieldOptions(e.field, mergeOptions);\n\t            }\n\t        });\n\t    };\n\t    Declarative.prototype.onFieldRemoved = function (e) {\n\t        if (e.field && this.addedFields.has(e.field)) {\n\t            this.addedFields.delete(e.field);\n\t        }\n\t    };\n\t    Declarative.prototype.parseOptions = function () {\n\t        var _this = this;\n\t        // Find all fields which have either `name` or `data-fv-field` attribute\n\t        var prefix = this.opts.prefix;\n\t        var opts = {};\n\t        var fields = this.core.getFields();\n\t        var form = this.core.getFormElement();\n\t        var elements = [].slice.call(form.querySelectorAll(\"[name], [\".concat(prefix, \"field]\")));\n\t        elements.forEach(function (ele) {\n\t            var validators = _this.parseElement(ele);\n\t            // Do not try to merge the options if it's empty\n\t            // For instance, there are multiple elements having the same name,\n\t            // we only set the HTML attribute to one of them\n\t            if (!_this.isEmptyOption(validators)) {\n\t                var field = ele.getAttribute('name') || ele.getAttribute(\"\".concat(prefix, \"field\"));\n\t                opts[field] = Object.assign({}, opts[field], validators);\n\t            }\n\t        });\n\t        Object.keys(opts).forEach(function (field) {\n\t            Object.keys(opts[field].validators).forEach(function (v) {\n\t                // Set the `enabled` key to `false` if it isn't set\n\t                // (the data-fv-{validator} attribute is missing, for example)\n\t                opts[field].validators[v].enabled = opts[field].validators[v].enabled || false;\n\t                // Mix the options in declarative and programmatic modes\n\t                if (fields[field] && fields[field].validators && fields[field].validators[v]) {\n\t                    Object.assign(opts[field].validators[v], fields[field].validators[v]);\n\t                }\n\t            });\n\t        });\n\t        return Object.assign({}, fields, opts);\n\t    };\n\t    Declarative.prototype.createPluginInstance = function (clazz, opts) {\n\t        var arr = clazz.split('.');\n\t        // TODO: Find a safer way to create a plugin instance from the class\n\t        // Currently, I have to use `any` here instead of a construtable interface\n\t        var fn = window || this; // eslint-disable-line @typescript-eslint/no-explicit-any\n\t        for (var i = 0, len = arr.length; i < len; i++) {\n\t            fn = fn[arr[i]];\n\t        }\n\t        if (typeof fn !== 'function') {\n\t            throw new Error(\"the plugin \".concat(clazz, \" doesn't exist\"));\n\t        }\n\t        return new fn(opts);\n\t    };\n\t    Declarative.prototype.parsePlugins = function () {\n\t        var _a;\n\t        var _this = this;\n\t        var form = this.core.getFormElement();\n\t        var reg = new RegExp(\"^\".concat(this.opts.pluginPrefix, \"([a-z0-9-]+)(___)*([a-z0-9-]+)*$\"));\n\t        var numAttributes = form.attributes.length;\n\t        var plugins = {};\n\t        for (var i = 0; i < numAttributes; i++) {\n\t            var name_1 = form.attributes[i].name;\n\t            var value = form.attributes[i].value;\n\t            var items = reg.exec(name_1);\n\t            if (items && items.length === 4) {\n\t                var pluginName = this.toCamelCase(items[1]);\n\t                plugins[pluginName] = Object.assign({}, items[3] ? (_a = {}, _a[this.toCamelCase(items[3])] = value, _a) : { enabled: '' === value || 'true' === value }, plugins[pluginName]);\n\t            }\n\t        }\n\t        Object.keys(plugins).forEach(function (pluginName) {\n\t            var opts = plugins[pluginName];\n\t            var enabled = opts['enabled'];\n\t            var clazz = opts['class'];\n\t            if (enabled && clazz) {\n\t                delete opts['enabled'];\n\t                delete opts['clazz'];\n\t                var p = _this.createPluginInstance(clazz, opts);\n\t                _this.core.registerPlugin(pluginName, p);\n\t            }\n\t        });\n\t    };\n\t    Declarative.prototype.isEmptyOption = function (opts) {\n\t        var validators = opts.validators;\n\t        return Object.keys(validators).length === 0 && validators.constructor === Object;\n\t    };\n\t    Declarative.prototype.parseElement = function (ele) {\n\t        var reg = new RegExp(\"^\".concat(this.opts.prefix, \"([a-z0-9-]+)(___)*([a-z0-9-]+)*$\"));\n\t        var numAttributes = ele.attributes.length;\n\t        var opts = {};\n\t        var type = ele.getAttribute('type');\n\t        for (var i = 0; i < numAttributes; i++) {\n\t            var name_2 = ele.attributes[i].name;\n\t            var value = ele.attributes[i].value;\n\t            if (this.opts.html5Input) {\n\t                switch (true) {\n\t                    case 'minlength' === name_2:\n\t                        opts['stringLength'] = Object.assign({}, {\n\t                            enabled: true,\n\t                            min: parseInt(value, 10),\n\t                        }, opts['stringLength']);\n\t                        break;\n\t                    case 'maxlength' === name_2:\n\t                        opts['stringLength'] = Object.assign({}, {\n\t                            enabled: true,\n\t                            max: parseInt(value, 10),\n\t                        }, opts['stringLength']);\n\t                        break;\n\t                    case 'pattern' === name_2:\n\t                        opts['regexp'] = Object.assign({}, {\n\t                            enabled: true,\n\t                            regexp: value,\n\t                        }, opts['regexp']);\n\t                        break;\n\t                    case 'required' === name_2:\n\t                        opts['notEmpty'] = Object.assign({}, {\n\t                            enabled: true,\n\t                        }, opts['notEmpty']);\n\t                        break;\n\t                    case 'type' === name_2 && 'color' === value:\n\t                        // Only accept 6 hex character values due to the HTML 5 spec\n\t                        // See http://www.w3.org/TR/html-markup/input.color.html#input.color.attrs.value\n\t                        opts['color'] = Object.assign({}, {\n\t                            enabled: true,\n\t                            type: 'hex',\n\t                        }, opts['color']);\n\t                        break;\n\t                    case 'type' === name_2 && 'email' === value:\n\t                        opts['emailAddress'] = Object.assign({}, {\n\t                            enabled: true,\n\t                        }, opts['emailAddress']);\n\t                        break;\n\t                    case 'type' === name_2 && 'url' === value:\n\t                        opts['uri'] = Object.assign({}, {\n\t                            enabled: true,\n\t                        }, opts['uri']);\n\t                        break;\n\t                    case 'type' === name_2 && 'range' === value:\n\t                        opts['between'] = Object.assign({}, {\n\t                            enabled: true,\n\t                            max: parseFloat(ele.getAttribute('max')),\n\t                            min: parseFloat(ele.getAttribute('min')),\n\t                        }, opts['between']);\n\t                        break;\n\t                    case 'min' === name_2 && type !== 'date' && type !== 'range':\n\t                        opts['greaterThan'] = Object.assign({}, {\n\t                            enabled: true,\n\t                            min: parseFloat(value),\n\t                        }, opts['greaterThan']);\n\t                        break;\n\t                    case 'max' === name_2 && type !== 'date' && type !== 'range':\n\t                        opts['lessThan'] = Object.assign({}, {\n\t                            enabled: true,\n\t                            max: parseFloat(value),\n\t                        }, opts['lessThan']);\n\t                        break;\n\t                }\n\t            }\n\t            var items = reg.exec(name_2);\n\t            if (items && items.length === 4) {\n\t                var v = this.toCamelCase(items[1]);\n\t                if (!opts[v]) {\n\t                    opts[v] = {};\n\t                }\n\t                if (items[3]) {\n\t                    opts[v][this.toCamelCase(items[3])] = this.normalizeValue(value);\n\t                }\n\t                else if (opts[v]['enabled'] !== true || opts[v]['enabled'] !== false) {\n\t                    opts[v]['enabled'] = '' === value || 'true' === value;\n\t                }\n\t            }\n\t        }\n\t        return { validators: opts };\n\t    };\n\t    // Many validators accept `boolean` options, for example\n\t    // `data-fv-between___inclusive=\"false\"` should be identical to `inclusive: false`, not `inclusive: 'false'`\n\t    Declarative.prototype.normalizeValue = function (value) {\n\t        return value === 'true' || value === '' ? true : value === 'false' ? false : value;\n\t    };\n\t    Declarative.prototype.toUpperCase = function (input) {\n\t        return input.charAt(1).toUpperCase();\n\t    };\n\t    Declarative.prototype.toCamelCase = function (input) {\n\t        return input.replace(/-./g, this.toUpperCase);\n\t    };\n\t    return Declarative;\n\t}(core.Plugin));\n\n\tcjs$y.Declarative = Declarative;\n\treturn cjs$y;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\nif (false) {} else {\n    lib$y.exports = requireCjs$y();\n}\n\nvar libExports$y = lib$y.exports;\n\nvar lib$x = {exports: {}};\n\nvar index_min$x = {};\n\n/** \n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n *\n * @license https://formvalidation.io/license\n * @package @form-validation/plugin-default-submit\n * @version 2.4.0\n */\n\nvar hasRequiredIndex_min$x;\n\nfunction requireIndex_min$x () {\n\tif (hasRequiredIndex_min$x) return index_min$x;\n\thasRequiredIndex_min$x = 1;\nvar t=libExports$B,o=function(t,r){return o=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,o){t.__proto__=o;}||function(t,o){for(var r in o)Object.prototype.hasOwnProperty.call(o,r)&&(t[r]=o[r]);},o(t,r)};var r=function(t){function r(){var o=t.call(this,{})||this;return o.onValidHandler=o.onFormValid.bind(o),o}return function(t,r){if(\"function\"!=typeof r&&null!==r)throw new TypeError(\"Class extends value \"+String(r)+\" is not a constructor or null\");function n(){this.constructor=t;}o(t,r),t.prototype=null===r?Object.create(r):(n.prototype=r.prototype,new n);}(r,t),r.prototype.install=function(){if(this.core.getFormElement().querySelectorAll('[type=\"submit\"][name=\"submit\"]').length)throw new Error(\"Do not use `submit` for the name attribute of submit button\");this.core.on(\"core.form.valid\",this.onValidHandler);},r.prototype.uninstall=function(){this.core.off(\"core.form.valid\",this.onValidHandler);},r.prototype.onFormValid=function(){var t=this.core.getFormElement();this.isEnabled&&t instanceof HTMLFormElement&&t.submit();},r}(t.Plugin);index_min$x.DefaultSubmit=r;\n\treturn index_min$x;\n}\n\nvar cjs$x = {};\n\nvar hasRequiredCjs$x;\n\nfunction requireCjs$x () {\n\tif (hasRequiredCjs$x) return cjs$x;\n\thasRequiredCjs$x = 1;\n\n\tvar core = libExports$B;\n\n\t/******************************************************************************\r\n\tCopyright (c) Microsoft Corporation.\r\n\r\n\tPermission to use, copy, modify, and/or distribute this software for any\r\n\tpurpose with or without fee is hereby granted.\r\n\r\n\tTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n\tREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n\tAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n\tINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n\tLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n\tOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n\tPERFORMANCE OF THIS SOFTWARE.\r\n\t***************************************************************************** */\r\n\t/* global Reflect, Promise */\r\n\r\n\tvar extendStatics = function(d, b) {\r\n\t    extendStatics = Object.setPrototypeOf ||\r\n\t        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n\t        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n\t    return extendStatics(d, b);\r\n\t};\r\n\r\n\tfunction __extends(d, b) {\r\n\t    if (typeof b !== \"function\" && b !== null)\r\n\t        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n\t    extendStatics(d, b);\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t}\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\t/**\n\t * This plugin will submit the form if all fields are valid after validating\n\t */\n\tvar DefaultSubmit = /** @class */ (function (_super) {\n\t    __extends(DefaultSubmit, _super);\n\t    function DefaultSubmit() {\n\t        var _this = _super.call(this, {}) || this;\n\t        _this.onValidHandler = _this.onFormValid.bind(_this);\n\t        return _this;\n\t    }\n\t    DefaultSubmit.prototype.install = function () {\n\t        var form = this.core.getFormElement();\n\t        if (form.querySelectorAll('[type=\"submit\"][name=\"submit\"]').length) {\n\t            throw new Error('Do not use `submit` for the name attribute of submit button');\n\t        }\n\t        this.core.on('core.form.valid', this.onValidHandler);\n\t    };\n\t    DefaultSubmit.prototype.uninstall = function () {\n\t        this.core.off('core.form.valid', this.onValidHandler);\n\t    };\n\t    DefaultSubmit.prototype.onFormValid = function () {\n\t        var form = this.core.getFormElement();\n\t        if (this.isEnabled && form instanceof HTMLFormElement) {\n\t            form.submit();\n\t        }\n\t    };\n\t    return DefaultSubmit;\n\t}(core.Plugin));\n\n\tcjs$x.DefaultSubmit = DefaultSubmit;\n\treturn cjs$x;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\nif (false) {} else {\n    lib$x.exports = requireCjs$x();\n}\n\nvar libExports$x = lib$x.exports;\n\nvar lib$w = {exports: {}};\n\nvar index_min$w = {};\n\n/** \n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n *\n * @license https://formvalidation.io/license\n * @package @form-validation/plugin-dependency\n * @version 2.4.0\n */\n\nvar hasRequiredIndex_min$w;\n\nfunction requireIndex_min$w () {\n\tif (hasRequiredIndex_min$w) return index_min$w;\n\thasRequiredIndex_min$w = 1;\nvar t=libExports$B,e=function(t,r){return e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e;}||function(t,e){for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);},e(t,r)};var r=function(t){function r(e){var r=t.call(this,e)||this;return r.opts=e||{},r.triggerExecutedHandler=r.onTriggerExecuted.bind(r),r}return function(t,r){if(\"function\"!=typeof r&&null!==r)throw new TypeError(\"Class extends value \"+String(r)+\" is not a constructor or null\");function o(){this.constructor=t;}e(t,r),t.prototype=null===r?Object.create(r):(o.prototype=r.prototype,new o);}(r,t),r.prototype.install=function(){this.core.on(\"plugins.trigger.executed\",this.triggerExecutedHandler);},r.prototype.uninstall=function(){this.core.off(\"plugins.trigger.executed\",this.triggerExecutedHandler);},r.prototype.onTriggerExecuted=function(t){if(this.isEnabled&&this.opts[t.field])for(var e=0,r=this.opts[t.field].split(\" \");e<r.length;e++){var o=r[e].trim();this.opts[o]&&this.core.revalidateField(o);}},r}(t.Plugin);index_min$w.Dependency=r;\n\treturn index_min$w;\n}\n\nvar cjs$w = {};\n\nvar hasRequiredCjs$w;\n\nfunction requireCjs$w () {\n\tif (hasRequiredCjs$w) return cjs$w;\n\thasRequiredCjs$w = 1;\n\n\tvar core = libExports$B;\n\n\t/******************************************************************************\r\n\tCopyright (c) Microsoft Corporation.\r\n\r\n\tPermission to use, copy, modify, and/or distribute this software for any\r\n\tpurpose with or without fee is hereby granted.\r\n\r\n\tTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n\tREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n\tAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n\tINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n\tLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n\tOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n\tPERFORMANCE OF THIS SOFTWARE.\r\n\t***************************************************************************** */\r\n\t/* global Reflect, Promise */\r\n\r\n\tvar extendStatics = function(d, b) {\r\n\t    extendStatics = Object.setPrototypeOf ||\r\n\t        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n\t        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n\t    return extendStatics(d, b);\r\n\t};\r\n\r\n\tfunction __extends(d, b) {\r\n\t    if (typeof b !== \"function\" && b !== null)\r\n\t        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n\t    extendStatics(d, b);\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t}\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\tvar Dependency = /** @class */ (function (_super) {\n\t    __extends(Dependency, _super);\n\t    function Dependency(opts) {\n\t        var _this = _super.call(this, opts) || this;\n\t        _this.opts = opts || {};\n\t        _this.triggerExecutedHandler = _this.onTriggerExecuted.bind(_this);\n\t        return _this;\n\t    }\n\t    Dependency.prototype.install = function () {\n\t        this.core.on('plugins.trigger.executed', this.triggerExecutedHandler);\n\t    };\n\t    Dependency.prototype.uninstall = function () {\n\t        this.core.off('plugins.trigger.executed', this.triggerExecutedHandler);\n\t    };\n\t    Dependency.prototype.onTriggerExecuted = function (e) {\n\t        if (this.isEnabled && this.opts[e.field]) {\n\t            var dependencies = this.opts[e.field].split(' ');\n\t            for (var _i = 0, dependencies_1 = dependencies; _i < dependencies_1.length; _i++) {\n\t                var d = dependencies_1[_i];\n\t                var dependentField = d.trim();\n\t                if (this.opts[dependentField]) {\n\t                    // Revalidate the dependent field\n\t                    this.core.revalidateField(dependentField);\n\t                }\n\t            }\n\t        }\n\t    };\n\t    return Dependency;\n\t}(core.Plugin));\n\n\tcjs$w.Dependency = Dependency;\n\treturn cjs$w;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\nif (false) {} else {\n    lib$w.exports = requireCjs$w();\n}\n\nvar libExports$w = lib$w.exports;\n\nvar lib$v = {exports: {}};\n\nvar index_min$v = {};\n\n/** \n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n *\n * @license https://formvalidation.io/license\n * @package @form-validation/plugin-excluded\n * @version 2.4.0\n */\n\nvar hasRequiredIndex_min$v;\n\nfunction requireIndex_min$v () {\n\tif (hasRequiredIndex_min$v) return index_min$v;\n\thasRequiredIndex_min$v = 1;\nvar t=libExports$B,e=function(t,n){return e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e;}||function(t,e){for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);},e(t,n)};var n=t.utils.removeUndefined,i=function(t){function i(e){var r=t.call(this,e)||this;return r.opts=Object.assign({},{excluded:i.defaultIgnore},n(e)),r.ignoreValidationFilter=r.ignoreValidation.bind(r),r}return function(t,n){if(\"function\"!=typeof n&&null!==n)throw new TypeError(\"Class extends value \"+String(n)+\" is not a constructor or null\");function i(){this.constructor=t;}e(t,n),t.prototype=null===n?Object.create(n):(i.prototype=n.prototype,new i);}(i,t),i.defaultIgnore=function(t,e,n){var i=!!(e.offsetWidth||e.offsetHeight||e.getClientRects().length),r=e.getAttribute(\"disabled\");return \"\"===r||\"disabled\"===r||\"hidden\"===e.getAttribute(\"type\")||!i},i.prototype.install=function(){this.core.registerFilter(\"element-ignored\",this.ignoreValidationFilter);},i.prototype.uninstall=function(){this.core.deregisterFilter(\"element-ignored\",this.ignoreValidationFilter);},i.prototype.ignoreValidation=function(t,e,n){return !!this.isEnabled&&this.opts.excluded.apply(this,[t,e,n])},i}(t.Plugin);index_min$v.Excluded=i;\n\treturn index_min$v;\n}\n\nvar cjs$v = {};\n\nvar hasRequiredCjs$v;\n\nfunction requireCjs$v () {\n\tif (hasRequiredCjs$v) return cjs$v;\n\thasRequiredCjs$v = 1;\n\n\tvar core = libExports$B;\n\n\t/******************************************************************************\r\n\tCopyright (c) Microsoft Corporation.\r\n\r\n\tPermission to use, copy, modify, and/or distribute this software for any\r\n\tpurpose with or without fee is hereby granted.\r\n\r\n\tTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n\tREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n\tAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n\tINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n\tLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n\tOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n\tPERFORMANCE OF THIS SOFTWARE.\r\n\t***************************************************************************** */\r\n\t/* global Reflect, Promise */\r\n\r\n\tvar extendStatics = function(d, b) {\r\n\t    extendStatics = Object.setPrototypeOf ||\r\n\t        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n\t        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n\t    return extendStatics(d, b);\r\n\t};\r\n\r\n\tfunction __extends(d, b) {\r\n\t    if (typeof b !== \"function\" && b !== null)\r\n\t        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n\t    extendStatics(d, b);\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t}\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\tvar removeUndefined = core.utils.removeUndefined;\n\tvar Excluded = /** @class */ (function (_super) {\n\t    __extends(Excluded, _super);\n\t    function Excluded(opts) {\n\t        var _this = _super.call(this, opts) || this;\n\t        _this.opts = Object.assign({}, { excluded: Excluded.defaultIgnore }, removeUndefined(opts));\n\t        _this.ignoreValidationFilter = _this.ignoreValidation.bind(_this);\n\t        return _this;\n\t    }\n\t    Excluded.defaultIgnore = function (_field, element, _elements) {\n\t        var isVisible = !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);\n\t        var disabled = element.getAttribute('disabled');\n\t        return disabled === '' || disabled === 'disabled' || element.getAttribute('type') === 'hidden' || !isVisible;\n\t    };\n\t    Excluded.prototype.install = function () {\n\t        this.core.registerFilter('element-ignored', this.ignoreValidationFilter);\n\t    };\n\t    Excluded.prototype.uninstall = function () {\n\t        this.core.deregisterFilter('element-ignored', this.ignoreValidationFilter);\n\t    };\n\t    Excluded.prototype.ignoreValidation = function (field, element, elements) {\n\t        if (!this.isEnabled) {\n\t            return false;\n\t        }\n\t        return this.opts.excluded.apply(this, [field, element, elements]);\n\t    };\n\t    return Excluded;\n\t}(core.Plugin));\n\n\tcjs$v.Excluded = Excluded;\n\treturn cjs$v;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\nif (false) {} else {\n    lib$v.exports = requireCjs$v();\n}\n\nvar libExports$v = lib$v.exports;\n\nvar lib$u = {exports: {}};\n\nvar index_min$u = {};\n\n/** \n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n *\n * @license https://formvalidation.io/license\n * @package @form-validation/plugin-field-status\n * @version 2.4.0\n */\n\nvar hasRequiredIndex_min$u;\n\nfunction requireIndex_min$u () {\n\tif (hasRequiredIndex_min$u) return index_min$u;\n\thasRequiredIndex_min$u = 1;\nvar e=libExports$B,t=function(e,n){return t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t;}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);},t(e,n)};var n=function(e){function n(t){var n=e.call(this,t)||this;return n.statuses=new Map,n.opts=Object.assign({},{onStatusChanged:function(){}},t),n.elementValidatingHandler=n.onElementValidating.bind(n),n.elementValidatedHandler=n.onElementValidated.bind(n),n.elementNotValidatedHandler=n.onElementNotValidated.bind(n),n.elementIgnoredHandler=n.onElementIgnored.bind(n),n.fieldAddedHandler=n.onFieldAdded.bind(n),n.fieldRemovedHandler=n.onFieldRemoved.bind(n),n}return function(e,n){if(\"function\"!=typeof n&&null!==n)throw new TypeError(\"Class extends value \"+String(n)+\" is not a constructor or null\");function d(){this.constructor=e;}t(e,n),e.prototype=null===n?Object.create(n):(d.prototype=n.prototype,new d);}(n,e),n.prototype.install=function(){this.core.on(\"core.element.validating\",this.elementValidatingHandler).on(\"core.element.validated\",this.elementValidatedHandler).on(\"core.element.notvalidated\",this.elementNotValidatedHandler).on(\"core.element.ignored\",this.elementIgnoredHandler).on(\"core.field.added\",this.fieldAddedHandler).on(\"core.field.removed\",this.fieldRemovedHandler);},n.prototype.uninstall=function(){this.statuses.clear(),this.core.off(\"core.element.validating\",this.elementValidatingHandler).off(\"core.element.validated\",this.elementValidatedHandler).off(\"core.element.notvalidated\",this.elementNotValidatedHandler).off(\"core.element.ignored\",this.elementIgnoredHandler).off(\"core.field.added\",this.fieldAddedHandler).off(\"core.field.removed\",this.fieldRemovedHandler);},n.prototype.areFieldsValid=function(){return Array.from(this.statuses.values()).every((function(e){return \"Valid\"===e||\"NotValidated\"===e||\"Ignored\"===e}))},n.prototype.getStatuses=function(){return this.isEnabled?this.statuses:new Map},n.prototype.onFieldAdded=function(e){this.statuses.set(e.field,\"NotValidated\");},n.prototype.onFieldRemoved=function(e){this.statuses.has(e.field)&&this.statuses.delete(e.field),this.handleStatusChanged(this.areFieldsValid());},n.prototype.onElementValidating=function(e){this.statuses.set(e.field,\"Validating\"),this.handleStatusChanged(!1);},n.prototype.onElementValidated=function(e){this.statuses.set(e.field,e.valid?\"Valid\":\"Invalid\"),e.valid?this.handleStatusChanged(this.areFieldsValid()):this.handleStatusChanged(!1);},n.prototype.onElementNotValidated=function(e){this.statuses.set(e.field,\"NotValidated\"),this.handleStatusChanged(!1);},n.prototype.onElementIgnored=function(e){this.statuses.set(e.field,\"Ignored\"),this.handleStatusChanged(this.areFieldsValid());},n.prototype.handleStatusChanged=function(e){this.isEnabled&&this.opts.onStatusChanged(e);},n}(e.Plugin);index_min$u.FieldStatus=n;\n\treturn index_min$u;\n}\n\nvar cjs$u = {};\n\nvar hasRequiredCjs$u;\n\nfunction requireCjs$u () {\n\tif (hasRequiredCjs$u) return cjs$u;\n\thasRequiredCjs$u = 1;\n\n\tvar core = libExports$B;\n\n\t/******************************************************************************\r\n\tCopyright (c) Microsoft Corporation.\r\n\r\n\tPermission to use, copy, modify, and/or distribute this software for any\r\n\tpurpose with or without fee is hereby granted.\r\n\r\n\tTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n\tREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n\tAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n\tINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n\tLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n\tOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n\tPERFORMANCE OF THIS SOFTWARE.\r\n\t***************************************************************************** */\r\n\t/* global Reflect, Promise */\r\n\r\n\tvar extendStatics = function(d, b) {\r\n\t    extendStatics = Object.setPrototypeOf ||\r\n\t        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n\t        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n\t    return extendStatics(d, b);\r\n\t};\r\n\r\n\tfunction __extends(d, b) {\r\n\t    if (typeof b !== \"function\" && b !== null)\r\n\t        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n\t    extendStatics(d, b);\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t}\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\tvar FieldStatus = /** @class */ (function (_super) {\n\t    __extends(FieldStatus, _super);\n\t    function FieldStatus(opts) {\n\t        var _this = _super.call(this, opts) || this;\n\t        _this.statuses = new Map();\n\t        _this.opts = Object.assign({}, {\n\t            onStatusChanged: function () { },\n\t        }, opts);\n\t        _this.elementValidatingHandler = _this.onElementValidating.bind(_this);\n\t        _this.elementValidatedHandler = _this.onElementValidated.bind(_this);\n\t        _this.elementNotValidatedHandler = _this.onElementNotValidated.bind(_this);\n\t        _this.elementIgnoredHandler = _this.onElementIgnored.bind(_this);\n\t        _this.fieldAddedHandler = _this.onFieldAdded.bind(_this);\n\t        _this.fieldRemovedHandler = _this.onFieldRemoved.bind(_this);\n\t        return _this;\n\t    }\n\t    FieldStatus.prototype.install = function () {\n\t        this.core\n\t            .on('core.element.validating', this.elementValidatingHandler)\n\t            .on('core.element.validated', this.elementValidatedHandler)\n\t            .on('core.element.notvalidated', this.elementNotValidatedHandler)\n\t            .on('core.element.ignored', this.elementIgnoredHandler)\n\t            .on('core.field.added', this.fieldAddedHandler)\n\t            .on('core.field.removed', this.fieldRemovedHandler);\n\t    };\n\t    FieldStatus.prototype.uninstall = function () {\n\t        this.statuses.clear();\n\t        this.core\n\t            .off('core.element.validating', this.elementValidatingHandler)\n\t            .off('core.element.validated', this.elementValidatedHandler)\n\t            .off('core.element.notvalidated', this.elementNotValidatedHandler)\n\t            .off('core.element.ignored', this.elementIgnoredHandler)\n\t            .off('core.field.added', this.fieldAddedHandler)\n\t            .off('core.field.removed', this.fieldRemovedHandler);\n\t    };\n\t    FieldStatus.prototype.areFieldsValid = function () {\n\t        return Array.from(this.statuses.values()).every(function (value) {\n\t            return value === 'Valid' || value === 'NotValidated' || value === 'Ignored';\n\t        });\n\t    };\n\t    FieldStatus.prototype.getStatuses = function () {\n\t        return this.isEnabled ? this.statuses : new Map();\n\t    };\n\t    FieldStatus.prototype.onFieldAdded = function (e) {\n\t        this.statuses.set(e.field, 'NotValidated');\n\t    };\n\t    FieldStatus.prototype.onFieldRemoved = function (e) {\n\t        if (this.statuses.has(e.field)) {\n\t            this.statuses.delete(e.field);\n\t        }\n\t        this.handleStatusChanged(this.areFieldsValid());\n\t    };\n\t    FieldStatus.prototype.onElementValidating = function (e) {\n\t        this.statuses.set(e.field, 'Validating');\n\t        this.handleStatusChanged(false);\n\t    };\n\t    FieldStatus.prototype.onElementValidated = function (e) {\n\t        this.statuses.set(e.field, e.valid ? 'Valid' : 'Invalid');\n\t        if (e.valid) {\n\t            this.handleStatusChanged(this.areFieldsValid());\n\t        }\n\t        else {\n\t            this.handleStatusChanged(false);\n\t        }\n\t    };\n\t    FieldStatus.prototype.onElementNotValidated = function (e) {\n\t        this.statuses.set(e.field, 'NotValidated');\n\t        this.handleStatusChanged(false);\n\t    };\n\t    FieldStatus.prototype.onElementIgnored = function (e) {\n\t        this.statuses.set(e.field, 'Ignored');\n\t        this.handleStatusChanged(this.areFieldsValid());\n\t    };\n\t    FieldStatus.prototype.handleStatusChanged = function (areFieldsValid) {\n\t        if (this.isEnabled) {\n\t            this.opts.onStatusChanged(areFieldsValid);\n\t        }\n\t    };\n\t    return FieldStatus;\n\t}(core.Plugin));\n\n\tcjs$u.FieldStatus = FieldStatus;\n\treturn cjs$u;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\nif (false) {} else {\n    lib$u.exports = requireCjs$u();\n}\n\nvar libExports$u = lib$u.exports;\n\nvar lib$t = {exports: {}};\n\nvar index_min$t = {};\n\nvar lib$s = {exports: {}};\n\nvar index_min$s = {};\n\n/** \n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n *\n * @license https://formvalidation.io/license\n * @package @form-validation/plugin-message\n * @version 2.4.0\n */\n\nvar hasRequiredIndex_min$t;\n\nfunction requireIndex_min$t () {\n\tif (hasRequiredIndex_min$t) return index_min$s;\n\thasRequiredIndex_min$t = 1;\nvar e=libExports$B,t=function(e,a){return t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t;}||function(e,t){for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a]);},t(e,a)};var a=e.utils.classSet,n=function(e){function n(t){var a=e.call(this,t)||this;return a.useDefaultContainer=!1,a.messages=new Map,a.defaultContainer=document.createElement(\"div\"),a.useDefaultContainer=!t||!t.container,a.opts=Object.assign({},{container:function(e,t){return a.defaultContainer}},t),a.elementIgnoredHandler=a.onElementIgnored.bind(a),a.fieldAddedHandler=a.onFieldAdded.bind(a),a.fieldRemovedHandler=a.onFieldRemoved.bind(a),a.validatorValidatedHandler=a.onValidatorValidated.bind(a),a.validatorNotValidatedHandler=a.onValidatorNotValidated.bind(a),a}return function(e,a){if(\"function\"!=typeof a&&null!==a)throw new TypeError(\"Class extends value \"+String(a)+\" is not a constructor or null\");function n(){this.constructor=e;}t(e,a),e.prototype=null===a?Object.create(a):(n.prototype=a.prototype,new n);}(n,e),n.getClosestContainer=function(e,t,a){for(var n=e;n&&n!==t&&(n=n.parentElement,!a.test(n.className)););return n},n.prototype.install=function(){this.useDefaultContainer&&this.core.getFormElement().appendChild(this.defaultContainer),this.core.on(\"core.element.ignored\",this.elementIgnoredHandler).on(\"core.field.added\",this.fieldAddedHandler).on(\"core.field.removed\",this.fieldRemovedHandler).on(\"core.validator.validated\",this.validatorValidatedHandler).on(\"core.validator.notvalidated\",this.validatorNotValidatedHandler);},n.prototype.uninstall=function(){this.useDefaultContainer&&this.core.getFormElement().removeChild(this.defaultContainer),this.messages.forEach((function(e){return e.parentNode.removeChild(e)})),this.messages.clear(),this.core.off(\"core.element.ignored\",this.elementIgnoredHandler).off(\"core.field.added\",this.fieldAddedHandler).off(\"core.field.removed\",this.fieldRemovedHandler).off(\"core.validator.validated\",this.validatorValidatedHandler).off(\"core.validator.notvalidated\",this.validatorNotValidatedHandler);},n.prototype.onEnabled=function(){this.messages.forEach((function(e,t,n){a(t,{\"fv-plugins-message-container--enabled\":!0,\"fv-plugins-message-container--disabled\":!1});}));},n.prototype.onDisabled=function(){this.messages.forEach((function(e,t,n){a(t,{\"fv-plugins-message-container--enabled\":!1,\"fv-plugins-message-container--disabled\":!0});}));},n.prototype.onFieldAdded=function(e){var t=this,a=e.elements;a&&(a.forEach((function(e){var a=t.messages.get(e);a&&(a.parentNode.removeChild(a),t.messages.delete(e));})),this.prepareFieldContainer(e.field,a));},n.prototype.onFieldRemoved=function(e){var t=this;if(e.elements.length&&e.field){var a=e.elements[0].getAttribute(\"type\");(\"radio\"===a||\"checkbox\"===a?[e.elements[0]]:e.elements).forEach((function(e){if(t.messages.has(e)){var a=t.messages.get(e);a.parentNode.removeChild(a),t.messages.delete(e);}}));}},n.prototype.prepareFieldContainer=function(e,t){var a=this;if(t.length){var n=t[0].getAttribute(\"type\");\"radio\"===n||\"checkbox\"===n?this.prepareElementContainer(e,t[0],t):t.forEach((function(n){return a.prepareElementContainer(e,n,t)}));}},n.prototype.prepareElementContainer=function(e,t,n){var i;if(\"string\"==typeof this.opts.container){var o=\"#\"===this.opts.container.charAt(0)?'[id=\"'.concat(this.opts.container.substring(1),'\"]'):this.opts.container;i=this.core.getFormElement().querySelector(o);}else i=this.opts.container(e,t);var r=document.createElement(\"div\");i.appendChild(r),a(r,{\"fv-plugins-message-container\":!0,\"fv-plugins-message-container--enabled\":this.isEnabled,\"fv-plugins-message-container--disabled\":!this.isEnabled}),this.core.emit(\"plugins.message.placed\",{element:t,elements:n,field:e,messageElement:r}),this.messages.set(t,r);},n.prototype.getMessage=function(e){return \"string\"==typeof e.message?e.message:e.message[this.core.getLocale()]},n.prototype.onValidatorValidated=function(e){var t,n=e.elements,i=e.element.getAttribute(\"type\"),o=(\"radio\"===i||\"checkbox\"===i)&&n.length>0?n[0]:e.element;if(this.messages.has(o)){var r=this.messages.get(o),s=r.querySelector('[data-field=\"'.concat(e.field.replace(/\"/g,'\\\\\"'),'\"][data-validator=\"').concat(e.validator.replace(/\"/g,'\\\\\"'),'\"]'));if(s||e.result.valid)s&&!e.result.valid?(s.innerHTML=this.getMessage(e.result),this.core.emit(\"plugins.message.displayed\",{element:e.element,field:e.field,message:e.result.message,messageElement:s,meta:e.result.meta,validator:e.validator})):s&&e.result.valid&&r.removeChild(s);else {var l=document.createElement(\"div\");l.innerHTML=this.getMessage(e.result),l.setAttribute(\"data-field\",e.field),l.setAttribute(\"data-validator\",e.validator),this.opts.clazz&&a(l,((t={})[this.opts.clazz]=!0,t)),r.appendChild(l),this.core.emit(\"plugins.message.displayed\",{element:e.element,field:e.field,message:e.result.message,messageElement:l,meta:e.result.meta,validator:e.validator});}}},n.prototype.onValidatorNotValidated=function(e){var t=e.elements,a=e.element.getAttribute(\"type\"),n=\"radio\"===a||\"checkbox\"===a?t[0]:e.element;if(this.messages.has(n)){var i=this.messages.get(n),o=i.querySelector('[data-field=\"'.concat(e.field.replace(/\"/g,'\\\\\"'),'\"][data-validator=\"').concat(e.validator.replace(/\"/g,'\\\\\"'),'\"]'));o&&i.removeChild(o);}},n.prototype.onElementIgnored=function(e){var t=e.elements,a=e.element.getAttribute(\"type\"),n=\"radio\"===a||\"checkbox\"===a?t[0]:e.element;if(this.messages.has(n)){var i=this.messages.get(n);[].slice.call(i.querySelectorAll('[data-field=\"'.concat(e.field.replace(/\"/g,'\\\\\"'),'\"]'))).forEach((function(e){i.removeChild(e);}));}},n}(e.Plugin);index_min$s.Message=n;\n\treturn index_min$s;\n}\n\nvar cjs$t = {};\n\nvar hasRequiredCjs$t;\n\nfunction requireCjs$t () {\n\tif (hasRequiredCjs$t) return cjs$t;\n\thasRequiredCjs$t = 1;\n\n\tvar core = libExports$B;\n\n\t/******************************************************************************\r\n\tCopyright (c) Microsoft Corporation.\r\n\r\n\tPermission to use, copy, modify, and/or distribute this software for any\r\n\tpurpose with or without fee is hereby granted.\r\n\r\n\tTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n\tREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n\tAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n\tINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n\tLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n\tOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n\tPERFORMANCE OF THIS SOFTWARE.\r\n\t***************************************************************************** */\r\n\t/* global Reflect, Promise */\r\n\r\n\tvar extendStatics = function(d, b) {\r\n\t    extendStatics = Object.setPrototypeOf ||\r\n\t        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n\t        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n\t    return extendStatics(d, b);\r\n\t};\r\n\r\n\tfunction __extends(d, b) {\r\n\t    if (typeof b !== \"function\" && b !== null)\r\n\t        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n\t    extendStatics(d, b);\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t}\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\tvar classSet = core.utils.classSet;\n\tvar Message = /** @class */ (function (_super) {\n\t    __extends(Message, _super);\n\t    function Message(opts) {\n\t        var _this = _super.call(this, opts) || this;\n\t        _this.useDefaultContainer = false;\n\t        // Map the field element to message container\n\t        _this.messages = new Map();\n\t        // By default, we will display error messages at the bottom of form\n\t        _this.defaultContainer = document.createElement('div');\n\t        _this.useDefaultContainer = !opts || !opts.container;\n\t        _this.opts = Object.assign({}, {\n\t            container: function (_field, _element) { return _this.defaultContainer; },\n\t        }, opts);\n\t        _this.elementIgnoredHandler = _this.onElementIgnored.bind(_this);\n\t        _this.fieldAddedHandler = _this.onFieldAdded.bind(_this);\n\t        _this.fieldRemovedHandler = _this.onFieldRemoved.bind(_this);\n\t        _this.validatorValidatedHandler = _this.onValidatorValidated.bind(_this);\n\t        _this.validatorNotValidatedHandler = _this.onValidatorNotValidated.bind(_this);\n\t        return _this;\n\t    }\n\t    /**\n\t     * Determine the closest element that its class matches with given pattern.\n\t     * In popular cases, all the fields might follow the same markup, so that closest element\n\t     * can be used as message container.\n\t     *\n\t     * For example, if we use the Bootstrap framework then the field often be placed inside a\n\t     * `col-{size}-{numberOfColumns}` class, we can register the plugin as following:\n\t     * ```\n\t     *  formValidation(form, {\n\t     *      plugins: {\n\t     *          message: new Message({\n\t     *              container: function(field, element) {\n\t     *                  return Message.getClosestContainer(element, form, /^(.*)(col|offset)-(xs|sm|md|lg)-[0-9]+(.*)$/)\n\t     *              }\n\t     *          })\n\t     *      }\n\t     *  })\n\t     * ```\n\t     *\n\t     * @param element The field element\n\t     * @param upper The upper element, so we don't have to look for the entire page\n\t     * @param pattern The pattern\n\t     * @return {HTMLElement}\n\t     */\n\t    Message.getClosestContainer = function (element, upper, pattern) {\n\t        var ele = element;\n\t        while (ele) {\n\t            if (ele === upper) {\n\t                break;\n\t            }\n\t            ele = ele.parentElement;\n\t            if (pattern.test(ele.className)) {\n\t                break;\n\t            }\n\t        }\n\t        return ele;\n\t    };\n\t    Message.prototype.install = function () {\n\t        if (this.useDefaultContainer) {\n\t            this.core.getFormElement().appendChild(this.defaultContainer);\n\t        }\n\t        this.core\n\t            .on('core.element.ignored', this.elementIgnoredHandler)\n\t            .on('core.field.added', this.fieldAddedHandler)\n\t            .on('core.field.removed', this.fieldRemovedHandler)\n\t            .on('core.validator.validated', this.validatorValidatedHandler)\n\t            .on('core.validator.notvalidated', this.validatorNotValidatedHandler);\n\t    };\n\t    Message.prototype.uninstall = function () {\n\t        if (this.useDefaultContainer) {\n\t            this.core.getFormElement().removeChild(this.defaultContainer);\n\t        }\n\t        this.messages.forEach(function (message) { return message.parentNode.removeChild(message); });\n\t        this.messages.clear();\n\t        this.core\n\t            .off('core.element.ignored', this.elementIgnoredHandler)\n\t            .off('core.field.added', this.fieldAddedHandler)\n\t            .off('core.field.removed', this.fieldRemovedHandler)\n\t            .off('core.validator.validated', this.validatorValidatedHandler)\n\t            .off('core.validator.notvalidated', this.validatorNotValidatedHandler);\n\t    };\n\t    Message.prototype.onEnabled = function () {\n\t        this.messages.forEach(function (_element, message, _map) {\n\t            classSet(message, {\n\t                'fv-plugins-message-container--enabled': true,\n\t                'fv-plugins-message-container--disabled': false,\n\t            });\n\t        });\n\t    };\n\t    Message.prototype.onDisabled = function () {\n\t        this.messages.forEach(function (_element, message, _map) {\n\t            classSet(message, {\n\t                'fv-plugins-message-container--enabled': false,\n\t                'fv-plugins-message-container--disabled': true,\n\t            });\n\t        });\n\t    };\n\t    // Prepare message container for new added field\n\t    Message.prototype.onFieldAdded = function (e) {\n\t        var _this = this;\n\t        var elements = e.elements;\n\t        if (elements) {\n\t            elements.forEach(function (ele) {\n\t                var msg = _this.messages.get(ele);\n\t                if (msg) {\n\t                    msg.parentNode.removeChild(msg);\n\t                    _this.messages.delete(ele);\n\t                }\n\t            });\n\t            this.prepareFieldContainer(e.field, elements);\n\t        }\n\t    };\n\t    // When a field is removed, we remove all error messages that associates with the field\n\t    Message.prototype.onFieldRemoved = function (e) {\n\t        var _this = this;\n\t        if (!e.elements.length || !e.field) {\n\t            return;\n\t        }\n\t        var type = e.elements[0].getAttribute('type');\n\t        var elements = 'radio' === type || 'checkbox' === type ? [e.elements[0]] : e.elements;\n\t        elements.forEach(function (ele) {\n\t            if (_this.messages.has(ele)) {\n\t                var container = _this.messages.get(ele);\n\t                container.parentNode.removeChild(container);\n\t                _this.messages.delete(ele);\n\t            }\n\t        });\n\t    };\n\t    Message.prototype.prepareFieldContainer = function (field, elements) {\n\t        var _this = this;\n\t        if (elements.length) {\n\t            var type = elements[0].getAttribute('type');\n\t            if ('radio' === type || 'checkbox' === type) {\n\t                this.prepareElementContainer(field, elements[0], elements);\n\t            }\n\t            else {\n\t                elements.forEach(function (ele) { return _this.prepareElementContainer(field, ele, elements); });\n\t            }\n\t        }\n\t    };\n\t    Message.prototype.prepareElementContainer = function (field, element, elements) {\n\t        var container;\n\t        if ('string' === typeof this.opts.container) {\n\t            var selector = '#' === this.opts.container.charAt(0)\n\t                ? \"[id=\\\"\".concat(this.opts.container.substring(1), \"\\\"]\")\n\t                : this.opts.container;\n\t            container = this.core.getFormElement().querySelector(selector);\n\t        }\n\t        else {\n\t            container = this.opts.container(field, element);\n\t        }\n\t        var message = document.createElement('div');\n\t        container.appendChild(message);\n\t        classSet(message, {\n\t            'fv-plugins-message-container': true,\n\t            'fv-plugins-message-container--enabled': this.isEnabled,\n\t            'fv-plugins-message-container--disabled': !this.isEnabled,\n\t        });\n\t        this.core.emit('plugins.message.placed', {\n\t            element: element,\n\t            elements: elements,\n\t            field: field,\n\t            messageElement: message,\n\t        });\n\t        this.messages.set(element, message);\n\t    };\n\t    Message.prototype.getMessage = function (result) {\n\t        return typeof result.message === 'string' ? result.message : result.message[this.core.getLocale()];\n\t    };\n\t    Message.prototype.onValidatorValidated = function (e) {\n\t        var _a;\n\t        var elements = e.elements;\n\t        var type = e.element.getAttribute('type');\n\t        var element = ('radio' === type || 'checkbox' === type) && elements.length > 0 ? elements[0] : e.element;\n\t        if (this.messages.has(element)) {\n\t            var container = this.messages.get(element);\n\t            var messageEle = container.querySelector(\"[data-field=\\\"\".concat(e.field.replace(/\"/g, '\\\\\"'), \"\\\"][data-validator=\\\"\").concat(e.validator.replace(/\"/g, '\\\\\"'), \"\\\"]\"));\n\t            if (!messageEle && !e.result.valid) {\n\t                var ele = document.createElement('div');\n\t                ele.innerHTML = this.getMessage(e.result);\n\t                ele.setAttribute('data-field', e.field);\n\t                ele.setAttribute('data-validator', e.validator);\n\t                if (this.opts.clazz) {\n\t                    classSet(ele, (_a = {},\n\t                        _a[this.opts.clazz] = true,\n\t                        _a));\n\t                }\n\t                container.appendChild(ele);\n\t                this.core.emit('plugins.message.displayed', {\n\t                    element: e.element,\n\t                    field: e.field,\n\t                    message: e.result.message,\n\t                    messageElement: ele,\n\t                    meta: e.result.meta,\n\t                    validator: e.validator,\n\t                });\n\t            }\n\t            else if (messageEle && !e.result.valid) {\n\t                // The validator returns new message\n\t                messageEle.innerHTML = this.getMessage(e.result);\n\t                this.core.emit('plugins.message.displayed', {\n\t                    element: e.element,\n\t                    field: e.field,\n\t                    message: e.result.message,\n\t                    messageElement: messageEle,\n\t                    meta: e.result.meta,\n\t                    validator: e.validator,\n\t                });\n\t            }\n\t            else if (messageEle && e.result.valid) {\n\t                // Field is valid\n\t                container.removeChild(messageEle);\n\t            }\n\t        }\n\t    };\n\t    Message.prototype.onValidatorNotValidated = function (e) {\n\t        var elements = e.elements;\n\t        var type = e.element.getAttribute('type');\n\t        var element = 'radio' === type || 'checkbox' === type ? elements[0] : e.element;\n\t        if (this.messages.has(element)) {\n\t            var container = this.messages.get(element);\n\t            var messageEle = container.querySelector(\"[data-field=\\\"\".concat(e.field.replace(/\"/g, '\\\\\"'), \"\\\"][data-validator=\\\"\").concat(e.validator.replace(/\"/g, '\\\\\"'), \"\\\"]\"));\n\t            if (messageEle) {\n\t                container.removeChild(messageEle);\n\t            }\n\t        }\n\t    };\n\t    Message.prototype.onElementIgnored = function (e) {\n\t        var elements = e.elements;\n\t        var type = e.element.getAttribute('type');\n\t        var element = 'radio' === type || 'checkbox' === type ? elements[0] : e.element;\n\t        if (this.messages.has(element)) {\n\t            var container_1 = this.messages.get(element);\n\t            var messageElements = [].slice.call(container_1.querySelectorAll(\"[data-field=\\\"\".concat(e.field.replace(/\"/g, '\\\\\"'), \"\\\"]\")));\n\t            messageElements.forEach(function (messageEle) {\n\t                container_1.removeChild(messageEle);\n\t            });\n\t        }\n\t    };\n\t    return Message;\n\t}(core.Plugin));\n\n\tcjs$t.Message = Message;\n\treturn cjs$t;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\nif (false) {} else {\n    lib$s.exports = requireCjs$t();\n}\n\nvar libExports$t = lib$s.exports;\n\n/** \n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n *\n * @license https://formvalidation.io/license\n * @package @form-validation/plugin-framework\n * @version 2.4.0\n */\n\nvar hasRequiredIndex_min$s;\n\nfunction requireIndex_min$s () {\n\tif (hasRequiredIndex_min$s) return index_min$t;\n\thasRequiredIndex_min$s = 1;\nvar e=libExports$B,t=libExports$t,o=function(e,t){return o=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t;}||function(e,t){for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o]);},o(e,t)};var n=e.utils.classSet,s=e.utils.closest,i=function(e){function i(t){var o=e.call(this,t)||this;return o.results=new Map,o.containers=new Map,o.opts=Object.assign({},{defaultMessageContainer:!0,eleInvalidClass:\"\",eleValidClass:\"\",rowClasses:\"\",rowValidatingClass:\"\"},t),o.elementIgnoredHandler=o.onElementIgnored.bind(o),o.elementValidatingHandler=o.onElementValidating.bind(o),o.elementValidatedHandler=o.onElementValidated.bind(o),o.elementNotValidatedHandler=o.onElementNotValidated.bind(o),o.iconPlacedHandler=o.onIconPlaced.bind(o),o.fieldAddedHandler=o.onFieldAdded.bind(o),o.fieldRemovedHandler=o.onFieldRemoved.bind(o),o.messagePlacedHandler=o.onMessagePlaced.bind(o),o}return function(e,t){if(\"function\"!=typeof t&&null!==t)throw new TypeError(\"Class extends value \"+String(t)+\" is not a constructor or null\");function n(){this.constructor=e;}o(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n);}(i,e),i.prototype.install=function(){var e,o=this;n(this.core.getFormElement(),((e={})[this.opts.formClass]=!0,e[\"fv-plugins-framework\"]=!0,e)),this.core.on(\"core.element.ignored\",this.elementIgnoredHandler).on(\"core.element.validating\",this.elementValidatingHandler).on(\"core.element.validated\",this.elementValidatedHandler).on(\"core.element.notvalidated\",this.elementNotValidatedHandler).on(\"plugins.icon.placed\",this.iconPlacedHandler).on(\"core.field.added\",this.fieldAddedHandler).on(\"core.field.removed\",this.fieldRemovedHandler),this.opts.defaultMessageContainer&&(this.core.registerPlugin(i.MESSAGE_PLUGIN,new t.Message({clazz:this.opts.messageClass,container:function(e,n){var i=\"string\"==typeof o.opts.rowSelector?o.opts.rowSelector:o.opts.rowSelector(e,n),a=s(n,i);return t.Message.getClosestContainer(n,a,o.opts.rowPattern)}})),this.core.on(\"plugins.message.placed\",this.messagePlacedHandler));},i.prototype.uninstall=function(){var e;this.results.clear(),this.containers.clear(),n(this.core.getFormElement(),((e={})[this.opts.formClass]=!1,e[\"fv-plugins-framework\"]=!1,e)),this.core.off(\"core.element.ignored\",this.elementIgnoredHandler).off(\"core.element.validating\",this.elementValidatingHandler).off(\"core.element.validated\",this.elementValidatedHandler).off(\"core.element.notvalidated\",this.elementNotValidatedHandler).off(\"plugins.icon.placed\",this.iconPlacedHandler).off(\"core.field.added\",this.fieldAddedHandler).off(\"core.field.removed\",this.fieldRemovedHandler),this.opts.defaultMessageContainer&&(this.core.deregisterPlugin(i.MESSAGE_PLUGIN),this.core.off(\"plugins.message.placed\",this.messagePlacedHandler));},i.prototype.onEnabled=function(){var e;n(this.core.getFormElement(),((e={})[this.opts.formClass]=!0,e)),this.opts.defaultMessageContainer&&this.core.enablePlugin(i.MESSAGE_PLUGIN);},i.prototype.onDisabled=function(){var e;n(this.core.getFormElement(),((e={})[this.opts.formClass]=!1,e)),this.opts.defaultMessageContainer&&this.core.disablePlugin(i.MESSAGE_PLUGIN);},i.prototype.onIconPlaced=function(e){},i.prototype.onMessagePlaced=function(e){},i.prototype.onFieldAdded=function(e){var t=this,o=e.elements;o&&(o.forEach((function(e){var o,s=t.containers.get(e);s&&(n(s,((o={})[t.opts.rowInvalidClass]=!1,o[t.opts.rowValidatingClass]=!1,o[t.opts.rowValidClass]=!1,o[\"fv-plugins-icon-container\"]=!1,o)),t.containers.delete(e));})),this.prepareFieldContainer(e.field,o));},i.prototype.onFieldRemoved=function(e){var t=this;e.elements.forEach((function(e){var o,s=t.containers.get(e);s&&n(s,((o={})[t.opts.rowInvalidClass]=!1,o[t.opts.rowValidatingClass]=!1,o[t.opts.rowValidClass]=!1,o));}));},i.prototype.prepareFieldContainer=function(e,t){var o=this;if(t.length){var n=t[0].getAttribute(\"type\");\"radio\"===n||\"checkbox\"===n?this.prepareElementContainer(e,t[0]):t.forEach((function(t){return o.prepareElementContainer(e,t)}));}},i.prototype.prepareElementContainer=function(e,t){var o,i=\"string\"==typeof this.opts.rowSelector?this.opts.rowSelector:this.opts.rowSelector(e,t),a=s(t,i);a!==t&&(n(a,((o={})[this.opts.rowClasses]=!0,o[\"fv-plugins-icon-container\"]=!0,o)),this.containers.set(t,a));},i.prototype.onElementValidating=function(e){this.removeClasses(e.element,e.elements);},i.prototype.onElementNotValidated=function(e){this.removeClasses(e.element,e.elements);},i.prototype.onElementIgnored=function(e){this.removeClasses(e.element,e.elements);},i.prototype.removeClasses=function(e,t){var o,s=this,i=e.getAttribute(\"type\"),a=\"radio\"===i||\"checkbox\"===i?t[0]:e;t.forEach((function(e){var t;n(e,((t={})[s.opts.eleValidClass]=!1,t[s.opts.eleInvalidClass]=!1,t));}));var l=this.containers.get(a);l&&n(l,((o={})[this.opts.rowInvalidClass]=!1,o[this.opts.rowValidatingClass]=!1,o[this.opts.rowValidClass]=!1,o));},i.prototype.onElementValidated=function(e){var t,o,s=this,i=e.elements,a=e.element.getAttribute(\"type\"),l=\"radio\"===a||\"checkbox\"===a?i[0]:e.element;i.forEach((function(t){var o;n(t,((o={})[s.opts.eleValidClass]=e.valid,o[s.opts.eleInvalidClass]=!e.valid,o));}));var r=this.containers.get(l);if(r)if(e.valid){this.results.delete(l);var d=!0;this.containers.forEach((function(e,t){e===r&&!1===s.results.get(t)&&(d=!1);})),d&&n(r,((o={})[this.opts.rowInvalidClass]=!1,o[this.opts.rowValidatingClass]=!1,o[this.opts.rowValidClass]=!0,o));}else this.results.set(l,!1),n(r,((t={})[this.opts.rowInvalidClass]=!0,t[this.opts.rowValidatingClass]=!1,t[this.opts.rowValidClass]=!1,t));},i.MESSAGE_PLUGIN=\"___frameworkMessage\",i}(e.Plugin);index_min$t.Framework=i;\n\treturn index_min$t;\n}\n\nvar cjs$s = {};\n\nvar hasRequiredCjs$s;\n\nfunction requireCjs$s () {\n\tif (hasRequiredCjs$s) return cjs$s;\n\thasRequiredCjs$s = 1;\n\n\tvar core = libExports$B;\n\tvar pluginMessage = libExports$t;\n\n\t/******************************************************************************\r\n\tCopyright (c) Microsoft Corporation.\r\n\r\n\tPermission to use, copy, modify, and/or distribute this software for any\r\n\tpurpose with or without fee is hereby granted.\r\n\r\n\tTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n\tREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n\tAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n\tINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n\tLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n\tOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n\tPERFORMANCE OF THIS SOFTWARE.\r\n\t***************************************************************************** */\r\n\t/* global Reflect, Promise */\r\n\r\n\tvar extendStatics = function(d, b) {\r\n\t    extendStatics = Object.setPrototypeOf ||\r\n\t        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n\t        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n\t    return extendStatics(d, b);\r\n\t};\r\n\r\n\tfunction __extends(d, b) {\r\n\t    if (typeof b !== \"function\" && b !== null)\r\n\t        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n\t    extendStatics(d, b);\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t}\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\tvar classSet = core.utils.classSet, closest = core.utils.closest;\n\tvar Framework = /** @class */ (function (_super) {\n\t    __extends(Framework, _super);\n\t    function Framework(opts) {\n\t        var _this = _super.call(this, opts) || this;\n\t        _this.results = new Map();\n\t        _this.containers = new Map();\n\t        _this.opts = Object.assign({}, {\n\t            defaultMessageContainer: true,\n\t            eleInvalidClass: '',\n\t            eleValidClass: '',\n\t            rowClasses: '',\n\t            rowValidatingClass: '',\n\t        }, opts);\n\t        _this.elementIgnoredHandler = _this.onElementIgnored.bind(_this);\n\t        _this.elementValidatingHandler = _this.onElementValidating.bind(_this);\n\t        _this.elementValidatedHandler = _this.onElementValidated.bind(_this);\n\t        _this.elementNotValidatedHandler = _this.onElementNotValidated.bind(_this);\n\t        _this.iconPlacedHandler = _this.onIconPlaced.bind(_this);\n\t        _this.fieldAddedHandler = _this.onFieldAdded.bind(_this);\n\t        _this.fieldRemovedHandler = _this.onFieldRemoved.bind(_this);\n\t        _this.messagePlacedHandler = _this.onMessagePlaced.bind(_this);\n\t        return _this;\n\t    }\n\t    Framework.prototype.install = function () {\n\t        var _a;\n\t        var _this = this;\n\t        classSet(this.core.getFormElement(), (_a = {},\n\t            _a[this.opts.formClass] = true,\n\t            _a['fv-plugins-framework'] = true,\n\t            _a));\n\t        this.core\n\t            .on('core.element.ignored', this.elementIgnoredHandler)\n\t            .on('core.element.validating', this.elementValidatingHandler)\n\t            .on('core.element.validated', this.elementValidatedHandler)\n\t            .on('core.element.notvalidated', this.elementNotValidatedHandler)\n\t            .on('plugins.icon.placed', this.iconPlacedHandler)\n\t            .on('core.field.added', this.fieldAddedHandler)\n\t            .on('core.field.removed', this.fieldRemovedHandler);\n\t        if (this.opts.defaultMessageContainer) {\n\t            this.core.registerPlugin(Framework.MESSAGE_PLUGIN, new pluginMessage.Message({\n\t                clazz: this.opts.messageClass,\n\t                container: function (field, element) {\n\t                    var selector = 'string' === typeof _this.opts.rowSelector\n\t                        ? _this.opts.rowSelector\n\t                        : _this.opts.rowSelector(field, element);\n\t                    var groupEle = closest(element, selector);\n\t                    return pluginMessage.Message.getClosestContainer(element, groupEle, _this.opts.rowPattern);\n\t                },\n\t            }));\n\t            this.core.on('plugins.message.placed', this.messagePlacedHandler);\n\t        }\n\t    };\n\t    Framework.prototype.uninstall = function () {\n\t        var _a;\n\t        this.results.clear();\n\t        this.containers.clear();\n\t        classSet(this.core.getFormElement(), (_a = {},\n\t            _a[this.opts.formClass] = false,\n\t            _a['fv-plugins-framework'] = false,\n\t            _a));\n\t        this.core\n\t            .off('core.element.ignored', this.elementIgnoredHandler)\n\t            .off('core.element.validating', this.elementValidatingHandler)\n\t            .off('core.element.validated', this.elementValidatedHandler)\n\t            .off('core.element.notvalidated', this.elementNotValidatedHandler)\n\t            .off('plugins.icon.placed', this.iconPlacedHandler)\n\t            .off('core.field.added', this.fieldAddedHandler)\n\t            .off('core.field.removed', this.fieldRemovedHandler);\n\t        if (this.opts.defaultMessageContainer) {\n\t            this.core.deregisterPlugin(Framework.MESSAGE_PLUGIN);\n\t            this.core.off('plugins.message.placed', this.messagePlacedHandler);\n\t        }\n\t    };\n\t    Framework.prototype.onEnabled = function () {\n\t        var _a;\n\t        classSet(this.core.getFormElement(), (_a = {},\n\t            _a[this.opts.formClass] = true,\n\t            _a));\n\t        if (this.opts.defaultMessageContainer) {\n\t            this.core.enablePlugin(Framework.MESSAGE_PLUGIN);\n\t        }\n\t    };\n\t    Framework.prototype.onDisabled = function () {\n\t        var _a;\n\t        classSet(this.core.getFormElement(), (_a = {},\n\t            _a[this.opts.formClass] = false,\n\t            _a));\n\t        if (this.opts.defaultMessageContainer) {\n\t            this.core.disablePlugin(Framework.MESSAGE_PLUGIN);\n\t        }\n\t    };\n\t    Framework.prototype.onIconPlaced = function (_e) { }; // eslint-disable-line @typescript-eslint/no-empty-function\n\t    Framework.prototype.onMessagePlaced = function (_e) { }; // eslint-disable-line @typescript-eslint/no-empty-function\n\t    Framework.prototype.onFieldAdded = function (e) {\n\t        var _this = this;\n\t        var elements = e.elements;\n\t        if (elements) {\n\t            elements.forEach(function (ele) {\n\t                var _a;\n\t                var groupEle = _this.containers.get(ele);\n\t                if (groupEle) {\n\t                    classSet(groupEle, (_a = {},\n\t                        _a[_this.opts.rowInvalidClass] = false,\n\t                        _a[_this.opts.rowValidatingClass] = false,\n\t                        _a[_this.opts.rowValidClass] = false,\n\t                        _a['fv-plugins-icon-container'] = false,\n\t                        _a));\n\t                    _this.containers.delete(ele);\n\t                }\n\t            });\n\t            this.prepareFieldContainer(e.field, elements);\n\t        }\n\t    };\n\t    Framework.prototype.onFieldRemoved = function (e) {\n\t        var _this = this;\n\t        e.elements.forEach(function (ele) {\n\t            var _a;\n\t            var groupEle = _this.containers.get(ele);\n\t            if (groupEle) {\n\t                classSet(groupEle, (_a = {},\n\t                    _a[_this.opts.rowInvalidClass] = false,\n\t                    _a[_this.opts.rowValidatingClass] = false,\n\t                    _a[_this.opts.rowValidClass] = false,\n\t                    _a));\n\t            }\n\t        });\n\t    };\n\t    Framework.prototype.prepareFieldContainer = function (field, elements) {\n\t        var _this = this;\n\t        if (elements.length) {\n\t            var type = elements[0].getAttribute('type');\n\t            if ('radio' === type || 'checkbox' === type) {\n\t                this.prepareElementContainer(field, elements[0]);\n\t            }\n\t            else {\n\t                elements.forEach(function (ele) { return _this.prepareElementContainer(field, ele); });\n\t            }\n\t        }\n\t    };\n\t    Framework.prototype.prepareElementContainer = function (field, element) {\n\t        var _a;\n\t        var selector = 'string' === typeof this.opts.rowSelector ? this.opts.rowSelector : this.opts.rowSelector(field, element);\n\t        var groupEle = closest(element, selector);\n\t        if (groupEle !== element) {\n\t            classSet(groupEle, (_a = {},\n\t                _a[this.opts.rowClasses] = true,\n\t                _a['fv-plugins-icon-container'] = true,\n\t                _a));\n\t            this.containers.set(element, groupEle);\n\t        }\n\t    };\n\t    Framework.prototype.onElementValidating = function (e) {\n\t        this.removeClasses(e.element, e.elements);\n\t    };\n\t    Framework.prototype.onElementNotValidated = function (e) {\n\t        this.removeClasses(e.element, e.elements);\n\t    };\n\t    Framework.prototype.onElementIgnored = function (e) {\n\t        this.removeClasses(e.element, e.elements);\n\t    };\n\t    Framework.prototype.removeClasses = function (element, elements) {\n\t        var _a;\n\t        var _this = this;\n\t        var type = element.getAttribute('type');\n\t        var ele = 'radio' === type || 'checkbox' === type ? elements[0] : element;\n\t        elements.forEach(function (ele) {\n\t            var _a;\n\t            classSet(ele, (_a = {},\n\t                _a[_this.opts.eleValidClass] = false,\n\t                _a[_this.opts.eleInvalidClass] = false,\n\t                _a));\n\t        });\n\t        var groupEle = this.containers.get(ele);\n\t        if (groupEle) {\n\t            classSet(groupEle, (_a = {},\n\t                _a[this.opts.rowInvalidClass] = false,\n\t                _a[this.opts.rowValidatingClass] = false,\n\t                _a[this.opts.rowValidClass] = false,\n\t                _a));\n\t        }\n\t    };\n\t    Framework.prototype.onElementValidated = function (e) {\n\t        var _a, _b;\n\t        var _this = this;\n\t        var elements = e.elements;\n\t        var type = e.element.getAttribute('type');\n\t        var element = 'radio' === type || 'checkbox' === type ? elements[0] : e.element;\n\t        // Set the valid or invalid class for all elements\n\t        elements.forEach(function (ele) {\n\t            var _a;\n\t            classSet(ele, (_a = {},\n\t                _a[_this.opts.eleValidClass] = e.valid,\n\t                _a[_this.opts.eleInvalidClass] = !e.valid,\n\t                _a));\n\t        });\n\t        var groupEle = this.containers.get(element);\n\t        if (groupEle) {\n\t            if (!e.valid) {\n\t                this.results.set(element, false);\n\t                classSet(groupEle, (_a = {},\n\t                    _a[this.opts.rowInvalidClass] = true,\n\t                    _a[this.opts.rowValidatingClass] = false,\n\t                    _a[this.opts.rowValidClass] = false,\n\t                    _a));\n\t            }\n\t            else {\n\t                this.results.delete(element);\n\t                // Maybe there're multiple fields belong to the same row\n\t                var isValid_1 = true;\n\t                this.containers.forEach(function (value, key) {\n\t                    if (value === groupEle && _this.results.get(key) === false) {\n\t                        isValid_1 = false;\n\t                    }\n\t                });\n\t                // If all field(s) belonging to the row are valid\n\t                if (isValid_1) {\n\t                    classSet(groupEle, (_b = {},\n\t                        _b[this.opts.rowInvalidClass] = false,\n\t                        _b[this.opts.rowValidatingClass] = false,\n\t                        _b[this.opts.rowValidClass] = true,\n\t                        _b));\n\t                }\n\t            }\n\t        }\n\t    };\n\t    Framework.MESSAGE_PLUGIN = '___frameworkMessage';\n\t    return Framework;\n\t}(core.Plugin));\n\n\tcjs$s.Framework = Framework;\n\treturn cjs$s;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\nif (false) {} else {\n    lib$t.exports = requireCjs$s();\n}\n\nvar libExports$s = lib$t.exports;\n\nvar lib$r = {exports: {}};\n\nvar index_min$r = {};\n\n/** \n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n *\n * @license https://formvalidation.io/license\n * @package @form-validation/plugin-icon\n * @version 2.4.0\n */\n\nvar hasRequiredIndex_min$r;\n\nfunction requireIndex_min$r () {\n\tif (hasRequiredIndex_min$r) return index_min$r;\n\thasRequiredIndex_min$r = 1;\nvar e=libExports$B,t=function(e,n){return t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t;}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);},t(e,n)};var n=e.utils.classSet,i=function(e){function i(t){var n=e.call(this,t)||this;return n.icons=new Map,n.opts=Object.assign({},{invalid:\"fv-plugins-icon--invalid\",onPlaced:function(){},onSet:function(){},valid:\"fv-plugins-icon--valid\",validating:\"fv-plugins-icon--validating\"},t),n.elementValidatingHandler=n.onElementValidating.bind(n),n.elementValidatedHandler=n.onElementValidated.bind(n),n.elementNotValidatedHandler=n.onElementNotValidated.bind(n),n.elementIgnoredHandler=n.onElementIgnored.bind(n),n.fieldAddedHandler=n.onFieldAdded.bind(n),n}return function(e,n){if(\"function\"!=typeof n&&null!==n)throw new TypeError(\"Class extends value \"+String(n)+\" is not a constructor or null\");function i(){this.constructor=e;}t(e,n),e.prototype=null===n?Object.create(n):(i.prototype=n.prototype,new i);}(i,e),i.prototype.install=function(){this.core.on(\"core.element.validating\",this.elementValidatingHandler).on(\"core.element.validated\",this.elementValidatedHandler).on(\"core.element.notvalidated\",this.elementNotValidatedHandler).on(\"core.element.ignored\",this.elementIgnoredHandler).on(\"core.field.added\",this.fieldAddedHandler);},i.prototype.uninstall=function(){this.icons.forEach((function(e){return e.parentNode.removeChild(e)})),this.icons.clear(),this.core.off(\"core.element.validating\",this.elementValidatingHandler).off(\"core.element.validated\",this.elementValidatedHandler).off(\"core.element.notvalidated\",this.elementNotValidatedHandler).off(\"core.element.ignored\",this.elementIgnoredHandler).off(\"core.field.added\",this.fieldAddedHandler);},i.prototype.onEnabled=function(){this.icons.forEach((function(e,t,i){n(t,{\"fv-plugins-icon--enabled\":!0,\"fv-plugins-icon--disabled\":!1});}));},i.prototype.onDisabled=function(){this.icons.forEach((function(e,t,i){n(t,{\"fv-plugins-icon--enabled\":!1,\"fv-plugins-icon--disabled\":!0});}));},i.prototype.onFieldAdded=function(e){var t=this,n=e.elements;n&&(n.forEach((function(e){var n=t.icons.get(e);n&&(n.parentNode.removeChild(n),t.icons.delete(e));})),this.prepareFieldIcon(e.field,n));},i.prototype.prepareFieldIcon=function(e,t){var n=this;if(t.length){var i=t[0].getAttribute(\"type\");\"radio\"===i||\"checkbox\"===i?this.prepareElementIcon(e,t[0]):t.forEach((function(t){return n.prepareElementIcon(e,t)}));}},i.prototype.prepareElementIcon=function(e,t){var i=document.createElement(\"i\");i.setAttribute(\"data-field\",e),t.parentNode.insertBefore(i,t.nextSibling),n(i,{\"fv-plugins-icon\":!0,\"fv-plugins-icon--enabled\":this.isEnabled,\"fv-plugins-icon--disabled\":!this.isEnabled});var o={classes:{invalid:this.opts.invalid,valid:this.opts.valid,validating:this.opts.validating},element:t,field:e,iconElement:i};this.core.emit(\"plugins.icon.placed\",o),this.opts.onPlaced(o),this.icons.set(t,i);},i.prototype.onElementValidating=function(e){var t,n=this.setClasses(e.field,e.element,e.elements,((t={})[this.opts.invalid]=!1,t[this.opts.valid]=!1,t[this.opts.validating]=!0,t)),i={element:e.element,field:e.field,iconElement:n,status:\"Validating\"};this.core.emit(\"plugins.icon.set\",i),this.opts.onSet(i);},i.prototype.onElementValidated=function(e){var t,n=this.setClasses(e.field,e.element,e.elements,((t={})[this.opts.invalid]=!e.valid,t[this.opts.valid]=e.valid,t[this.opts.validating]=!1,t)),i={element:e.element,field:e.field,iconElement:n,status:e.valid?\"Valid\":\"Invalid\"};this.core.emit(\"plugins.icon.set\",i),this.opts.onSet(i);},i.prototype.onElementNotValidated=function(e){var t,n=this.setClasses(e.field,e.element,e.elements,((t={})[this.opts.invalid]=!1,t[this.opts.valid]=!1,t[this.opts.validating]=!1,t)),i={element:e.element,field:e.field,iconElement:n,status:\"NotValidated\"};this.core.emit(\"plugins.icon.set\",i),this.opts.onSet(i);},i.prototype.onElementIgnored=function(e){var t,n=this.setClasses(e.field,e.element,e.elements,((t={})[this.opts.invalid]=!1,t[this.opts.valid]=!1,t[this.opts.validating]=!1,t)),i={element:e.element,field:e.field,iconElement:n,status:\"Ignored\"};this.core.emit(\"plugins.icon.set\",i),this.opts.onSet(i);},i.prototype.setClasses=function(e,t,i,o){var l=t.getAttribute(\"type\"),a=\"radio\"===l||\"checkbox\"===l?i[0]:t;if(this.icons.has(a)){var s=this.icons.get(a);return n(s,o),s}return null},i}(e.Plugin);index_min$r.Icon=i;\n\treturn index_min$r;\n}\n\nvar cjs$r = {};\n\nvar hasRequiredCjs$r;\n\nfunction requireCjs$r () {\n\tif (hasRequiredCjs$r) return cjs$r;\n\thasRequiredCjs$r = 1;\n\n\tvar core = libExports$B;\n\n\t/******************************************************************************\r\n\tCopyright (c) Microsoft Corporation.\r\n\r\n\tPermission to use, copy, modify, and/or distribute this software for any\r\n\tpurpose with or without fee is hereby granted.\r\n\r\n\tTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n\tREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n\tAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n\tINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n\tLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n\tOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n\tPERFORMANCE OF THIS SOFTWARE.\r\n\t***************************************************************************** */\r\n\t/* global Reflect, Promise */\r\n\r\n\tvar extendStatics = function(d, b) {\r\n\t    extendStatics = Object.setPrototypeOf ||\r\n\t        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n\t        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n\t    return extendStatics(d, b);\r\n\t};\r\n\r\n\tfunction __extends(d, b) {\r\n\t    if (typeof b !== \"function\" && b !== null)\r\n\t        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n\t    extendStatics(d, b);\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t}\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\tvar classSet = core.utils.classSet;\n\tvar Icon = /** @class */ (function (_super) {\n\t    __extends(Icon, _super);\n\t    function Icon(opts) {\n\t        var _this = _super.call(this, opts) || this;\n\t        // Map the field element with icon\n\t        _this.icons = new Map();\n\t        _this.opts = Object.assign({}, {\n\t            invalid: 'fv-plugins-icon--invalid',\n\t            onPlaced: function () { },\n\t            onSet: function () { },\n\t            valid: 'fv-plugins-icon--valid',\n\t            validating: 'fv-plugins-icon--validating',\n\t        }, opts);\n\t        _this.elementValidatingHandler = _this.onElementValidating.bind(_this);\n\t        _this.elementValidatedHandler = _this.onElementValidated.bind(_this);\n\t        _this.elementNotValidatedHandler = _this.onElementNotValidated.bind(_this);\n\t        _this.elementIgnoredHandler = _this.onElementIgnored.bind(_this);\n\t        _this.fieldAddedHandler = _this.onFieldAdded.bind(_this);\n\t        return _this;\n\t    }\n\t    Icon.prototype.install = function () {\n\t        this.core\n\t            .on('core.element.validating', this.elementValidatingHandler)\n\t            .on('core.element.validated', this.elementValidatedHandler)\n\t            .on('core.element.notvalidated', this.elementNotValidatedHandler)\n\t            .on('core.element.ignored', this.elementIgnoredHandler)\n\t            .on('core.field.added', this.fieldAddedHandler);\n\t    };\n\t    Icon.prototype.uninstall = function () {\n\t        this.icons.forEach(function (icon) { return icon.parentNode.removeChild(icon); });\n\t        this.icons.clear();\n\t        this.core\n\t            .off('core.element.validating', this.elementValidatingHandler)\n\t            .off('core.element.validated', this.elementValidatedHandler)\n\t            .off('core.element.notvalidated', this.elementNotValidatedHandler)\n\t            .off('core.element.ignored', this.elementIgnoredHandler)\n\t            .off('core.field.added', this.fieldAddedHandler);\n\t    };\n\t    Icon.prototype.onEnabled = function () {\n\t        this.icons.forEach(function (_element, i, _map) {\n\t            classSet(i, {\n\t                'fv-plugins-icon--enabled': true,\n\t                'fv-plugins-icon--disabled': false,\n\t            });\n\t        });\n\t    };\n\t    Icon.prototype.onDisabled = function () {\n\t        this.icons.forEach(function (_element, i, _map) {\n\t            classSet(i, {\n\t                'fv-plugins-icon--enabled': false,\n\t                'fv-plugins-icon--disabled': true,\n\t            });\n\t        });\n\t    };\n\t    Icon.prototype.onFieldAdded = function (e) {\n\t        var _this = this;\n\t        var elements = e.elements;\n\t        if (elements) {\n\t            elements.forEach(function (ele) {\n\t                var icon = _this.icons.get(ele);\n\t                if (icon) {\n\t                    icon.parentNode.removeChild(icon);\n\t                    _this.icons.delete(ele);\n\t                }\n\t            });\n\t            this.prepareFieldIcon(e.field, elements);\n\t        }\n\t    };\n\t    Icon.prototype.prepareFieldIcon = function (field, elements) {\n\t        var _this = this;\n\t        if (elements.length) {\n\t            var type = elements[0].getAttribute('type');\n\t            if ('radio' === type || 'checkbox' === type) {\n\t                this.prepareElementIcon(field, elements[0]);\n\t            }\n\t            else {\n\t                elements.forEach(function (ele) { return _this.prepareElementIcon(field, ele); });\n\t            }\n\t        }\n\t    };\n\t    Icon.prototype.prepareElementIcon = function (field, ele) {\n\t        var i = document.createElement('i');\n\t        i.setAttribute('data-field', field);\n\t        // Append the icon right after the field element\n\t        ele.parentNode.insertBefore(i, ele.nextSibling);\n\t        classSet(i, {\n\t            'fv-plugins-icon': true,\n\t            'fv-plugins-icon--enabled': this.isEnabled,\n\t            'fv-plugins-icon--disabled': !this.isEnabled,\n\t        });\n\t        var e = {\n\t            classes: {\n\t                invalid: this.opts.invalid,\n\t                valid: this.opts.valid,\n\t                validating: this.opts.validating,\n\t            },\n\t            element: ele,\n\t            field: field,\n\t            iconElement: i,\n\t        };\n\t        this.core.emit('plugins.icon.placed', e);\n\t        this.opts.onPlaced(e);\n\t        this.icons.set(ele, i);\n\t    };\n\t    Icon.prototype.onElementValidating = function (e) {\n\t        var _a;\n\t        var icon = this.setClasses(e.field, e.element, e.elements, (_a = {},\n\t            _a[this.opts.invalid] = false,\n\t            _a[this.opts.valid] = false,\n\t            _a[this.opts.validating] = true,\n\t            _a));\n\t        var evt = {\n\t            element: e.element,\n\t            field: e.field,\n\t            iconElement: icon,\n\t            status: 'Validating',\n\t        };\n\t        this.core.emit('plugins.icon.set', evt);\n\t        this.opts.onSet(evt);\n\t    };\n\t    Icon.prototype.onElementValidated = function (e) {\n\t        var _a;\n\t        var icon = this.setClasses(e.field, e.element, e.elements, (_a = {},\n\t            _a[this.opts.invalid] = !e.valid,\n\t            _a[this.opts.valid] = e.valid,\n\t            _a[this.opts.validating] = false,\n\t            _a));\n\t        var evt = {\n\t            element: e.element,\n\t            field: e.field,\n\t            iconElement: icon,\n\t            status: e.valid ? 'Valid' : 'Invalid',\n\t        };\n\t        this.core.emit('plugins.icon.set', evt);\n\t        this.opts.onSet(evt);\n\t    };\n\t    Icon.prototype.onElementNotValidated = function (e) {\n\t        var _a;\n\t        var icon = this.setClasses(e.field, e.element, e.elements, (_a = {},\n\t            _a[this.opts.invalid] = false,\n\t            _a[this.opts.valid] = false,\n\t            _a[this.opts.validating] = false,\n\t            _a));\n\t        var evt = {\n\t            element: e.element,\n\t            field: e.field,\n\t            iconElement: icon,\n\t            status: 'NotValidated',\n\t        };\n\t        this.core.emit('plugins.icon.set', evt);\n\t        this.opts.onSet(evt);\n\t    };\n\t    Icon.prototype.onElementIgnored = function (e) {\n\t        var _a;\n\t        var icon = this.setClasses(e.field, e.element, e.elements, (_a = {},\n\t            _a[this.opts.invalid] = false,\n\t            _a[this.opts.valid] = false,\n\t            _a[this.opts.validating] = false,\n\t            _a));\n\t        var evt = {\n\t            element: e.element,\n\t            field: e.field,\n\t            iconElement: icon,\n\t            status: 'Ignored',\n\t        };\n\t        this.core.emit('plugins.icon.set', evt);\n\t        this.opts.onSet(evt);\n\t    };\n\t    Icon.prototype.setClasses = function (_field, element, elements, classes) {\n\t        var type = element.getAttribute('type');\n\t        var ele = 'radio' === type || 'checkbox' === type ? elements[0] : element;\n\t        if (this.icons.has(ele)) {\n\t            var icon = this.icons.get(ele);\n\t            classSet(icon, classes);\n\t            return icon;\n\t        }\n\t        else {\n\t            return null;\n\t        }\n\t    };\n\t    return Icon;\n\t}(core.Plugin));\n\n\tcjs$r.Icon = Icon;\n\treturn cjs$r;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\nif (false) {} else {\n    lib$r.exports = requireCjs$r();\n}\n\nvar libExports$r = lib$r.exports;\n\nvar lib$q = {exports: {}};\n\nvar index_min$q = {};\n\n/** \n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n *\n * @license https://formvalidation.io/license\n * @package @form-validation/plugin-sequence\n * @version 2.4.0\n */\n\nvar hasRequiredIndex_min$q;\n\nfunction requireIndex_min$q () {\n\tif (hasRequiredIndex_min$q) return index_min$q;\n\thasRequiredIndex_min$q = 1;\nvar e=libExports$B,t=function(e,i){return t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t;}||function(e,t){for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i]);},t(e,i)};var i=e.utils.removeUndefined,l=function(e){function l(t){var l=e.call(this,t)||this;return l.invalidFields=new Map,l.opts=Object.assign({},{enabled:!0},i(t)),l.validatorHandler=l.onValidatorValidated.bind(l),l.shouldValidateFilter=l.shouldValidate.bind(l),l.fieldAddedHandler=l.onFieldAdded.bind(l),l.elementNotValidatedHandler=l.onElementNotValidated.bind(l),l.elementValidatingHandler=l.onElementValidating.bind(l),l}return function(e,i){if(\"function\"!=typeof i&&null!==i)throw new TypeError(\"Class extends value \"+String(i)+\" is not a constructor or null\");function l(){this.constructor=e;}t(e,i),e.prototype=null===i?Object.create(i):(l.prototype=i.prototype,new l);}(l,e),l.prototype.install=function(){this.core.on(\"core.validator.validated\",this.validatorHandler).on(\"core.field.added\",this.fieldAddedHandler).on(\"core.element.notvalidated\",this.elementNotValidatedHandler).on(\"core.element.validating\",this.elementValidatingHandler).registerFilter(\"field-should-validate\",this.shouldValidateFilter);},l.prototype.uninstall=function(){this.invalidFields.clear(),this.core.off(\"core.validator.validated\",this.validatorHandler).off(\"core.field.added\",this.fieldAddedHandler).off(\"core.element.notvalidated\",this.elementNotValidatedHandler).off(\"core.element.validating\",this.elementValidatingHandler).deregisterFilter(\"field-should-validate\",this.shouldValidateFilter);},l.prototype.shouldValidate=function(e,t,i,l){return !this.isEnabled||!((!0===this.opts.enabled||!0===this.opts.enabled[e])&&this.invalidFields.has(t)&&!!this.invalidFields.get(t).length&&-1===this.invalidFields.get(t).indexOf(l))},l.prototype.onValidatorValidated=function(e){var t=this.invalidFields.has(e.element)?this.invalidFields.get(e.element):[],i=t.indexOf(e.validator);e.result.valid&&i>=0?t.splice(i,1):e.result.valid||-1!==i||t.push(e.validator),this.invalidFields.set(e.element,t);},l.prototype.onFieldAdded=function(e){e.elements&&this.clearInvalidFields(e.elements);},l.prototype.onElementNotValidated=function(e){this.clearInvalidFields(e.elements);},l.prototype.onElementValidating=function(e){this.clearInvalidFields(e.elements);},l.prototype.clearInvalidFields=function(e){var t=this;e.forEach((function(e){return t.invalidFields.delete(e)}));},l}(e.Plugin);index_min$q.Sequence=l;\n\treturn index_min$q;\n}\n\nvar cjs$q = {};\n\nvar hasRequiredCjs$q;\n\nfunction requireCjs$q () {\n\tif (hasRequiredCjs$q) return cjs$q;\n\thasRequiredCjs$q = 1;\n\n\tvar core = libExports$B;\n\n\t/******************************************************************************\r\n\tCopyright (c) Microsoft Corporation.\r\n\r\n\tPermission to use, copy, modify, and/or distribute this software for any\r\n\tpurpose with or without fee is hereby granted.\r\n\r\n\tTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n\tREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n\tAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n\tINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n\tLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n\tOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n\tPERFORMANCE OF THIS SOFTWARE.\r\n\t***************************************************************************** */\r\n\t/* global Reflect, Promise */\r\n\r\n\tvar extendStatics = function(d, b) {\r\n\t    extendStatics = Object.setPrototypeOf ||\r\n\t        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n\t        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n\t    return extendStatics(d, b);\r\n\t};\r\n\r\n\tfunction __extends(d, b) {\r\n\t    if (typeof b !== \"function\" && b !== null)\r\n\t        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n\t    extendStatics(d, b);\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t}\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\tvar removeUndefined = core.utils.removeUndefined;\n\t/**\n\t * ```\n\t *  new Core(form, { ... })\n\t *      .registerPlugin('sequence', new Sequence({\n\t *          enabled: false // Default value is `true`\n\t *      }));\n\t * ```\n\t *\n\t * The `enabled` option can be:\n\t * - `true` (default): When a field has multiple validators, all of them will be checked respectively.\n\t * If errors occur in multiple validators, all of them will be displayed to the user\n\t * - `false`: When a field has multiple validators, validation for this field will be terminated upon the\n\t * first encountered error.\n\t * Thus, only the very first error message related to this field will be displayed to the user\n\t *\n\t * User can set the `enabled` option to all fields as sample code above, or apply it for specific fields as following:\n\t * ```\n\t *  new Core(form, { ... })\n\t *      .registerPlugin('sequence', new Sequence({\n\t *          enabled: {\n\t *              fullName: true, // It's not necessary since the default value is `true`\n\t *              username: false,\n\t *              email: false\n\t *          }\n\t *      }));\n\t * ```\n\t */\n\tvar Sequence = /** @class */ (function (_super) {\n\t    __extends(Sequence, _super);\n\t    function Sequence(opts) {\n\t        var _this = _super.call(this, opts) || this;\n\t        _this.invalidFields = new Map();\n\t        _this.opts = Object.assign({}, { enabled: true }, removeUndefined(opts));\n\t        _this.validatorHandler = _this.onValidatorValidated.bind(_this);\n\t        _this.shouldValidateFilter = _this.shouldValidate.bind(_this);\n\t        _this.fieldAddedHandler = _this.onFieldAdded.bind(_this);\n\t        _this.elementNotValidatedHandler = _this.onElementNotValidated.bind(_this);\n\t        _this.elementValidatingHandler = _this.onElementValidating.bind(_this);\n\t        return _this;\n\t    }\n\t    Sequence.prototype.install = function () {\n\t        this.core\n\t            .on('core.validator.validated', this.validatorHandler)\n\t            .on('core.field.added', this.fieldAddedHandler)\n\t            .on('core.element.notvalidated', this.elementNotValidatedHandler)\n\t            .on('core.element.validating', this.elementValidatingHandler)\n\t            .registerFilter('field-should-validate', this.shouldValidateFilter);\n\t    };\n\t    Sequence.prototype.uninstall = function () {\n\t        this.invalidFields.clear();\n\t        this.core\n\t            .off('core.validator.validated', this.validatorHandler)\n\t            .off('core.field.added', this.fieldAddedHandler)\n\t            .off('core.element.notvalidated', this.elementNotValidatedHandler)\n\t            .off('core.element.validating', this.elementValidatingHandler)\n\t            .deregisterFilter('field-should-validate', this.shouldValidateFilter);\n\t    };\n\t    Sequence.prototype.shouldValidate = function (field, element, _value, validator) {\n\t        if (!this.isEnabled) {\n\t            return true;\n\t        }\n\t        // Stop validating\n\t        // if the `enabled` option is set to `false`\n\t        // and there's at least one validator that field doesn't pass\n\t        var stop = (this.opts.enabled === true || this.opts.enabled[field] === true) &&\n\t            this.invalidFields.has(element) &&\n\t            !!this.invalidFields.get(element).length &&\n\t            this.invalidFields.get(element).indexOf(validator) === -1;\n\t        return !stop;\n\t    };\n\t    Sequence.prototype.onValidatorValidated = function (e) {\n\t        var validators = this.invalidFields.has(e.element) ? this.invalidFields.get(e.element) : [];\n\t        var index = validators.indexOf(e.validator);\n\t        if (e.result.valid && index >= 0) {\n\t            validators.splice(index, 1);\n\t        }\n\t        else if (!e.result.valid && index === -1) {\n\t            validators.push(e.validator);\n\t        }\n\t        this.invalidFields.set(e.element, validators);\n\t    };\n\t    Sequence.prototype.onFieldAdded = function (e) {\n\t        // Remove the field element from set of invalid elements\n\t        if (e.elements) {\n\t            this.clearInvalidFields(e.elements);\n\t        }\n\t    };\n\t    Sequence.prototype.onElementNotValidated = function (e) {\n\t        this.clearInvalidFields(e.elements);\n\t    };\n\t    Sequence.prototype.onElementValidating = function (e) {\n\t        this.clearInvalidFields(e.elements);\n\t    };\n\t    Sequence.prototype.clearInvalidFields = function (elements) {\n\t        var _this = this;\n\t        elements.forEach(function (ele) { return _this.invalidFields.delete(ele); });\n\t    };\n\t    return Sequence;\n\t}(core.Plugin));\n\n\tcjs$q.Sequence = Sequence;\n\treturn cjs$q;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\nif (false) {} else {\n    lib$q.exports = requireCjs$q();\n}\n\nvar libExports$q = lib$q.exports;\n\nvar lib$p = {exports: {}};\n\nvar index_min$p = {};\n\n/** \n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n *\n * @license https://formvalidation.io/license\n * @package @form-validation/plugin-submit-button\n * @version 2.4.0\n */\n\nvar hasRequiredIndex_min$p;\n\nfunction requireIndex_min$p () {\n\tif (hasRequiredIndex_min$p) return index_min$p;\n\thasRequiredIndex_min$p = 1;\nvar t=libExports$B,e=function(t,i){return e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e;}||function(t,e){for(var i in e)Object.prototype.hasOwnProperty.call(e,i)&&(t[i]=e[i]);},e(t,i)};var i=function(t){function i(e){var i=t.call(this,e)||this;return i.isFormValid=!1,i.isButtonClicked=!1,i.opts=Object.assign({},{aspNetButton:!1,buttons:function(t){return [].slice.call(t.querySelectorAll('[type=\"submit\"]:not([formnovalidate])'))},liveMode:!0},e),i.submitHandler=i.handleSubmitEvent.bind(i),i.buttonClickHandler=i.handleClickEvent.bind(i),i.ignoreValidationFilter=i.ignoreValidation.bind(i),i}return function(t,i){if(\"function\"!=typeof i&&null!==i)throw new TypeError(\"Class extends value \"+String(i)+\" is not a constructor or null\");function n(){this.constructor=t;}e(t,i),t.prototype=null===i?Object.create(i):(n.prototype=i.prototype,new n);}(i,t),i.prototype.install=function(){var t=this;if(this.core.getFormElement()instanceof HTMLFormElement){var e=this.core.getFormElement();this.submitButtons=this.opts.buttons(e),e.setAttribute(\"novalidate\",\"novalidate\"),e.addEventListener(\"submit\",this.submitHandler),this.hiddenClickedEle=document.createElement(\"input\"),this.hiddenClickedEle.setAttribute(\"type\",\"hidden\"),e.appendChild(this.hiddenClickedEle),this.submitButtons.forEach((function(e){e.addEventListener(\"click\",t.buttonClickHandler);})),this.core.registerFilter(\"element-ignored\",this.ignoreValidationFilter);}},i.prototype.uninstall=function(){var t=this,e=this.core.getFormElement();e instanceof HTMLFormElement&&e.removeEventListener(\"submit\",this.submitHandler),this.submitButtons.forEach((function(e){e.removeEventListener(\"click\",t.buttonClickHandler);})),this.hiddenClickedEle.parentElement.removeChild(this.hiddenClickedEle),this.core.deregisterFilter(\"element-ignored\",this.ignoreValidationFilter);},i.prototype.handleSubmitEvent=function(t){this.validateForm(t);},i.prototype.handleClickEvent=function(t){var e=t.currentTarget;if(this.isButtonClicked=!0,e instanceof HTMLElement)if(this.opts.aspNetButton&&!0===this.isFormValid);else {this.core.getFormElement().removeEventListener(\"submit\",this.submitHandler),this.clickedButton=t.target;var i=this.clickedButton.getAttribute(\"name\"),n=this.clickedButton.getAttribute(\"value\");i&&n&&(this.hiddenClickedEle.setAttribute(\"name\",i),this.hiddenClickedEle.setAttribute(\"value\",n)),this.validateForm(t);}},i.prototype.validateForm=function(t){var e=this;this.isEnabled&&(t.preventDefault(),this.core.validate().then((function(t){\"Valid\"===t&&e.opts.aspNetButton&&!e.isFormValid&&e.clickedButton&&(e.isFormValid=!0,e.clickedButton.removeEventListener(\"click\",e.buttonClickHandler),e.clickedButton.click());})));},i.prototype.ignoreValidation=function(t,e,i){return !!this.isEnabled&&(!this.opts.liveMode&&!this.isButtonClicked)},i}(t.Plugin);index_min$p.SubmitButton=i;\n\treturn index_min$p;\n}\n\nvar cjs$p = {};\n\nvar hasRequiredCjs$p;\n\nfunction requireCjs$p () {\n\tif (hasRequiredCjs$p) return cjs$p;\n\thasRequiredCjs$p = 1;\n\n\tvar core = libExports$B;\n\n\t/******************************************************************************\r\n\tCopyright (c) Microsoft Corporation.\r\n\r\n\tPermission to use, copy, modify, and/or distribute this software for any\r\n\tpurpose with or without fee is hereby granted.\r\n\r\n\tTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n\tREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n\tAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n\tINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n\tLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n\tOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n\tPERFORMANCE OF THIS SOFTWARE.\r\n\t***************************************************************************** */\r\n\t/* global Reflect, Promise */\r\n\r\n\tvar extendStatics = function(d, b) {\r\n\t    extendStatics = Object.setPrototypeOf ||\r\n\t        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n\t        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n\t    return extendStatics(d, b);\r\n\t};\r\n\r\n\tfunction __extends(d, b) {\r\n\t    if (typeof b !== \"function\" && b !== null)\r\n\t        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n\t    extendStatics(d, b);\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t}\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\tvar SubmitButton = /** @class */ (function (_super) {\n\t    __extends(SubmitButton, _super);\n\t    function SubmitButton(opts) {\n\t        var _this = _super.call(this, opts) || this;\n\t        _this.isFormValid = false;\n\t        _this.isButtonClicked = false;\n\t        _this.opts = Object.assign({}, {\n\t            // Set it to `true` to support classical ASP.Net form\n\t            aspNetButton: false,\n\t            // By default, don't perform validation when clicking on\n\t            // the submit button/input which have `formnovalidate` attribute\n\t            buttons: function (form) {\n\t                return [].slice.call(form.querySelectorAll('[type=\"submit\"]:not([formnovalidate])'));\n\t            },\n\t            liveMode: true,\n\t        }, opts);\n\t        _this.submitHandler = _this.handleSubmitEvent.bind(_this);\n\t        _this.buttonClickHandler = _this.handleClickEvent.bind(_this);\n\t        _this.ignoreValidationFilter = _this.ignoreValidation.bind(_this);\n\t        return _this;\n\t    }\n\t    SubmitButton.prototype.install = function () {\n\t        var _this = this;\n\t        if (!(this.core.getFormElement() instanceof HTMLFormElement)) {\n\t            return;\n\t        }\n\t        var form = this.core.getFormElement();\n\t        this.submitButtons = this.opts.buttons(form);\n\t        // Disable client side validation in HTML 5\n\t        form.setAttribute('novalidate', 'novalidate');\n\t        // Disable the default submission first\n\t        form.addEventListener('submit', this.submitHandler);\n\t        this.hiddenClickedEle = document.createElement('input');\n\t        this.hiddenClickedEle.setAttribute('type', 'hidden');\n\t        form.appendChild(this.hiddenClickedEle);\n\t        this.submitButtons.forEach(function (button) {\n\t            button.addEventListener('click', _this.buttonClickHandler);\n\t        });\n\t        this.core.registerFilter('element-ignored', this.ignoreValidationFilter);\n\t    };\n\t    SubmitButton.prototype.uninstall = function () {\n\t        var _this = this;\n\t        var form = this.core.getFormElement();\n\t        if (form instanceof HTMLFormElement) {\n\t            form.removeEventListener('submit', this.submitHandler);\n\t        }\n\t        this.submitButtons.forEach(function (button) {\n\t            button.removeEventListener('click', _this.buttonClickHandler);\n\t        });\n\t        this.hiddenClickedEle.parentElement.removeChild(this.hiddenClickedEle);\n\t        this.core.deregisterFilter('element-ignored', this.ignoreValidationFilter);\n\t    };\n\t    SubmitButton.prototype.handleSubmitEvent = function (e) {\n\t        this.validateForm(e);\n\t    };\n\t    SubmitButton.prototype.handleClickEvent = function (e) {\n\t        var target = e.currentTarget;\n\t        this.isButtonClicked = true;\n\t        if (target instanceof HTMLElement) {\n\t            if (this.opts.aspNetButton && this.isFormValid === true) ;\n\t            else {\n\t                var form = this.core.getFormElement();\n\t                form.removeEventListener('submit', this.submitHandler);\n\t                this.clickedButton = e.target;\n\t                var name_1 = this.clickedButton.getAttribute('name');\n\t                var value = this.clickedButton.getAttribute('value');\n\t                if (name_1 && value) {\n\t                    this.hiddenClickedEle.setAttribute('name', name_1);\n\t                    this.hiddenClickedEle.setAttribute('value', value);\n\t                }\n\t                this.validateForm(e);\n\t            }\n\t        }\n\t    };\n\t    SubmitButton.prototype.validateForm = function (e) {\n\t        var _this = this;\n\t        if (!this.isEnabled) {\n\t            return;\n\t        }\n\t        e.preventDefault();\n\t        this.core.validate().then(function (result) {\n\t            if (result === 'Valid' && _this.opts.aspNetButton && !_this.isFormValid && _this.clickedButton) {\n\t                _this.isFormValid = true;\n\t                _this.clickedButton.removeEventListener('click', _this.buttonClickHandler);\n\t                // It's the time for ASP.Net submit button to do its own submission\n\t                _this.clickedButton.click();\n\t            }\n\t        });\n\t    };\n\t    SubmitButton.prototype.ignoreValidation = function (_field, _element, _elements) {\n\t        if (!this.isEnabled) {\n\t            return false;\n\t        }\n\t        return this.opts.liveMode ? false : !this.isButtonClicked;\n\t    };\n\t    return SubmitButton;\n\t}(core.Plugin));\n\n\tcjs$p.SubmitButton = SubmitButton;\n\treturn cjs$p;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\nif (false) {} else {\n    lib$p.exports = requireCjs$p();\n}\n\nvar libExports$p = lib$p.exports;\n\nvar lib$o = {exports: {}};\n\nvar index_min$o = {};\n\n/** \n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n *\n * @license https://formvalidation.io/license\n * @package @form-validation/plugin-tooltip\n * @version 2.4.0\n */\n\nvar hasRequiredIndex_min$o;\n\nfunction requireIndex_min$o () {\n\tif (hasRequiredIndex_min$o) return index_min$o;\n\thasRequiredIndex_min$o = 1;\nvar t=libExports$B,e=function(t,i){return e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e;}||function(t,e){for(var i in e)Object.prototype.hasOwnProperty.call(e,i)&&(t[i]=e[i]);},e(t,i)};var i=t.utils.classSet,o=function(t){function o(e){var i=t.call(this,e)||this;return i.messages=new Map,i.opts=Object.assign({},{placement:\"top\",trigger:\"click\"},e),i.iconPlacedHandler=i.onIconPlaced.bind(i),i.validatorValidatedHandler=i.onValidatorValidated.bind(i),i.elementValidatedHandler=i.onElementValidated.bind(i),i.documentClickHandler=i.onDocumentClicked.bind(i),i}return function(t,i){if(\"function\"!=typeof i&&null!==i)throw new TypeError(\"Class extends value \"+String(i)+\" is not a constructor or null\");function o(){this.constructor=t;}e(t,i),t.prototype=null===i?Object.create(i):(o.prototype=i.prototype,new o);}(o,t),o.prototype.install=function(){var t;this.tip=document.createElement(\"div\"),i(this.tip,((t={\"fv-plugins-tooltip\":!0})[\"fv-plugins-tooltip--\".concat(this.opts.placement)]=!0,t)),document.body.appendChild(this.tip),this.core.on(\"plugins.icon.placed\",this.iconPlacedHandler).on(\"core.validator.validated\",this.validatorValidatedHandler).on(\"core.element.validated\",this.elementValidatedHandler),\"click\"===this.opts.trigger&&document.addEventListener(\"click\",this.documentClickHandler);},o.prototype.uninstall=function(){this.messages.clear(),document.body.removeChild(this.tip),this.core.off(\"plugins.icon.placed\",this.iconPlacedHandler).off(\"core.validator.validated\",this.validatorValidatedHandler).off(\"core.element.validated\",this.elementValidatedHandler),\"click\"===this.opts.trigger&&document.removeEventListener(\"click\",this.documentClickHandler);},o.prototype.onIconPlaced=function(t){var e=this;if(i(t.iconElement,{\"fv-plugins-tooltip-icon\":!0}),\"hover\"===this.opts.trigger)t.iconElement.addEventListener(\"mouseenter\",(function(i){return e.show(t.element,i)})),t.iconElement.addEventListener(\"mouseleave\",(function(t){return e.hide()}));else t.iconElement.addEventListener(\"click\",(function(i){return e.show(t.element,i)}));},o.prototype.onValidatorValidated=function(t){if(!t.result.valid){var e=t.elements,i=t.element.getAttribute(\"type\"),o=\"radio\"===i||\"checkbox\"===i?e[0]:t.element,n=\"string\"==typeof t.result.message?t.result.message:t.result.message[this.core.getLocale()];this.messages.set(o,n);}},o.prototype.onElementValidated=function(t){if(t.valid){var e=t.elements,i=t.element.getAttribute(\"type\"),o=\"radio\"===i||\"checkbox\"===i?e[0]:t.element;this.messages.delete(o);}},o.prototype.onDocumentClicked=function(t){this.hide();},o.prototype.show=function(t,e){if(this.isEnabled&&(e.preventDefault(),e.stopPropagation(),this.messages.has(t))){i(this.tip,{\"fv-plugins-tooltip--hide\":!1}),this.tip.innerHTML='<div class=\"fv-plugins-tooltip__content\">'.concat(this.messages.get(t),\"</div>\");var o=e.target.getBoundingClientRect(),n=this.tip.getBoundingClientRect(),l=n.height,a=n.width,s=0,r=0;switch(this.opts.placement){case\"bottom\":s=o.top+o.height,r=o.left+o.width/2-a/2;break;case\"bottom-left\":s=o.top+o.height,r=o.left;break;case\"bottom-right\":s=o.top+o.height,r=o.left+o.width-a;break;case\"left\":s=o.top+o.height/2-l/2,r=o.left-a;break;case\"right\":s=o.top+o.height/2-l/2,r=o.left+o.width;break;case\"top-left\":s=o.top-l,r=o.left;break;case\"top-right\":s=o.top-l,r=o.left+o.width-a;break;default:s=o.top-l,r=o.left+o.width/2-a/2;}s+=window.scrollY||document.documentElement.scrollTop||document.body.scrollTop||0,r+=window.scrollX||document.documentElement.scrollLeft||document.body.scrollLeft||0,this.tip.setAttribute(\"style\",\"top: \".concat(s,\"px; left: \").concat(r,\"px\"));}},o.prototype.hide=function(){this.isEnabled&&i(this.tip,{\"fv-plugins-tooltip--hide\":!0});},o}(t.Plugin);index_min$o.Tooltip=o;\n\treturn index_min$o;\n}\n\nvar cjs$o = {};\n\nvar hasRequiredCjs$o;\n\nfunction requireCjs$o () {\n\tif (hasRequiredCjs$o) return cjs$o;\n\thasRequiredCjs$o = 1;\n\n\tvar core = libExports$B;\n\n\t/******************************************************************************\r\n\tCopyright (c) Microsoft Corporation.\r\n\r\n\tPermission to use, copy, modify, and/or distribute this software for any\r\n\tpurpose with or without fee is hereby granted.\r\n\r\n\tTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n\tREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n\tAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n\tINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n\tLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n\tOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n\tPERFORMANCE OF THIS SOFTWARE.\r\n\t***************************************************************************** */\r\n\t/* global Reflect, Promise */\r\n\r\n\tvar extendStatics = function(d, b) {\r\n\t    extendStatics = Object.setPrototypeOf ||\r\n\t        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n\t        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n\t    return extendStatics(d, b);\r\n\t};\r\n\r\n\tfunction __extends(d, b) {\r\n\t    if (typeof b !== \"function\" && b !== null)\r\n\t        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n\t    extendStatics(d, b);\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t}\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\tvar classSet = core.utils.classSet;\n\tvar Tooltip = /** @class */ (function (_super) {\n\t    __extends(Tooltip, _super);\n\t    function Tooltip(opts) {\n\t        var _this = _super.call(this, opts) || this;\n\t        // Map the element with message\n\t        _this.messages = new Map();\n\t        _this.opts = Object.assign({}, {\n\t            placement: 'top',\n\t            trigger: 'click',\n\t        }, opts);\n\t        _this.iconPlacedHandler = _this.onIconPlaced.bind(_this);\n\t        _this.validatorValidatedHandler = _this.onValidatorValidated.bind(_this);\n\t        _this.elementValidatedHandler = _this.onElementValidated.bind(_this);\n\t        _this.documentClickHandler = _this.onDocumentClicked.bind(_this);\n\t        return _this;\n\t    }\n\t    Tooltip.prototype.install = function () {\n\t        var _a;\n\t        this.tip = document.createElement('div');\n\t        classSet(this.tip, (_a = {\n\t                'fv-plugins-tooltip': true\n\t            },\n\t            _a[\"fv-plugins-tooltip--\".concat(this.opts.placement)] = true,\n\t            _a));\n\t        document.body.appendChild(this.tip);\n\t        this.core\n\t            .on('plugins.icon.placed', this.iconPlacedHandler)\n\t            .on('core.validator.validated', this.validatorValidatedHandler)\n\t            .on('core.element.validated', this.elementValidatedHandler);\n\t        if ('click' === this.opts.trigger) {\n\t            document.addEventListener('click', this.documentClickHandler);\n\t        }\n\t    };\n\t    Tooltip.prototype.uninstall = function () {\n\t        this.messages.clear();\n\t        document.body.removeChild(this.tip);\n\t        this.core\n\t            .off('plugins.icon.placed', this.iconPlacedHandler)\n\t            .off('core.validator.validated', this.validatorValidatedHandler)\n\t            .off('core.element.validated', this.elementValidatedHandler);\n\t        if ('click' === this.opts.trigger) {\n\t            document.removeEventListener('click', this.documentClickHandler);\n\t        }\n\t    };\n\t    Tooltip.prototype.onIconPlaced = function (e) {\n\t        var _this = this;\n\t        classSet(e.iconElement, {\n\t            'fv-plugins-tooltip-icon': true,\n\t        });\n\t        switch (this.opts.trigger) {\n\t            case 'hover':\n\t                e.iconElement.addEventListener('mouseenter', function (evt) { return _this.show(e.element, evt); });\n\t                e.iconElement.addEventListener('mouseleave', function (_evt) { return _this.hide(); });\n\t                break;\n\t            case 'click':\n\t            default:\n\t                e.iconElement.addEventListener('click', function (evt) { return _this.show(e.element, evt); });\n\t                break;\n\t        }\n\t    };\n\t    Tooltip.prototype.onValidatorValidated = function (e) {\n\t        if (!e.result.valid) {\n\t            var elements = e.elements;\n\t            var type = e.element.getAttribute('type');\n\t            var ele = 'radio' === type || 'checkbox' === type ? elements[0] : e.element;\n\t            // Get the message\n\t            var message = typeof e.result.message === 'string' ? e.result.message : e.result.message[this.core.getLocale()];\n\t            this.messages.set(ele, message);\n\t        }\n\t    };\n\t    Tooltip.prototype.onElementValidated = function (e) {\n\t        if (e.valid) {\n\t            // Clear the message\n\t            var elements = e.elements;\n\t            var type = e.element.getAttribute('type');\n\t            var ele = 'radio' === type || 'checkbox' === type ? elements[0] : e.element;\n\t            this.messages.delete(ele);\n\t        }\n\t    };\n\t    Tooltip.prototype.onDocumentClicked = function (_e) {\n\t        this.hide();\n\t    };\n\t    Tooltip.prototype.show = function (ele, e) {\n\t        if (!this.isEnabled) {\n\t            return;\n\t        }\n\t        e.preventDefault();\n\t        e.stopPropagation();\n\t        if (!this.messages.has(ele)) {\n\t            return;\n\t        }\n\t        classSet(this.tip, {\n\t            'fv-plugins-tooltip--hide': false,\n\t        });\n\t        this.tip.innerHTML = \"<div class=\\\"fv-plugins-tooltip__content\\\">\".concat(this.messages.get(ele), \"</div>\");\n\t        // Calculate position of the icon element\n\t        var icon = e.target;\n\t        var targetRect = icon.getBoundingClientRect();\n\t        var _a = this.tip.getBoundingClientRect(), height = _a.height, width = _a.width;\n\t        var top = 0;\n\t        var left = 0;\n\t        switch (this.opts.placement) {\n\t            case 'bottom':\n\t                top = targetRect.top + targetRect.height;\n\t                left = targetRect.left + targetRect.width / 2 - width / 2;\n\t                break;\n\t            case 'bottom-left':\n\t                top = targetRect.top + targetRect.height;\n\t                left = targetRect.left;\n\t                break;\n\t            case 'bottom-right':\n\t                top = targetRect.top + targetRect.height;\n\t                left = targetRect.left + targetRect.width - width;\n\t                break;\n\t            case 'left':\n\t                top = targetRect.top + targetRect.height / 2 - height / 2;\n\t                left = targetRect.left - width;\n\t                break;\n\t            case 'right':\n\t                top = targetRect.top + targetRect.height / 2 - height / 2;\n\t                left = targetRect.left + targetRect.width;\n\t                break;\n\t            case 'top-left':\n\t                top = targetRect.top - height;\n\t                left = targetRect.left;\n\t                break;\n\t            case 'top-right':\n\t                top = targetRect.top - height;\n\t                left = targetRect.left + targetRect.width - width;\n\t                break;\n\t            case 'top':\n\t            default:\n\t                top = targetRect.top - height;\n\t                left = targetRect.left + targetRect.width / 2 - width / 2;\n\t                break;\n\t        }\n\t        var scrollTop = window.scrollY || document.documentElement.scrollTop || document.body.scrollTop || 0;\n\t        var scrollLeft = window.scrollX || document.documentElement.scrollLeft || document.body.scrollLeft || 0;\n\t        top = top + scrollTop;\n\t        left = left + scrollLeft;\n\t        this.tip.setAttribute('style', \"top: \".concat(top, \"px; left: \").concat(left, \"px\"));\n\t    };\n\t    Tooltip.prototype.hide = function () {\n\t        if (this.isEnabled) {\n\t            classSet(this.tip, {\n\t                'fv-plugins-tooltip--hide': true,\n\t            });\n\t        }\n\t    };\n\t    return Tooltip;\n\t}(core.Plugin));\n\n\tcjs$o.Tooltip = Tooltip;\n\treturn cjs$o;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\nif (false) {} else {\n    lib$o.exports = requireCjs$o();\n}\n\nvar libExports$o = lib$o.exports;\n\nvar lib$n = {exports: {}};\n\nvar index_min$n = {};\n\n/** \n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n *\n * @license https://formvalidation.io/license\n * @package @form-validation/plugin-trigger\n * @version 2.4.0\n */\n\nvar hasRequiredIndex_min$n;\n\nfunction requireIndex_min$n () {\n\tif (hasRequiredIndex_min$n) return index_min$n;\n\thasRequiredIndex_min$n = 1;\nvar e=libExports$B,t=function(e,n){return t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t;}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);},t(e,n)};var n=function(e){function n(t){var n=e.call(this,t)||this;n.handlers=[],n.timers=new Map;var r=document.createElement(\"div\");return n.defaultEvent=\"oninput\"in r?\"input\":\"keyup\",n.opts=Object.assign({},{delay:0,event:n.defaultEvent,threshold:0},t),n.fieldAddedHandler=n.onFieldAdded.bind(n),n.fieldRemovedHandler=n.onFieldRemoved.bind(n),n}return function(e,n){if(\"function\"!=typeof n&&null!==n)throw new TypeError(\"Class extends value \"+String(n)+\" is not a constructor or null\");function r(){this.constructor=e;}t(e,n),e.prototype=null===n?Object.create(n):(r.prototype=n.prototype,new r);}(n,e),n.prototype.install=function(){this.core.on(\"core.field.added\",this.fieldAddedHandler).on(\"core.field.removed\",this.fieldRemovedHandler);},n.prototype.uninstall=function(){this.handlers.forEach((function(e){return e.element.removeEventListener(e.event,e.handler)})),this.handlers=[],this.timers.forEach((function(e){return window.clearTimeout(e)})),this.timers.clear(),this.core.off(\"core.field.added\",this.fieldAddedHandler).off(\"core.field.removed\",this.fieldRemovedHandler);},n.prototype.prepareHandler=function(e,t){var n=this;t.forEach((function(t){var r=[];if(n.opts.event&&!1===n.opts.event[e])r=[];else if(n.opts.event&&n.opts.event[e]&&\"function\"!=typeof n.opts.event[e])r=n.opts.event[e].split(\" \");else if(\"string\"==typeof n.opts.event&&n.opts.event!==n.defaultEvent)r=n.opts.event.split(\" \");else {var o=t.getAttribute(\"type\"),i=t.tagName.toLowerCase();r=[\"radio\"===o||\"checkbox\"===o||\"file\"===o||\"select\"===i?\"change\":n.ieVersion>=10&&t.getAttribute(\"placeholder\")?\"keyup\":n.defaultEvent];}r.forEach((function(r){var o=function(r){return n.handleEvent(r,e,t)};n.handlers.push({element:t,event:r,field:e,handler:o}),t.addEventListener(r,o);}));}));},n.prototype.handleEvent=function(e,t,n){var r=this;if(this.isEnabled&&this.exceedThreshold(t,n)&&this.core.executeFilter(\"plugins-trigger-should-validate\",!0,[t,n])){var o=function(){return r.core.validateElement(t,n).then((function(o){r.core.emit(\"plugins.trigger.executed\",{element:n,event:e,field:t});}))},i=this.opts.delay[t]||this.opts.delay;if(0===i)o();else {var l=this.timers.get(n);l&&window.clearTimeout(l),this.timers.set(n,window.setTimeout(o,1e3*i));}}},n.prototype.onFieldAdded=function(e){this.handlers.filter((function(t){return t.field===e.field})).forEach((function(e){return e.element.removeEventListener(e.event,e.handler)})),this.prepareHandler(e.field,e.elements);},n.prototype.onFieldRemoved=function(e){this.handlers.filter((function(t){return t.field===e.field&&e.elements.indexOf(t.element)>=0})).forEach((function(e){return e.element.removeEventListener(e.event,e.handler)}));},n.prototype.exceedThreshold=function(e,t){var n=0!==this.opts.threshold[e]&&0!==this.opts.threshold&&(this.opts.threshold[e]||this.opts.threshold);if(!n)return !0;var r=t.getAttribute(\"type\");return -1!==[\"button\",\"checkbox\",\"file\",\"hidden\",\"image\",\"radio\",\"reset\",\"submit\"].indexOf(r)||this.core.getElementValue(e,t).length>=n},n}(e.Plugin);index_min$n.Trigger=n;\n\treturn index_min$n;\n}\n\nvar cjs$n = {};\n\nvar hasRequiredCjs$n;\n\nfunction requireCjs$n () {\n\tif (hasRequiredCjs$n) return cjs$n;\n\thasRequiredCjs$n = 1;\n\n\tvar core = libExports$B;\n\n\t/******************************************************************************\r\n\tCopyright (c) Microsoft Corporation.\r\n\r\n\tPermission to use, copy, modify, and/or distribute this software for any\r\n\tpurpose with or without fee is hereby granted.\r\n\r\n\tTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n\tREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n\tAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n\tINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n\tLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n\tOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n\tPERFORMANCE OF THIS SOFTWARE.\r\n\t***************************************************************************** */\r\n\t/* global Reflect, Promise */\r\n\r\n\tvar extendStatics = function(d, b) {\r\n\t    extendStatics = Object.setPrototypeOf ||\r\n\t        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n\t        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n\t    return extendStatics(d, b);\r\n\t};\r\n\r\n\tfunction __extends(d, b) {\r\n\t    if (typeof b !== \"function\" && b !== null)\r\n\t        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n\t    extendStatics(d, b);\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t}\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\t/**\n\t * Indicate the events which the validation will be executed when these events are triggered\n\t *\n\t * ```\n\t *  const fv = formValidation(form, {\n\t *      fields: {\n\t *          fullName: {},\n\t *          email: {},\n\t *      },\n\t *  });\n\t *\n\t *  // Validate fields when the `blur` events are triggered\n\t *  fv.registerPlugin(Trigger, {\n\t *      event: 'blur',\n\t *  });\n\t *\n\t *  // We can indicate different events for each particular field\n\t *  fv.registerPlugin(Trigger, {\n\t *      event: {\n\t *          fullName: 'blur',\n\t *          email: 'change',\n\t *      },\n\t *  });\n\t *\n\t *  // If we don't want the field to be validated automatically, set the associate value to `false`\n\t *  fv.registerPlugin(Trigger, {\n\t *      event: {\n\t *          email: false,    // The field is only validated when we click the submit button of form\n\t *      },\n\t *  });\n\t * ```\n\t */\n\tvar Trigger = /** @class */ (function (_super) {\n\t    __extends(Trigger, _super);\n\t    function Trigger(opts) {\n\t        var _this = _super.call(this, opts) || this;\n\t        _this.handlers = [];\n\t        _this.timers = new Map();\n\t        var ele = document.createElement('div');\n\t        _this.defaultEvent = !('oninput' in ele) ? 'keyup' : 'input';\n\t        _this.opts = Object.assign({}, {\n\t            delay: 0,\n\t            event: _this.defaultEvent,\n\t            threshold: 0,\n\t        }, opts);\n\t        _this.fieldAddedHandler = _this.onFieldAdded.bind(_this);\n\t        _this.fieldRemovedHandler = _this.onFieldRemoved.bind(_this);\n\t        return _this;\n\t    }\n\t    Trigger.prototype.install = function () {\n\t        this.core.on('core.field.added', this.fieldAddedHandler).on('core.field.removed', this.fieldRemovedHandler);\n\t    };\n\t    Trigger.prototype.uninstall = function () {\n\t        this.handlers.forEach(function (item) { return item.element.removeEventListener(item.event, item.handler); });\n\t        this.handlers = [];\n\t        this.timers.forEach(function (t) { return window.clearTimeout(t); });\n\t        this.timers.clear();\n\t        this.core.off('core.field.added', this.fieldAddedHandler).off('core.field.removed', this.fieldRemovedHandler);\n\t    };\n\t    Trigger.prototype.prepareHandler = function (field, elements) {\n\t        var _this = this;\n\t        elements.forEach(function (ele) {\n\t            var events = [];\n\t            if (!!_this.opts.event && _this.opts.event[field] === false) {\n\t                events = [];\n\t            }\n\t            else if (!!_this.opts.event && !!_this.opts.event[field] && typeof _this.opts.event[field] !== 'function') {\n\t                // To fix the case where `field` is a special property of String\n\t                // For example, `link` is the special function of `String.prototype`\n\t                // In this case, `this.opts.event[field]` is a function, not a string\n\t                events = _this.opts.event[field].split(' ');\n\t            }\n\t            else if ('string' === typeof _this.opts.event && _this.opts.event !== _this.defaultEvent) {\n\t                events = _this.opts.event.split(' ');\n\t            }\n\t            else {\n\t                var type = ele.getAttribute('type');\n\t                var tagName = ele.tagName.toLowerCase();\n\t                // IE10/11 fires the `input` event when focus on the field having a placeholder\n\t                var event_1 = 'radio' === type || 'checkbox' === type || 'file' === type || 'select' === tagName\n\t                    ? 'change'\n\t                    : _this.ieVersion >= 10 && ele.getAttribute('placeholder')\n\t                        ? 'keyup'\n\t                        : _this.defaultEvent;\n\t                events = [event_1];\n\t            }\n\t            events.forEach(function (evt) {\n\t                var evtHandler = function (e) { return _this.handleEvent(e, field, ele); };\n\t                _this.handlers.push({\n\t                    element: ele,\n\t                    event: evt,\n\t                    field: field,\n\t                    handler: evtHandler,\n\t                });\n\t                ele.addEventListener(evt, evtHandler);\n\t            });\n\t        });\n\t    };\n\t    Trigger.prototype.handleEvent = function (e, field, ele) {\n\t        var _this = this;\n\t        if (this.isEnabled &&\n\t            this.exceedThreshold(field, ele) &&\n\t            this.core.executeFilter('plugins-trigger-should-validate', true, [field, ele])) {\n\t            var handler = function () {\n\t                return _this.core.validateElement(field, ele).then(function (_) {\n\t                    _this.core.emit('plugins.trigger.executed', {\n\t                        element: ele,\n\t                        event: e,\n\t                        field: field,\n\t                    });\n\t                });\n\t            };\n\t            var delay = this.opts.delay[field] || this.opts.delay;\n\t            if (delay === 0) {\n\t                handler();\n\t            }\n\t            else {\n\t                var timer = this.timers.get(ele);\n\t                if (timer) {\n\t                    window.clearTimeout(timer);\n\t                }\n\t                this.timers.set(ele, window.setTimeout(handler, delay * 1000));\n\t            }\n\t        }\n\t    };\n\t    Trigger.prototype.onFieldAdded = function (e) {\n\t        this.handlers\n\t            .filter(function (item) { return item.field === e.field; })\n\t            .forEach(function (item) { return item.element.removeEventListener(item.event, item.handler); });\n\t        this.prepareHandler(e.field, e.elements);\n\t    };\n\t    Trigger.prototype.onFieldRemoved = function (e) {\n\t        this.handlers\n\t            .filter(function (item) { return item.field === e.field && e.elements.indexOf(item.element) >= 0; })\n\t            .forEach(function (item) { return item.element.removeEventListener(item.event, item.handler); });\n\t    };\n\t    Trigger.prototype.exceedThreshold = function (field, element) {\n\t        var threshold = this.opts.threshold[field] === 0 || this.opts.threshold === 0\n\t            ? false\n\t            : this.opts.threshold[field] || this.opts.threshold;\n\t        if (!threshold) {\n\t            return true;\n\t        }\n\t        // List of input type which user can't type in\n\t        var type = element.getAttribute('type');\n\t        if (['button', 'checkbox', 'file', 'hidden', 'image', 'radio', 'reset', 'submit'].indexOf(type) !== -1) {\n\t            return true;\n\t        }\n\t        var value = this.core.getElementValue(field, element);\n\t        return value.length >= threshold;\n\t    };\n\t    return Trigger;\n\t}(core.Plugin));\n\n\tcjs$n.Trigger = Trigger;\n\treturn cjs$n;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\nif (false) {} else {\n    lib$n.exports = requireCjs$n();\n}\n\nvar libExports$n = lib$n.exports;\n\nvar lib$m = {exports: {}};\n\nvar index_min$m = {};\n\n/** \n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n *\n * @license https://formvalidation.io/license\n * @package @form-validation/validator-between\n * @version 2.4.0\n */\n\nvar hasRequiredIndex_min$m;\n\nfunction requireIndex_min$m () {\n\tif (hasRequiredIndex_min$m) return index_min$m;\n\thasRequiredIndex_min$m = 1;\nvar e=libExports$B,a=e.utils.format,n=e.utils.removeUndefined;index_min$m.between=function(){var e=function(e){return parseFloat(\"\".concat(e).replace(\",\",\".\"))};return {validate:function(t){var s=t.value;if(\"\"===s)return {valid:!0};var r=Object.assign({},{inclusive:!0,message:\"\"},n(t.options)),i=e(r.min),l=e(r.max);return r.inclusive?{message:a(t.l10n?r.message||t.l10n.between.default:r.message,[\"\".concat(i),\"\".concat(l)]),valid:parseFloat(s)>=i&&parseFloat(s)<=l}:{message:a(t.l10n?r.message||t.l10n.between.notInclusive:r.message,[\"\".concat(i),\"\".concat(l)]),valid:parseFloat(s)>i&&parseFloat(s)<l}}}};\n\treturn index_min$m;\n}\n\nvar cjs$m = {};\n\nvar hasRequiredCjs$m;\n\nfunction requireCjs$m () {\n\tif (hasRequiredCjs$m) return cjs$m;\n\thasRequiredCjs$m = 1;\n\n\tvar core = libExports$B;\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\tvar format = core.utils.format, removeUndefined = core.utils.removeUndefined;\n\tfunction between() {\n\t    var formatValue = function (value) {\n\t        return parseFloat(\"\".concat(value).replace(',', '.'));\n\t    };\n\t    return {\n\t        validate: function (input) {\n\t            var value = input.value;\n\t            if (value === '') {\n\t                return { valid: true };\n\t            }\n\t            var opts = Object.assign({}, { inclusive: true, message: '' }, removeUndefined(input.options));\n\t            var minValue = formatValue(opts.min);\n\t            var maxValue = formatValue(opts.max);\n\t            return opts.inclusive\n\t                ? {\n\t                    message: format(input.l10n ? opts.message || input.l10n.between.default : opts.message, [\n\t                        \"\".concat(minValue),\n\t                        \"\".concat(maxValue),\n\t                    ]),\n\t                    valid: parseFloat(value) >= minValue && parseFloat(value) <= maxValue,\n\t                }\n\t                : {\n\t                    message: format(input.l10n ? opts.message || input.l10n.between.notInclusive : opts.message, [\n\t                        \"\".concat(minValue),\n\t                        \"\".concat(maxValue),\n\t                    ]),\n\t                    valid: parseFloat(value) > minValue && parseFloat(value) < maxValue,\n\t                };\n\t        },\n\t    };\n\t}\n\n\tcjs$m.between = between;\n\treturn cjs$m;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\nif (false) {} else {\n    lib$m.exports = requireCjs$m();\n}\n\nvar libExports$m = lib$m.exports;\n\nvar lib$l = {exports: {}};\n\nvar index_min$l = {};\n\n/** \n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n *\n * @license https://formvalidation.io/license\n * @package @form-validation/validator-blank\n * @version 2.4.0\n */\n\nvar hasRequiredIndex_min$l;\n\nfunction requireIndex_min$l () {\n\tif (hasRequiredIndex_min$l) return index_min$l;\n\thasRequiredIndex_min$l = 1;\nindex_min$l.blank=function(){return {validate:function(t){return {valid:!0}}}};\n\treturn index_min$l;\n}\n\nvar cjs$l = {};\n\nvar hasRequiredCjs$l;\n\nfunction requireCjs$l () {\n\tif (hasRequiredCjs$l) return cjs$l;\n\thasRequiredCjs$l = 1;\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\t/**\n\t * This validator always returns valid.\n\t * It can be used when we want to show the custom message returned from server\n\t */\n\tfunction blank() {\n\t    return {\n\t        validate: function (_input) {\n\t            return { valid: true };\n\t        },\n\t    };\n\t}\n\n\tcjs$l.blank = blank;\n\treturn cjs$l;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\nif (false) {} else {\n    lib$l.exports = requireCjs$l();\n}\n\nvar libExports$l = lib$l.exports;\n\nvar lib$k = {exports: {}};\n\nvar index_min$k = {};\n\n/** \n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n *\n * @license https://formvalidation.io/license\n * @package @form-validation/validator-callback\n * @version 2.4.0\n */\n\nvar hasRequiredIndex_min$k;\n\nfunction requireIndex_min$k () {\n\tif (hasRequiredIndex_min$k) return index_min$k;\n\thasRequiredIndex_min$k = 1;\nvar a=libExports$B.utils.call;index_min$k.callback=function(){return {validate:function(r){var t=a(r.options.callback,[r]);return \"boolean\"==typeof t?{valid:t}:t}}};\n\treturn index_min$k;\n}\n\nvar cjs$k = {};\n\nvar hasRequiredCjs$k;\n\nfunction requireCjs$k () {\n\tif (hasRequiredCjs$k) return cjs$k;\n\thasRequiredCjs$k = 1;\n\n\tvar core = libExports$B;\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\tvar call = core.utils.call;\n\tfunction callback() {\n\t    return {\n\t        validate: function (input) {\n\t            var response = call(input.options.callback, [input]);\n\t            return 'boolean' === typeof response\n\t                ? { valid: response } // Deprecated\n\t                : response;\n\t        },\n\t    };\n\t}\n\n\tcjs$k.callback = callback;\n\treturn cjs$k;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\nif (false) {} else {\n    lib$k.exports = requireCjs$k();\n}\n\nvar libExports$k = lib$k.exports;\n\nvar lib$j = {exports: {}};\n\nvar index_min$j = {};\n\n/** \n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n *\n * @license https://formvalidation.io/license\n * @package @form-validation/validator-choice\n * @version 2.4.0\n */\n\nvar hasRequiredIndex_min$j;\n\nfunction requireIndex_min$j () {\n\tif (hasRequiredIndex_min$j) return index_min$j;\n\thasRequiredIndex_min$j = 1;\nvar e=libExports$B.utils.format;index_min$j.choice=function(){return {validate:function(n){var t=\"select\"===n.element.tagName.toLowerCase()?n.element.querySelectorAll(\"option:checked\").length:n.elements.filter((function(e){return e.checked})).length,o=n.options.min?\"\".concat(n.options.min):\"\",s=n.options.max?\"\".concat(n.options.max):\"\",a=n.l10n?n.options.message||n.l10n.choice.default:n.options.message,c=!(o&&t<parseInt(o,10)||s&&t>parseInt(s,10));switch(!0){case!!o&&!!s:a=e(n.l10n?n.l10n.choice.between:n.options.message,[o,s]);break;case!!o:a=e(n.l10n?n.l10n.choice.more:n.options.message,o);break;case!!s:a=e(n.l10n?n.l10n.choice.less:n.options.message,s);}return {message:a,valid:c}}}};\n\treturn index_min$j;\n}\n\nvar cjs$j = {};\n\nvar hasRequiredCjs$j;\n\nfunction requireCjs$j () {\n\tif (hasRequiredCjs$j) return cjs$j;\n\thasRequiredCjs$j = 1;\n\n\tvar core = libExports$B;\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\tvar format = core.utils.format;\n\tfunction choice() {\n\t    return {\n\t        validate: function (input) {\n\t            var numChoices = 'select' === input.element.tagName.toLowerCase()\n\t                ? input.element.querySelectorAll('option:checked').length\n\t                : input.elements.filter(function (ele) { return ele.checked; }).length;\n\t            var min = input.options.min ? \"\".concat(input.options.min) : '';\n\t            var max = input.options.max ? \"\".concat(input.options.max) : '';\n\t            var msg = input.l10n ? input.options.message || input.l10n.choice.default : input.options.message;\n\t            var isValid = !((min && numChoices < parseInt(min, 10)) || (max && numChoices > parseInt(max, 10)));\n\t            switch (true) {\n\t                case !!min && !!max:\n\t                    msg = format(input.l10n ? input.l10n.choice.between : input.options.message, [min, max]);\n\t                    break;\n\t                case !!min:\n\t                    msg = format(input.l10n ? input.l10n.choice.more : input.options.message, min);\n\t                    break;\n\t                case !!max:\n\t                    msg = format(input.l10n ? input.l10n.choice.less : input.options.message, max);\n\t                    break;\n\t            }\n\t            return {\n\t                message: msg,\n\t                valid: isValid,\n\t            };\n\t        },\n\t    };\n\t}\n\n\tcjs$j.choice = choice;\n\treturn cjs$j;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\nif (false) {} else {\n    lib$j.exports = requireCjs$j();\n}\n\nvar libExports$j = lib$j.exports;\n\nvar lib$i = {exports: {}};\n\nvar index_min$i = {};\n\n/** \n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n *\n * @license https://formvalidation.io/license\n * @package @form-validation/validator-credit-card\n * @version 2.4.0\n */\n\nvar hasRequiredIndex_min$i;\n\nfunction requireIndex_min$i () {\n\tif (hasRequiredIndex_min$i) return index_min$i;\n\thasRequiredIndex_min$i = 1;\nvar e=libExports$B.algorithms.luhn,r={AMERICAN_EXPRESS:{length:[15],prefix:[\"34\",\"37\"]},DANKORT:{length:[16],prefix:[\"5019\"]},DINERS_CLUB:{length:[14],prefix:[\"300\",\"301\",\"302\",\"303\",\"304\",\"305\",\"36\"]},DINERS_CLUB_US:{length:[16],prefix:[\"54\",\"55\"]},DISCOVER:{length:[16],prefix:[\"6011\",\"622126\",\"622127\",\"622128\",\"622129\",\"62213\",\"62214\",\"62215\",\"62216\",\"62217\",\"62218\",\"62219\",\"6222\",\"6223\",\"6224\",\"6225\",\"6226\",\"6227\",\"6228\",\"62290\",\"62291\",\"622920\",\"622921\",\"622922\",\"622923\",\"622924\",\"622925\",\"644\",\"645\",\"646\",\"647\",\"648\",\"649\",\"65\"]},ELO:{length:[16],prefix:[\"4011\",\"4312\",\"4389\",\"4514\",\"4573\",\"4576\",\"5041\",\"5066\",\"5067\",\"509\",\"6277\",\"6362\",\"6363\",\"650\",\"6516\",\"6550\"]},FORBRUGSFORENINGEN:{length:[16],prefix:[\"600722\"]},JCB:{length:[16],prefix:[\"3528\",\"3529\",\"353\",\"354\",\"355\",\"356\",\"357\",\"358\"]},LASER:{length:[16,17,18,19],prefix:[\"6304\",\"6706\",\"6771\",\"6709\"]},MAESTRO:{length:[12,13,14,15,16,17,18,19],prefix:[\"5018\",\"5020\",\"5038\",\"5868\",\"6304\",\"6759\",\"6761\",\"6762\",\"6763\",\"6764\",\"6765\",\"6766\"]},MASTERCARD:{length:[16],prefix:[\"51\",\"52\",\"53\",\"54\",\"55\"]},SOLO:{length:[16,18,19],prefix:[\"6334\",\"6767\"]},UNIONPAY:{length:[16,17,18,19],prefix:[\"622126\",\"622127\",\"622128\",\"622129\",\"62213\",\"62214\",\"62215\",\"62216\",\"62217\",\"62218\",\"62219\",\"6222\",\"6223\",\"6224\",\"6225\",\"6226\",\"6227\",\"6228\",\"62290\",\"62291\",\"622920\",\"622921\",\"622922\",\"622923\",\"622924\",\"622925\"]},VISA:{length:[16],prefix:[\"4\"]},VISA_ELECTRON:{length:[16],prefix:[\"4026\",\"417500\",\"4405\",\"4508\",\"4844\",\"4913\",\"4917\"]}};index_min$i.CREDIT_CARD_TYPES=r,index_min$i.creditCard=function(){return {validate:function(t){if(\"\"===t.value)return {meta:{type:null},valid:!0};if(/[^0-9-\\s]+/.test(t.value))return {meta:{type:null},valid:!1};var l=t.value.replace(/\\D/g,\"\");if(!e(l))return {meta:{type:null},valid:!1};for(var i=0,n=Object.keys(r);i<n.length;i++){var f=n[i];for(var a in r[f].prefix)if(t.value.substr(0,r[f].prefix[a].length)===r[f].prefix[a]&&-1!==r[f].length.indexOf(l.length))return {meta:{type:f},valid:!0}}return {meta:{type:null},valid:!1}}}};\n\treturn index_min$i;\n}\n\nvar cjs$i = {};\n\nvar hasRequiredCjs$i;\n\nfunction requireCjs$i () {\n\tif (hasRequiredCjs$i) return cjs$i;\n\thasRequiredCjs$i = 1;\n\n\tvar core = libExports$B;\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\tvar luhn = core.algorithms.luhn;\n\tvar CREDIT_CARD_TYPES = {\n\t    AMERICAN_EXPRESS: {\n\t        length: [15],\n\t        prefix: ['34', '37'],\n\t    },\n\t    DANKORT: {\n\t        length: [16],\n\t        prefix: ['5019'],\n\t    },\n\t    DINERS_CLUB: {\n\t        length: [14],\n\t        prefix: ['300', '301', '302', '303', '304', '305', '36'],\n\t    },\n\t    DINERS_CLUB_US: {\n\t        length: [16],\n\t        prefix: ['54', '55'],\n\t    },\n\t    DISCOVER: {\n\t        length: [16],\n\t        prefix: [\n\t            '6011',\n\t            '622126',\n\t            '622127',\n\t            '622128',\n\t            '622129',\n\t            '62213',\n\t            '62214',\n\t            '62215',\n\t            '62216',\n\t            '62217',\n\t            '62218',\n\t            '62219',\n\t            '6222',\n\t            '6223',\n\t            '6224',\n\t            '6225',\n\t            '6226',\n\t            '6227',\n\t            '6228',\n\t            '62290',\n\t            '62291',\n\t            '622920',\n\t            '622921',\n\t            '622922',\n\t            '622923',\n\t            '622924',\n\t            '622925',\n\t            '644',\n\t            '645',\n\t            '646',\n\t            '647',\n\t            '648',\n\t            '649',\n\t            '65',\n\t        ],\n\t    },\n\t    ELO: {\n\t        length: [16],\n\t        prefix: [\n\t            '4011',\n\t            '4312',\n\t            '4389',\n\t            '4514',\n\t            '4573',\n\t            '4576',\n\t            '5041',\n\t            '5066',\n\t            '5067',\n\t            '509',\n\t            '6277',\n\t            '6362',\n\t            '6363',\n\t            '650',\n\t            '6516',\n\t            '6550',\n\t        ],\n\t    },\n\t    FORBRUGSFORENINGEN: {\n\t        length: [16],\n\t        prefix: ['600722'],\n\t    },\n\t    JCB: {\n\t        length: [16],\n\t        prefix: ['3528', '3529', '353', '354', '355', '356', '357', '358'],\n\t    },\n\t    LASER: {\n\t        length: [16, 17, 18, 19],\n\t        prefix: ['6304', '6706', '6771', '6709'],\n\t    },\n\t    MAESTRO: {\n\t        length: [12, 13, 14, 15, 16, 17, 18, 19],\n\t        prefix: ['5018', '5020', '5038', '5868', '6304', '6759', '6761', '6762', '6763', '6764', '6765', '6766'],\n\t    },\n\t    MASTERCARD: {\n\t        length: [16],\n\t        prefix: ['51', '52', '53', '54', '55'],\n\t    },\n\t    SOLO: {\n\t        length: [16, 18, 19],\n\t        prefix: ['6334', '6767'],\n\t    },\n\t    UNIONPAY: {\n\t        length: [16, 17, 18, 19],\n\t        prefix: [\n\t            '622126',\n\t            '622127',\n\t            '622128',\n\t            '622129',\n\t            '62213',\n\t            '62214',\n\t            '62215',\n\t            '62216',\n\t            '62217',\n\t            '62218',\n\t            '62219',\n\t            '6222',\n\t            '6223',\n\t            '6224',\n\t            '6225',\n\t            '6226',\n\t            '6227',\n\t            '6228',\n\t            '62290',\n\t            '62291',\n\t            '622920',\n\t            '622921',\n\t            '622922',\n\t            '622923',\n\t            '622924',\n\t            '622925',\n\t        ],\n\t    },\n\t    VISA: {\n\t        length: [16],\n\t        prefix: ['4'],\n\t    },\n\t    VISA_ELECTRON: {\n\t        length: [16],\n\t        prefix: ['4026', '417500', '4405', '4508', '4844', '4913', '4917'],\n\t    },\n\t};\n\tfunction creditCard() {\n\t    return {\n\t        /**\n\t         * Return true if the input value is valid credit card number\n\t         */\n\t        validate: function (input) {\n\t            if (input.value === '') {\n\t                return {\n\t                    meta: {\n\t                        type: null,\n\t                    },\n\t                    valid: true,\n\t                };\n\t            }\n\t            // Accept only digits, dashes or spaces\n\t            if (/[^0-9-\\s]+/.test(input.value)) {\n\t                return {\n\t                    meta: {\n\t                        type: null,\n\t                    },\n\t                    valid: false,\n\t                };\n\t            }\n\t            var v = input.value.replace(/\\D/g, '');\n\t            if (!luhn(v)) {\n\t                return {\n\t                    meta: {\n\t                        type: null,\n\t                    },\n\t                    valid: false,\n\t                };\n\t            }\n\t            for (var _i = 0, _a = Object.keys(CREDIT_CARD_TYPES); _i < _a.length; _i++) {\n\t                var tpe = _a[_i];\n\t                for (var i in CREDIT_CARD_TYPES[tpe].prefix) {\n\t                    // Check the prefix and length\n\t                    if (input.value.substr(0, CREDIT_CARD_TYPES[tpe].prefix[i].length) ===\n\t                        CREDIT_CARD_TYPES[tpe].prefix[i] &&\n\t                        CREDIT_CARD_TYPES[tpe].length.indexOf(v.length) !== -1) {\n\t                        return {\n\t                            meta: {\n\t                                type: tpe,\n\t                            },\n\t                            valid: true,\n\t                        };\n\t                    }\n\t                }\n\t            }\n\t            return {\n\t                meta: {\n\t                    type: null,\n\t                },\n\t                valid: false,\n\t            };\n\t        },\n\t    };\n\t}\n\n\tcjs$i.CREDIT_CARD_TYPES = CREDIT_CARD_TYPES;\n\tcjs$i.creditCard = creditCard;\n\treturn cjs$i;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\nif (false) {} else {\n    lib$i.exports = requireCjs$i();\n}\n\nvar libExports$i = lib$i.exports;\n\nvar lib$h = {exports: {}};\n\nvar index_min$h = {};\n\n/** \n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n *\n * @license https://formvalidation.io/license\n * @package @form-validation/validator-date\n * @version 2.4.0\n */\n\nvar hasRequiredIndex_min$h;\n\nfunction requireIndex_min$h () {\n\tif (hasRequiredIndex_min$h) return index_min$h;\n\thasRequiredIndex_min$h = 1;\nvar e=libExports$B,t=e.utils.format,n=e.utils.isValidDate,a=e.utils.removeUndefined,r=function(e,t,n){var a=t.indexOf(\"YYYY\"),r=t.indexOf(\"MM\"),l=t.indexOf(\"DD\");if(-1===a||-1===r||-1===l)return null;var s=e.split(\" \"),i=s[0].split(n);if(i.length<3)return null;var c=new Date(parseInt(i[a],10),parseInt(i[r],10)-1,parseInt(i[l],10)),o=s.length>2?s[2]:null;if(s.length>1){var g=s[1].split(\":\"),u=g.length>0?parseInt(g[0],10):0;c.setHours(o&&\"PM\"===o.toUpperCase()&&u<12?u+12:u),c.setMinutes(g.length>1?parseInt(g[1],10):0),c.setSeconds(g.length>2?parseInt(g[2],10):0);}return c},l=function(e,t){var n=t.replace(/Y/g,\"y\").replace(/M/g,\"m\").replace(/D/g,\"d\").replace(/:m/g,\":M\").replace(/:mm/g,\":MM\").replace(/:S/,\":s\").replace(/:SS/,\":ss\"),a=e.getDate(),r=a<10?\"0\".concat(a):a,l=e.getMonth()+1,s=l<10?\"0\".concat(l):l,i=\"\".concat(e.getFullYear()).substr(2),c=e.getFullYear(),o=e.getHours()%12||12,g=o<10?\"0\".concat(o):o,u=e.getHours(),d=u<10?\"0\".concat(u):u,f=e.getMinutes(),m=f<10?\"0\".concat(f):f,p=e.getSeconds(),h=p<10?\"0\".concat(p):p,v={H:\"\".concat(u),HH:\"\".concat(d),M:\"\".concat(f),MM:\"\".concat(m),d:\"\".concat(a),dd:\"\".concat(r),h:\"\".concat(o),hh:\"\".concat(g),m:\"\".concat(l),mm:\"\".concat(s),s:\"\".concat(p),ss:\"\".concat(h),yy:\"\".concat(i),yyyy:\"\".concat(c)};return n.replace(/d{1,4}|m{1,4}|yy(?:yy)?|([HhMs])\\1?|\"[^\"]*\"|'[^']*'/g,(function(e){return v[e]?v[e]:e.slice(1,e.length-1)}))};index_min$h.date=function(){return {validate:function(e){if(\"\"===e.value)return {meta:{date:null},valid:!0};var s=Object.assign({},{format:e.element&&\"date\"===e.element.getAttribute(\"type\")?\"YYYY-MM-DD\":\"MM/DD/YYYY\",message:\"\"},a(e.options)),i=e.l10n?e.l10n.date.default:s.message,c={message:\"\".concat(i),meta:{date:null},valid:!1},o=s.format.split(\" \"),g=o.length>1?o[1]:null,u=o.length>2?o[2]:null,d=e.value.split(\" \"),f=d[0],m=d.length>1?d[1]:null,p=d.length>2?d[2]:null;if(o.length!==d.length)return c;var h=s.separator||(-1!==f.indexOf(\"/\")?\"/\":-1!==f.indexOf(\"-\")?\"-\":-1!==f.indexOf(\".\")?\".\":\"/\");if(null===h||-1===f.indexOf(h))return c;var v=f.split(h),M=o[0].split(h);if(v.length!==M.length)return c;var Y=v[M.indexOf(\"YYYY\")],D=v[M.indexOf(\"MM\")],x=v[M.indexOf(\"DD\")];if(!/^\\d+$/.test(Y)||!/^\\d+$/.test(D)||!/^\\d+$/.test(x)||Y.length>4||D.length>2||x.length>2)return c;var y=parseInt(Y,10),I=parseInt(D,10),O=parseInt(x,10);if(!n(y,I,O))return c;var H=new Date(y,I-1,O);if(g){var T=m.split(\":\");if(g.split(\":\").length!==T.length)return c;var S=T.length>0?T[0].length<=2&&/^\\d+$/.test(T[0])?parseInt(T[0],10):-1:0,$=T.length>1?T[1].length<=2&&/^\\d+$/.test(T[1])?parseInt(T[1],10):-1:0,b=T.length>2?T[2].length<=2&&/^\\d+$/.test(T[2])?parseInt(T[2],10):-1:0;if(-1===S||-1===$||-1===b)return c;if(b<0||b>60)return c;if(S<0||S>=24||u&&S>12)return c;if($<0||$>59)return c;H.setHours(p&&\"PM\"===p.toUpperCase()&&S<12?S+12:S),H.setMinutes($),H.setSeconds(b);}var w=\"function\"==typeof s.min?s.min():s.min,U=w instanceof Date?w:w?r(w,M,h):H,C=\"function\"==typeof s.max?s.max():s.max,F=C instanceof Date?C:C?r(C,M,h):H,P=w instanceof Date?l(U,s.format):w,j=C instanceof Date?l(F,s.format):C;switch(!0){case!!P&&!j:return {message:t(e.l10n?e.l10n.date.min:i,P),meta:{date:H},valid:H.getTime()>=U.getTime()};case!!j&&!P:return {message:t(e.l10n?e.l10n.date.max:i,j),meta:{date:H},valid:H.getTime()<=F.getTime()};case!!j&&!!P:return {message:t(e.l10n?e.l10n.date.range:i,[P,j]),meta:{date:H},valid:H.getTime()<=F.getTime()&&H.getTime()>=U.getTime()};default:return {message:\"\".concat(i),meta:{date:H},valid:!0}}}}};\n\treturn index_min$h;\n}\n\nvar cjs$h = {};\n\nvar hasRequiredCjs$h;\n\nfunction requireCjs$h () {\n\tif (hasRequiredCjs$h) return cjs$h;\n\thasRequiredCjs$h = 1;\n\n\tvar core = libExports$B;\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\tvar format = core.utils.format, isValidDate = core.utils.isValidDate, removeUndefined = core.utils.removeUndefined;\n\t/**\n\t * Return a date object after parsing the date string\n\t *\n\t * @param {string} input The date to parse\n\t * @param {string[]} inputFormat The date format\n\t * The format can be:\n\t * - date: Consist of DD, MM, YYYY parts which are separated by the separator option\n\t * - date and time: The time can consist of h, m, s parts which are separated by :\n\t * @param {string} separator The separator used to separate the date, month, and year\n\t * @return {Date}\n\t * @private\n\t */\n\tvar parseDate = function (input, inputFormat, separator) {\n\t    // Ensure that the format must consist of year, month and day patterns\n\t    var yearIndex = inputFormat.indexOf('YYYY');\n\t    var monthIndex = inputFormat.indexOf('MM');\n\t    var dayIndex = inputFormat.indexOf('DD');\n\t    if (yearIndex === -1 || monthIndex === -1 || dayIndex === -1) {\n\t        return null;\n\t    }\n\t    var sections = input.split(' ');\n\t    var dateSection = sections[0].split(separator);\n\t    if (dateSection.length < 3) {\n\t        return null;\n\t    }\n\t    var d = new Date(parseInt(dateSection[yearIndex], 10), parseInt(dateSection[monthIndex], 10) - 1, parseInt(dateSection[dayIndex], 10));\n\t    var amPmSection = sections.length > 2 ? sections[2] : null;\n\t    if (sections.length > 1) {\n\t        var timeSection = sections[1].split(':');\n\t        var h = timeSection.length > 0 ? parseInt(timeSection[0], 10) : 0;\n\t        d.setHours(amPmSection && amPmSection.toUpperCase() === 'PM' && h < 12 ? h + 12 : h);\n\t        d.setMinutes(timeSection.length > 1 ? parseInt(timeSection[1], 10) : 0);\n\t        d.setSeconds(timeSection.length > 2 ? parseInt(timeSection[2], 10) : 0);\n\t    }\n\t    return d;\n\t};\n\t/**\n\t * Format date\n\t *\n\t * @param {Date} input The date object to format\n\t * @param {string} inputFormat The date format\n\t * The format can consist of the following tokens:\n\t *      d       Day of the month without leading zeros (1 through 31)\n\t *      dd      Day of the month with leading zeros (01 through 31)\n\t *      m       Month without leading zeros (1 through 12)\n\t *      mm      Month with leading zeros (01 through 12)\n\t *      yy      Last two digits of year (for example: 14)\n\t *      yyyy    Full four digits of year (for example: 2014)\n\t *      h       Hours without leading zeros (1 through 12)\n\t *      hh      Hours with leading zeros (01 through 12)\n\t *      H       Hours without leading zeros (0 through 23)\n\t *      HH      Hours with leading zeros (00 through 23)\n\t *      M       Minutes without leading zeros (0 through 59)\n\t *      MM      Minutes with leading zeros (00 through 59)\n\t *      s       Seconds without leading zeros (0 through 59)\n\t *      ss      Seconds with leading zeros (00 through 59)\n\t * @return {string}\n\t * @private\n\t */\n\tvar formatDate = function (input, inputFormat) {\n\t    var dateFormat = inputFormat\n\t        .replace(/Y/g, 'y')\n\t        .replace(/M/g, 'm')\n\t        .replace(/D/g, 'd')\n\t        .replace(/:m/g, ':M')\n\t        .replace(/:mm/g, ':MM')\n\t        .replace(/:S/, ':s')\n\t        .replace(/:SS/, ':ss');\n\t    var d = input.getDate();\n\t    var dd = d < 10 ? \"0\".concat(d) : d;\n\t    var m = input.getMonth() + 1;\n\t    var mm = m < 10 ? \"0\".concat(m) : m;\n\t    var yy = \"\".concat(input.getFullYear()).substr(2);\n\t    var yyyy = input.getFullYear();\n\t    var h = input.getHours() % 12 || 12;\n\t    var hh = h < 10 ? \"0\".concat(h) : h;\n\t    var H = input.getHours();\n\t    var HH = H < 10 ? \"0\".concat(H) : H;\n\t    var M = input.getMinutes();\n\t    var MM = M < 10 ? \"0\".concat(M) : M;\n\t    var s = input.getSeconds();\n\t    var ss = s < 10 ? \"0\".concat(s) : s;\n\t    var replacer = {\n\t        H: \"\".concat(H),\n\t        HH: \"\".concat(HH),\n\t        M: \"\".concat(M),\n\t        MM: \"\".concat(MM),\n\t        d: \"\".concat(d),\n\t        dd: \"\".concat(dd),\n\t        h: \"\".concat(h),\n\t        hh: \"\".concat(hh),\n\t        m: \"\".concat(m),\n\t        mm: \"\".concat(mm),\n\t        s: \"\".concat(s),\n\t        ss: \"\".concat(ss),\n\t        yy: \"\".concat(yy),\n\t        yyyy: \"\".concat(yyyy),\n\t    };\n\t    return dateFormat.replace(/d{1,4}|m{1,4}|yy(?:yy)?|([HhMs])\\1?|\"[^\"]*\"|'[^']*'/g, function (match) {\n\t        return replacer[match] ? replacer[match] : match.slice(1, match.length - 1);\n\t    });\n\t};\n\tvar date = function () {\n\t    return {\n\t        validate: function (input) {\n\t            if (input.value === '') {\n\t                return {\n\t                    meta: {\n\t                        date: null,\n\t                    },\n\t                    valid: true,\n\t                };\n\t            }\n\t            var opts = Object.assign({}, {\n\t                // Force the format to `YYYY-MM-DD` as the default browser behaviour when using type=\"date\" attribute\n\t                format: input.element && input.element.getAttribute('type') === 'date' ? 'YYYY-MM-DD' : 'MM/DD/YYYY',\n\t                message: '',\n\t            }, removeUndefined(input.options));\n\t            var message = input.l10n ? input.l10n.date.default : opts.message;\n\t            var invalidResult = {\n\t                message: \"\".concat(message),\n\t                meta: {\n\t                    date: null,\n\t                },\n\t                valid: false,\n\t            };\n\t            var formats = opts.format.split(' ');\n\t            var timeFormat = formats.length > 1 ? formats[1] : null;\n\t            var amOrPm = formats.length > 2 ? formats[2] : null;\n\t            var sections = input.value.split(' ');\n\t            var dateSection = sections[0];\n\t            var timeSection = sections.length > 1 ? sections[1] : null;\n\t            var amPmSection = sections.length > 2 ? sections[2] : null;\n\t            if (formats.length !== sections.length) {\n\t                return invalidResult;\n\t            }\n\t            // Determine the separator\n\t            var separator = opts.separator ||\n\t                (dateSection.indexOf('/') !== -1\n\t                    ? '/'\n\t                    : dateSection.indexOf('-') !== -1\n\t                        ? '-'\n\t                        : dateSection.indexOf('.') !== -1\n\t                            ? '.'\n\t                            : '/');\n\t            if (separator === null || dateSection.indexOf(separator) === -1) {\n\t                return invalidResult;\n\t            }\n\t            // Determine the date\n\t            var dateStr = dateSection.split(separator);\n\t            var dateFormat = formats[0].split(separator);\n\t            if (dateStr.length !== dateFormat.length) {\n\t                return invalidResult;\n\t            }\n\t            var yearStr = dateStr[dateFormat.indexOf('YYYY')];\n\t            var monthStr = dateStr[dateFormat.indexOf('MM')];\n\t            var dayStr = dateStr[dateFormat.indexOf('DD')];\n\t            if (!/^\\d+$/.test(yearStr) ||\n\t                !/^\\d+$/.test(monthStr) ||\n\t                !/^\\d+$/.test(dayStr) ||\n\t                yearStr.length > 4 ||\n\t                monthStr.length > 2 ||\n\t                dayStr.length > 2) {\n\t                return invalidResult;\n\t            }\n\t            var year = parseInt(yearStr, 10);\n\t            var month = parseInt(monthStr, 10);\n\t            var day = parseInt(dayStr, 10);\n\t            if (!isValidDate(year, month, day)) {\n\t                return invalidResult;\n\t            }\n\t            // Determine the time\n\t            var d = new Date(year, month - 1, day);\n\t            if (timeFormat) {\n\t                var hms = timeSection.split(':');\n\t                if (timeFormat.split(':').length !== hms.length) {\n\t                    return invalidResult;\n\t                }\n\t                var h = hms.length > 0 ? (hms[0].length <= 2 && /^\\d+$/.test(hms[0]) ? parseInt(hms[0], 10) : -1) : 0;\n\t                var m = hms.length > 1 ? (hms[1].length <= 2 && /^\\d+$/.test(hms[1]) ? parseInt(hms[1], 10) : -1) : 0;\n\t                var s = hms.length > 2 ? (hms[2].length <= 2 && /^\\d+$/.test(hms[2]) ? parseInt(hms[2], 10) : -1) : 0;\n\t                if (h === -1 || m === -1 || s === -1) {\n\t                    return invalidResult;\n\t                }\n\t                // Validate seconds\n\t                if (s < 0 || s > 60) {\n\t                    return invalidResult;\n\t                }\n\t                // Validate hours\n\t                if (h < 0 || h >= 24 || (amOrPm && h > 12)) {\n\t                    return invalidResult;\n\t                }\n\t                // Validate minutes\n\t                if (m < 0 || m > 59) {\n\t                    return invalidResult;\n\t                }\n\t                d.setHours(amPmSection && amPmSection.toUpperCase() === 'PM' && h < 12 ? h + 12 : h);\n\t                d.setMinutes(m);\n\t                d.setSeconds(s);\n\t            }\n\t            // Validate day, month, and year\n\t            var minOption = typeof opts.min === 'function' ? opts.min() : opts.min;\n\t            var min = minOption instanceof Date\n\t                ? minOption\n\t                : minOption\n\t                    ? parseDate(minOption, dateFormat, separator)\n\t                    : d;\n\t            var maxOption = typeof opts.max === 'function' ? opts.max() : opts.max;\n\t            var max = maxOption instanceof Date\n\t                ? maxOption\n\t                : maxOption\n\t                    ? parseDate(maxOption, dateFormat, separator)\n\t                    : d;\n\t            // In order to avoid displaying a date string like \"Mon Dec 08 2014 19:14:12 GMT+0000 (WET)\"\n\t            var minOptionStr = minOption instanceof Date ? formatDate(min, opts.format) : minOption;\n\t            var maxOptionStr = maxOption instanceof Date ? formatDate(max, opts.format) : maxOption;\n\t            switch (true) {\n\t                case !!minOptionStr && !maxOptionStr:\n\t                    return {\n\t                        message: format(input.l10n ? input.l10n.date.min : message, minOptionStr),\n\t                        meta: {\n\t                            date: d,\n\t                        },\n\t                        valid: d.getTime() >= min.getTime(),\n\t                    };\n\t                case !!maxOptionStr && !minOptionStr:\n\t                    return {\n\t                        message: format(input.l10n ? input.l10n.date.max : message, maxOptionStr),\n\t                        meta: {\n\t                            date: d,\n\t                        },\n\t                        valid: d.getTime() <= max.getTime(),\n\t                    };\n\t                case !!maxOptionStr && !!minOptionStr:\n\t                    return {\n\t                        message: format(input.l10n ? input.l10n.date.range : message, [minOptionStr, maxOptionStr]),\n\t                        meta: {\n\t                            date: d,\n\t                        },\n\t                        valid: d.getTime() <= max.getTime() && d.getTime() >= min.getTime(),\n\t                    };\n\t                default:\n\t                    return {\n\t                        message: \"\".concat(message),\n\t                        meta: {\n\t                            date: d,\n\t                        },\n\t                        valid: true,\n\t                    };\n\t            }\n\t        },\n\t    };\n\t};\n\n\tcjs$h.date = date;\n\treturn cjs$h;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\nif (false) {} else {\n    lib$h.exports = requireCjs$h();\n}\n\nvar libExports$h = lib$h.exports;\n\nvar lib$g = {exports: {}};\n\nvar index_min$g = {};\n\n/** \n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n *\n * @license https://formvalidation.io/license\n * @package @form-validation/validator-different\n * @version 2.4.0\n */\n\nvar hasRequiredIndex_min$g;\n\nfunction requireIndex_min$g () {\n\tif (hasRequiredIndex_min$g) return index_min$g;\n\thasRequiredIndex_min$g = 1;\nindex_min$g.different=function(){return {validate:function(t){var o=\"function\"==typeof t.options.compare?t.options.compare.call(this):t.options.compare;return {valid:\"\"===o||t.value!==o}}}};\n\treturn index_min$g;\n}\n\nvar cjs$g = {};\n\nvar hasRequiredCjs$g;\n\nfunction requireCjs$g () {\n\tif (hasRequiredCjs$g) return cjs$g;\n\thasRequiredCjs$g = 1;\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\tfunction different() {\n\t    return {\n\t        validate: function (input) {\n\t            var compareWith = 'function' === typeof input.options.compare\n\t                ? input.options.compare.call(this)\n\t                : input.options.compare;\n\t            return {\n\t                valid: compareWith === '' || input.value !== compareWith,\n\t            };\n\t        },\n\t    };\n\t}\n\n\tcjs$g.different = different;\n\treturn cjs$g;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\nif (false) {} else {\n    lib$g.exports = requireCjs$g();\n}\n\nvar libExports$g = lib$g.exports;\n\nvar lib$f = {exports: {}};\n\nvar index_min$f = {};\n\n/** \n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n *\n * @license https://formvalidation.io/license\n * @package @form-validation/validator-digits\n * @version 2.4.0\n */\n\nvar hasRequiredIndex_min$f;\n\nfunction requireIndex_min$f () {\n\tif (hasRequiredIndex_min$f) return index_min$f;\n\thasRequiredIndex_min$f = 1;\nindex_min$f.digits=function(){return {validate:function(t){return {valid:\"\"===t.value||/^\\d+$/.test(t.value)}}}};\n\treturn index_min$f;\n}\n\nvar cjs$f = {};\n\nvar hasRequiredCjs$f;\n\nfunction requireCjs$f () {\n\tif (hasRequiredCjs$f) return cjs$f;\n\thasRequiredCjs$f = 1;\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\tfunction digits() {\n\t    return {\n\t        /**\n\t         * Return true if the input value contains digits only\n\t         */\n\t        validate: function (input) {\n\t            return { valid: input.value === '' || /^\\d+$/.test(input.value) };\n\t        },\n\t    };\n\t}\n\n\tcjs$f.digits = digits;\n\treturn cjs$f;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\nif (false) {} else {\n    lib$f.exports = requireCjs$f();\n}\n\nvar libExports$f = lib$f.exports;\n\nvar lib$e = {exports: {}};\n\nvar index_min$e = {};\n\n/** \n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n *\n * @license https://formvalidation.io/license\n * @package @form-validation/validator-email-address\n * @version 2.4.0\n */\n\nvar hasRequiredIndex_min$e;\n\nfunction requireIndex_min$e () {\n\tif (hasRequiredIndex_min$e) return index_min$e;\n\thasRequiredIndex_min$e = 1;\nvar e=libExports$B.utils.removeUndefined,a=/^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,r=/^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+$/;index_min$e.emailAddress=function(){return {validate:function(t){if(\"\"===t.value)return {valid:!0};var i=Object.assign({},{multiple:!1,requireGlobalDomain:!1,separator:/[,;]/},e(t.options)),l=i.requireGlobalDomain?r:a;if(!0===i.multiple||\"true\"===\"\".concat(i.multiple)){for(var s=i.separator||/[,;]/,u=function(e,a){for(var r=e.split(/\"/),t=r.length,i=[],l=\"\",s=0;s<t;s++)if(s%2==0){var u=r[s].split(a),n=u.length;if(1===n)l+=u[0];else {i.push(l+u[0]);for(var o=1;o<n-1;o++)i.push(u[o]);l=u[n-1];}}else l+='\"'+r[s],s<t-1&&(l+='\"');return i.push(l),i}(t.value,s),n=u.length,o=0;o<n;o++)if(!l.test(u[o]))return {valid:!1};return {valid:!0}}return {valid:l.test(t.value)}}}};\n\treturn index_min$e;\n}\n\nvar cjs$e = {};\n\nvar hasRequiredCjs$e;\n\nfunction requireCjs$e () {\n\tif (hasRequiredCjs$e) return cjs$e;\n\thasRequiredCjs$e = 1;\n\n\tvar core = libExports$B;\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\tvar removeUndefined = core.utils.removeUndefined;\n\t// Email address regular expression\n\t// http://stackoverflow.com/questions/46155/validate-email-address-in-javascript\n\tvar GLOBAL_DOMAIN_OPTIONAL = /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n\tvar GLOBAL_DOMAIN_REQUIRED = /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+$/;\n\tfunction emailAddress() {\n\t    var splitEmailAddresses = function (emailAddresses, separator) {\n\t        var quotedFragments = emailAddresses.split(/\"/);\n\t        var quotedFragmentCount = quotedFragments.length;\n\t        var emailAddressArray = [];\n\t        var nextEmailAddress = '';\n\t        for (var i = 0; i < quotedFragmentCount; i++) {\n\t            if (i % 2 === 0) {\n\t                var splitEmailAddressFragments = quotedFragments[i].split(separator);\n\t                var splitEmailAddressFragmentCount = splitEmailAddressFragments.length;\n\t                if (splitEmailAddressFragmentCount === 1) {\n\t                    nextEmailAddress += splitEmailAddressFragments[0];\n\t                }\n\t                else {\n\t                    emailAddressArray.push(nextEmailAddress + splitEmailAddressFragments[0]);\n\t                    for (var j = 1; j < splitEmailAddressFragmentCount - 1; j++) {\n\t                        emailAddressArray.push(splitEmailAddressFragments[j]);\n\t                    }\n\t                    nextEmailAddress = splitEmailAddressFragments[splitEmailAddressFragmentCount - 1];\n\t                }\n\t            }\n\t            else {\n\t                nextEmailAddress += '\"' + quotedFragments[i];\n\t                if (i < quotedFragmentCount - 1) {\n\t                    nextEmailAddress += '\"';\n\t                }\n\t            }\n\t        }\n\t        emailAddressArray.push(nextEmailAddress);\n\t        return emailAddressArray;\n\t    };\n\t    return {\n\t        /**\n\t         * Return true if and only if the input value is a valid email address\n\t         */\n\t        validate: function (input) {\n\t            if (input.value === '') {\n\t                return { valid: true };\n\t            }\n\t            var opts = Object.assign({}, {\n\t                multiple: false,\n\t                requireGlobalDomain: false,\n\t                separator: /[,;]/,\n\t            }, removeUndefined(input.options));\n\t            var emailRegExp = opts.requireGlobalDomain ? GLOBAL_DOMAIN_REQUIRED : GLOBAL_DOMAIN_OPTIONAL;\n\t            var allowMultiple = opts.multiple === true || \"\".concat(opts.multiple) === 'true';\n\t            if (allowMultiple) {\n\t                var separator = opts.separator || /[,;]/;\n\t                var addresses = splitEmailAddresses(input.value, separator);\n\t                var length_1 = addresses.length;\n\t                for (var i = 0; i < length_1; i++) {\n\t                    if (!emailRegExp.test(addresses[i])) {\n\t                        return { valid: false };\n\t                    }\n\t                }\n\t                return { valid: true };\n\t            }\n\t            else {\n\t                return { valid: emailRegExp.test(input.value) };\n\t            }\n\t        },\n\t    };\n\t}\n\n\tcjs$e.emailAddress = emailAddress;\n\treturn cjs$e;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\nif (false) {} else {\n    lib$e.exports = requireCjs$e();\n}\n\nvar libExports$e = lib$e.exports;\n\nvar lib$d = {exports: {}};\n\nvar index_min$d = {};\n\n/** \n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n *\n * @license https://formvalidation.io/license\n * @package @form-validation/validator-file\n * @version 2.4.0\n */\n\nvar hasRequiredIndex_min$d;\n\nfunction requireIndex_min$d () {\n\tif (hasRequiredIndex_min$d) return index_min$d;\n\thasRequiredIndex_min$d = 1;\nvar e=function(e){return -1===e.indexOf(\".\")?e:e.split(\".\").slice(0,-1).join(\".\")};index_min$d.file=function(){return {validate:function(t){if(\"\"===t.value)return {valid:!0};var i,n,a=t.options.extension?t.options.extension.toLowerCase().split(\",\").map((function(e){return e.trim()})):[],r=t.options.type?t.options.type.toLowerCase().split(\",\").map((function(e){return e.trim()})):[];if(window.File&&window.FileList&&window.FileReader){var o=t.element.files,s=o.length,l=0;if(t.options.maxFiles&&s>parseInt(\"\".concat(t.options.maxFiles),10))return {meta:{error:\"INVALID_MAX_FILES\"},valid:!1};if(t.options.minFiles&&s<parseInt(\"\".concat(t.options.minFiles),10))return {meta:{error:\"INVALID_MIN_FILES\"},valid:!1};for(var I={},p=0;p<s;p++){if(l+=o[p].size,I={ext:i=o[p].name.substr(o[p].name.lastIndexOf(\".\")+1),file:o[p],size:o[p].size,type:o[p].type},t.options.minSize&&o[p].size<parseInt(\"\".concat(t.options.minSize),10))return {meta:Object.assign({},{error:\"INVALID_MIN_SIZE\"},I),valid:!1};if(t.options.maxSize&&o[p].size>parseInt(\"\".concat(t.options.maxSize),10))return {meta:Object.assign({},{error:\"INVALID_MAX_SIZE\"},I),valid:!1};if(a.length>0&&-1===a.indexOf(i.toLowerCase()))return {meta:Object.assign({},{error:\"INVALID_EXTENSION\"},I),valid:!1};if(r.length>0&&o[p].type&&-1===r.indexOf(o[p].type.toLowerCase()))return {meta:Object.assign({},{error:\"INVALID_TYPE\"},I),valid:!1};if(t.options.validateFileName&&!t.options.validateFileName(e(o[p].name)))return {meta:Object.assign({},{error:\"INVALID_NAME\"},I),valid:!1}}if(t.options.maxTotalSize&&l>parseInt(\"\".concat(t.options.maxTotalSize),10))return {meta:Object.assign({},{error:\"INVALID_MAX_TOTAL_SIZE\",totalSize:l},I),valid:!1};if(t.options.minTotalSize&&l<parseInt(\"\".concat(t.options.minTotalSize),10))return {meta:Object.assign({},{error:\"INVALID_MIN_TOTAL_SIZE\",totalSize:l},I),valid:!1}}else {if(i=t.value.substr(t.value.lastIndexOf(\".\")+1),a.length>0&&-1===a.indexOf(i.toLowerCase()))return {meta:{error:\"INVALID_EXTENSION\",ext:i},valid:!1};if(n=e(t.value),t.options.validateFileName&&!t.options.validateFileName(n))return {meta:{error:\"INVALID_NAME\",name:n},valid:!1}}return {valid:!0}}}};\n\treturn index_min$d;\n}\n\nvar cjs$d = {};\n\nvar hasRequiredCjs$d;\n\nfunction requireCjs$d () {\n\tif (hasRequiredCjs$d) return cjs$d;\n\thasRequiredCjs$d = 1;\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\t// Get the file name without extension\n\tvar getFileName = function (fileName) {\n\t    return fileName.indexOf('.') === -1 ? fileName : fileName.split('.').slice(0, -1).join('.');\n\t};\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\tfunction file() {\n\t    return {\n\t        validate: function (input) {\n\t            if (input.value === '') {\n\t                return { valid: true };\n\t            }\n\t            var extension;\n\t            var name;\n\t            var extensions = input.options.extension\n\t                ? input.options.extension\n\t                    .toLowerCase()\n\t                    .split(',')\n\t                    .map(function (item) { return item.trim(); })\n\t                : [];\n\t            var types = input.options.type\n\t                ? input.options.type\n\t                    .toLowerCase()\n\t                    .split(',')\n\t                    .map(function (item) { return item.trim(); })\n\t                : [];\n\t            var html5 = window['File'] && window['FileList'] && window['FileReader'];\n\t            if (html5) {\n\t                // Get FileList instance\n\t                var files = input.element.files;\n\t                var total = files.length;\n\t                var allSize = 0;\n\t                // Check the maxFiles\n\t                if (input.options.maxFiles && total > parseInt(\"\".concat(input.options.maxFiles), 10)) {\n\t                    return {\n\t                        meta: { error: 'INVALID_MAX_FILES' },\n\t                        valid: false,\n\t                    };\n\t                }\n\t                // Check the minFiles\n\t                if (input.options.minFiles && total < parseInt(\"\".concat(input.options.minFiles), 10)) {\n\t                    return {\n\t                        meta: { error: 'INVALID_MIN_FILES' },\n\t                        valid: false,\n\t                    };\n\t                }\n\t                var metaData = {};\n\t                for (var i = 0; i < total; i++) {\n\t                    allSize += files[i].size;\n\t                    extension = files[i].name.substr(files[i].name.lastIndexOf('.') + 1);\n\t                    metaData = {\n\t                        ext: extension,\n\t                        file: files[i],\n\t                        size: files[i].size,\n\t                        type: files[i].type,\n\t                    };\n\t                    // Check the minSize\n\t                    if (input.options.minSize && files[i].size < parseInt(\"\".concat(input.options.minSize), 10)) {\n\t                        return {\n\t                            meta: Object.assign({}, { error: 'INVALID_MIN_SIZE' }, metaData),\n\t                            valid: false,\n\t                        };\n\t                    }\n\t                    // Check the maxSize\n\t                    if (input.options.maxSize && files[i].size > parseInt(\"\".concat(input.options.maxSize), 10)) {\n\t                        return {\n\t                            meta: Object.assign({}, { error: 'INVALID_MAX_SIZE' }, metaData),\n\t                            valid: false,\n\t                        };\n\t                    }\n\t                    // Check file extension\n\t                    if (extensions.length > 0 && extensions.indexOf(extension.toLowerCase()) === -1) {\n\t                        return {\n\t                            meta: Object.assign({}, { error: 'INVALID_EXTENSION' }, metaData),\n\t                            valid: false,\n\t                        };\n\t                    }\n\t                    // Check file type\n\t                    if (types.length > 0 && files[i].type && types.indexOf(files[i].type.toLowerCase()) === -1) {\n\t                        return {\n\t                            meta: Object.assign({}, { error: 'INVALID_TYPE' }, metaData),\n\t                            valid: false,\n\t                        };\n\t                    }\n\t                    // Check file name\n\t                    if (input.options.validateFileName && !input.options.validateFileName(getFileName(files[i].name))) {\n\t                        return {\n\t                            meta: Object.assign({}, { error: 'INVALID_NAME' }, metaData),\n\t                            valid: false,\n\t                        };\n\t                    }\n\t                }\n\t                // Check the maxTotalSize\n\t                if (input.options.maxTotalSize && allSize > parseInt(\"\".concat(input.options.maxTotalSize), 10)) {\n\t                    return {\n\t                        meta: Object.assign({}, {\n\t                            error: 'INVALID_MAX_TOTAL_SIZE',\n\t                            totalSize: allSize,\n\t                        }, metaData),\n\t                        valid: false,\n\t                    };\n\t                }\n\t                // Check the minTotalSize\n\t                if (input.options.minTotalSize && allSize < parseInt(\"\".concat(input.options.minTotalSize), 10)) {\n\t                    return {\n\t                        meta: Object.assign({}, {\n\t                            error: 'INVALID_MIN_TOTAL_SIZE',\n\t                            totalSize: allSize,\n\t                        }, metaData),\n\t                        valid: false,\n\t                    };\n\t                }\n\t            }\n\t            else {\n\t                // Check file extension\n\t                extension = input.value.substr(input.value.lastIndexOf('.') + 1);\n\t                if (extensions.length > 0 && extensions.indexOf(extension.toLowerCase()) === -1) {\n\t                    return {\n\t                        meta: {\n\t                            error: 'INVALID_EXTENSION',\n\t                            ext: extension,\n\t                        },\n\t                        valid: false,\n\t                    };\n\t                }\n\t                // Check file name\n\t                name = getFileName(input.value);\n\t                if (input.options.validateFileName && !input.options.validateFileName(name)) {\n\t                    return {\n\t                        meta: {\n\t                            error: 'INVALID_NAME',\n\t                            name: name,\n\t                        },\n\t                        valid: false,\n\t                    };\n\t                }\n\t            }\n\t            return { valid: true };\n\t        },\n\t    };\n\t}\n\n\tcjs$d.file = file;\n\treturn cjs$d;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\nif (false) {} else {\n    lib$d.exports = requireCjs$d();\n}\n\nvar libExports$d = lib$d.exports;\n\nvar lib$c = {exports: {}};\n\nvar index_min$c = {};\n\n/** \n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n *\n * @license https://formvalidation.io/license\n * @package @form-validation/validator-greater-than\n * @version 2.4.0\n */\n\nvar hasRequiredIndex_min$c;\n\nfunction requireIndex_min$c () {\n\tif (hasRequiredIndex_min$c) return index_min$c;\n\thasRequiredIndex_min$c = 1;\nvar e=libExports$B,a=e.utils.format,s=e.utils.removeUndefined;index_min$c.greaterThan=function(){return {validate:function(e){if(\"\"===e.value)return {valid:!0};var n=Object.assign({},{inclusive:!0,message:\"\"},s(e.options)),r=parseFloat(\"\".concat(n.min).replace(\",\",\".\"));return n.inclusive?{message:a(e.l10n?n.message||e.l10n.greaterThan.default:n.message,\"\".concat(r)),valid:parseFloat(e.value)>=r}:{message:a(e.l10n?n.message||e.l10n.greaterThan.notInclusive:n.message,\"\".concat(r)),valid:parseFloat(e.value)>r}}}};\n\treturn index_min$c;\n}\n\nvar cjs$c = {};\n\nvar hasRequiredCjs$c;\n\nfunction requireCjs$c () {\n\tif (hasRequiredCjs$c) return cjs$c;\n\thasRequiredCjs$c = 1;\n\n\tvar core = libExports$B;\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\tvar format = core.utils.format, removeUndefined = core.utils.removeUndefined;\n\tfunction greaterThan() {\n\t    return {\n\t        validate: function (input) {\n\t            if (input.value === '') {\n\t                return { valid: true };\n\t            }\n\t            var opts = Object.assign({}, { inclusive: true, message: '' }, removeUndefined(input.options));\n\t            var minValue = parseFloat(\"\".concat(opts.min).replace(',', '.'));\n\t            return opts.inclusive\n\t                ? {\n\t                    message: format(input.l10n ? opts.message || input.l10n.greaterThan.default : opts.message, \"\".concat(minValue)),\n\t                    valid: parseFloat(input.value) >= minValue,\n\t                }\n\t                : {\n\t                    message: format(input.l10n ? opts.message || input.l10n.greaterThan.notInclusive : opts.message, \"\".concat(minValue)),\n\t                    valid: parseFloat(input.value) > minValue,\n\t                };\n\t        },\n\t    };\n\t}\n\n\tcjs$c.greaterThan = greaterThan;\n\treturn cjs$c;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\nif (false) {} else {\n    lib$c.exports = requireCjs$c();\n}\n\nvar libExports$c = lib$c.exports;\n\nvar lib$b = {exports: {}};\n\nvar index_min$b = {};\n\n/** \n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n *\n * @license https://formvalidation.io/license\n * @package @form-validation/validator-identical\n * @version 2.4.0\n */\n\nvar hasRequiredIndex_min$b;\n\nfunction requireIndex_min$b () {\n\tif (hasRequiredIndex_min$b) return index_min$b;\n\thasRequiredIndex_min$b = 1;\nindex_min$b.identical=function(){return {validate:function(t){var o=\"function\"==typeof t.options.compare?t.options.compare.call(this):t.options.compare;return {valid:\"\"===o||t.value===o}}}};\n\treturn index_min$b;\n}\n\nvar cjs$b = {};\n\nvar hasRequiredCjs$b;\n\nfunction requireCjs$b () {\n\tif (hasRequiredCjs$b) return cjs$b;\n\thasRequiredCjs$b = 1;\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\tfunction identical() {\n\t    return {\n\t        validate: function (input) {\n\t            var compareWith = 'function' === typeof input.options.compare\n\t                ? input.options.compare.call(this)\n\t                : input.options.compare;\n\t            return {\n\t                valid: compareWith === '' || input.value === compareWith,\n\t            };\n\t        },\n\t    };\n\t}\n\n\tcjs$b.identical = identical;\n\treturn cjs$b;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\nif (false) {} else {\n    lib$b.exports = requireCjs$b();\n}\n\nvar libExports$b = lib$b.exports;\n\nvar lib$a = {exports: {}};\n\nvar index_min$a = {};\n\n/** \n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n *\n * @license https://formvalidation.io/license\n * @package @form-validation/validator-integer\n * @version 2.4.0\n */\n\nvar hasRequiredIndex_min$a;\n\nfunction requireIndex_min$a () {\n\tif (hasRequiredIndex_min$a) return index_min$a;\n\thasRequiredIndex_min$a = 1;\nvar a=libExports$B.utils.removeUndefined;index_min$a.integer=function(){return {validate:function(e){if(\"\"===e.value)return {valid:!0};var r=Object.assign({},{decimalSeparator:\".\",thousandsSeparator:\"\"},a(e.options)),t=\".\"===r.decimalSeparator?\"\\\\.\":r.decimalSeparator,i=\".\"===r.thousandsSeparator?\"\\\\.\":r.thousandsSeparator,o=new RegExp(\"^-?[0-9]{1,3}(\".concat(i,\"[0-9]{3})*(\").concat(t,\"[0-9]+)?$\")),n=new RegExp(i,\"g\"),s=\"\".concat(e.value);if(!o.test(s))return {valid:!1};i&&(s=s.replace(n,\"\")),t&&(s=s.replace(t,\".\"));var c=parseFloat(s);return {valid:!isNaN(c)&&isFinite(c)&&Math.floor(c)===c}}}};\n\treturn index_min$a;\n}\n\nvar cjs$a = {};\n\nvar hasRequiredCjs$a;\n\nfunction requireCjs$a () {\n\tif (hasRequiredCjs$a) return cjs$a;\n\thasRequiredCjs$a = 1;\n\n\tvar core = libExports$B;\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\tvar removeUndefined = core.utils.removeUndefined;\n\tfunction integer() {\n\t    return {\n\t        validate: function (input) {\n\t            if (input.value === '') {\n\t                return { valid: true };\n\t            }\n\t            var opts = Object.assign({}, {\n\t                decimalSeparator: '.',\n\t                thousandsSeparator: '',\n\t            }, removeUndefined(input.options));\n\t            var decimalSeparator = opts.decimalSeparator === '.' ? '\\\\.' : opts.decimalSeparator;\n\t            var thousandsSeparator = opts.thousandsSeparator === '.' ? '\\\\.' : opts.thousandsSeparator;\n\t            var testRegexp = new RegExp(\"^-?[0-9]{1,3}(\".concat(thousandsSeparator, \"[0-9]{3})*(\").concat(decimalSeparator, \"[0-9]+)?$\"));\n\t            var thousandsReplacer = new RegExp(thousandsSeparator, 'g');\n\t            var v = \"\".concat(input.value);\n\t            if (!testRegexp.test(v)) {\n\t                return { valid: false };\n\t            }\n\t            // Replace thousands separator with blank\n\t            if (thousandsSeparator) {\n\t                v = v.replace(thousandsReplacer, '');\n\t            }\n\t            // Replace decimal separator with a dot\n\t            if (decimalSeparator) {\n\t                v = v.replace(decimalSeparator, '.');\n\t            }\n\t            var n = parseFloat(v);\n\t            return { valid: !isNaN(n) && isFinite(n) && Math.floor(n) === n };\n\t        },\n\t    };\n\t}\n\n\tcjs$a.integer = integer;\n\treturn cjs$a;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\nif (false) {} else {\n    lib$a.exports = requireCjs$a();\n}\n\nvar libExports$a = lib$a.exports;\n\nvar lib$9 = {exports: {}};\n\nvar index_min$9 = {};\n\n/** \n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n *\n * @license https://formvalidation.io/license\n * @package @form-validation/validator-ip\n * @version 2.4.0\n */\n\nvar hasRequiredIndex_min$9;\n\nfunction requireIndex_min$9 () {\n\tif (hasRequiredIndex_min$9) return index_min$9;\n\thasRequiredIndex_min$9 = 1;\nvar d=libExports$B.utils.removeUndefined;index_min$9.ip=function(){return {validate:function(a){if(\"\"===a.value)return {valid:!0};var e=Object.assign({},{ipv4:!0,ipv6:!0},d(a.options)),s=/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\\/([0-9]|[1-2][0-9]|3[0-2]))?$/,i=/^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*(\\/(\\d|\\d\\d|1[0-1]\\d|12[0-8]))?$/;switch(!0){case e.ipv4&&!e.ipv6:return {message:a.l10n?e.message||a.l10n.ip.ipv4:e.message,valid:s.test(a.value)};case!e.ipv4&&e.ipv6:return {message:a.l10n?e.message||a.l10n.ip.ipv6:e.message,valid:i.test(a.value)};case e.ipv4&&e.ipv6:default:return {message:a.l10n?e.message||a.l10n.ip.default:e.message,valid:s.test(a.value)||i.test(a.value)}}}}};\n\treturn index_min$9;\n}\n\nvar cjs$9 = {};\n\nvar hasRequiredCjs$9;\n\nfunction requireCjs$9 () {\n\tif (hasRequiredCjs$9) return cjs$9;\n\thasRequiredCjs$9 = 1;\n\n\tvar core = libExports$B;\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\tvar removeUndefined = core.utils.removeUndefined;\n\tfunction ip() {\n\t    return {\n\t        /**\n\t         * Return true if the input value is a IP address.\n\t         */\n\t        validate: function (input) {\n\t            if (input.value === '') {\n\t                return { valid: true };\n\t            }\n\t            var opts = Object.assign({}, {\n\t                ipv4: true,\n\t                ipv6: true,\n\t            }, removeUndefined(input.options));\n\t            var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\\/([0-9]|[1-2][0-9]|3[0-2]))?$/;\n\t            var ipv6Regex = /^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*(\\/(\\d|\\d\\d|1[0-1]\\d|12[0-8]))?$/;\n\t            switch (true) {\n\t                case opts.ipv4 && !opts.ipv6:\n\t                    return {\n\t                        message: input.l10n ? opts.message || input.l10n.ip.ipv4 : opts.message,\n\t                        valid: ipv4Regex.test(input.value),\n\t                    };\n\t                case !opts.ipv4 && opts.ipv6:\n\t                    return {\n\t                        message: input.l10n ? opts.message || input.l10n.ip.ipv6 : opts.message,\n\t                        valid: ipv6Regex.test(input.value),\n\t                    };\n\t                case opts.ipv4 && opts.ipv6:\n\t                default:\n\t                    return {\n\t                        message: input.l10n ? opts.message || input.l10n.ip.default : opts.message,\n\t                        valid: ipv4Regex.test(input.value) || ipv6Regex.test(input.value),\n\t                    };\n\t            }\n\t        },\n\t    };\n\t}\n\n\tcjs$9.ip = ip;\n\treturn cjs$9;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\nif (false) {} else {\n    lib$9.exports = requireCjs$9();\n}\n\nvar libExports$9 = lib$9.exports;\n\nvar lib$8 = {exports: {}};\n\nvar index_min$8 = {};\n\n/** \n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n *\n * @license https://formvalidation.io/license\n * @package @form-validation/validator-less-than\n * @version 2.4.0\n */\n\nvar hasRequiredIndex_min$8;\n\nfunction requireIndex_min$8 () {\n\tif (hasRequiredIndex_min$8) return index_min$8;\n\thasRequiredIndex_min$8 = 1;\nvar e=libExports$B,a=e.utils.format,s=e.utils.removeUndefined;index_min$8.lessThan=function(){return {validate:function(e){if(\"\"===e.value)return {valid:!0};var n=Object.assign({},{inclusive:!0,message:\"\"},s(e.options)),l=parseFloat(\"\".concat(n.max).replace(\",\",\".\"));return n.inclusive?{message:a(e.l10n?n.message||e.l10n.lessThan.default:n.message,\"\".concat(l)),valid:parseFloat(e.value)<=l}:{message:a(e.l10n?n.message||e.l10n.lessThan.notInclusive:n.message,\"\".concat(l)),valid:parseFloat(e.value)<l}}}};\n\treturn index_min$8;\n}\n\nvar cjs$8 = {};\n\nvar hasRequiredCjs$8;\n\nfunction requireCjs$8 () {\n\tif (hasRequiredCjs$8) return cjs$8;\n\thasRequiredCjs$8 = 1;\n\n\tvar core = libExports$B;\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\tvar format = core.utils.format, removeUndefined = core.utils.removeUndefined;\n\tfunction lessThan() {\n\t    return {\n\t        validate: function (input) {\n\t            if (input.value === '') {\n\t                return { valid: true };\n\t            }\n\t            var opts = Object.assign({}, { inclusive: true, message: '' }, removeUndefined(input.options));\n\t            var maxValue = parseFloat(\"\".concat(opts.max).replace(',', '.'));\n\t            return opts.inclusive\n\t                ? {\n\t                    message: format(input.l10n ? opts.message || input.l10n.lessThan.default : opts.message, \"\".concat(maxValue)),\n\t                    valid: parseFloat(input.value) <= maxValue,\n\t                }\n\t                : {\n\t                    message: format(input.l10n ? opts.message || input.l10n.lessThan.notInclusive : opts.message, \"\".concat(maxValue)),\n\t                    valid: parseFloat(input.value) < maxValue,\n\t                };\n\t        },\n\t    };\n\t}\n\n\tcjs$8.lessThan = lessThan;\n\treturn cjs$8;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\nif (false) {} else {\n    lib$8.exports = requireCjs$8();\n}\n\nvar libExports$8 = lib$8.exports;\n\nvar lib$7 = {exports: {}};\n\nvar index_min$7 = {};\n\n/** \n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n *\n * @license https://formvalidation.io/license\n * @package @form-validation/validator-not-empty\n * @version 2.4.0\n */\n\nvar hasRequiredIndex_min$7;\n\nfunction requireIndex_min$7 () {\n\tif (hasRequiredIndex_min$7) return index_min$7;\n\thasRequiredIndex_min$7 = 1;\nindex_min$7.notEmpty=function(){return {validate:function(t){var i=!!t.options&&!!t.options.trim,n=t.value;return {valid:!i&&\"\"!==n||i&&\"\"!==n&&\"\"!==n.trim()}}}};\n\treturn index_min$7;\n}\n\nvar cjs$7 = {};\n\nvar hasRequiredCjs$7;\n\nfunction requireCjs$7 () {\n\tif (hasRequiredCjs$7) return cjs$7;\n\thasRequiredCjs$7 = 1;\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\tfunction notEmpty() {\n\t    return {\n\t        validate: function (input) {\n\t            var trim = !!input.options && !!input.options.trim;\n\t            var value = input.value;\n\t            return {\n\t                valid: (!trim && value !== '') || (trim && value !== '' && value.trim() !== ''),\n\t            };\n\t        },\n\t    };\n\t}\n\n\tcjs$7.notEmpty = notEmpty;\n\treturn cjs$7;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\nif (false) {} else {\n    lib$7.exports = requireCjs$7();\n}\n\nvar libExports$7 = lib$7.exports;\n\nvar lib$6 = {exports: {}};\n\nvar index_min$6 = {};\n\n/** \n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n *\n * @license https://formvalidation.io/license\n * @package @form-validation/validator-numeric\n * @version 2.4.0\n */\n\nvar hasRequiredIndex_min$6;\n\nfunction requireIndex_min$6 () {\n\tif (hasRequiredIndex_min$6) return index_min$6;\n\thasRequiredIndex_min$6 = 1;\nvar a=libExports$B.utils.removeUndefined;index_min$6.numeric=function(){return {validate:function(r){if(\"\"===r.value)return {valid:!0};var e=Object.assign({},{decimalSeparator:\".\",thousandsSeparator:\"\"},a(r.options)),t=\"\".concat(r.value);t.substr(0,1)===e.decimalSeparator?t=\"0\".concat(e.decimalSeparator).concat(t.substr(1)):t.substr(0,2)===\"-\".concat(e.decimalSeparator)&&(t=\"-0\".concat(e.decimalSeparator).concat(t.substr(2)));var c=\".\"===e.decimalSeparator?\"\\\\.\":e.decimalSeparator,o=\".\"===e.thousandsSeparator?\"\\\\.\":e.thousandsSeparator,i=new RegExp(\"^-?[0-9]{1,3}(\".concat(o,\"[0-9]{3})*(\").concat(c,\"[0-9]+)?$\")),n=new RegExp(o,\"g\");if(!i.test(t))return {valid:!1};o&&(t=t.replace(n,\"\")),c&&(t=t.replace(c,\".\"));var s=parseFloat(t);return {valid:!isNaN(s)&&isFinite(s)}}}};\n\treturn index_min$6;\n}\n\nvar cjs$6 = {};\n\nvar hasRequiredCjs$6;\n\nfunction requireCjs$6 () {\n\tif (hasRequiredCjs$6) return cjs$6;\n\thasRequiredCjs$6 = 1;\n\n\tvar core = libExports$B;\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\tvar removeUndefined = core.utils.removeUndefined;\n\tfunction numeric() {\n\t    return {\n\t        validate: function (input) {\n\t            if (input.value === '') {\n\t                return { valid: true };\n\t            }\n\t            var opts = Object.assign({}, {\n\t                decimalSeparator: '.',\n\t                thousandsSeparator: '',\n\t            }, removeUndefined(input.options));\n\t            var v = \"\".concat(input.value);\n\t            // Support preceding zero numbers such as .5, -.5\n\t            if (v.substr(0, 1) === opts.decimalSeparator) {\n\t                v = \"0\".concat(opts.decimalSeparator).concat(v.substr(1));\n\t            }\n\t            else if (v.substr(0, 2) === \"-\".concat(opts.decimalSeparator)) {\n\t                v = \"-0\".concat(opts.decimalSeparator).concat(v.substr(2));\n\t            }\n\t            var decimalSeparator = opts.decimalSeparator === '.' ? '\\\\.' : opts.decimalSeparator;\n\t            var thousandsSeparator = opts.thousandsSeparator === '.' ? '\\\\.' : opts.thousandsSeparator;\n\t            var testRegexp = new RegExp(\"^-?[0-9]{1,3}(\".concat(thousandsSeparator, \"[0-9]{3})*(\").concat(decimalSeparator, \"[0-9]+)?$\"));\n\t            var thousandsReplacer = new RegExp(thousandsSeparator, 'g');\n\t            if (!testRegexp.test(v)) {\n\t                return { valid: false };\n\t            }\n\t            // Replace thousands separator with blank\n\t            if (thousandsSeparator) {\n\t                v = v.replace(thousandsReplacer, '');\n\t            }\n\t            // Replace decimal separator with a dot\n\t            if (decimalSeparator) {\n\t                v = v.replace(decimalSeparator, '.');\n\t            }\n\t            var n = parseFloat(v);\n\t            return { valid: !isNaN(n) && isFinite(n) };\n\t        },\n\t    };\n\t}\n\n\tcjs$6.numeric = numeric;\n\treturn cjs$6;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\nif (false) {} else {\n    lib$6.exports = requireCjs$6();\n}\n\nvar libExports$6 = lib$6.exports;\n\nvar lib$5 = {exports: {}};\n\nvar index_min$5 = {};\n\n/** \n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n *\n * @license https://formvalidation.io/license\n * @package @form-validation/validator-promise\n * @version 2.4.0\n */\n\nvar hasRequiredIndex_min$5;\n\nfunction requireIndex_min$5 () {\n\tif (hasRequiredIndex_min$5) return index_min$5;\n\thasRequiredIndex_min$5 = 1;\nvar r=libExports$B.utils.call;index_min$5.promise=function(){return {validate:function(i){return r(i.options.promise,[i])}}};\n\treturn index_min$5;\n}\n\nvar cjs$5 = {};\n\nvar hasRequiredCjs$5;\n\nfunction requireCjs$5 () {\n\tif (hasRequiredCjs$5) return cjs$5;\n\thasRequiredCjs$5 = 1;\n\n\tvar core = libExports$B;\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\tvar call = core.utils.call;\n\tfunction promise() {\n\t    return {\n\t        /**\n\t         * The following example demonstrates how to use a promise validator to requires both width and height\n\t         * of an image to be less than 300 px\n\t         *  ```\n\t         *  const p = new Promise((resolve, reject) => {\n\t         *      const img = new Image()\n\t         *      img.addEventListener('load', function() {\n\t         *          const w = this.width\n\t         *          const h = this.height\n\t         *          resolve({\n\t         *              valid: w <= 300 && h <= 300\n\t         *              meta: {\n\t         *                  source: img.src // So, you can reuse it later if you want\n\t         *              }\n\t         *          })\n\t         *      })\n\t         *      img.addEventListener('error', function() {\n\t         *          reject({\n\t         *              valid: false,\n\t         *              message: Please choose an image\n\t         *          })\n\t         *      })\n\t         *  })\n\t         *  ```\n\t         *\n\t         * @param input\n\t         * @return {Promise<ValidateResult>}\n\t         */\n\t        validate: function (input) {\n\t            return call(input.options.promise, [input]);\n\t        },\n\t    };\n\t}\n\n\tcjs$5.promise = promise;\n\treturn cjs$5;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\nif (false) {} else {\n    lib$5.exports = requireCjs$5();\n}\n\nvar libExports$5 = lib$5.exports;\n\nvar lib$4 = {exports: {}};\n\nvar index_min$4 = {};\n\n/** \n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n *\n * @license https://formvalidation.io/license\n * @package @form-validation/validator-regexp\n * @version 2.4.0\n */\n\nvar hasRequiredIndex_min$4;\n\nfunction requireIndex_min$4 () {\n\tif (hasRequiredIndex_min$4) return index_min$4;\n\thasRequiredIndex_min$4 = 1;\nindex_min$4.regexp=function(){return {validate:function(e){if(\"\"===e.value)return {valid:!0};var t=e.options.regexp;if(t instanceof RegExp)return {valid:t.test(e.value)};var n=t.toString();return {valid:(e.options.flags?new RegExp(n,e.options.flags):new RegExp(n)).test(e.value)}}}};\n\treturn index_min$4;\n}\n\nvar cjs$4 = {};\n\nvar hasRequiredCjs$4;\n\nfunction requireCjs$4 () {\n\tif (hasRequiredCjs$4) return cjs$4;\n\thasRequiredCjs$4 = 1;\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\tfunction regexp() {\n\t    return {\n\t        /**\n\t         * Check if the element value matches given regular expression\n\t         */\n\t        validate: function (input) {\n\t            if (input.value === '') {\n\t                return { valid: true };\n\t            }\n\t            var reg = input.options.regexp;\n\t            if (reg instanceof RegExp) {\n\t                return { valid: reg.test(input.value) };\n\t            }\n\t            else {\n\t                var pattern = reg.toString();\n\t                var exp = input.options.flags ? new RegExp(pattern, input.options.flags) : new RegExp(pattern);\n\t                return { valid: exp.test(input.value) };\n\t            }\n\t        },\n\t    };\n\t}\n\n\tcjs$4.regexp = regexp;\n\treturn cjs$4;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\nif (false) {} else {\n    lib$4.exports = requireCjs$4();\n}\n\nvar libExports$4 = lib$4.exports;\n\nvar lib$3 = {exports: {}};\n\nvar index_min$3 = {};\n\n/** \n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n *\n * @license https://formvalidation.io/license\n * @package @form-validation/validator-remote\n * @version 2.4.0\n */\n\nvar hasRequiredIndex_min$3;\n\nfunction requireIndex_min$3 () {\n\tif (hasRequiredIndex_min$3) return index_min$3;\n\thasRequiredIndex_min$3 = 1;\nvar e=libExports$B,a=e.utils.fetch,r=e.utils.removeUndefined;index_min$3.remote=function(){var e={crossDomain:!1,data:{},headers:{},method:\"GET\",validKey:\"valid\"};return {validate:function(t){if(\"\"===t.value)return Promise.resolve({valid:!0});var i=Object.assign({},e,r(t.options)),o=i.data;\"function\"==typeof i.data&&(o=i.data.call(this,t)),\"string\"==typeof o&&(o=JSON.parse(o)),o[i.name||t.field]=t.value;var s=\"function\"==typeof i.url?i.url.call(this,t):i.url;return a(s,{crossDomain:i.crossDomain,headers:i.headers,method:i.method,params:o}).then((function(e){return Promise.resolve({message:e.message,meta:e,valid:\"true\"===\"\".concat(e[i.validKey])})})).catch((function(e){return Promise.reject({valid:!1})}))}}};\n\treturn index_min$3;\n}\n\nvar cjs$3 = {};\n\nvar hasRequiredCjs$3;\n\nfunction requireCjs$3 () {\n\tif (hasRequiredCjs$3) return cjs$3;\n\thasRequiredCjs$3 = 1;\n\n\tvar core = libExports$B;\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\tvar fetch = core.utils.fetch, removeUndefined = core.utils.removeUndefined;\n\tfunction remote() {\n\t    var DEFAULT_OPTIONS = {\n\t        crossDomain: false,\n\t        data: {},\n\t        headers: {},\n\t        method: 'GET',\n\t        validKey: 'valid',\n\t    };\n\t    return {\n\t        validate: function (input) {\n\t            if (input.value === '') {\n\t                return Promise.resolve({\n\t                    valid: true,\n\t                });\n\t            }\n\t            var opts = Object.assign({}, DEFAULT_OPTIONS, removeUndefined(input.options));\n\t            var data = opts.data;\n\t            // Support dynamic data\n\t            if ('function' === typeof opts.data) {\n\t                data = opts.data.call(this, input);\n\t            }\n\t            // Parse string data from HTML5 attribute\n\t            if ('string' === typeof data) {\n\t                data = JSON.parse(data);\n\t            }\n\t            data[opts.name || input.field] = input.value;\n\t            // Support dynamic url\n\t            var url = 'function' === typeof opts.url\n\t                ? opts.url.call(this, input)\n\t                : opts.url;\n\t            return fetch(url, {\n\t                crossDomain: opts.crossDomain,\n\t                headers: opts.headers,\n\t                method: opts.method,\n\t                params: data,\n\t            })\n\t                .then(function (response) {\n\t                return Promise.resolve({\n\t                    message: response['message'],\n\t                    meta: response,\n\t                    valid: \"\".concat(response[opts.validKey]) === 'true',\n\t                });\n\t            })\n\t                .catch(function (_reason) {\n\t                return Promise.reject({\n\t                    valid: false,\n\t                });\n\t            });\n\t        },\n\t    };\n\t}\n\n\tcjs$3.remote = remote;\n\treturn cjs$3;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\nif (false) {} else {\n    lib$3.exports = requireCjs$3();\n}\n\nvar libExports$3 = lib$3.exports;\n\nvar lib$2 = {exports: {}};\n\nvar index_min$2 = {};\n\n/** \n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n *\n * @license https://formvalidation.io/license\n * @package @form-validation/validator-string-case\n * @version 2.4.0\n */\n\nvar hasRequiredIndex_min$2;\n\nfunction requireIndex_min$2 () {\n\tif (hasRequiredIndex_min$2) return index_min$2;\n\thasRequiredIndex_min$2 = 1;\nvar e=libExports$B.utils.removeUndefined;index_min$2.stringCase=function(){return {validate:function(a){if(\"\"===a.value)return {valid:!0};var r=Object.assign({},{case:\"lower\"},e(a.options)),s=(r.case||\"lower\").toLowerCase();return {message:r.message||(a.l10n?\"upper\"===s?a.l10n.stringCase.upper:a.l10n.stringCase.default:r.message),valid:\"upper\"===s?a.value===a.value.toUpperCase():a.value===a.value.toLowerCase()}}}};\n\treturn index_min$2;\n}\n\nvar cjs$2 = {};\n\nvar hasRequiredCjs$2;\n\nfunction requireCjs$2 () {\n\tif (hasRequiredCjs$2) return cjs$2;\n\thasRequiredCjs$2 = 1;\n\n\tvar core = libExports$B;\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\tvar removeUndefined = core.utils.removeUndefined;\n\tfunction stringCase() {\n\t    return {\n\t        /**\n\t         * Check if a string is a lower or upper case one\n\t         */\n\t        validate: function (input) {\n\t            if (input.value === '') {\n\t                return { valid: true };\n\t            }\n\t            var opts = Object.assign({}, { case: 'lower' }, removeUndefined(input.options));\n\t            var caseOpt = (opts.case || 'lower').toLowerCase();\n\t            return {\n\t                message: opts.message ||\n\t                    (input.l10n\n\t                        ? 'upper' === caseOpt\n\t                            ? input.l10n.stringCase.upper\n\t                            : input.l10n.stringCase.default\n\t                        : opts.message),\n\t                valid: 'upper' === caseOpt\n\t                    ? input.value === input.value.toUpperCase()\n\t                    : input.value === input.value.toLowerCase(),\n\t            };\n\t        },\n\t    };\n\t}\n\n\tcjs$2.stringCase = stringCase;\n\treturn cjs$2;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\nif (false) {} else {\n    lib$2.exports = requireCjs$2();\n}\n\nvar libExports$2 = lib$2.exports;\n\nvar lib$1 = {exports: {}};\n\nvar index_min$1 = {};\n\n/** \n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n *\n * @license https://formvalidation.io/license\n * @package @form-validation/validator-string-length\n * @version 2.4.0\n */\n\nvar hasRequiredIndex_min$1;\n\nfunction requireIndex_min$1 () {\n\tif (hasRequiredIndex_min$1) return index_min$1;\n\thasRequiredIndex_min$1 = 1;\nvar e=libExports$B,t=e.utils.format,n=e.utils.removeUndefined;index_min$1.stringLength=function(){return {validate:function(e){var s=Object.assign({},{message:\"\",trim:!1,utf8Bytes:!1},n(e.options)),a=!0===s.trim||\"true\"===\"\".concat(s.trim)?e.value.trim():e.value;if(\"\"===a)return {valid:!0};var r=s.min?\"\".concat(s.min):\"\",i=s.max?\"\".concat(s.max):\"\",g=s.utf8Bytes?function(e){for(var t=e.length,n=e.length-1;n>=0;n--){var s=e.charCodeAt(n);s>127&&s<=2047?t++:s>2047&&s<=65535&&(t+=2),s>=56320&&s<=57343&&n--;}return t}(a):a.length,m=!0,c=e.l10n?s.message||e.l10n.stringLength.default:s.message;switch((r&&g<parseInt(r,10)||i&&g>parseInt(i,10))&&(m=!1),!0){case!!r&&!!i:c=t(e.l10n?s.message||e.l10n.stringLength.between:s.message,[r,i]);break;case!!r:c=t(e.l10n?s.message||e.l10n.stringLength.more:s.message,\"\".concat(parseInt(r,10)));break;case!!i:c=t(e.l10n?s.message||e.l10n.stringLength.less:s.message,\"\".concat(parseInt(i,10)));}return {message:c,valid:m}}}};\n\treturn index_min$1;\n}\n\nvar cjs$1 = {};\n\nvar hasRequiredCjs$1;\n\nfunction requireCjs$1 () {\n\tif (hasRequiredCjs$1) return cjs$1;\n\thasRequiredCjs$1 = 1;\n\n\tvar core = libExports$B;\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\tvar format = core.utils.format, removeUndefined = core.utils.removeUndefined;\n\t// Credit to http://stackoverflow.com/a/23329386 (@lovasoa) for UTF-8 byte length code\n\tvar utf8Length = function (str) {\n\t    var s = str.length;\n\t    for (var i = str.length - 1; i >= 0; i--) {\n\t        var code = str.charCodeAt(i);\n\t        if (code > 0x7f && code <= 0x7ff) {\n\t            s++;\n\t        }\n\t        else if (code > 0x7ff && code <= 0xffff) {\n\t            s += 2;\n\t        }\n\t        if (code >= 0xdc00 && code <= 0xdfff) {\n\t            i--;\n\t        }\n\t    }\n\t    return s;\n\t};\n\tfunction stringLength() {\n\t    return {\n\t        /**\n\t         * Check if the length of element value is less or more than given number\n\t         */\n\t        validate: function (input) {\n\t            var opts = Object.assign({}, {\n\t                message: '',\n\t                trim: false,\n\t                utf8Bytes: false,\n\t            }, removeUndefined(input.options));\n\t            var v = opts.trim === true || \"\".concat(opts.trim) === 'true' ? input.value.trim() : input.value;\n\t            if (v === '') {\n\t                return { valid: true };\n\t            }\n\t            // TODO: `min`, `max` can be dynamic options\n\t            var min = opts.min ? \"\".concat(opts.min) : '';\n\t            var max = opts.max ? \"\".concat(opts.max) : '';\n\t            var length = opts.utf8Bytes ? utf8Length(v) : v.length;\n\t            var isValid = true;\n\t            var msg = input.l10n ? opts.message || input.l10n.stringLength.default : opts.message;\n\t            if ((min && length < parseInt(min, 10)) || (max && length > parseInt(max, 10))) {\n\t                isValid = false;\n\t            }\n\t            switch (true) {\n\t                case !!min && !!max:\n\t                    msg = format(input.l10n ? opts.message || input.l10n.stringLength.between : opts.message, [\n\t                        min,\n\t                        max,\n\t                    ]);\n\t                    break;\n\t                case !!min:\n\t                    msg = format(input.l10n ? opts.message || input.l10n.stringLength.more : opts.message, \"\".concat(parseInt(min, 10)));\n\t                    break;\n\t                case !!max:\n\t                    msg = format(input.l10n ? opts.message || input.l10n.stringLength.less : opts.message, \"\".concat(parseInt(max, 10)));\n\t                    break;\n\t            }\n\t            return {\n\t                message: msg,\n\t                valid: isValid,\n\t            };\n\t        },\n\t    };\n\t}\n\n\tcjs$1.stringLength = stringLength;\n\treturn cjs$1;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\nif (false) {} else {\n    lib$1.exports = requireCjs$1();\n}\n\nvar libExports$1 = lib$1.exports;\n\nvar lib = {exports: {}};\n\nvar index_min = {};\n\n/** \n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n *\n * @license https://formvalidation.io/license\n * @package @form-validation/validator-uri\n * @version 2.4.0\n */\n\nvar hasRequiredIndex_min;\n\nfunction requireIndex_min () {\n\tif (hasRequiredIndex_min) return index_min;\n\thasRequiredIndex_min = 1;\nvar o=libExports$B.utils.removeUndefined;index_min.uri=function(){var a={allowEmptyProtocol:!1,allowLocal:!1,protocol:\"http, https, ftp\"};return {validate:function(t){if(\"\"===t.value)return {valid:!0};var l=Object.assign({},a,o(t.options)),f=!0===l.allowLocal||\"true\"===\"\".concat(l.allowLocal),r=!0===l.allowEmptyProtocol||\"true\"===\"\".concat(l.allowEmptyProtocol),e=l.protocol.split(\",\").join(\"|\").replace(/\\s/g,\"\");return {valid:new RegExp(\"^(?:(?:\"+e+\")://)\"+(r?\"?\":\"\")+\"(?:\\\\S+(?::\\\\S*)?@)?(?:\"+(f?\"\":\"(?!(?:10|127)(?:\\\\.\\\\d{1,3}){3})(?!(?:169\\\\.254|192\\\\.168)(?:\\\\.\\\\d{1,3}){2})(?!172\\\\.(?:1[6-9]|2\\\\d|3[0-1])(?:\\\\.\\\\d{1,3}){2})\")+\"(?:[1-9]\\\\d?|1\\\\d\\\\d|2[01]\\\\d|22[0-3])(?:\\\\.(?:1?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])){2}(?:\\\\.(?:[1-9]\\\\d?|1\\\\d\\\\d|2[0-4]\\\\d|25[0-4]))|(?:(?:[a-z\\\\u00a1-\\\\uffff0-9]-?)*[a-z\\\\u00a1-\\\\uffff0-9]+)(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]-?)*[a-z\\\\u00a1-\\\\uffff0-9])*(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,}))\"+(f?\"?\":\"\")+\")(?::\\\\d{2,5})?(?:/[^\\\\s]*)?$\",\"i\").test(t.value)}}}};\n\treturn index_min;\n}\n\nvar cjs = {};\n\nvar hasRequiredCjs;\n\nfunction requireCjs () {\n\tif (hasRequiredCjs) return cjs;\n\thasRequiredCjs = 1;\n\n\tvar core = libExports$B;\n\n\t/**\n\t * FormValidation (https://formvalidation.io)\n\t * The best validation library for JavaScript\n\t * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n\t */\n\tvar removeUndefined = core.utils.removeUndefined;\n\tfunction uri() {\n\t    var DEFAULT_OPTIONS = {\n\t        allowEmptyProtocol: false,\n\t        allowLocal: false,\n\t        protocol: 'http, https, ftp',\n\t    };\n\t    return {\n\t        /**\n\t         * Return true if the input value is a valid URL\n\t         */\n\t        validate: function (input) {\n\t            if (input.value === '') {\n\t                return { valid: true };\n\t            }\n\t            var opts = Object.assign({}, DEFAULT_OPTIONS, removeUndefined(input.options));\n\t            // Credit to https://gist.github.com/dperini/729294\n\t            //\n\t            // Regular Expression for URL validation\n\t            //\n\t            // Author: Diego Perini\n\t            // Updated: 2010/12/05\n\t            //\n\t            // the regular expression composed & commented\n\t            // could be easily tweaked for RFC compliance,\n\t            // it was expressly modified to fit & satisfy\n\t            // these test for an URL shortener:\n\t            //\n\t            //   http://mathiasbynens.be/demo/url-regex\n\t            //\n\t            // Notes on possible differences from a standard/generic validation:\n\t            //\n\t            // - utf-8 char class take in consideration the full Unicode range\n\t            // - TLDs are mandatory unless `allowLocal` is true\n\t            // - protocols have been restricted to ftp, http and https only as requested\n\t            //\n\t            // Changes:\n\t            //\n\t            // - IP address dotted notation validation, range: 1.0.0.0 - 223.255.255.255\n\t            //   first and last IP address of each class is considered invalid\n\t            //   (since they are broadcast/network addresses)\n\t            //\n\t            // - Added exclusion of private, reserved and/or local networks ranges\n\t            //   unless `allowLocal` is true\n\t            //\n\t            // - Added possibility of choosing a custom protocol\n\t            //\n\t            // - Add option to validate without protocol\n\t            //\n\t            var allowLocal = opts.allowLocal === true || \"\".concat(opts.allowLocal) === 'true';\n\t            var allowEmptyProtocol = opts.allowEmptyProtocol === true || \"\".concat(opts.allowEmptyProtocol) === 'true';\n\t            var protocol = opts.protocol.split(',').join('|').replace(/\\s/g, '');\n\t            var urlExp = new RegExp('^' +\n\t                // protocol identifier\n\t                '(?:(?:' +\n\t                protocol +\n\t                ')://)' +\n\t                // allow empty protocol\n\t                (allowEmptyProtocol ? '?' : '') +\n\t                // user:pass authentication\n\t                '(?:\\\\S+(?::\\\\S*)?@)?' +\n\t                '(?:' +\n\t                // IP address exclusion\n\t                // private & local networks\n\t                (allowLocal\n\t                    ? ''\n\t                    : '(?!(?:10|127)(?:\\\\.\\\\d{1,3}){3})' +\n\t                        '(?!(?:169\\\\.254|192\\\\.168)(?:\\\\.\\\\d{1,3}){2})' +\n\t                        '(?!172\\\\.(?:1[6-9]|2\\\\d|3[0-1])(?:\\\\.\\\\d{1,3}){2})') +\n\t                // IP address dotted notation octets\n\t                // excludes loopback network 0.0.0.0\n\t                // excludes reserved space >= 224.0.0.0\n\t                // excludes network & broadcast addresses\n\t                // (first & last IP address of each class)\n\t                '(?:[1-9]\\\\d?|1\\\\d\\\\d|2[01]\\\\d|22[0-3])' +\n\t                '(?:\\\\.(?:1?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])){2}' +\n\t                '(?:\\\\.(?:[1-9]\\\\d?|1\\\\d\\\\d|2[0-4]\\\\d|25[0-4]))' +\n\t                '|' +\n\t                // host name\n\t                '(?:(?:[a-z\\\\u00a1-\\\\uffff0-9]-?)*[a-z\\\\u00a1-\\\\uffff0-9]+)' +\n\t                // domain name\n\t                '(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]-?)*[a-z\\\\u00a1-\\\\uffff0-9])*' +\n\t                // TLD identifier\n\t                '(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,}))' +\n\t                // Allow intranet sites (no TLD) if `allowLocal` is true\n\t                (allowLocal ? '?' : '') +\n\t                ')' +\n\t                // port number\n\t                '(?::\\\\d{2,5})?' +\n\t                // resource path\n\t                '(?:/[^\\\\s]*)?$', 'i');\n\t            return { valid: urlExp.test(input.value) };\n\t        },\n\t    };\n\t}\n\n\tcjs.uri = uri;\n\treturn cjs;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\nif (false) {} else {\n    lib.exports = requireCjs();\n}\n\nvar libExports = lib.exports;\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\nvar plugins = {\n    Alias: libExports$A.Alias,\n    Aria: libExports$z.Aria,\n    Declarative: libExports$y.Declarative,\n    DefaultSubmit: libExports$x.DefaultSubmit,\n    Dependency: libExports$w.Dependency,\n    Excluded: libExports$v.Excluded,\n    FieldStatus: libExports$u.FieldStatus,\n    Framework: libExports$s.Framework,\n    Icon: libExports$r.Icon,\n    Message: libExports$t.Message,\n    Sequence: libExports$q.Sequence,\n    SubmitButton: libExports$p.SubmitButton,\n    Tooltip: libExports$o.Tooltip,\n    Trigger: libExports$n.Trigger,\n};\nvar validators = {\n    between: libExports$m.between,\n    blank: libExports$l.blank,\n    callback: libExports$k.callback,\n    choice: libExports$j.choice,\n    creditCard: libExports$i.creditCard,\n    date: libExports$h.date,\n    different: libExports$g.different,\n    digits: libExports$f.digits,\n    emailAddress: libExports$e.emailAddress,\n    file: libExports$d.file,\n    greaterThan: libExports$c.greaterThan,\n    identical: libExports$b.identical,\n    integer: libExports$a.integer,\n    ip: libExports$9.ip,\n    lessThan: libExports$8.lessThan,\n    notEmpty: libExports$7.notEmpty,\n    numeric: libExports$6.numeric,\n    promise: libExports$5.promise,\n    regexp: libExports$4.regexp,\n    remote: libExports$3.remote,\n    stringCase: libExports$2.stringCase,\n    stringLength: libExports$1.stringLength,\n    uri: libExports.uri,\n};\n// Register popular validators\nvar formValidationWithPopularValidators = function (form, options) {\n    var instance = libExports$B.formValidation(form, options);\n    Object.keys(validators).forEach(function (name) { return instance.registerValidator(name, validators[name]); });\n    return instance;\n};\n\nexports.Plugin = libExports$B.Plugin;\nexports.algorithms = libExports$B.algorithms;\nexports.formValidation = formValidationWithPopularValidators;\nexports.plugins = plugins;\nexports.utils = libExports$B.utils;\nexports.validators = validators;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcm0tdmFsaWRhdGlvbi9idW5kbGUvbGliL2Nqcy9wb3B1bGFyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU8saUJBQWlCLDJFQUEyRSxJQUFJLHlDQUF5QyxvQkFBb0Isd0JBQXdCLDJCQUEyQixJQUFJLGlEQUFpRCxhQUFhLDBCQUEwQix1REFBdUQsb0RBQW9ELElBQUksZ0RBQWdELGFBQWEsd0JBQXdCLHNCQUFzQixvQ0FBb0Msc0JBQXNCLDJCQUEyQix1Q0FBdUMsc0JBQXNCLEdBQUcsdUJBQXVCLE1BQU0scUJBQXFCLHlCQUF5QixzQkFBc0Isa2JBQWtiLFdBQVcseUJBQXlCLGVBQWUsaUJBQWlCLGdCQUFnQixjQUFjLGlCQUFpQixVQUFVLE1BQU0sa0JBQWtCLGFBQWEsa0JBQWtCLGlCQUFpQixtQkFBbUIsd0JBQXdCLG1DQUFtQyxvQkFBb0IsSUFBSSxtQkFBbUIsZ0JBQWdCLDZCQUE2QixnQ0FBZ0Msa0JBQWtCLHdDQUF3QyxjQUFjLFVBQVUsbUJBQW1CLCtDQUErQyxrQkFBa0IsaUJBQWlCLHlCQUF5QixzREFBc0QsNkNBQTZDLElBQUksc0JBQXNCLFNBQVMsc0JBQXNCLHNFQUFzRSxhQUFhLE1BQU0sZ0JBQWdCLHdDQUF3Qyw0QkFBNEIsb0NBQW9DLDRCQUE0QiwrQkFBK0IsNkJBQTZCLDhCQUE4QixtQkFBbUIsbUJBQW1CLHdCQUF3QixnREFBZ0Qsb0RBQW9ELElBQUkscUVBQXFFLGtEQUFrRCxpQkFBaUIsMENBQTBDLDZFQUE2RSwwREFBMEQsMENBQTBDLHNCQUFzQixvREFBb0Qsc0NBQXNDLHNCQUFzQiwwQkFBMEIsdUNBQXVDLHNCQUFzQiwyQkFBMkIseUNBQXlDLHNCQUFzQixnQ0FBZ0MsNkNBQTZDLG1GQUFtRixpQ0FBaUMsMENBQTBDLGlDQUFpQyw0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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRjtBQUNBOztBQUVBOztBQUVBLGFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxRQUFRLHFCQUFxQiwwRkFBMEYsUUFBUTtBQUNoSztBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRjtBQUNBOztBQUVBOztBQUVBLGFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixRQUFRLHFCQUFxQixRQUFRO0FBQ25FO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRjtBQUNBOztBQUVBOztBQUVBLGFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCx3QkFBd0IsOENBQThDLEtBQUssNkNBQTZDLEtBQUssc0NBQXNDLHdCQUF3Qiw4Q0FBOEMsS0FBSyw2Q0FBNkMsS0FBSyxrQkFBa0Isb0NBQW9DLFFBQVEscUJBQXFCLHdCQUF3QixVQUFVLHNCQUFzQixFQUFFLGlEQUFpRCxHQUFHLDJDQUEyQyxvREFBb0QsMkJBQTJCLG1CQUFtQixnREFBZ0QsSUFBSSxlQUFlLCtCQUErQixpQkFBaUIsTUFBTSxlQUFlLFlBQVksTUFBTSxpQkFBaUIsV0FBVyxpQ0FBaUMsbUJBQW1CLDJCQUEyQixJQUFJLDZCQUE2QixVQUFVLFFBQVEsVUFBVSxRQUFRO0FBQ3IvQjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHdCQUF3Qiw4Q0FBOEMsS0FBSyw2Q0FBNkMsS0FBSztBQUM3SyxnREFBZ0Qsd0JBQXdCLDhDQUE4QyxLQUFLLDZDQUE2QyxLQUFLO0FBQzdLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix5QkFBeUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx3Q0FBd0M7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0EsaUNBQWlDLGNBQWM7QUFDL0M7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRjtBQUNBOztBQUVBOztBQUVBLGFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpRUFBaUUsNEJBQTRCLFFBQVEscUJBQXFCLHdCQUF3QixVQUFVLDRGQUE0RixnQkFBZ0IsZ0ZBQWdGLGdCQUFnQixNQUFNLG9EQUFvRCxxQ0FBcUMsNEVBQTRFLE1BQU0sMEJBQTBCLFdBQVcsNEVBQTRFLE1BQU0sMEJBQTBCLFdBQVcsWUFBWSxLQUFLLElBQUksS0FBSyxtQkFBbUIsNkZBQTZGLGdGQUFnRixxQkFBcUIsRUFBRSx5QkFBeUIsY0FBYyxrRkFBa0YscUJBQXFCLEVBQUUseUJBQXlCLGNBQWMsdURBQXVELHFCQUFxQixFQUFFLDBCQUEwQixjQUFjLDBFQUEwRSxxQkFBcUIsRUFBRSxxQkFBcUIsY0FBYyxpRkFBaUYscUJBQXFCLEVBQUUscUJBQXFCLGNBQWMsb0ZBQW9GLHFCQUFxQixFQUFFLDJDQUEyQyxjQUFjLG9GQUFvRixxQkFBcUIsRUFBRSwyQ0FBMkMsY0FBYyxNQUFNLG9HQUFvRyxNQUFNLGdDQUFnQyxXQUFXLG1GQUFtRixNQUFNLDRCQUE0QixXQUFXLFFBQVE7QUFDL2xFO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMscUJBQXFCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMscUJBQXFCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDRCQUE0QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNEJBQTRCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFdBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxJQUFJLDJCQUEyQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsSUFBSSwyQkFBMkI7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELElBQUksNEJBQTRCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxJQUFJLHVCQUF1QjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsSUFBSSx1QkFBdUI7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRjtBQUNBOztBQUVBOztBQUVBLGFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxtQ0FBbUMsUUFBUSxxQkFBcUIsd0JBQXdCLFVBQVUsc0JBQXNCLEVBQUUsd0JBQXdCLCtEQUErRCxvQkFBb0IsNEdBQTRHLEVBQUU7QUFDalo7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSx3Q0FBd0MsSUFBSSw4QkFBOEI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGO0FBQ0E7O0FBRUE7O0FBRUEsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVEscUJBQXFCLDBGQUEwRixRQUFRO0FBQ2hLO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGO0FBQ0E7O0FBRUE7O0FBRUEsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLCtCQUErQixRQUFRLHFCQUFxQix3QkFBd0IsVUFBVSxzQkFBc0IsRUFBRSwyQ0FBMkMsa0pBQWtKLElBQUksbUJBQW1CLEVBQUUsc0VBQXNFLHNCQUFzQixVQUFVLCtDQUErQyxvQkFBb0IsUUFBUTtBQUN0aUI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsbURBQW1ELElBQUkscUNBQXFDLEVBQUU7QUFDOUY7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQSxhQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsMEJBQTBCLFFBQVEscUJBQXFCLHdCQUF3QixVQUFVLHNCQUFzQixFQUFFLGdCQUFnQixrRUFBa0UsRUFBRSwrRkFBK0YsSUFBSSxHQUFHLEVBQUUsYUFBYSxJQUFJLG1CQUFtQixJQUFJLEdBQUcsRUFBRSxjQUFjLElBQUkseUVBQXlFLEVBQUUsb0JBQW9CLElBQUksR0FBRyxFQUFFLGdCQUFnQixJQUFJLEVBQUUsSUFBSSwyRUFBMkUsRUFBRSxvQkFBb0IsSUFBSSxHQUFHLEVBQUUsZ0JBQWdCLElBQUksRUFBRSxJQUFJLGlCQUFpQixJQUFJLDJFQUEyRSxFQUFFLHFCQUFxQixJQUFJLEdBQUcsRUFBRSxnQkFBZ0IsSUFBSSxFQUFFLElBQUksaUJBQWlCLElBQUksRUFBRSxJQUFJLHlFQUF5RSxFQUFFLHFCQUFxQixJQUFJLEdBQUcsRUFBRSxnQkFBZ0IsSUFBSSxFQUFFLElBQUksaUJBQWlCLElBQUksRUFBRSxJQUFJLHlFQUF5RSxFQUFFLHFCQUFxQixJQUFJLEdBQUcsRUFBRSxnQkFBZ0IsSUFBSSxFQUFFLElBQUksaUJBQWlCLElBQUksRUFBRSxJQUFJLHlFQUF5RSxFQUFFLHlCQUF5QixJQUFJLEVBQUUsSUFBSSxpQkFBaUIsSUFBSSxFQUFFLElBQUkseUVBQXlFLEVBQUUsa0RBQWtELFdBQVcsNkJBQTZCLDBFQUEwRSw0QkFBNEIsMEVBQTBFLG9DQUFvQztBQUM5b0Q7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBLGNBQWM7QUFDZCw4RUFBOEUsRUFBRTtBQUNoRixpREFBaUQsSUFBSSxHQUFHLEVBQUUsYUFBYSxJQUFJLG1CQUFtQixJQUFJLEdBQUcsRUFBRSxjQUFjLElBQUkseUVBQXlFLEVBQUUsb0JBQW9CLElBQUksR0FBRyxFQUFFLGdCQUFnQixJQUFJLEVBQUUsSUFBSSwyRUFBMkUsRUFBRSxvQkFBb0IsSUFBSSxHQUFHLEVBQUUsZ0JBQWdCLElBQUksRUFBRSxJQUFJLGlCQUFpQixJQUFJLDJFQUEyRSxFQUFFLHFCQUFxQixJQUFJLEdBQUcsRUFBRSxnQkFBZ0IsSUFBSSxFQUFFLElBQUksaUJBQWlCLElBQUksRUFBRSxJQUFJLHlFQUF5RSxFQUFFLHFCQUFxQixJQUFJLEdBQUcsRUFBRSxnQkFBZ0IsSUFBSSxFQUFFLElBQUksaUJBQWlCLElBQUksRUFBRSxJQUFJLHlFQUF5RSxFQUFFLHFCQUFxQixJQUFJLEdBQUcsRUFBRSxnQkFBZ0IsSUFBSSxFQUFFLElBQUksaUJBQWlCLElBQUksRUFBRSxJQUFJLHlFQUF5RSxFQUFFLHlCQUF5QixJQUFJLEVBQUUsSUFBSSxpQkFBaUIsSUFBSSxFQUFFLElBQUkseUVBQXlFLEVBQUU7QUFDcGtDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQSxhQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsZ0NBQWdDLFFBQVEscUJBQXFCLHdCQUF3QixVQUFVLHNCQUFzQixFQUFFLHdCQUF3QiwrREFBK0Qsb0JBQW9CLHlHQUF5RyxFQUFFO0FBQzNZO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0Esd0NBQXdDLElBQUksOEJBQThCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRjtBQUNBOztBQUVBOztBQUVBLGFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxRQUFRLHFCQUFxQiw4Q0FBOEMsUUFBUTtBQUNuSDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQSxhQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsK0JBQStCLFFBQVEscUJBQXFCLHdCQUF3QixVQUFVLHNCQUFzQixFQUFFLDJDQUEyQyxvQ0FBb0MsZ01BQWdNLHVJQUF1SSxJQUFJLG1CQUFtQixFQUFFLGlEQUFpRCxzQkFBc0IsVUFBVSwrQ0FBK0Msb0JBQW9CLFFBQVE7QUFDMXVCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsSUFBSSxxQ0FBcUMsRUFBRTtBQUM5RjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQSxhQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsK0JBQStCLFFBQVEscUJBQXFCO0FBQzFGO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGO0FBQ0E7O0FBRUE7O0FBRUEsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFFBQVEscUJBQXFCLHdCQUF3QixVQUFVLHVCQUF1QiwrQkFBK0IsdUJBQXVCLG1CQUFtQixRQUFRO0FBQ3JNO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGO0FBQ0E7O0FBRUE7O0FBRUEsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELDhCQUE4QixPQUFPLHNCQUFzQixXQUFXLGdDQUFnQyxRQUFRLHFCQUFxQix3Q0FBd0MsU0FBUyxFQUFFLHNCQUFzQiwwQkFBMEIsb0hBQW9ILHdEQUF3RCxZQUFZLHFFQUFxRSxvQkFBb0Isd0JBQXdCLGlFQUFpRSxFQUFFLHNCQUFzQix1QkFBdUIsU0FBUyxFQUFFO0FBQ3ZzQjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGNBQWM7QUFDZCxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGO0FBQ0E7O0FBRUE7O0FBRUEsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGtDQUFrQyxRQUFRLHFCQUFxQix3QkFBd0IsVUFBVSxzQkFBc0IsRUFBRSxhQUFhLGlEQUFpRCxRQUFRO0FBQ3hPO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0Esd0NBQXdDLElBQUksZUFBZTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGO0FBQ0E7O0FBRUE7O0FBRUEsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOERBQThELG9DQUFvQyxRQUFRLHFCQUFxQixzQkFBc0IsRUFBRSxnQ0FBZ0MsZ0ZBQWdGLGtCQUFrQixVQUFVLHNGQUFzRixnQ0FBZ0MsS0FBSyxLQUFLLHNCQUFzQixxRUFBcUUsU0FBUyw0RUFBNEUsOERBQThELGdGQUFnRixNQUFNLDRGQUE0RixNQUFNLDZGQUE2RixRQUFRO0FBQzk2QjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQSxXQUFXOztBQUVYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMseUJBQXlCLE9BQU8saUVBQWlFLFFBQVEscUJBQXFCLHdCQUF3QixVQUFVLHNCQUFzQixpTUFBaU0sUUFBUSx3R0FBd0csSUFBSSxFQUFFLEVBQUUscUNBQXFDLElBQUksRUFBRSxFQUFFLDBDQUEwQyxJQUFJLEVBQUUsRUFBRSwwREFBMEQsSUFBSSxxQkFBcUIsRUFBRSxvTUFBb00sR0FBRyx5QkFBeUIsSUFBSTtBQUNoN0I7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsSUFBSSxFQUFFLEVBQUU7QUFDdkQsOERBQThELElBQUksRUFBRSxFQUFFO0FBQ3RFLG1FQUFtRSxJQUFJLEVBQUUsRUFBRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsSUFBSSxxQkFBcUIsRUFBRTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxHQUFHO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLElBQUk7QUFDOUI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsNERBQTREO0FBQ2xIO0FBQ0E7O0FBRUEsY0FBYztBQUNkLGtCQUFrQjtBQUNsQixzQkFBc0I7QUFDdEIsZUFBZTtBQUNmLGFBQWE7QUFDYixrQkFBa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9WdWV4eS8uL25vZGVfbW9kdWxlcy9AZm9ybS12YWxpZGF0aW9uL2J1bmRsZS9saWIvY2pzL3BvcHVsYXIuanM/YTU2NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBsaWIkQiA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBpbmRleF9taW4kQiA9IHt9O1xuXG4vKiogXG4gKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcbiAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuICpcbiAqIEBsaWNlbnNlIGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8vbGljZW5zZVxuICogQHBhY2thZ2UgQGZvcm0tdmFsaWRhdGlvbi9jb3JlXG4gKiBAdmVyc2lvbiAyLjQuMFxuICovXG5cbnZhciBoYXNSZXF1aXJlZEluZGV4X21pbiRCO1xuXG5mdW5jdGlvbiByZXF1aXJlSW5kZXhfbWluJEIgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRJbmRleF9taW4kQikgcmV0dXJuIGluZGV4X21pbiRCO1xuXHRoYXNSZXF1aXJlZEluZGV4X21pbiRCID0gMTtcbnZhciBlPXtsdWhuOmZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1lLmxlbmd0aCxpPVtbMCwxLDIsMyw0LDUsNiw3LDgsOV0sWzAsMiw0LDYsOCwxLDMsNSw3LDldXSxyPTAsbj0wO3QtLTspbis9aVtyXVtwYXJzZUludChlLmNoYXJBdCh0KSwxMCldLHI9MS1yO3JldHVybiBuJTEwPT0wJiZuPjB9LG1vZDExQW5kMTA6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PWUubGVuZ3RoLGk9NSxyPTA7cjx0O3IrKylpPSgyKihpfHwxMCklMTErcGFyc2VJbnQoZS5jaGFyQXQociksMTApKSUxMDtyZXR1cm4gMT09PWl9LG1vZDM3QW5kMzY6ZnVuY3Rpb24oZSx0KXt2b2lkIDA9PT10JiYodD1cIjAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlwiKTtmb3IodmFyIGk9ZS5sZW5ndGgscj10Lmxlbmd0aCxuPU1hdGguZmxvb3Ioci8yKSxzPTA7czxpO3MrKyluPSgyKihufHxyKSUocisxKSt0LmluZGV4T2YoZS5jaGFyQXQocykpKSVyO3JldHVybiAxPT09bn0sbW9kOTdBbmQxMDpmdW5jdGlvbihlKXtmb3IodmFyIHQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuc3BsaXQoXCJcIikubWFwKChmdW5jdGlvbihlKXt2YXIgdD1lLmNoYXJDb2RlQXQoMCk7cmV0dXJuIHQ+PTY1JiZ0PD05MD90LTU1OmV9KSkuam9pbihcIlwiKS5zcGxpdChcIlwiKS5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBwYXJzZUludChlLDEwKX0pKX0oZSksaT0wLHI9dC5sZW5ndGgsbj0wO248ci0xOysrbilpPTEwKihpK3Rbbl0pJTk3O3JldHVybiAoaSs9dFtyLTFdKSU5Nz09MX0sdmVyaG9lZmY6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PVtbMCwxLDIsMyw0LDUsNiw3LDgsOV0sWzEsMiwzLDQsMCw2LDcsOCw5LDVdLFsyLDMsNCwwLDEsNyw4LDksNSw2XSxbMyw0LDAsMSwyLDgsOSw1LDYsN10sWzQsMCwxLDIsMyw5LDUsNiw3LDhdLFs1LDksOCw3LDYsMCw0LDMsMiwxXSxbNiw1LDksOCw3LDEsMCw0LDMsMl0sWzcsNiw1LDksOCwyLDEsMCw0LDNdLFs4LDcsNiw1LDksMywyLDEsMCw0XSxbOSw4LDcsNiw1LDQsMywyLDEsMF1dLGk9W1swLDEsMiwzLDQsNSw2LDcsOCw5XSxbMSw1LDcsNiwyLDgsMywwLDksNF0sWzUsOCwwLDMsNyw5LDYsMSw0LDJdLFs4LDksMSw2LDAsNCwzLDUsMiw3XSxbOSw0LDUsMywxLDIsNiw4LDcsMF0sWzQsMiw4LDYsNSw3LDMsOSwwLDFdLFsyLDcsOSwzLDgsMCw2LDQsMSw1XSxbNywwLDQsNiw5LDEsMywyLDUsOF1dLHI9ZS5yZXZlcnNlKCksbj0wLHM9MDtzPHIubGVuZ3RoO3MrKyluPXRbbl1baVtzJThdW3Jbc11dXTtyZXR1cm4gMD09PW59fTt2YXIgdD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXt0aGlzLmZpZWxkcz17fSx0aGlzLmVsZW1lbnRzPXt9LHRoaXMuZWU9e2Zuczp7fSxjbGVhcjpmdW5jdGlvbigpe3RoaXMuZm5zPXt9O30sZW1pdDpmdW5jdGlvbihlKXtmb3IodmFyIHQ9W10saT0xO2k8YXJndW1lbnRzLmxlbmd0aDtpKyspdFtpLTFdPWFyZ3VtZW50c1tpXTsodGhpcy5mbnNbZV18fFtdKS5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBlLmFwcGx5KGUsdCl9KSk7fSxvZmY6ZnVuY3Rpb24oZSx0KXtpZih0aGlzLmZuc1tlXSl7dmFyIGk9dGhpcy5mbnNbZV0uaW5kZXhPZih0KTtpPj0wJiZ0aGlzLmZuc1tlXS5zcGxpY2UoaSwxKTt9fSxvbjpmdW5jdGlvbihlLHQpeyh0aGlzLmZuc1tlXT10aGlzLmZuc1tlXXx8W10pLnB1c2godCk7fX0sdGhpcy5maWx0ZXI9e2ZpbHRlcnM6e30sYWRkOmZ1bmN0aW9uKGUsdCl7KHRoaXMuZmlsdGVyc1tlXT10aGlzLmZpbHRlcnNbZV18fFtdKS5wdXNoKHQpO30sY2xlYXI6ZnVuY3Rpb24oKXt0aGlzLmZpbHRlcnM9e307fSxleGVjdXRlOmZ1bmN0aW9uKGUsdCxpKXtpZighdGhpcy5maWx0ZXJzW2VdfHwhdGhpcy5maWx0ZXJzW2VdLmxlbmd0aClyZXR1cm4gdDtmb3IodmFyIHI9dCxuPXRoaXMuZmlsdGVyc1tlXSxzPW4ubGVuZ3RoLGw9MDtsPHM7bCsrKXI9bltsXS5hcHBseShyLGkpO3JldHVybiByfSxyZW1vdmU6ZnVuY3Rpb24oZSx0KXt0aGlzLmZpbHRlcnNbZV0mJih0aGlzLmZpbHRlcnNbZV09dGhpcy5maWx0ZXJzW2VdLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIGUhPT10fSkpKTt9fSx0aGlzLnBsdWdpbnM9e30sdGhpcy5yZXN1bHRzPW5ldyBNYXAsdGhpcy52YWxpZGF0b3JzPXt9LHRoaXMuZm9ybT1lLHRoaXMuZmllbGRzPXQ7fXJldHVybiBlLnByb3RvdHlwZS5vbj1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLmVlLm9uKGUsdCksdGhpc30sZS5wcm90b3R5cGUub2ZmPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuZWUub2ZmKGUsdCksdGhpc30sZS5wcm90b3R5cGUuZW1pdD1mdW5jdGlvbihlKXtmb3IodmFyIHQsaT1bXSxyPTE7cjxhcmd1bWVudHMubGVuZ3RoO3IrKylpW3ItMV09YXJndW1lbnRzW3JdO3JldHVybiAodD10aGlzLmVlKS5lbWl0LmFwcGx5KHQsZnVuY3Rpb24oZSx0LGkpe2lmKGl8fDI9PT1hcmd1bWVudHMubGVuZ3RoKWZvcih2YXIgcixuPTAscz10Lmxlbmd0aDtuPHM7bisrKSFyJiZuIGluIHR8fChyfHwocj1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0LDAsbikpLHJbbl09dFtuXSk7cmV0dXJuIGUuY29uY2F0KHJ8fEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHQpKX0oW2VdLGksITEpKSx0aGlzfSxlLnByb3RvdHlwZS5yZWdpc3RlclBsdWdpbj1mdW5jdGlvbihlLHQpe2lmKHRoaXMucGx1Z2luc1tlXSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcGxndWluIFwiLmNvbmNhdChlLFwiIGlzIHJlZ2lzdGVyZWRcIikpO3JldHVybiB0LnNldENvcmUodGhpcyksdC5pbnN0YWxsKCksdGhpcy5wbHVnaW5zW2VdPXQsdGhpc30sZS5wcm90b3R5cGUuZGVyZWdpc3RlclBsdWdpbj1mdW5jdGlvbihlKXt2YXIgdD10aGlzLnBsdWdpbnNbZV07cmV0dXJuIHQmJnQudW5pbnN0YWxsKCksZGVsZXRlIHRoaXMucGx1Z2luc1tlXSx0aGlzfSxlLnByb3RvdHlwZS5lbmFibGVQbHVnaW49ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5wbHVnaW5zW2VdO3JldHVybiB0JiZ0LmVuYWJsZSgpLHRoaXN9LGUucHJvdG90eXBlLmRpc2FibGVQbHVnaW49ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5wbHVnaW5zW2VdO3JldHVybiB0JiZ0LmRpc2FibGUoKSx0aGlzfSxlLnByb3RvdHlwZS5pc1BsdWdpbkVuYWJsZWQ9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5wbHVnaW5zW2VdO3JldHVybiAhIXQmJnQuaXNQbHVnaW5FbmFibGVkKCl9LGUucHJvdG90eXBlLnJlZ2lzdGVyVmFsaWRhdG9yPWZ1bmN0aW9uKGUsdCl7aWYodGhpcy52YWxpZGF0b3JzW2VdKXRocm93IG5ldyBFcnJvcihcIlRoZSB2YWxpZGF0b3IgXCIuY29uY2F0KGUsXCIgaXMgcmVnaXN0ZXJlZFwiKSk7cmV0dXJuIHRoaXMudmFsaWRhdG9yc1tlXT10LHRoaXN9LGUucHJvdG90eXBlLnJlZ2lzdGVyRmlsdGVyPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuZmlsdGVyLmFkZChlLHQpLHRoaXN9LGUucHJvdG90eXBlLmRlcmVnaXN0ZXJGaWx0ZXI9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5maWx0ZXIucmVtb3ZlKGUsdCksdGhpc30sZS5wcm90b3R5cGUuZXhlY3V0ZUZpbHRlcj1mdW5jdGlvbihlLHQsaSl7cmV0dXJuIHRoaXMuZmlsdGVyLmV4ZWN1dGUoZSx0LGkpfSxlLnByb3RvdHlwZS5hZGRGaWVsZD1mdW5jdGlvbihlLHQpe3ZhciBpPU9iamVjdC5hc3NpZ24oe30se3NlbGVjdG9yOlwiXCIsdmFsaWRhdG9yczp7fX0sdCk7cmV0dXJuIHRoaXMuZmllbGRzW2VdPXRoaXMuZmllbGRzW2VdP3tzZWxlY3RvcjppLnNlbGVjdG9yfHx0aGlzLmZpZWxkc1tlXS5zZWxlY3Rvcix2YWxpZGF0b3JzOk9iamVjdC5hc3NpZ24oe30sdGhpcy5maWVsZHNbZV0udmFsaWRhdG9ycyxpLnZhbGlkYXRvcnMpfTppLHRoaXMuZWxlbWVudHNbZV09dGhpcy5xdWVyeUVsZW1lbnRzKGUpLHRoaXMuZW1pdChcImNvcmUuZmllbGQuYWRkZWRcIix7ZWxlbWVudHM6dGhpcy5lbGVtZW50c1tlXSxmaWVsZDplLG9wdGlvbnM6dGhpcy5maWVsZHNbZV19KSx0aGlzfSxlLnByb3RvdHlwZS5yZW1vdmVGaWVsZD1mdW5jdGlvbihlKXtpZighdGhpcy5maWVsZHNbZV0pdGhyb3cgbmV3IEVycm9yKFwiVGhlIGZpZWxkIFwiLmNvbmNhdChlLFwiIHZhbGlkYXRvcnMgYXJlIG5vdCBkZWZpbmVkLiBQbGVhc2UgZW5zdXJlIHRoZSBmaWVsZCBpcyBhZGRlZCBmaXJzdFwiKSk7dmFyIHQ9dGhpcy5lbGVtZW50c1tlXSxpPXRoaXMuZmllbGRzW2VdO3JldHVybiBkZWxldGUgdGhpcy5lbGVtZW50c1tlXSxkZWxldGUgdGhpcy5maWVsZHNbZV0sdGhpcy5lbWl0KFwiY29yZS5maWVsZC5yZW1vdmVkXCIse2VsZW1lbnRzOnQsZmllbGQ6ZSxvcHRpb25zOml9KSx0aGlzfSxlLnByb3RvdHlwZS52YWxpZGF0ZT1mdW5jdGlvbigpe3ZhciBlPXRoaXM7cmV0dXJuIHRoaXMuZW1pdChcImNvcmUuZm9ybS52YWxpZGF0aW5nXCIse2Zvcm1WYWxpZGF0aW9uOnRoaXN9KSx0aGlzLmZpbHRlci5leGVjdXRlKFwidmFsaWRhdGUtcHJlXCIsUHJvbWlzZS5yZXNvbHZlKCksW10pLnRoZW4oKGZ1bmN0aW9uKCl7cmV0dXJuIFByb21pc2UuYWxsKE9iamVjdC5rZXlzKGUuZmllbGRzKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBlLnZhbGlkYXRlRmllbGQodCl9KSkpLnRoZW4oKGZ1bmN0aW9uKHQpe3N3aXRjaCghMCl7Y2FzZS0xIT09dC5pbmRleE9mKFwiSW52YWxpZFwiKTpyZXR1cm4gZS5lbWl0KFwiY29yZS5mb3JtLmludmFsaWRcIix7Zm9ybVZhbGlkYXRpb246ZX0pLFByb21pc2UucmVzb2x2ZShcIkludmFsaWRcIik7Y2FzZS0xIT09dC5pbmRleE9mKFwiTm90VmFsaWRhdGVkXCIpOnJldHVybiBlLmVtaXQoXCJjb3JlLmZvcm0ubm90dmFsaWRhdGVkXCIse2Zvcm1WYWxpZGF0aW9uOmV9KSxQcm9taXNlLnJlc29sdmUoXCJOb3RWYWxpZGF0ZWRcIik7ZGVmYXVsdDpyZXR1cm4gZS5lbWl0KFwiY29yZS5mb3JtLnZhbGlkXCIse2Zvcm1WYWxpZGF0aW9uOmV9KSxQcm9taXNlLnJlc29sdmUoXCJWYWxpZFwiKX19KSl9KSl9LGUucHJvdG90eXBlLnZhbGlkYXRlRmllbGQ9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxpPXRoaXMucmVzdWx0cy5nZXQoZSk7aWYoXCJWYWxpZFwiPT09aXx8XCJJbnZhbGlkXCI9PT1pKXJldHVybiBQcm9taXNlLnJlc29sdmUoaSk7dGhpcy5lbWl0KFwiY29yZS5maWVsZC52YWxpZGF0aW5nXCIsZSk7dmFyIHI9dGhpcy5lbGVtZW50c1tlXTtpZigwPT09ci5sZW5ndGgpcmV0dXJuIHRoaXMuZW1pdChcImNvcmUuZmllbGQudmFsaWRcIixlKSxQcm9taXNlLnJlc29sdmUoXCJWYWxpZFwiKTt2YXIgbj1yWzBdLmdldEF0dHJpYnV0ZShcInR5cGVcIik7cmV0dXJuIFwicmFkaW9cIj09PW58fFwiY2hlY2tib3hcIj09PW58fDE9PT1yLmxlbmd0aD90aGlzLnZhbGlkYXRlRWxlbWVudChlLHJbMF0pOlByb21pc2UuYWxsKHIubWFwKChmdW5jdGlvbihpKXtyZXR1cm4gdC52YWxpZGF0ZUVsZW1lbnQoZSxpKX0pKSkudGhlbigoZnVuY3Rpb24oaSl7c3dpdGNoKCEwKXtjYXNlLTEhPT1pLmluZGV4T2YoXCJJbnZhbGlkXCIpOnJldHVybiB0LmVtaXQoXCJjb3JlLmZpZWxkLmludmFsaWRcIixlKSx0LnJlc3VsdHMuc2V0KGUsXCJJbnZhbGlkXCIpLFByb21pc2UucmVzb2x2ZShcIkludmFsaWRcIik7Y2FzZS0xIT09aS5pbmRleE9mKFwiTm90VmFsaWRhdGVkXCIpOnJldHVybiB0LmVtaXQoXCJjb3JlLmZpZWxkLm5vdHZhbGlkYXRlZFwiLGUpLHQucmVzdWx0cy5kZWxldGUoZSksUHJvbWlzZS5yZXNvbHZlKFwiTm90VmFsaWRhdGVkXCIpO2RlZmF1bHQ6cmV0dXJuIHQuZW1pdChcImNvcmUuZmllbGQudmFsaWRcIixlKSx0LnJlc3VsdHMuc2V0KGUsXCJWYWxpZFwiKSxQcm9taXNlLnJlc29sdmUoXCJWYWxpZFwiKX19KSl9LGUucHJvdG90eXBlLnZhbGlkYXRlRWxlbWVudD1mdW5jdGlvbihlLHQpe3ZhciBpPXRoaXM7dGhpcy5yZXN1bHRzLmRlbGV0ZShlKTt2YXIgcj10aGlzLmVsZW1lbnRzW2VdO2lmKHRoaXMuZmlsdGVyLmV4ZWN1dGUoXCJlbGVtZW50LWlnbm9yZWRcIiwhMSxbZSx0LHJdKSlyZXR1cm4gdGhpcy5lbWl0KFwiY29yZS5lbGVtZW50Lmlnbm9yZWRcIix7ZWxlbWVudDp0LGVsZW1lbnRzOnIsZmllbGQ6ZX0pLFByb21pc2UucmVzb2x2ZShcIklnbm9yZWRcIik7dmFyIG49dGhpcy5maWVsZHNbZV0udmFsaWRhdG9yczt0aGlzLmVtaXQoXCJjb3JlLmVsZW1lbnQudmFsaWRhdGluZ1wiLHtlbGVtZW50OnQsZWxlbWVudHM6cixmaWVsZDplfSk7dmFyIHM9T2JqZWN0LmtleXMobikubWFwKChmdW5jdGlvbihyKXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gaS5leGVjdXRlVmFsaWRhdG9yKGUsdCxyLG5bcl0pfX0pKTtyZXR1cm4gdGhpcy53YXRlcmZhbGwocykudGhlbigoZnVuY3Rpb24obil7dmFyIHM9LTE9PT1uLmluZGV4T2YoXCJJbnZhbGlkXCIpO2kuZW1pdChcImNvcmUuZWxlbWVudC52YWxpZGF0ZWRcIix7ZWxlbWVudDp0LGVsZW1lbnRzOnIsZmllbGQ6ZSx2YWxpZDpzfSk7dmFyIGw9dC5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpO3JldHVybiBcInJhZGlvXCIhPT1sJiZcImNoZWNrYm94XCIhPT1sJiYxIT09ci5sZW5ndGh8fGkuZW1pdChzP1wiY29yZS5maWVsZC52YWxpZFwiOlwiY29yZS5maWVsZC5pbnZhbGlkXCIsZSksUHJvbWlzZS5yZXNvbHZlKHM/XCJWYWxpZFwiOlwiSW52YWxpZFwiKX0pKS5jYXRjaCgoZnVuY3Rpb24obil7cmV0dXJuIGkuZW1pdChcImNvcmUuZWxlbWVudC5ub3R2YWxpZGF0ZWRcIix7ZWxlbWVudDp0LGVsZW1lbnRzOnIsZmllbGQ6ZX0pLFByb21pc2UucmVzb2x2ZShuKX0pKX0sZS5wcm90b3R5cGUuZXhlY3V0ZVZhbGlkYXRvcj1mdW5jdGlvbihlLHQsaSxyKXt2YXIgbj10aGlzLHM9dGhpcy5lbGVtZW50c1tlXSxsPXRoaXMuZmlsdGVyLmV4ZWN1dGUoXCJ2YWxpZGF0b3ItbmFtZVwiLGksW2ksZV0pO2lmKHIubWVzc2FnZT10aGlzLmZpbHRlci5leGVjdXRlKFwidmFsaWRhdG9yLW1lc3NhZ2VcIixyLm1lc3NhZ2UsW3RoaXMubG9jYWxlLGUsbF0pLCF0aGlzLnZhbGlkYXRvcnNbbF18fCExPT09ci5lbmFibGVkKXJldHVybiB0aGlzLmVtaXQoXCJjb3JlLnZhbGlkYXRvci52YWxpZGF0ZWRcIix7ZWxlbWVudDp0LGVsZW1lbnRzOnMsZmllbGQ6ZSxyZXN1bHQ6dGhpcy5ub3JtYWxpemVSZXN1bHQoZSxsLHt2YWxpZDohMH0pLHZhbGlkYXRvcjpsfSksUHJvbWlzZS5yZXNvbHZlKFwiVmFsaWRcIik7dmFyIG89dGhpcy52YWxpZGF0b3JzW2xdLGE9dGhpcy5nZXRFbGVtZW50VmFsdWUoZSx0LGwpO2lmKCF0aGlzLmZpbHRlci5leGVjdXRlKFwiZmllbGQtc2hvdWxkLXZhbGlkYXRlXCIsITAsW2UsdCxhLGldKSlyZXR1cm4gdGhpcy5lbWl0KFwiY29yZS52YWxpZGF0b3Iubm90dmFsaWRhdGVkXCIse2VsZW1lbnQ6dCxlbGVtZW50czpzLGZpZWxkOmUsdmFsaWRhdG9yOml9KSxQcm9taXNlLnJlc29sdmUoXCJOb3RWYWxpZGF0ZWRcIik7dGhpcy5lbWl0KFwiY29yZS52YWxpZGF0b3IudmFsaWRhdGluZ1wiLHtlbGVtZW50OnQsZWxlbWVudHM6cyxmaWVsZDplLHZhbGlkYXRvcjppfSk7dmFyIGQ9bygpLnZhbGlkYXRlKHtlbGVtZW50OnQsZWxlbWVudHM6cyxmaWVsZDplLGwxMG46dGhpcy5sb2NhbGl6YXRpb24sb3B0aW9uczpyLHZhbHVlOmF9KTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBkLnRoZW4pcmV0dXJuIGQudGhlbigoZnVuY3Rpb24ocil7dmFyIGw9bi5ub3JtYWxpemVSZXN1bHQoZSxpLHIpO3JldHVybiBuLmVtaXQoXCJjb3JlLnZhbGlkYXRvci52YWxpZGF0ZWRcIix7ZWxlbWVudDp0LGVsZW1lbnRzOnMsZmllbGQ6ZSxyZXN1bHQ6bCx2YWxpZGF0b3I6aX0pLGwudmFsaWQ/XCJWYWxpZFwiOlwiSW52YWxpZFwifSkpO3ZhciBjPXRoaXMubm9ybWFsaXplUmVzdWx0KGUsaSxkKTtyZXR1cm4gdGhpcy5lbWl0KFwiY29yZS52YWxpZGF0b3IudmFsaWRhdGVkXCIse2VsZW1lbnQ6dCxlbGVtZW50czpzLGZpZWxkOmUscmVzdWx0OmMsdmFsaWRhdG9yOml9KSxQcm9taXNlLnJlc29sdmUoYy52YWxpZD9cIlZhbGlkXCI6XCJJbnZhbGlkXCIpfSxlLnByb3RvdHlwZS5nZXRFbGVtZW50VmFsdWU9ZnVuY3Rpb24oZSx0LGkpe3ZhciByPWZ1bmN0aW9uKGUsdCxpLHIpe3ZhciBuPShpLmdldEF0dHJpYnV0ZShcInR5cGVcIil8fFwiXCIpLnRvTG93ZXJDYXNlKCkscz1pLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtpZihcInRleHRhcmVhXCI9PT1zKXJldHVybiBpLnZhbHVlO2lmKFwic2VsZWN0XCI9PT1zKXt2YXIgbD1pLG89bC5zZWxlY3RlZEluZGV4O3JldHVybiBvPj0wP2wub3B0aW9ucy5pdGVtKG8pLnZhbHVlOlwiXCJ9aWYoXCJpbnB1dFwiPT09cyl7aWYoXCJyYWRpb1wiPT09bnx8XCJjaGVja2JveFwiPT09bil7dmFyIGE9ci5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiBlLmNoZWNrZWR9KSkubGVuZ3RoO3JldHVybiAwPT09YT9cIlwiOmErXCJcIn1yZXR1cm4gaS52YWx1ZX1yZXR1cm4gXCJcIn0odGhpcy5mb3JtLDAsdCx0aGlzLmVsZW1lbnRzW2VdKTtyZXR1cm4gdGhpcy5maWx0ZXIuZXhlY3V0ZShcImZpZWxkLXZhbHVlXCIscixbcixlLHQsaV0pfSxlLnByb3RvdHlwZS5nZXRFbGVtZW50cz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5lbGVtZW50c1tlXX0sZS5wcm90b3R5cGUuZ2V0RmllbGRzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZmllbGRzfSxlLnByb3RvdHlwZS5nZXRGb3JtRWxlbWVudD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmZvcm19LGUucHJvdG90eXBlLmdldExvY2FsZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmxvY2FsZX0sZS5wcm90b3R5cGUuZ2V0UGx1Z2luPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnBsdWdpbnNbZV19LGUucHJvdG90eXBlLnVwZGF0ZUZpZWxkU3RhdHVzPWZ1bmN0aW9uKGUsdCxpKXt2YXIgcj10aGlzLG49dGhpcy5lbGVtZW50c1tlXSxzPW5bMF0uZ2V0QXR0cmlidXRlKFwidHlwZVwiKTtpZigoXCJyYWRpb1wiPT09c3x8XCJjaGVja2JveFwiPT09cz9bblswXV06bikuZm9yRWFjaCgoZnVuY3Rpb24obil7cmV0dXJuIHIudXBkYXRlRWxlbWVudFN0YXR1cyhlLG4sdCxpKX0pKSxpKVwiSW52YWxpZFwiPT09dCYmKHRoaXMuZW1pdChcImNvcmUuZmllbGQuaW52YWxpZFwiLGUpLHRoaXMucmVzdWx0cy5zZXQoZSxcIkludmFsaWRcIikpO2Vsc2Ugc3dpdGNoKHQpe2Nhc2VcIk5vdFZhbGlkYXRlZFwiOnRoaXMuZW1pdChcImNvcmUuZmllbGQubm90dmFsaWRhdGVkXCIsZSksdGhpcy5yZXN1bHRzLmRlbGV0ZShlKTticmVhaztjYXNlXCJWYWxpZGF0aW5nXCI6dGhpcy5lbWl0KFwiY29yZS5maWVsZC52YWxpZGF0aW5nXCIsZSksdGhpcy5yZXN1bHRzLmRlbGV0ZShlKTticmVhaztjYXNlXCJWYWxpZFwiOnRoaXMuZW1pdChcImNvcmUuZmllbGQudmFsaWRcIixlKSx0aGlzLnJlc3VsdHMuc2V0KGUsXCJWYWxpZFwiKTticmVhaztjYXNlXCJJbnZhbGlkXCI6dGhpcy5lbWl0KFwiY29yZS5maWVsZC5pbnZhbGlkXCIsZSksdGhpcy5yZXN1bHRzLnNldChlLFwiSW52YWxpZFwiKTt9cmV0dXJuIHRoaXN9LGUucHJvdG90eXBlLnVwZGF0ZUVsZW1lbnRTdGF0dXM9ZnVuY3Rpb24oZSx0LGkscil7dmFyIG49dGhpcyxzPXRoaXMuZWxlbWVudHNbZV0sbD10aGlzLmZpZWxkc1tlXS52YWxpZGF0b3JzLG89cj9bcl06T2JqZWN0LmtleXMobCk7c3dpdGNoKGkpe2Nhc2VcIk5vdFZhbGlkYXRlZFwiOm8uZm9yRWFjaCgoZnVuY3Rpb24oaSl7cmV0dXJuIG4uZW1pdChcImNvcmUudmFsaWRhdG9yLm5vdHZhbGlkYXRlZFwiLHtlbGVtZW50OnQsZWxlbWVudHM6cyxmaWVsZDplLHZhbGlkYXRvcjppfSl9KSksdGhpcy5lbWl0KFwiY29yZS5lbGVtZW50Lm5vdHZhbGlkYXRlZFwiLHtlbGVtZW50OnQsZWxlbWVudHM6cyxmaWVsZDplfSk7YnJlYWs7Y2FzZVwiVmFsaWRhdGluZ1wiOm8uZm9yRWFjaCgoZnVuY3Rpb24oaSl7cmV0dXJuIG4uZW1pdChcImNvcmUudmFsaWRhdG9yLnZhbGlkYXRpbmdcIix7ZWxlbWVudDp0LGVsZW1lbnRzOnMsZmllbGQ6ZSx2YWxpZGF0b3I6aX0pfSkpLHRoaXMuZW1pdChcImNvcmUuZWxlbWVudC52YWxpZGF0aW5nXCIse2VsZW1lbnQ6dCxlbGVtZW50czpzLGZpZWxkOmV9KTticmVhaztjYXNlXCJWYWxpZFwiOm8uZm9yRWFjaCgoZnVuY3Rpb24oaSl7cmV0dXJuIG4uZW1pdChcImNvcmUudmFsaWRhdG9yLnZhbGlkYXRlZFwiLHtlbGVtZW50OnQsZWxlbWVudHM6cyxmaWVsZDplLHJlc3VsdDp7bWVzc2FnZTpsW2ldLm1lc3NhZ2UsdmFsaWQ6ITB9LHZhbGlkYXRvcjppfSl9KSksdGhpcy5lbWl0KFwiY29yZS5lbGVtZW50LnZhbGlkYXRlZFwiLHtlbGVtZW50OnQsZWxlbWVudHM6cyxmaWVsZDplLHZhbGlkOiEwfSk7YnJlYWs7Y2FzZVwiSW52YWxpZFwiOm8uZm9yRWFjaCgoZnVuY3Rpb24oaSl7cmV0dXJuIG4uZW1pdChcImNvcmUudmFsaWRhdG9yLnZhbGlkYXRlZFwiLHtlbGVtZW50OnQsZWxlbWVudHM6cyxmaWVsZDplLHJlc3VsdDp7bWVzc2FnZTpsW2ldLm1lc3NhZ2UsdmFsaWQ6ITF9LHZhbGlkYXRvcjppfSl9KSksdGhpcy5lbWl0KFwiY29yZS5lbGVtZW50LnZhbGlkYXRlZFwiLHtlbGVtZW50OnQsZWxlbWVudHM6cyxmaWVsZDplLHZhbGlkOiExfSk7fXJldHVybiB0aGlzfSxlLnByb3RvdHlwZS5yZXNldEZvcm09ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztyZXR1cm4gT2JqZWN0LmtleXModGhpcy5maWVsZHMpLmZvckVhY2goKGZ1bmN0aW9uKGkpe3JldHVybiB0LnJlc2V0RmllbGQoaSxlKX0pKSx0aGlzLmVtaXQoXCJjb3JlLmZvcm0ucmVzZXRcIix7Zm9ybVZhbGlkYXRpb246dGhpcyxyZXNldDplfSksdGhpc30sZS5wcm90b3R5cGUucmVzZXRGaWVsZD1mdW5jdGlvbihlLHQpe2lmKHQpe3ZhciBpPXRoaXMuZWxlbWVudHNbZV0scj1pWzBdLmdldEF0dHJpYnV0ZShcInR5cGVcIik7aS5mb3JFYWNoKChmdW5jdGlvbihlKXtcInJhZGlvXCI9PT1yfHxcImNoZWNrYm94XCI9PT1yPyhlLnJlbW92ZUF0dHJpYnV0ZShcInNlbGVjdGVkXCIpLGUucmVtb3ZlQXR0cmlidXRlKFwiY2hlY2tlZFwiKSxlLmNoZWNrZWQ9ITEpOihlLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsXCJcIiksKGUgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50fHxlIGluc3RhbmNlb2YgSFRNTFRleHRBcmVhRWxlbWVudCkmJihlLnZhbHVlPVwiXCIpKTt9KSk7fXJldHVybiB0aGlzLnVwZGF0ZUZpZWxkU3RhdHVzKGUsXCJOb3RWYWxpZGF0ZWRcIiksdGhpcy5lbWl0KFwiY29yZS5maWVsZC5yZXNldFwiLHtmaWVsZDplLHJlc2V0OnR9KSx0aGlzfSxlLnByb3RvdHlwZS5yZXZhbGlkYXRlRmllbGQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZmllbGRzW2VdPyh0aGlzLnVwZGF0ZUZpZWxkU3RhdHVzKGUsXCJOb3RWYWxpZGF0ZWRcIiksdGhpcy52YWxpZGF0ZUZpZWxkKGUpKTpQcm9taXNlLnJlc29sdmUoXCJJZ25vcmVkXCIpfSxlLnByb3RvdHlwZS5kaXNhYmxlVmFsaWRhdG9yPWZ1bmN0aW9uKGUsdCl7aWYoIXRoaXMuZmllbGRzW2VdKXJldHVybiB0aGlzO3ZhciBpPXRoaXMuZWxlbWVudHNbZV07cmV0dXJuIHRoaXMudG9nZ2xlVmFsaWRhdG9yKCExLGUsdCksdGhpcy5lbWl0KFwiY29yZS52YWxpZGF0b3IuZGlzYWJsZWRcIix7ZWxlbWVudHM6aSxmaWVsZDplLGZvcm1WYWxpZGF0aW9uOnRoaXMsdmFsaWRhdG9yOnR9KSx0aGlzfSxlLnByb3RvdHlwZS5lbmFibGVWYWxpZGF0b3I9ZnVuY3Rpb24oZSx0KXtpZighdGhpcy5maWVsZHNbZV0pcmV0dXJuIHRoaXM7dmFyIGk9dGhpcy5lbGVtZW50c1tlXTtyZXR1cm4gdGhpcy50b2dnbGVWYWxpZGF0b3IoITAsZSx0KSx0aGlzLmVtaXQoXCJjb3JlLnZhbGlkYXRvci5lbmFibGVkXCIse2VsZW1lbnRzOmksZmllbGQ6ZSxmb3JtVmFsaWRhdGlvbjp0aGlzLHZhbGlkYXRvcjp0fSksdGhpc30sZS5wcm90b3R5cGUudXBkYXRlVmFsaWRhdG9yT3B0aW9uPWZ1bmN0aW9uKGUsdCxpLHIpe3JldHVybiB0aGlzLmZpZWxkc1tlXSYmdGhpcy5maWVsZHNbZV0udmFsaWRhdG9ycyYmdGhpcy5maWVsZHNbZV0udmFsaWRhdG9yc1t0XSYmKHRoaXMuZmllbGRzW2VdLnZhbGlkYXRvcnNbdF1baV09ciksdGhpc30sZS5wcm90b3R5cGUuc2V0RmllbGRPcHRpb25zPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuZmllbGRzW2VdPXQsdGhpc30sZS5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3ZhciBlPXRoaXM7cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMucGx1Z2lucykuZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIGUucGx1Z2luc1t0XS51bmluc3RhbGwoKX0pKSx0aGlzLmVlLmNsZWFyKCksdGhpcy5maWx0ZXIuY2xlYXIoKSx0aGlzLnJlc3VsdHMuY2xlYXIoKSx0aGlzLnBsdWdpbnM9e30sdGhpc30sZS5wcm90b3R5cGUuc2V0TG9jYWxlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMubG9jYWxlPWUsdGhpcy5sb2NhbGl6YXRpb249dCx0aGlzfSxlLnByb3RvdHlwZS53YXRlcmZhbGw9ZnVuY3Rpb24oZSl7cmV0dXJuIGUucmVkdWNlKChmdW5jdGlvbihlLHQpe3JldHVybiBlLnRoZW4oKGZ1bmN0aW9uKGUpe3JldHVybiB0KCkudGhlbigoZnVuY3Rpb24odCl7cmV0dXJuIGUucHVzaCh0KSxlfSkpfSkpfSksUHJvbWlzZS5yZXNvbHZlKFtdKSl9LGUucHJvdG90eXBlLnF1ZXJ5RWxlbWVudHM9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5maWVsZHNbZV0uc2VsZWN0b3I/XCIjXCI9PT10aGlzLmZpZWxkc1tlXS5zZWxlY3Rvci5jaGFyQXQoMCk/J1tpZD1cIicuY29uY2F0KHRoaXMuZmllbGRzW2VdLnNlbGVjdG9yLnN1YnN0cmluZygxKSwnXCJdJyk6dGhpcy5maWVsZHNbZV0uc2VsZWN0b3I6J1tuYW1lPVwiJy5jb25jYXQoZS5yZXBsYWNlKC9cIi9nLCdcXFxcXCInKSwnXCJdJyk7cmV0dXJuIFtdLnNsaWNlLmNhbGwodGhpcy5mb3JtLnF1ZXJ5U2VsZWN0b3JBbGwodCkpfSxlLnByb3RvdHlwZS5ub3JtYWxpemVSZXN1bHQ9ZnVuY3Rpb24oZSx0LGkpe3ZhciByPXRoaXMuZmllbGRzW2VdLnZhbGlkYXRvcnNbdF07cmV0dXJuIE9iamVjdC5hc3NpZ24oe30saSx7bWVzc2FnZTppLm1lc3NhZ2V8fChyP3IubWVzc2FnZTpcIlwiKXx8KHRoaXMubG9jYWxpemF0aW9uJiZ0aGlzLmxvY2FsaXphdGlvblt0XSYmdGhpcy5sb2NhbGl6YXRpb25bdF0uZGVmYXVsdD90aGlzLmxvY2FsaXphdGlvblt0XS5kZWZhdWx0OlwiXCIpfHxcIlRoZSBmaWVsZCBcIi5jb25jYXQoZSxcIiBpcyBub3QgdmFsaWRcIil9KX0sZS5wcm90b3R5cGUudG9nZ2xlVmFsaWRhdG9yPWZ1bmN0aW9uKGUsdCxpKXt2YXIgcj10aGlzLG49dGhpcy5maWVsZHNbdF0udmFsaWRhdG9ycztyZXR1cm4gaSYmbiYmbltpXT90aGlzLmZpZWxkc1t0XS52YWxpZGF0b3JzW2ldLmVuYWJsZWQ9ZTppfHxPYmplY3Qua2V5cyhuKS5mb3JFYWNoKChmdW5jdGlvbihpKXtyZXR1cm4gci5maWVsZHNbdF0udmFsaWRhdG9yc1tpXS5lbmFibGVkPWV9KSksdGhpcy51cGRhdGVGaWVsZFN0YXR1cyh0LFwiTm90VmFsaWRhdGVkXCIsaSl9LGV9KCk7dmFyIGk9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe3RoaXMub3B0cz1lLHRoaXMuaXNFbmFibGVkPSEwO31yZXR1cm4gZS5wcm90b3R5cGUuc2V0Q29yZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5jb3JlPWUsdGhpc30sZS5wcm90b3R5cGUuZW5hYmxlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNFbmFibGVkPSEwLHRoaXMub25FbmFibGVkKCksdGhpc30sZS5wcm90b3R5cGUuZGlzYWJsZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmlzRW5hYmxlZD0hMSx0aGlzLm9uRGlzYWJsZWQoKSx0aGlzfSxlLnByb3RvdHlwZS5pc1BsdWdpbkVuYWJsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0VuYWJsZWR9LGUucHJvdG90eXBlLm9uRW5hYmxlZD1mdW5jdGlvbigpe30sZS5wcm90b3R5cGUub25EaXNhYmxlZD1mdW5jdGlvbigpe30sZS5wcm90b3R5cGUuaW5zdGFsbD1mdW5jdGlvbigpe30sZS5wcm90b3R5cGUudW5pbnN0YWxsPWZ1bmN0aW9uKCl7fSxlfSgpO3ZhciByPWZ1bmN0aW9uKGUsdCl7dmFyIGk9ZS5tYXRjaGVzfHxlLndlYmtpdE1hdGNoZXNTZWxlY3Rvcnx8ZS5tb3pNYXRjaGVzU2VsZWN0b3J8fGUubXNNYXRjaGVzU2VsZWN0b3I7cmV0dXJuIGk/aS5jYWxsKGUsdCk6W10uc2xpY2UuY2FsbChlLnBhcmVudEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCh0KSkuaW5kZXhPZihlKT49MH0sbj17Y2FsbDpmdW5jdGlvbihlLHQpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGUpcmV0dXJuIGUuYXBwbHkodGhpcyx0KTtpZihcInN0cmluZ1wiPT10eXBlb2YgZSl7dmFyIGk9ZTtcIigpXCI9PT1pLnN1YnN0cmluZyhpLmxlbmd0aC0yKSYmKGk9aS5zdWJzdHJpbmcoMCxpLmxlbmd0aC0yKSk7Zm9yKHZhciByPWkuc3BsaXQoXCIuXCIpLG49ci5wb3AoKSxzPXdpbmRvdyxsPTAsbz1yO2w8by5sZW5ndGg7bCsrKXtzPXNbb1tsXV07fXJldHVybiB2b2lkIDA9PT1zW25dP251bGw6c1tuXS5hcHBseSh0aGlzLHQpfX0sY2xhc3NTZXQ6ZnVuY3Rpb24oZSx0KXt2YXIgaT1bXSxyPVtdO09iamVjdC5rZXlzKHQpLmZvckVhY2goKGZ1bmN0aW9uKGUpe2UmJih0W2VdP2kucHVzaChlKTpyLnB1c2goZSkpO30pKSxyLmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlLHQpe3Quc3BsaXQoXCIgXCIpLmZvckVhY2goKGZ1bmN0aW9uKHQpe2UuY2xhc3NMaXN0P2UuY2xhc3NMaXN0LnJlbW92ZSh0KTplLmNsYXNzTmFtZT1lLmNsYXNzTmFtZS5yZXBsYWNlKHQsXCJcIik7fSkpO30oZSx0KX0pKSxpLmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlLHQpe3Quc3BsaXQoXCIgXCIpLmZvckVhY2goKGZ1bmN0aW9uKHQpe2UuY2xhc3NMaXN0P2UuY2xhc3NMaXN0LmFkZCh0KTpcIiBcIi5jb25jYXQoZS5jbGFzc05hbWUsXCIgXCIpLmluZGV4T2YoXCIgXCIuY29uY2F0KHQsXCIgXCIpKSYmKGUuY2xhc3NOYW1lKz1cIiBcIi5jb25jYXQodCkpO30pKTt9KGUsdCl9KSk7fSxjbG9zZXN0OmZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBpPWU7aSYmIXIoaSx0KTspaT1pLnBhcmVudEVsZW1lbnQ7cmV0dXJuIGl9LGZldGNoOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbihpLHIpe3ZhciBuLHM9T2JqZWN0LmFzc2lnbih7fSx7Y3Jvc3NEb21haW46ITEsaGVhZGVyczp7fSxtZXRob2Q6XCJHRVRcIixwYXJhbXM6e319LHQpLGw9T2JqZWN0LmtleXMocy5wYXJhbXMpLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIFwiXCIuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudChlKSxcIj1cIikuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudChzLnBhcmFtc1tlXSkpfSkpLmpvaW4oXCImXCIpLG89ZS5pbmRleE9mKFwiP1wiKT4tMSxhPVwiR0VUXCI9PT1zLm1ldGhvZD9cIlwiLmNvbmNhdChlKS5jb25jYXQobz9cIiZcIjpcIj9cIikuY29uY2F0KGwpOmU7aWYocy5jcm9zc0RvbWFpbil7dmFyIGQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSxjPVwiX19fRm9ybVZhbGlkYXRpb25GZXRjaF9cIi5jb25jYXQoQXJyYXkoMTIpLmZpbGwoXCJcIikubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuY2hhckF0KDIpfSkpLmpvaW4oXCJcIiksXCJfX19cIik7d2luZG93W2NdPWZ1bmN0aW9uKGUpe2RlbGV0ZSB3aW5kb3dbY10saShlKTt9LGQuc3JjPVwiXCIuY29uY2F0KGEpLmNvbmNhdChvP1wiJlwiOlwiP1wiLFwiY2FsbGJhY2s9XCIpLmNvbmNhdChjKSxkLmFzeW5jPSEwLGQuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwoZnVuY3Rpb24oKXtkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZCk7fSkpLGQuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KSksZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChkKTt9ZWxzZSB7dmFyIHU9bmV3IFhNTEh0dHBSZXF1ZXN0O3Uub3BlbihzLm1ldGhvZCxhKSx1LnNldFJlcXVlc3RIZWFkZXIoXCJYLVJlcXVlc3RlZC1XaXRoXCIsXCJYTUxIdHRwUmVxdWVzdFwiKSxcIlBPU1RcIj09PXMubWV0aG9kJiZ1LnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIixcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKSxPYmplY3Qua2V5cyhzLmhlYWRlcnMpLmZvckVhY2goKGZ1bmN0aW9uKGUpe3JldHVybiB1LnNldFJlcXVlc3RIZWFkZXIoZSxzLmhlYWRlcnNbZV0pfSkpLHUuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwoZnVuY3Rpb24oKXtpKEpTT04ucGFyc2UodGhpcy5yZXNwb25zZVRleHQpKTt9KSksdS5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwoZnVuY3Rpb24oKXtyZXR1cm4gcn0pKSx1LnNlbmQoKG49cy5wYXJhbXMsT2JqZWN0LmtleXMobikubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gXCJcIi5jb25jYXQoZW5jb2RlVVJJQ29tcG9uZW50KGUpLFwiPVwiKS5jb25jYXQoZW5jb2RlVVJJQ29tcG9uZW50KG5bZV0pKX0pKS5qb2luKFwiJlwiKSkpO319KSl9LGZvcm1hdDpmdW5jdGlvbihlLHQpe3ZhciBpPUFycmF5LmlzQXJyYXkodCk/dDpbdF0scj1lO3JldHVybiBpLmZvckVhY2goKGZ1bmN0aW9uKGUpe3I9ci5yZXBsYWNlKFwiJXNcIixlKTt9KSkscn0saGFzQ2xhc3M6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5jbGFzc0xpc3Q/ZS5jbGFzc0xpc3QuY29udGFpbnModCk6bmV3IFJlZ0V4cChcIihefCApXCIuY29uY2F0KHQsXCIoIHwkKVwiKSxcImdpXCIpLnRlc3QoZS5jbGFzc05hbWUpfSxpc1ZhbGlkRGF0ZTpmdW5jdGlvbihlLHQsaSxyKXtpZihpc05hTihlKXx8aXNOYU4odCl8fGlzTmFOKGkpKXJldHVybiAhMTtpZihlPDFlM3x8ZT45OTk5fHx0PD0wfHx0PjEyKXJldHVybiAhMTtpZihpPD0wfHxpPlszMSxlJTQwMD09MHx8ZSUxMDAhPTAmJmUlND09MD8yOToyOCwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV1bdC0xXSlyZXR1cm4gITE7aWYoITA9PT1yKXt2YXIgbj1uZXcgRGF0ZSxzPW4uZ2V0RnVsbFllYXIoKSxsPW4uZ2V0TW9udGgoKSxvPW4uZ2V0RGF0ZSgpO3JldHVybiBlPHN8fGU9PT1zJiZ0LTE8bHx8ZT09PXMmJnQtMT09PWwmJmk8b31yZXR1cm4gITB9LHJlbW92ZVVuZGVmaW5lZDpmdW5jdGlvbihlKXtyZXR1cm4gZT9PYmplY3QuZW50cmllcyhlKS5yZWR1Y2UoKGZ1bmN0aW9uKGUsdCl7dmFyIGk9dFswXSxyPXRbMV07cmV0dXJuIHZvaWQgMD09PXJ8fChlW2ldPXIpLGV9KSx7fSk6e319fTtpbmRleF9taW4kQi5QbHVnaW49aSxpbmRleF9taW4kQi5hbGdvcml0aG1zPWUsaW5kZXhfbWluJEIuZm9ybVZhbGlkYXRpb249ZnVuY3Rpb24oZSxpKXt2YXIgcj1PYmplY3QuYXNzaWduKHt9LHtmaWVsZHM6e30sbG9jYWxlOlwiZW5fVVNcIixwbHVnaW5zOnt9LGluaXQ6ZnVuY3Rpb24oZSl7fX0saSksbj1uZXcgdChlLHIuZmllbGRzKTtyZXR1cm4gbi5zZXRMb2NhbGUoci5sb2NhbGUsci5sb2NhbGl6YXRpb24pLE9iamVjdC5rZXlzKHIucGx1Z2lucykuZm9yRWFjaCgoZnVuY3Rpb24oZSl7cmV0dXJuIG4ucmVnaXN0ZXJQbHVnaW4oZSxyLnBsdWdpbnNbZV0pfSkpLHIuaW5pdChuKSxPYmplY3Qua2V5cyhyLmZpZWxkcykuZm9yRWFjaCgoZnVuY3Rpb24oZSl7cmV0dXJuIG4uYWRkRmllbGQoZSxyLmZpZWxkc1tlXSl9KSksbn0saW5kZXhfbWluJEIudXRpbHM9bjtcblx0cmV0dXJuIGluZGV4X21pbiRCO1xufVxuXG52YXIgY2pzJEIgPSB7fTtcblxudmFyIGhhc1JlcXVpcmVkQ2pzJEI7XG5cbmZ1bmN0aW9uIHJlcXVpcmVDanMkQiAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZENqcyRCKSByZXR1cm4gY2pzJEI7XG5cdGhhc1JlcXVpcmVkQ2pzJEIgPSAxO1xuXG5cdC8qKlxuXHQgKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcblx0ICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG5cdCAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cblx0ICovXG5cdC8qKlxuXHQgKiBJbXBsZW1lbnQgTHVobiB2YWxpZGF0aW9uIGFsZ29yaXRobVxuXHQgKiBDcmVkaXQgdG8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vU2hpcnRsZXNzS2lyay8yMTM0Mzc2XG5cdCAqXG5cdCAqIEBzZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MdWhuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGZ1bmN0aW9uIGx1aG4odmFsdWUpIHtcblx0ICAgIHZhciBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG5cdCAgICB2YXIgcHJvZEFyciA9IFtcblx0ICAgICAgICBbMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOV0sXG5cdCAgICAgICAgWzAsIDIsIDQsIDYsIDgsIDEsIDMsIDUsIDcsIDldLFxuXHQgICAgXTtcblx0ICAgIHZhciBtdWwgPSAwO1xuXHQgICAgdmFyIHN1bSA9IDA7XG5cdCAgICB3aGlsZSAobGVuZ3RoLS0pIHtcblx0ICAgICAgICBzdW0gKz0gcHJvZEFyclttdWxdW3BhcnNlSW50KHZhbHVlLmNoYXJBdChsZW5ndGgpLCAxMCldO1xuXHQgICAgICAgIG11bCA9IDEgLSBtdWw7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gc3VtICUgMTAgPT09IDAgJiYgc3VtID4gMDtcblx0fVxuXG5cdC8qKlxuXHQgKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcblx0ICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG5cdCAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cblx0ICovXG5cdC8qKlxuXHQgKiBJbXBsZW1lbnQgbW9kdWx1cyAxMSwgMTAgKElTTyA3MDY0KSBhbGdvcml0aG1cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0ZnVuY3Rpb24gbW9kMTFBbmQxMCh2YWx1ZSkge1xuXHQgICAgdmFyIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcblx0ICAgIHZhciBjaGVjayA9IDU7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgY2hlY2sgPSAoKCgoY2hlY2sgfHwgMTApICogMikgJSAxMSkgKyBwYXJzZUludCh2YWx1ZS5jaGFyQXQoaSksIDEwKSkgJSAxMDtcblx0ICAgIH1cblx0ICAgIHJldHVybiBjaGVjayA9PT0gMTtcblx0fVxuXG5cdC8qKlxuXHQgKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcblx0ICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG5cdCAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cblx0ICovXG5cdC8qKlxuXHQgKiBJbXBsZW1lbnRzIE1vZCAzNywgMzYgKElTTyA3MDY0KSBhbGdvcml0aG1cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbYWxwaGFiZXRdXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0ZnVuY3Rpb24gbW9kMzdBbmQzNih2YWx1ZSwgYWxwaGFiZXQpIHtcblx0ICAgIGlmIChhbHBoYWJldCA9PT0gdm9pZCAwKSB7IGFscGhhYmV0ID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWic7IH1cblx0ICAgIHZhciBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG5cdCAgICB2YXIgbW9kdWx1cyA9IGFscGhhYmV0Lmxlbmd0aDtcblx0ICAgIHZhciBjaGVjayA9IE1hdGguZmxvb3IobW9kdWx1cyAvIDIpO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHQgICAgICAgIGNoZWNrID0gKCgoKGNoZWNrIHx8IG1vZHVsdXMpICogMikgJSAobW9kdWx1cyArIDEpKSArIGFscGhhYmV0LmluZGV4T2YodmFsdWUuY2hhckF0KGkpKSkgJSBtb2R1bHVzO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGNoZWNrID09PSAxO1xuXHR9XG5cblx0LyoqXG5cdCAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuXHQgKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcblx0ICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuXHQgKi9cblx0ZnVuY3Rpb24gdHJhbnNmb3JtKGlucHV0KSB7XG5cdCAgICByZXR1cm4gaW5wdXRcblx0ICAgICAgICAuc3BsaXQoJycpXG5cdCAgICAgICAgLm1hcChmdW5jdGlvbiAoYykge1xuXHQgICAgICAgIHZhciBjb2RlID0gYy5jaGFyQ29kZUF0KDApO1xuXHQgICAgICAgIC8vIDY1LCA2NiwgLi4uLCA5MCBhcmUgdGhlIGNoYXIgY29kZSBvZiBBLCBCLCAuLi4sIFpcblx0ICAgICAgICByZXR1cm4gY29kZSA+PSA2NSAmJiBjb2RlIDw9IDkwXG5cdCAgICAgICAgICAgID8gLy8gUmVwbGFjZSBBLCBCLCBDLCAuLi4sIFogd2l0aCAxMCwgMTEsIC4uLiwgMzVcblx0ICAgICAgICAgICAgICAgIGNvZGUgLSA1NVxuXHQgICAgICAgICAgICA6IGM7XG5cdCAgICB9KVxuXHQgICAgICAgIC5qb2luKCcnKVxuXHQgICAgICAgIC5zcGxpdCgnJylcblx0ICAgICAgICAubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBwYXJzZUludChjLCAxMCk7IH0pO1xuXHR9XG5cdGZ1bmN0aW9uIG1vZDk3QW5kMTAoaW5wdXQpIHtcblx0ICAgIHZhciBkaWdpdHMgPSB0cmFuc2Zvcm0oaW5wdXQpO1xuXHQgICAgdmFyIHRlbXAgPSAwO1xuXHQgICAgdmFyIGxlbmd0aCA9IGRpZ2l0cy5sZW5ndGg7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aCAtIDE7ICsraSkge1xuXHQgICAgICAgIHRlbXAgPSAoKHRlbXAgKyBkaWdpdHNbaV0pICogMTApICUgOTc7XG5cdCAgICB9XG5cdCAgICB0ZW1wICs9IGRpZ2l0c1tsZW5ndGggLSAxXTtcblx0ICAgIHJldHVybiB0ZW1wICUgOTcgPT09IDE7XG5cdH1cblxuXHQvKipcblx0ICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG5cdCAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuXHQgKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG5cdCAqL1xuXHQvKipcblx0ICogSW1wbGVtZW50IFZlcmhvZWZmIHZhbGlkYXRpb24gYWxnb3JpdGhtXG5cdCAqIENyZWRpdCB0byBTZXJnZXkgUGV0dXNoa292LCAyMDE0XG5cdCAqXG5cdCAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmVyaG9lZmZfYWxnb3JpdGhtXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGZ1bmN0aW9uIHZlcmhvZWZmKHZhbHVlKSB7XG5cdCAgICAvLyBNdWx0aXBsaWNhdGlvbiB0YWJsZSBkXG5cdCAgICB2YXIgZCA9IFtcblx0ICAgICAgICBbMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOV0sXG5cdCAgICAgICAgWzEsIDIsIDMsIDQsIDAsIDYsIDcsIDgsIDksIDVdLFxuXHQgICAgICAgIFsyLCAzLCA0LCAwLCAxLCA3LCA4LCA5LCA1LCA2XSxcblx0ICAgICAgICBbMywgNCwgMCwgMSwgMiwgOCwgOSwgNSwgNiwgN10sXG5cdCAgICAgICAgWzQsIDAsIDEsIDIsIDMsIDksIDUsIDYsIDcsIDhdLFxuXHQgICAgICAgIFs1LCA5LCA4LCA3LCA2LCAwLCA0LCAzLCAyLCAxXSxcblx0ICAgICAgICBbNiwgNSwgOSwgOCwgNywgMSwgMCwgNCwgMywgMl0sXG5cdCAgICAgICAgWzcsIDYsIDUsIDksIDgsIDIsIDEsIDAsIDQsIDNdLFxuXHQgICAgICAgIFs4LCA3LCA2LCA1LCA5LCAzLCAyLCAxLCAwLCA0XSxcblx0ICAgICAgICBbOSwgOCwgNywgNiwgNSwgNCwgMywgMiwgMSwgMF0sXG5cdCAgICBdO1xuXHQgICAgLy8gUGVybXV0YXRpb24gdGFibGUgcFxuXHQgICAgdmFyIHAgPSBbXG5cdCAgICAgICAgWzAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDldLFxuXHQgICAgICAgIFsxLCA1LCA3LCA2LCAyLCA4LCAzLCAwLCA5LCA0XSxcblx0ICAgICAgICBbNSwgOCwgMCwgMywgNywgOSwgNiwgMSwgNCwgMl0sXG5cdCAgICAgICAgWzgsIDksIDEsIDYsIDAsIDQsIDMsIDUsIDIsIDddLFxuXHQgICAgICAgIFs5LCA0LCA1LCAzLCAxLCAyLCA2LCA4LCA3LCAwXSxcblx0ICAgICAgICBbNCwgMiwgOCwgNiwgNSwgNywgMywgOSwgMCwgMV0sXG5cdCAgICAgICAgWzIsIDcsIDksIDMsIDgsIDAsIDYsIDQsIDEsIDVdLFxuXHQgICAgICAgIFs3LCAwLCA0LCA2LCA5LCAxLCAzLCAyLCA1LCA4XSxcblx0ICAgIF07XG5cdCAgICAvLyBJbnZlcnNlIHRhYmxlIGludlxuXHQgICAgdmFyIGludmVydGVkQXJyYXkgPSB2YWx1ZS5yZXZlcnNlKCk7XG5cdCAgICB2YXIgYyA9IDA7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGludmVydGVkQXJyYXkubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBjID0gZFtjXVtwW2kgJSA4XVtpbnZlcnRlZEFycmF5W2ldXV07XG5cdCAgICB9XG5cdCAgICByZXR1cm4gYyA9PT0gMDtcblx0fVxuXG5cdC8qKlxuXHQgKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcblx0ICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG5cdCAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cblx0ICovXG5cdHZhciBpbmRleCQxID0ge1xuXHQgICAgbHVobjogbHVobixcblx0ICAgIG1vZDExQW5kMTA6IG1vZDExQW5kMTAsXG5cdCAgICBtb2QzN0FuZDM2OiBtb2QzN0FuZDM2LFxuXHQgICAgbW9kOTdBbmQxMDogbW9kOTdBbmQxMCxcblx0ICAgIHZlcmhvZWZmOiB2ZXJob2VmZixcblx0fTtcblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblx0Q29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5cdFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5cdHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblx0VEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5cdFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5cdEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuXHRJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuXHRMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5cdE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuXHRQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG5cdCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblx0LyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcblxyXG5cdGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcclxuXHQgICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcclxuXHQgICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcclxuXHQgICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xyXG5cdCAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcclxuXHR9XG5cblx0LyoqXG5cdCAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuXHQgKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcblx0ICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuXHQgKi9cblx0LyoqXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGZvcm0gVGhlIGZvcm0gZWxlbWVudFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkIG5hbWVcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgZmllbGQgZWxlbWVudFxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50W119IGVsZW1lbnRzIFRoZSBsaXN0IG9mIGVsZW1lbnRzIHdoaWNoIGhhdmUgdGhlIHNhbWUgbmFtZSBhcyBgZmllbGRgXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdGZ1bmN0aW9uIGdldEZpZWxkVmFsdWUoZm9ybSwgZmllbGQsIGVsZW1lbnQsIGVsZW1lbnRzKSB7XG5cdCAgICB2YXIgdHlwZSA9IChlbGVtZW50LmdldEF0dHJpYnV0ZSgndHlwZScpIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuXHQgICAgdmFyIHRhZ05hbWUgPSBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblx0ICAgIGlmICh0YWdOYW1lID09PSAndGV4dGFyZWEnKSB7XG5cdCAgICAgICAgcmV0dXJuIGVsZW1lbnQudmFsdWU7XG5cdCAgICB9XG5cdCAgICBpZiAodGFnTmFtZSA9PT0gJ3NlbGVjdCcpIHtcblx0ICAgICAgICB2YXIgc2VsZWN0ID0gZWxlbWVudDtcblx0ICAgICAgICB2YXIgaW5kZXggPSBzZWxlY3Quc2VsZWN0ZWRJbmRleDtcblx0ICAgICAgICByZXR1cm4gaW5kZXggPj0gMCA/IHNlbGVjdC5vcHRpb25zLml0ZW0oaW5kZXgpLnZhbHVlIDogJyc7XG5cdCAgICB9XG5cdCAgICBpZiAodGFnTmFtZSA9PT0gJ2lucHV0Jykge1xuXHQgICAgICAgIGlmICgncmFkaW8nID09PSB0eXBlIHx8ICdjaGVja2JveCcgPT09IHR5cGUpIHtcblx0ICAgICAgICAgICAgdmFyIGNoZWNrZWQgPSBlbGVtZW50cy5maWx0ZXIoZnVuY3Rpb24gKGVsZSkgeyByZXR1cm4gZWxlLmNoZWNrZWQ7IH0pLmxlbmd0aDtcblx0ICAgICAgICAgICAgcmV0dXJuIGNoZWNrZWQgPT09IDAgPyAnJyA6IGNoZWNrZWQgKyAnJztcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHJldHVybiBlbGVtZW50LnZhbHVlO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiAnJztcblx0fVxuXG5cdC8qKlxuXHQgKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcblx0ICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG5cdCAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cblx0ICovXG5cdGZ1bmN0aW9uIGVtaXR0ZXIoKSB7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICAgIGZuczoge30sXG5cdCAgICAgICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdGhpcy5mbnMgPSB7fTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGVtaXQ6IGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuXHQgICAgICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAodGhpcy5mbnNbZXZlbnRdIHx8IFtdKS5tYXAoZnVuY3Rpb24gKGhhbmRsZXIpIHsgcmV0dXJuIGhhbmRsZXIuYXBwbHkoaGFuZGxlciwgYXJncyk7IH0pO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgb2ZmOiBmdW5jdGlvbiAoZXZlbnQsIGZ1bmMpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuZm5zW2V2ZW50XSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5mbnNbZXZlbnRdLmluZGV4T2YoZnVuYyk7XG5cdCAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZm5zW2V2ZW50XS5zcGxpY2UoaW5kZXgsIDEpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBvbjogZnVuY3Rpb24gKGV2ZW50LCBmdW5jKSB7XG5cdCAgICAgICAgICAgICh0aGlzLmZuc1tldmVudF0gPSB0aGlzLmZuc1tldmVudF0gfHwgW10pLnB1c2goZnVuYyk7XG5cdCAgICAgICAgfSxcblx0ICAgIH07XG5cdH1cblxuXHQvKipcblx0ICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG5cdCAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuXHQgKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG5cdCAqL1xuXHRmdW5jdGlvbiBmaWx0ZXIoKSB7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICAgIGZpbHRlcnM6IHt9LFxuXHQgICAgICAgIGFkZDogZnVuY3Rpb24gKG5hbWUsIGZ1bmMpIHtcblx0ICAgICAgICAgICAgKHRoaXMuZmlsdGVyc1tuYW1lXSA9IHRoaXMuZmlsdGVyc1tuYW1lXSB8fCBbXSkucHVzaChmdW5jKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHRoaXMuZmlsdGVycyA9IHt9O1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZXhlY3V0ZTogZnVuY3Rpb24gKG5hbWUsIGRlZmF1bHRWYWx1ZSwgYXJncykge1xuXHQgICAgICAgICAgICBpZiAoIXRoaXMuZmlsdGVyc1tuYW1lXSB8fCAhdGhpcy5maWx0ZXJzW25hbWVdLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgcmVzdWx0ID0gZGVmYXVsdFZhbHVlO1xuXHQgICAgICAgICAgICB2YXIgZmlsdGVycyA9IHRoaXMuZmlsdGVyc1tuYW1lXTtcblx0ICAgICAgICAgICAgdmFyIGNvdW50ID0gZmlsdGVycy5sZW5ndGg7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0ID0gZmlsdGVyc1tpXS5hcHBseShyZXN1bHQsIGFyZ3MpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChuYW1lLCBmdW5jKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcnNbbmFtZV0pIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyc1tuYW1lXSA9IHRoaXMuZmlsdGVyc1tuYW1lXS5maWx0ZXIoZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYgIT09IGZ1bmM7IH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgIH07XG5cdH1cblxuXHQvKipcblx0ICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG5cdCAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuXHQgKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG5cdCAqL1xuXHR2YXIgQ29yZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIENvcmUoZm9ybSwgZmllbGRzKSB7XG5cdCAgICAgICAgdGhpcy5maWVsZHMgPSB7fTtcblx0ICAgICAgICB0aGlzLmVsZW1lbnRzID0ge307XG5cdCAgICAgICAgdGhpcy5lZSA9IGVtaXR0ZXIoKTtcblx0ICAgICAgICB0aGlzLmZpbHRlciA9IGZpbHRlcigpO1xuXHQgICAgICAgIHRoaXMucGx1Z2lucyA9IHt9O1xuXHQgICAgICAgIC8vIFN0b3JlIHRoZSByZXN1bHQgb2YgdmFsaWRhdGlvbiBmb3IgZWFjaCBmaWVsZFxuXHQgICAgICAgIHRoaXMucmVzdWx0cyA9IG5ldyBNYXAoKTtcblx0ICAgICAgICB0aGlzLnZhbGlkYXRvcnMgPSB7fTtcblx0ICAgICAgICB0aGlzLmZvcm0gPSBmb3JtO1xuXHQgICAgICAgIHRoaXMuZmllbGRzID0gZmllbGRzO1xuXHQgICAgfVxuXHQgICAgQ29yZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnQsIGZ1bmMpIHtcblx0ICAgICAgICB0aGlzLmVlLm9uKGV2ZW50LCBmdW5jKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICBDb3JlLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGZ1bmMpIHtcblx0ICAgICAgICB0aGlzLmVlLm9mZihldmVudCwgZnVuYyk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgQ29yZS5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgIHZhciBfYTtcblx0ICAgICAgICB2YXIgYXJncyA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIChfYSA9IHRoaXMuZWUpLmVtaXQuYXBwbHkoX2EsIF9fc3ByZWFkQXJyYXkoW2V2ZW50XSwgYXJncywgZmFsc2UpKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICBDb3JlLnByb3RvdHlwZS5yZWdpc3RlclBsdWdpbiA9IGZ1bmN0aW9uIChuYW1lLCBwbHVnaW4pIHtcblx0ICAgICAgICAvLyBDaGVjayBpZiB3aGV0aGVyIHRoZSBwbHVnaW4gaXMgcmVnaXN0ZXJlZFxuXHQgICAgICAgIGlmICh0aGlzLnBsdWdpbnNbbmFtZV0pIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHBsZ3VpbiBcIi5jb25jYXQobmFtZSwgXCIgaXMgcmVnaXN0ZXJlZFwiKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIEluc3RhbGwgdGhlIHBsdWdpblxuXHQgICAgICAgIHBsdWdpbi5zZXRDb3JlKHRoaXMpO1xuXHQgICAgICAgIHBsdWdpbi5pbnN0YWxsKCk7XG5cdCAgICAgICAgdGhpcy5wbHVnaW5zW25hbWVdID0gcGx1Z2luO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIENvcmUucHJvdG90eXBlLmRlcmVnaXN0ZXJQbHVnaW4gPSBmdW5jdGlvbiAobmFtZSkge1xuXHQgICAgICAgIHZhciBwbHVnaW4gPSB0aGlzLnBsdWdpbnNbbmFtZV07XG5cdCAgICAgICAgaWYgKHBsdWdpbikge1xuXHQgICAgICAgICAgICBwbHVnaW4udW5pbnN0YWxsKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGRlbGV0ZSB0aGlzLnBsdWdpbnNbbmFtZV07XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgQ29yZS5wcm90b3R5cGUuZW5hYmxlUGx1Z2luID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0ICAgICAgICB2YXIgcGx1Z2luID0gdGhpcy5wbHVnaW5zW25hbWVdO1xuXHQgICAgICAgIGlmIChwbHVnaW4pIHtcblx0ICAgICAgICAgICAgcGx1Z2luLmVuYWJsZSgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICBDb3JlLnByb3RvdHlwZS5kaXNhYmxlUGx1Z2luID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0ICAgICAgICB2YXIgcGx1Z2luID0gdGhpcy5wbHVnaW5zW25hbWVdO1xuXHQgICAgICAgIGlmIChwbHVnaW4pIHtcblx0ICAgICAgICAgICAgcGx1Z2luLmRpc2FibGUoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgQ29yZS5wcm90b3R5cGUuaXNQbHVnaW5FbmFibGVkID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0ICAgICAgICB2YXIgcGx1Z2luID0gdGhpcy5wbHVnaW5zW25hbWVdO1xuXHQgICAgICAgIHJldHVybiBwbHVnaW4gPyBwbHVnaW4uaXNQbHVnaW5FbmFibGVkKCkgOiBmYWxzZTtcblx0ICAgIH07XG5cdCAgICBDb3JlLnByb3RvdHlwZS5yZWdpc3RlclZhbGlkYXRvciA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jKSB7XG5cdCAgICAgICAgaWYgKHRoaXMudmFsaWRhdG9yc1tuYW1lXSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgdmFsaWRhdG9yIFwiLmNvbmNhdChuYW1lLCBcIiBpcyByZWdpc3RlcmVkXCIpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy52YWxpZGF0b3JzW25hbWVdID0gZnVuYztcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0ICAgICAqIEFkZCBhIGZpbHRlclxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIGZpbHRlclxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZmlsdGVyIGZ1bmN0aW9uXG5cdCAgICAgKiBAcmV0dXJuIHtDb3JlfVxuXHQgICAgICovXG5cdCAgICBDb3JlLnByb3RvdHlwZS5yZWdpc3RlckZpbHRlciA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jKSB7XG5cdCAgICAgICAgdGhpcy5maWx0ZXIuYWRkKG5hbWUsIGZ1bmMpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHQgICAgICogUmVtb3ZlIGEgZmlsdGVyXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgZmlsdGVyXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmaWx0ZXIgZnVuY3Rpb25cblx0ICAgICAqIEByZXR1cm4ge0NvcmV9XG5cdCAgICAgKi9cblx0ICAgIENvcmUucHJvdG90eXBlLmRlcmVnaXN0ZXJGaWx0ZXIgPSBmdW5jdGlvbiAobmFtZSwgZnVuYykge1xuXHQgICAgICAgIHRoaXMuZmlsdGVyLnJlbW92ZShuYW1lLCBmdW5jKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0ICAgICAqIEV4ZWN1dGUgYSBmaWx0ZXJcblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiBmaWx0ZXJcblx0ICAgICAqIEBwYXJhbSB7VH0gZGVmYXVsdFZhbHVlIFRoZSBkZWZhdWx0IHZhbHVlIHJldHVybnMgYnkgdGhlIGZpbHRlclxuXHQgICAgICogQHBhcmFtIHthcnJheX0gYXJncyBUaGUgZmlsdGVyIGFyZ3VtZW50c1xuXHQgICAgICogQHJldHVybnMge1R9XG5cdCAgICAgKi9cblx0ICAgIENvcmUucHJvdG90eXBlLmV4ZWN1dGVGaWx0ZXIgPSBmdW5jdGlvbiAobmFtZSwgZGVmYXVsdFZhbHVlLCBhcmdzKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyLmV4ZWN1dGUobmFtZSwgZGVmYXVsdFZhbHVlLCBhcmdzKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0ICAgICAqIEFkZCBhIGZpZWxkXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCBuYW1lXG5cdCAgICAgKiBAcGFyYW0ge0ZpZWxkT3B0aW9uc30gb3B0aW9ucyBUaGUgZmllbGQgb3B0aW9ucy4gVGhlIG9wdGlvbnMgd2lsbCBiZSBtZXJnZWQgd2l0aCB0aGUgb3JpZ2luYWwgdmFsaWRhdG9yIHJ1bGVzXG5cdCAgICAgKiBpZiB0aGUgZmllbGQgaXMgYWxyZWFkeSBkZWZpbmVkXG5cdCAgICAgKiBAcmV0dXJuIHtDb3JlfVxuXHQgICAgICovXG5cdCAgICBDb3JlLnByb3RvdHlwZS5hZGRGaWVsZCA9IGZ1bmN0aW9uIChmaWVsZCwgb3B0aW9ucykge1xuXHQgICAgICAgIHZhciBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwge1xuXHQgICAgICAgICAgICBzZWxlY3RvcjogJycsXG5cdCAgICAgICAgICAgIHZhbGlkYXRvcnM6IHt9LFxuXHQgICAgICAgIH0sIG9wdGlvbnMpO1xuXHQgICAgICAgIC8vIE1lcmdlIHRoZSBvcHRpb25zXG5cdCAgICAgICAgdGhpcy5maWVsZHNbZmllbGRdID0gdGhpcy5maWVsZHNbZmllbGRdXG5cdCAgICAgICAgICAgID8ge1xuXHQgICAgICAgICAgICAgICAgc2VsZWN0b3I6IG9wdHMuc2VsZWN0b3IgfHwgdGhpcy5maWVsZHNbZmllbGRdLnNlbGVjdG9yLFxuXHQgICAgICAgICAgICAgICAgdmFsaWRhdG9yczogT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5maWVsZHNbZmllbGRdLnZhbGlkYXRvcnMsIG9wdHMudmFsaWRhdG9ycyksXG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgOiBvcHRzO1xuXHQgICAgICAgIHRoaXMuZWxlbWVudHNbZmllbGRdID0gdGhpcy5xdWVyeUVsZW1lbnRzKGZpZWxkKTtcblx0ICAgICAgICB0aGlzLmVtaXQoJ2NvcmUuZmllbGQuYWRkZWQnLCB7XG5cdCAgICAgICAgICAgIGVsZW1lbnRzOiB0aGlzLmVsZW1lbnRzW2ZpZWxkXSxcblx0ICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuXHQgICAgICAgICAgICBvcHRpb25zOiB0aGlzLmZpZWxkc1tmaWVsZF0sXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdCAgICAgKiBSZW1vdmUgZ2l2ZW4gZmllbGQgYnkgbmFtZVxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQgbmFtZVxuXHQgICAgICogQHJldHVybiB7Q29yZX1cblx0ICAgICAqL1xuXHQgICAgQ29yZS5wcm90b3R5cGUucmVtb3ZlRmllbGQgPSBmdW5jdGlvbiAoZmllbGQpIHtcblx0ICAgICAgICBpZiAoIXRoaXMuZmllbGRzW2ZpZWxkXSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZmllbGQgXCIuY29uY2F0KGZpZWxkLCBcIiB2YWxpZGF0b3JzIGFyZSBub3QgZGVmaW5lZC4gUGxlYXNlIGVuc3VyZSB0aGUgZmllbGQgaXMgYWRkZWQgZmlyc3RcIikpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzW2ZpZWxkXTtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuZmllbGRzW2ZpZWxkXTtcblx0ICAgICAgICBkZWxldGUgdGhpcy5lbGVtZW50c1tmaWVsZF07XG5cdCAgICAgICAgZGVsZXRlIHRoaXMuZmllbGRzW2ZpZWxkXTtcblx0ICAgICAgICB0aGlzLmVtaXQoJ2NvcmUuZmllbGQucmVtb3ZlZCcsIHtcblx0ICAgICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLFxuXHQgICAgICAgICAgICBmaWVsZDogZmllbGQsXG5cdCAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdCAgICAgKiBWYWxpZGF0ZSBhbGwgZmllbGRzXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7UHJvbWlzZTxzdHJpbmc+fVxuXHQgICAgICovXG5cdCAgICBDb3JlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHRoaXMuZW1pdCgnY29yZS5mb3JtLnZhbGlkYXRpbmcnLCB7XG5cdCAgICAgICAgICAgIGZvcm1WYWxpZGF0aW9uOiB0aGlzLFxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbHRlci5leGVjdXRlKCd2YWxpZGF0ZS1wcmUnLCBQcm9taXNlLnJlc29sdmUoKSwgW10pLnRoZW4oZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoT2JqZWN0LmtleXMoX3RoaXMuZmllbGRzKS5tYXAoZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiBfdGhpcy52YWxpZGF0ZUZpZWxkKGZpZWxkKTsgfSkpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdHMpIHtcblx0ICAgICAgICAgICAgICAgIC8vIGByZXN1bHRzYCBpcyBhbiBhcnJheSBvZiBgVmFsaWRgLCBgSW52YWxpZGAgYW5kIGBOb3RWYWxpZGF0ZWRgXG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKHRydWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIHJlc3VsdHMuaW5kZXhPZignSW52YWxpZCcpICE9PSAtMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgnY29yZS5mb3JtLmludmFsaWQnLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtVmFsaWRhdGlvbjogX3RoaXMsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCdJbnZhbGlkJyk7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSByZXN1bHRzLmluZGV4T2YoJ05vdFZhbGlkYXRlZCcpICE9PSAtMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgnY29yZS5mb3JtLm5vdHZhbGlkYXRlZCcsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1WYWxpZGF0aW9uOiBfdGhpcyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoJ05vdFZhbGlkYXRlZCcpO1xuXHQgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ2NvcmUuZm9ybS52YWxpZCcsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1WYWxpZGF0aW9uOiBfdGhpcyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoJ1ZhbGlkJyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHQgICAgICogVmFsaWRhdGUgYSBwYXJ0aWN1bGFyIGZpZWxkXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCBuYW1lXG5cdCAgICAgKiBAcmV0dXJuIHtQcm9taXNlPHN0cmluZz59XG5cdCAgICAgKi9cblx0ICAgIENvcmUucHJvdG90eXBlLnZhbGlkYXRlRmllbGQgPSBmdW5jdGlvbiAoZmllbGQpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIC8vIFN0b3AgdmFsaWRhdGlvbiBwcm9jZXNzIGlmIHRoZSBmaWVsZCBpcyBhbHJlYWR5IHZhbGlkYXRlZFxuXHQgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnJlc3VsdHMuZ2V0KGZpZWxkKTtcblx0ICAgICAgICBpZiAocmVzdWx0ID09PSAnVmFsaWQnIHx8IHJlc3VsdCA9PT0gJ0ludmFsaWQnKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5lbWl0KCdjb3JlLmZpZWxkLnZhbGlkYXRpbmcnLCBmaWVsZCk7XG5cdCAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50c1tmaWVsZF07XG5cdCAgICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgICAgICB0aGlzLmVtaXQoJ2NvcmUuZmllbGQudmFsaWQnLCBmaWVsZCk7XG5cdCAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoJ1ZhbGlkJyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciB0eXBlID0gZWxlbWVudHNbMF0uZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG5cdCAgICAgICAgaWYgKCdyYWRpbycgPT09IHR5cGUgfHwgJ2NoZWNrYm94JyA9PT0gdHlwZSB8fCBlbGVtZW50cy5sZW5ndGggPT09IDEpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVFbGVtZW50KGZpZWxkLCBlbGVtZW50c1swXSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoZWxlbWVudHMubWFwKGZ1bmN0aW9uIChlbGUpIHsgcmV0dXJuIF90aGlzLnZhbGlkYXRlRWxlbWVudChmaWVsZCwgZWxlKTsgfSkpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdHMpIHtcblx0ICAgICAgICAgICAgICAgIC8vIGByZXN1bHRzYCBpcyBhbiBhcnJheSBvZiBgVmFsaWRgLCBgSW52YWxpZGAgYW5kIGBOb3RWYWxpZGF0ZWRgXG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKHRydWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIHJlc3VsdHMuaW5kZXhPZignSW52YWxpZCcpICE9PSAtMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgnY29yZS5maWVsZC5pbnZhbGlkJywgZmllbGQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXN1bHRzLnNldChmaWVsZCwgJ0ludmFsaWQnKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgnSW52YWxpZCcpO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgcmVzdWx0cy5pbmRleE9mKCdOb3RWYWxpZGF0ZWQnKSAhPT0gLTE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ2NvcmUuZmllbGQubm90dmFsaWRhdGVkJywgZmllbGQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXN1bHRzLmRlbGV0ZShmaWVsZCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoJ05vdFZhbGlkYXRlZCcpO1xuXHQgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ2NvcmUuZmllbGQudmFsaWQnLCBmaWVsZCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlc3VsdHMuc2V0KGZpZWxkLCAnVmFsaWQnKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgnVmFsaWQnKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHQgICAgICogVmFsaWRhdGUgcGFydGljdWxhciBlbGVtZW50XG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCBuYW1lXG5cdCAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGUgVGhlIGZpZWxkIGVsZW1lbnRcblx0ICAgICAqIEByZXR1cm4ge1Byb21pc2U8c3RyaW5nPn1cblx0ICAgICAqL1xuXHQgICAgQ29yZS5wcm90b3R5cGUudmFsaWRhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGZpZWxkLCBlbGUpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIC8vIFJlc2V0IHZhbGlkYXRpb24gcmVzdWx0XG5cdCAgICAgICAgdGhpcy5yZXN1bHRzLmRlbGV0ZShmaWVsZCk7XG5cdCAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50c1tmaWVsZF07XG5cdCAgICAgICAgdmFyIGlnbm9yZWQgPSB0aGlzLmZpbHRlci5leGVjdXRlKCdlbGVtZW50LWlnbm9yZWQnLCBmYWxzZSwgW2ZpZWxkLCBlbGUsIGVsZW1lbnRzXSk7XG5cdCAgICAgICAgaWYgKGlnbm9yZWQpIHtcblx0ICAgICAgICAgICAgdGhpcy5lbWl0KCdjb3JlLmVsZW1lbnQuaWdub3JlZCcsIHtcblx0ICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZSxcblx0ICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcblx0ICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoJ0lnbm9yZWQnKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHZhbGlkYXRvckxpc3QgPSB0aGlzLmZpZWxkc1tmaWVsZF0udmFsaWRhdG9ycztcblx0ICAgICAgICB0aGlzLmVtaXQoJ2NvcmUuZWxlbWVudC52YWxpZGF0aW5nJywge1xuXHQgICAgICAgICAgICBlbGVtZW50OiBlbGUsXG5cdCAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcblx0ICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHZhciBwcm9taXNlcyA9IE9iamVjdC5rZXlzKHZhbGlkYXRvckxpc3QpLm1hcChmdW5jdGlvbiAodikge1xuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZXhlY3V0ZVZhbGlkYXRvcihmaWVsZCwgZWxlLCB2LCB2YWxpZGF0b3JMaXN0W3ZdKTsgfTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR1cm4gdGhpcy53YXRlcmZhbGwocHJvbWlzZXMpXG5cdCAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXN1bHRzKSB7XG5cdCAgICAgICAgICAgIC8vIGByZXN1bHRzYCBpcyBhbiBhcnJheSBvZiBgVmFsaWRgIG9yIGBJbnZhbGlkYFxuXHQgICAgICAgICAgICB2YXIgaXNWYWxpZCA9IHJlc3VsdHMuaW5kZXhPZignSW52YWxpZCcpID09PSAtMTtcblx0ICAgICAgICAgICAgX3RoaXMuZW1pdCgnY29yZS5lbGVtZW50LnZhbGlkYXRlZCcsIHtcblx0ICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZSxcblx0ICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcblx0ICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcblx0ICAgICAgICAgICAgICAgIHZhbGlkOiBpc1ZhbGlkLFxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgdmFyIHR5cGUgPSBlbGUuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG5cdCAgICAgICAgICAgIGlmICgncmFkaW8nID09PSB0eXBlIHx8ICdjaGVja2JveCcgPT09IHR5cGUgfHwgZWxlbWVudHMubGVuZ3RoID09PSAxKSB7XG5cdCAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KGlzVmFsaWQgPyAnY29yZS5maWVsZC52YWxpZCcgOiAnY29yZS5maWVsZC5pbnZhbGlkJywgZmllbGQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoaXNWYWxpZCA/ICdWYWxpZCcgOiAnSW52YWxpZCcpO1xuXHQgICAgICAgIH0pXG5cdCAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAocmVhc29uKSB7XG5cdCAgICAgICAgICAgIC8vIHJlYXNvbiBpcyBgTm90VmFsaWRhdGVkYFxuXHQgICAgICAgICAgICBfdGhpcy5lbWl0KCdjb3JlLmVsZW1lbnQubm90dmFsaWRhdGVkJywge1xuXHQgICAgICAgICAgICAgICAgZWxlbWVudDogZWxlLFxuXHQgICAgICAgICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLFxuXHQgICAgICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWFzb24pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHQgICAgICogUGVyZm9ybSBnaXZlbiB2YWxpZGF0b3Igb24gZmllbGRcblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkIG5hbWVcblx0ICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZSBUaGUgZmllbGQgZWxlbWVudFxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IHYgVGhlIHZhbGlkYXRvciBuYW1lXG5cdCAgICAgKiBAcGFyYW0ge1ZhbGlkYXRvck9wdGlvbnN9IG9wdHMgVGhlIHZhbGlkYXRvciBvcHRpb25zXG5cdCAgICAgKiBAcmV0dXJuIHtQcm9taXNlPHN0cmluZz59XG5cdCAgICAgKi9cblx0ICAgIENvcmUucHJvdG90eXBlLmV4ZWN1dGVWYWxpZGF0b3IgPSBmdW5jdGlvbiAoZmllbGQsIGVsZSwgdiwgb3B0cykge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50c1tmaWVsZF07XG5cdCAgICAgICAgdmFyIG5hbWUgPSB0aGlzLmZpbHRlci5leGVjdXRlKCd2YWxpZGF0b3ItbmFtZScsIHYsIFt2LCBmaWVsZF0pO1xuXHQgICAgICAgIG9wdHMubWVzc2FnZSA9IHRoaXMuZmlsdGVyLmV4ZWN1dGUoJ3ZhbGlkYXRvci1tZXNzYWdlJywgb3B0cy5tZXNzYWdlLCBbdGhpcy5sb2NhbGUsIGZpZWxkLCBuYW1lXSk7XG5cdCAgICAgICAgLy8gU2ltcGx5IHBhc3MgdGhlIHZhbGlkYXRvciBpZlxuXHQgICAgICAgIC8vIC0gaXQgaXNuJ3QgZGVmaW5lZCB5ZXRcblx0ICAgICAgICAvLyAtIG9yIHRoZSBhc3NvY2lhdGVkIHZhbGlkYXRvciBpc24ndCBlbmFibGVkXG5cdCAgICAgICAgaWYgKCF0aGlzLnZhbGlkYXRvcnNbbmFtZV0gfHwgb3B0cy5lbmFibGVkID09PSBmYWxzZSkge1xuXHQgICAgICAgICAgICB0aGlzLmVtaXQoJ2NvcmUudmFsaWRhdG9yLnZhbGlkYXRlZCcsIHtcblx0ICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZSxcblx0ICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcblx0ICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcblx0ICAgICAgICAgICAgICAgIHJlc3VsdDogdGhpcy5ub3JtYWxpemVSZXN1bHQoZmllbGQsIG5hbWUsIHsgdmFsaWQ6IHRydWUgfSksXG5cdCAgICAgICAgICAgICAgICB2YWxpZGF0b3I6IG5hbWUsXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCdWYWxpZCcpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgdmFsaWRhdG9yID0gdGhpcy52YWxpZGF0b3JzW25hbWVdO1xuXHQgICAgICAgIC8vIEdldCB0aGUgZmllbGQgdmFsdWVcblx0ICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldEVsZW1lbnRWYWx1ZShmaWVsZCwgZWxlLCBuYW1lKTtcblx0ICAgICAgICB2YXIgd2lsbFZhbGlkYXRlID0gdGhpcy5maWx0ZXIuZXhlY3V0ZSgnZmllbGQtc2hvdWxkLXZhbGlkYXRlJywgdHJ1ZSwgW2ZpZWxkLCBlbGUsIHZhbHVlLCB2XSk7XG5cdCAgICAgICAgaWYgKCF3aWxsVmFsaWRhdGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5lbWl0KCdjb3JlLnZhbGlkYXRvci5ub3R2YWxpZGF0ZWQnLCB7XG5cdCAgICAgICAgICAgICAgICBlbGVtZW50OiBlbGUsXG5cdCAgICAgICAgICAgICAgICBlbGVtZW50czogZWxlbWVudHMsXG5cdCAgICAgICAgICAgICAgICBmaWVsZDogZmllbGQsXG5cdCAgICAgICAgICAgICAgICB2YWxpZGF0b3I6IHYsXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCdOb3RWYWxpZGF0ZWQnKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5lbWl0KCdjb3JlLnZhbGlkYXRvci52YWxpZGF0aW5nJywge1xuXHQgICAgICAgICAgICBlbGVtZW50OiBlbGUsXG5cdCAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcblx0ICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuXHQgICAgICAgICAgICB2YWxpZGF0b3I6IHYsXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLy8gUGVyZm9ybSB2YWxpZGF0aW9uXG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IHZhbGlkYXRvcigpLnZhbGlkYXRlKHtcblx0ICAgICAgICAgICAgZWxlbWVudDogZWxlLFxuXHQgICAgICAgICAgICBlbGVtZW50czogZWxlbWVudHMsXG5cdCAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcblx0ICAgICAgICAgICAgbDEwbjogdGhpcy5sb2NhbGl6YXRpb24sXG5cdCAgICAgICAgICAgIG9wdGlvbnM6IG9wdHMsXG5cdCAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSByZXN1bHQgaXMgYSBgUHJvbWlzZWBcblx0ICAgICAgICB2YXIgaXNQcm9taXNlID0gJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHJlc3VsdFsndGhlbiddO1xuXHQgICAgICAgIGlmIChpc1Byb21pc2UpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKGZ1bmN0aW9uIChyKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IF90aGlzLm5vcm1hbGl6ZVJlc3VsdChmaWVsZCwgdiwgcik7XG5cdCAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KCdjb3JlLnZhbGlkYXRvci52YWxpZGF0ZWQnLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogZWxlLFxuXHQgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcblx0ICAgICAgICAgICAgICAgICAgICBmaWVsZDogZmllbGQsXG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBkYXRhLFxuXHQgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvcjogdixcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEudmFsaWQgPyAnVmFsaWQnIDogJ0ludmFsaWQnO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5ub3JtYWxpemVSZXN1bHQoZmllbGQsIHYsIHJlc3VsdCk7XG5cdCAgICAgICAgICAgIHRoaXMuZW1pdCgnY29yZS52YWxpZGF0b3IudmFsaWRhdGVkJywge1xuXHQgICAgICAgICAgICAgICAgZWxlbWVudDogZWxlLFxuXHQgICAgICAgICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLFxuXHQgICAgICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuXHQgICAgICAgICAgICAgICAgcmVzdWx0OiBkYXRhLFxuXHQgICAgICAgICAgICAgICAgdmFsaWRhdG9yOiB2LFxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkYXRhLnZhbGlkID8gJ1ZhbGlkJyA6ICdJbnZhbGlkJyk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIENvcmUucHJvdG90eXBlLmdldEVsZW1lbnRWYWx1ZSA9IGZ1bmN0aW9uIChmaWVsZCwgZWxlLCB2YWxpZGF0b3IpIHtcblx0ICAgICAgICB2YXIgZGVmYXVsdFZhbHVlID0gZ2V0RmllbGRWYWx1ZSh0aGlzLmZvcm0sIGZpZWxkLCBlbGUsIHRoaXMuZWxlbWVudHNbZmllbGRdKTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIuZXhlY3V0ZSgnZmllbGQtdmFsdWUnLCBkZWZhdWx0VmFsdWUsIFtkZWZhdWx0VmFsdWUsIGZpZWxkLCBlbGUsIHZhbGlkYXRvcl0pO1xuXHQgICAgfTtcblx0ICAgIC8vIFNvbWUgZ2V0dGVyIG1ldGhvZHNcblx0ICAgIENvcmUucHJvdG90eXBlLmdldEVsZW1lbnRzID0gZnVuY3Rpb24gKGZpZWxkKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHNbZmllbGRdO1xuXHQgICAgfTtcblx0ICAgIENvcmUucHJvdG90eXBlLmdldEZpZWxkcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5maWVsZHM7XG5cdCAgICB9O1xuXHQgICAgQ29yZS5wcm90b3R5cGUuZ2V0Rm9ybUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZm9ybTtcblx0ICAgIH07XG5cdCAgICBDb3JlLnByb3RvdHlwZS5nZXRMb2NhbGUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlO1xuXHQgICAgfTtcblx0ICAgIENvcmUucHJvdG90eXBlLmdldFBsdWdpbiA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMucGx1Z2luc1tuYW1lXTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0ICAgICAqIFVwZGF0ZSB0aGUgZmllbGQgc3RhdHVzXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCBuYW1lXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RhdHVzIFRoZSBuZXcgc3RhdHVzXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3ZhbGlkYXRvcl0gVGhlIHZhbGlkYXRvciBuYW1lLiBJZiBpdCBpc24ndCBzcGVjaWZpZWQsIGFsbCB2YWxpZGF0b3JzIHdpbGwgYmUgdXBkYXRlZFxuXHQgICAgICogQHJldHVybiB7Q29yZX1cblx0ICAgICAqL1xuXHQgICAgQ29yZS5wcm90b3R5cGUudXBkYXRlRmllbGRTdGF0dXMgPSBmdW5jdGlvbiAoZmllbGQsIHN0YXR1cywgdmFsaWRhdG9yKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzW2ZpZWxkXTtcblx0ICAgICAgICB2YXIgdHlwZSA9IGVsZW1lbnRzWzBdLmdldEF0dHJpYnV0ZSgndHlwZScpO1xuXHQgICAgICAgIHZhciBsaXN0ID0gJ3JhZGlvJyA9PT0gdHlwZSB8fCAnY2hlY2tib3gnID09PSB0eXBlID8gW2VsZW1lbnRzWzBdXSA6IGVsZW1lbnRzO1xuXHQgICAgICAgIGxpc3QuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7IHJldHVybiBfdGhpcy51cGRhdGVFbGVtZW50U3RhdHVzKGZpZWxkLCBlbGUsIHN0YXR1cywgdmFsaWRhdG9yKTsgfSk7XG5cdCAgICAgICAgaWYgKCF2YWxpZGF0b3IpIHtcblx0ICAgICAgICAgICAgc3dpdGNoIChzdGF0dXMpIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ05vdFZhbGlkYXRlZCc6XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdjb3JlLmZpZWxkLm5vdHZhbGlkYXRlZCcsIGZpZWxkKTtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdHMuZGVsZXRlKGZpZWxkKTtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ1ZhbGlkYXRpbmcnOlxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnY29yZS5maWVsZC52YWxpZGF0aW5nJywgZmllbGQpO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0cy5kZWxldGUoZmllbGQpO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAnVmFsaWQnOlxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnY29yZS5maWVsZC52YWxpZCcsIGZpZWxkKTtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdHMuc2V0KGZpZWxkLCAnVmFsaWQnKTtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ0ludmFsaWQnOlxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnY29yZS5maWVsZC5pbnZhbGlkJywgZmllbGQpO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0cy5zZXQoZmllbGQsICdJbnZhbGlkJyk7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAoc3RhdHVzID09PSAnSW52YWxpZCcpIHtcblx0ICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBtYXJrIHRoZSBmaWVsZCBhcyBpbnZhbGlkIGJlY2F1c2UgaXQgZG9lc24ndCBwYXNzIHRoZSBgdmFsaWRhdG9yYFxuXHQgICAgICAgICAgICB0aGlzLmVtaXQoJ2NvcmUuZmllbGQuaW52YWxpZCcsIGZpZWxkKTtcblx0ICAgICAgICAgICAgdGhpcy5yZXN1bHRzLnNldChmaWVsZCwgJ0ludmFsaWQnKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdCAgICAgKiBVcGRhdGUgdGhlIGVsZW1lbnQgc3RhdHVzXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCBuYW1lXG5cdCAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGUgVGhlIGZpZWxkIGVsZW1lbnRcblx0ICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGF0dXMgVGhlIG5ldyBzdGF0dXNcblx0ICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdmFsaWRhdG9yXSBUaGUgdmFsaWRhdG9yIG5hbWUuIElmIGl0IGlzbid0IHNwZWNpZmllZCwgYWxsIHZhbGlkYXRvcnMgd2lsbCBiZSB1cGRhdGVkXG5cdCAgICAgKiBAcmV0dXJuIHtDb3JlfVxuXHQgICAgICovXG5cdCAgICBDb3JlLnByb3RvdHlwZS51cGRhdGVFbGVtZW50U3RhdHVzID0gZnVuY3Rpb24gKGZpZWxkLCBlbGUsIHN0YXR1cywgdmFsaWRhdG9yKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzW2ZpZWxkXTtcblx0ICAgICAgICB2YXIgZmllbGRWYWxpZGF0b3JzID0gdGhpcy5maWVsZHNbZmllbGRdLnZhbGlkYXRvcnM7XG5cdCAgICAgICAgdmFyIHZhbGlkYXRvckFyciA9IHZhbGlkYXRvciA/IFt2YWxpZGF0b3JdIDogT2JqZWN0LmtleXMoZmllbGRWYWxpZGF0b3JzKTtcblx0ICAgICAgICBzd2l0Y2ggKHN0YXR1cykge1xuXHQgICAgICAgICAgICBjYXNlICdOb3RWYWxpZGF0ZWQnOlxuXHQgICAgICAgICAgICAgICAgdmFsaWRhdG9yQXJyLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZW1pdCgnY29yZS52YWxpZGF0b3Iubm90dmFsaWRhdGVkJywge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBlbGUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3I6IHYsXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnY29yZS5lbGVtZW50Lm5vdHZhbGlkYXRlZCcsIHtcblx0ICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBlbGUsXG5cdCAgICAgICAgICAgICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLFxuXHQgICAgICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgJ1ZhbGlkYXRpbmcnOlxuXHQgICAgICAgICAgICAgICAgdmFsaWRhdG9yQXJyLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZW1pdCgnY29yZS52YWxpZGF0b3IudmFsaWRhdGluZycsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogZWxlLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50czogZWxlbWVudHMsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yOiB2LFxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2NvcmUuZWxlbWVudC52YWxpZGF0aW5nJywge1xuXHQgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZSxcblx0ICAgICAgICAgICAgICAgICAgICBlbGVtZW50czogZWxlbWVudHMsXG5cdCAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSAnVmFsaWQnOlxuXHQgICAgICAgICAgICAgICAgdmFsaWRhdG9yQXJyLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZW1pdCgnY29yZS52YWxpZGF0b3IudmFsaWRhdGVkJywge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBlbGUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGZpZWxkVmFsaWRhdG9yc1t2XS5tZXNzYWdlLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQ6IHRydWUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvcjogdixcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdjb3JlLmVsZW1lbnQudmFsaWRhdGVkJywge1xuXHQgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZSxcblx0ICAgICAgICAgICAgICAgICAgICBlbGVtZW50czogZWxlbWVudHMsXG5cdCAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuXHQgICAgICAgICAgICAgICAgICAgIHZhbGlkOiB0cnVlLFxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSAnSW52YWxpZCc6XG5cdCAgICAgICAgICAgICAgICB2YWxpZGF0b3JBcnIuZm9yRWFjaChmdW5jdGlvbiAodikge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5lbWl0KCdjb3JlLnZhbGlkYXRvci52YWxpZGF0ZWQnLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZDogZmllbGQsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDoge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZmllbGRWYWxpZGF0b3JzW3ZdLm1lc3NhZ2UsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZDogZmFsc2UsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvcjogdixcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdjb3JlLmVsZW1lbnQudmFsaWRhdGVkJywge1xuXHQgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZSxcblx0ICAgICAgICAgICAgICAgICAgICBlbGVtZW50czogZWxlbWVudHMsXG5cdCAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuXHQgICAgICAgICAgICAgICAgICAgIHZhbGlkOiBmYWxzZSxcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHQgICAgICogUmVzZXQgdGhlIGZvcm0uIEl0IGFsc28gY2xlYXJzIGFsbCB0aGUgbWVzc2FnZXMsIGhpZGUgdGhlIGZlZWRiYWNrIGljb25zLCBldGMuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtib29sZWFufSByZXNldCBJZiB0cnVlLCB0aGUgbWV0aG9kIHJlc2V0cyBmaWVsZCB2YWx1ZSB0byBlbXB0eVxuXHQgICAgICogb3IgcmVtb3ZlIGBjaGVja2VkYCwgYHNlbGVjdGVkYCBhdHRyaWJ1dGVzXG5cdCAgICAgKiBAcmV0dXJuIHtDb3JlfVxuXHQgICAgICovXG5cdCAgICBDb3JlLnByb3RvdHlwZS5yZXNldEZvcm0gPSBmdW5jdGlvbiAocmVzZXQpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuZmllbGRzKS5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkgeyByZXR1cm4gX3RoaXMucmVzZXRGaWVsZChmaWVsZCwgcmVzZXQpOyB9KTtcblx0ICAgICAgICB0aGlzLmVtaXQoJ2NvcmUuZm9ybS5yZXNldCcsIHtcblx0ICAgICAgICAgICAgZm9ybVZhbGlkYXRpb246IHRoaXMsXG5cdCAgICAgICAgICAgIHJlc2V0OiByZXNldCxcblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0ICAgICAqIFJlc2V0IHRoZSBmaWVsZC4gSXQgYWxzbyBjbGVhcnMgYWxsIHRoZSBtZXNzYWdlcywgaGlkZSB0aGUgZmVlZGJhY2sgaWNvbnMsIGV0Yy5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkIG5hbWVcblx0ICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVzZXQgSWYgdHJ1ZSwgdGhlIG1ldGhvZCByZXNldHMgZmllbGQgdmFsdWUgdG8gZW1wdHlcblx0ICAgICAqIG9yIHJlbW92ZSBgY2hlY2tlZGAsIGBzZWxlY3RlZGAgYXR0cmlidXRlc1xuXHQgICAgICogQHJldHVybiB7Q29yZX1cblx0ICAgICAqL1xuXHQgICAgQ29yZS5wcm90b3R5cGUucmVzZXRGaWVsZCA9IGZ1bmN0aW9uIChmaWVsZCwgcmVzZXQpIHtcblx0ICAgICAgICAvLyBSZXNldCB0aGUgZmllbGQgZWxlbWVudCB2YWx1ZSBpZiBuZWVkZWRcblx0ICAgICAgICBpZiAocmVzZXQpIHtcblx0ICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50c1tmaWVsZF07XG5cdCAgICAgICAgICAgIHZhciB0eXBlXzEgPSBlbGVtZW50c1swXS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcblx0ICAgICAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoJ3JhZGlvJyA9PT0gdHlwZV8xIHx8ICdjaGVja2JveCcgPT09IHR5cGVfMSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGVsZS5yZW1vdmVBdHRyaWJ1dGUoJ3NlbGVjdGVkJyk7XG5cdCAgICAgICAgICAgICAgICAgICAgZWxlLnJlbW92ZUF0dHJpYnV0ZSgnY2hlY2tlZCcpO1xuXHQgICAgICAgICAgICAgICAgICAgIGVsZS5jaGVja2VkID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBlbGUuc2V0QXR0cmlidXRlKCd2YWx1ZScsICcnKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZWxlIGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCB8fCBlbGUgaW5zdGFuY2VvZiBIVE1MVGV4dEFyZWFFbGVtZW50KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsZS52YWx1ZSA9ICcnO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIE1hcmsgdGhlIGZpZWxkIGFzIG5vdCB2YWxpZGF0ZWQgeWV0XG5cdCAgICAgICAgdGhpcy51cGRhdGVGaWVsZFN0YXR1cyhmaWVsZCwgJ05vdFZhbGlkYXRlZCcpO1xuXHQgICAgICAgIHRoaXMuZW1pdCgnY29yZS5maWVsZC5yZXNldCcsIHtcblx0ICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuXHQgICAgICAgICAgICByZXNldDogcmVzZXQsXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdCAgICAgKiBSZXZhbGlkYXRlIGEgcGFydGljdWxhciBmaWVsZC4gSXQncyB1c2VmdWwgd2hlbiB0aGUgZmllbGQgdmFsdWUgaXMgZWZmZWN0ZWQgYnkgdGhpcmQgcGFydGllc1xuXHQgICAgICogKGZvciBleGFtcGxlLCBhdHRhY2ggYW5vdGhlciBVSSBsaWJyYXJ5IHRvIHRoZSBmaWVsZCkuXG5cdCAgICAgKiBTaW5jZSB0aGVyZSBpc24ndCBhbiBhdXRvbWF0aWMgd2F5IGZvciBGb3JtVmFsaWRhdGlvbiB0byBrbm93IHdoZW4gdGhlIGZpZWxkIHZhbHVlIGlzIG1vZGlmaWVkIGluIHRob3NlIGNhc2VzLFxuXHQgICAgICogd2UgbmVlZCB0byByZXZhbGlkYXRlIHRoZSBmaWVsZCBtYW51YWxseS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkIG5hbWVcblx0ICAgICAqIEByZXR1cm4ge1Byb21pc2U8c3RyaW5nPn1cblx0ICAgICAqL1xuXHQgICAgQ29yZS5wcm90b3R5cGUucmV2YWxpZGF0ZUZpZWxkID0gZnVuY3Rpb24gKGZpZWxkKSB7XG5cdCAgICAgICAgaWYgKCF0aGlzLmZpZWxkc1tmaWVsZF0pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgnSWdub3JlZCcpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLnVwZGF0ZUZpZWxkU3RhdHVzKGZpZWxkLCAnTm90VmFsaWRhdGVkJyk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVGaWVsZChmaWVsZCk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdCAgICAgKiBEaXNhYmxlIHBhcnRpY3VsYXIgdmFsaWRhdG9yIGZvciBnaXZlbiBmaWVsZFxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQgbmFtZVxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbGlkYXRvciBUaGUgdmFsaWRhdG9yIG5hbWUuIElmIGl0IGlzbid0IHNwZWNpZmllZCwgYWxsIHZhbGlkYXRvcnMgd2lsbCBiZSBkaXNhYmxlZFxuXHQgICAgICogQHJldHVybiB7Q29yZX1cblx0ICAgICAqL1xuXHQgICAgQ29yZS5wcm90b3R5cGUuZGlzYWJsZVZhbGlkYXRvciA9IGZ1bmN0aW9uIChmaWVsZCwgdmFsaWRhdG9yKSB7XG5cdCAgICAgICAgaWYgKCF0aGlzLmZpZWxkc1tmaWVsZF0pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHNbZmllbGRdO1xuXHQgICAgICAgIHRoaXMudG9nZ2xlVmFsaWRhdG9yKGZhbHNlLCBmaWVsZCwgdmFsaWRhdG9yKTtcblx0ICAgICAgICB0aGlzLmVtaXQoJ2NvcmUudmFsaWRhdG9yLmRpc2FibGVkJywge1xuXHQgICAgICAgICAgICBlbGVtZW50czogZWxlbWVudHMsXG5cdCAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcblx0ICAgICAgICAgICAgZm9ybVZhbGlkYXRpb246IHRoaXMsXG5cdCAgICAgICAgICAgIHZhbGlkYXRvcjogdmFsaWRhdG9yLFxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHQgICAgICogRW5hYmxlIHBhcnRpY3VsYXIgdmFsaWRhdG9yIGZvciBnaXZlbiBmaWVsZFxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQgbmFtZVxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbGlkYXRvciBUaGUgdmFsaWRhdG9yIG5hbWUuIElmIGl0IGlzbid0IHNwZWNpZmllZCwgYWxsIHZhbGlkYXRvcnMgd2lsbCBiZSBlbmFibGVkXG5cdCAgICAgKiBAcmV0dXJuIHtDb3JlfVxuXHQgICAgICovXG5cdCAgICBDb3JlLnByb3RvdHlwZS5lbmFibGVWYWxpZGF0b3IgPSBmdW5jdGlvbiAoZmllbGQsIHZhbGlkYXRvcikge1xuXHQgICAgICAgIGlmICghdGhpcy5maWVsZHNbZmllbGRdKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzW2ZpZWxkXTtcblx0ICAgICAgICB0aGlzLnRvZ2dsZVZhbGlkYXRvcih0cnVlLCBmaWVsZCwgdmFsaWRhdG9yKTtcblx0ICAgICAgICB0aGlzLmVtaXQoJ2NvcmUudmFsaWRhdG9yLmVuYWJsZWQnLCB7XG5cdCAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcblx0ICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuXHQgICAgICAgICAgICBmb3JtVmFsaWRhdGlvbjogdGhpcyxcblx0ICAgICAgICAgICAgdmFsaWRhdG9yOiB2YWxpZGF0b3IsXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdCAgICAgKiBVcGRhdGUgb3B0aW9uIG9mIHBhcnRpY3VsYXIgdmFsaWRhdG9yIGZvciBnaXZlbiBmaWVsZFxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQgbmFtZVxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbGlkYXRvciBUaGUgdmFsaWRhdG9yIG5hbWVcblx0ICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBvcHRpb24ncyBuYW1lXG5cdCAgICAgKiBAcGFyYW0ge3Vua25vd259IHZhbHVlIFRoZSBvcHRpb24ncyB2YWx1ZVxuXHQgICAgICogQHJldHVybiB7Q29yZX1cblx0ICAgICAqL1xuXHQgICAgQ29yZS5wcm90b3R5cGUudXBkYXRlVmFsaWRhdG9yT3B0aW9uID0gZnVuY3Rpb24gKGZpZWxkLCB2YWxpZGF0b3IsIG5hbWUsIHZhbHVlKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuZmllbGRzW2ZpZWxkXSAmJiB0aGlzLmZpZWxkc1tmaWVsZF0udmFsaWRhdG9ycyAmJiB0aGlzLmZpZWxkc1tmaWVsZF0udmFsaWRhdG9yc1t2YWxpZGF0b3JdKSB7XG5cdCAgICAgICAgICAgIHRoaXMuZmllbGRzW2ZpZWxkXS52YWxpZGF0b3JzW3ZhbGlkYXRvcl1bbmFtZV0gPSB2YWx1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgQ29yZS5wcm90b3R5cGUuc2V0RmllbGRPcHRpb25zID0gZnVuY3Rpb24gKGZpZWxkLCBvcHRpb25zKSB7XG5cdCAgICAgICAgdGhpcy5maWVsZHNbZmllbGRdID0gb3B0aW9ucztcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICBDb3JlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgLy8gUmVtb3ZlIHBsdWdpbnMgYW5kIGZpbHRlcnNcblx0ICAgICAgICBPYmplY3Qua2V5cyh0aGlzLnBsdWdpbnMpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7IHJldHVybiBfdGhpcy5wbHVnaW5zW2lkXS51bmluc3RhbGwoKTsgfSk7XG5cdCAgICAgICAgdGhpcy5lZS5jbGVhcigpO1xuXHQgICAgICAgIHRoaXMuZmlsdGVyLmNsZWFyKCk7XG5cdCAgICAgICAgdGhpcy5yZXN1bHRzLmNsZWFyKCk7XG5cdCAgICAgICAgdGhpcy5wbHVnaW5zID0ge307XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgQ29yZS5wcm90b3R5cGUuc2V0TG9jYWxlID0gZnVuY3Rpb24gKGxvY2FsZSwgbG9jYWxpemF0aW9uKSB7XG5cdCAgICAgICAgdGhpcy5sb2NhbGUgPSBsb2NhbGU7XG5cdCAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgQ29yZS5wcm90b3R5cGUud2F0ZXJmYWxsID0gZnVuY3Rpb24gKHByb21pc2VzKSB7XG5cdCAgICAgICAgcmV0dXJuIHByb21pc2VzLnJlZHVjZShmdW5jdGlvbiAocCwgYykge1xuXHQgICAgICAgICAgICByZXR1cm4gcC50aGVuKGZ1bmN0aW9uIChyZXMpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBjKCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2gocmVzdWx0KTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0sIFByb21pc2UucmVzb2x2ZShbXSkpO1xuXHQgICAgfTtcblx0ICAgIENvcmUucHJvdG90eXBlLnF1ZXJ5RWxlbWVudHMgPSBmdW5jdGlvbiAoZmllbGQpIHtcblx0ICAgICAgICB2YXIgc2VsZWN0b3IgPSB0aGlzLmZpZWxkc1tmaWVsZF0uc2VsZWN0b3Jcblx0ICAgICAgICAgICAgPyAvLyBDaGVjayBpZiB0aGUgc2VsZWN0b3IgaXMgYW4gSUQgc2VsZWN0b3Igd2hpY2ggc3RhcnRzIHdpdGggYCNgXG5cdCAgICAgICAgICAgICAgICAnIycgPT09IHRoaXMuZmllbGRzW2ZpZWxkXS5zZWxlY3Rvci5jaGFyQXQoMClcblx0ICAgICAgICAgICAgICAgICAgICA/IFwiW2lkPVxcXCJcIi5jb25jYXQodGhpcy5maWVsZHNbZmllbGRdLnNlbGVjdG9yLnN1YnN0cmluZygxKSwgXCJcXFwiXVwiKVxuXHQgICAgICAgICAgICAgICAgICAgIDogdGhpcy5maWVsZHNbZmllbGRdLnNlbGVjdG9yXG5cdCAgICAgICAgICAgIDogXCJbbmFtZT1cXFwiXCIuY29uY2F0KGZpZWxkLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKSwgXCJcXFwiXVwiKTtcblx0ICAgICAgICByZXR1cm4gW10uc2xpY2UuY2FsbCh0aGlzLmZvcm0ucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xuXHQgICAgfTtcblx0ICAgIENvcmUucHJvdG90eXBlLm5vcm1hbGl6ZVJlc3VsdCA9IGZ1bmN0aW9uIChmaWVsZCwgdmFsaWRhdG9yLCByZXN1bHQpIHtcblx0ICAgICAgICB2YXIgb3B0cyA9IHRoaXMuZmllbGRzW2ZpZWxkXS52YWxpZGF0b3JzW3ZhbGlkYXRvcl07XG5cdCAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHJlc3VsdCwge1xuXHQgICAgICAgICAgICBtZXNzYWdlOiByZXN1bHQubWVzc2FnZSB8fFxuXHQgICAgICAgICAgICAgICAgKG9wdHMgPyBvcHRzLm1lc3NhZ2UgOiAnJykgfHxcblx0ICAgICAgICAgICAgICAgICh0aGlzLmxvY2FsaXphdGlvbiAmJiB0aGlzLmxvY2FsaXphdGlvblt2YWxpZGF0b3JdICYmIHRoaXMubG9jYWxpemF0aW9uW3ZhbGlkYXRvcl1bJ2RlZmF1bHQnXVxuXHQgICAgICAgICAgICAgICAgICAgID8gdGhpcy5sb2NhbGl6YXRpb25bdmFsaWRhdG9yXVsnZGVmYXVsdCddXG5cdCAgICAgICAgICAgICAgICAgICAgOiAnJykgfHxcblx0ICAgICAgICAgICAgICAgIFwiVGhlIGZpZWxkIFwiLmNvbmNhdChmaWVsZCwgXCIgaXMgbm90IHZhbGlkXCIpLFxuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIENvcmUucHJvdG90eXBlLnRvZ2dsZVZhbGlkYXRvciA9IGZ1bmN0aW9uIChlbmFibGVkLCBmaWVsZCwgdmFsaWRhdG9yKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB2YXIgdmFsaWRhdG9yQXJyID0gdGhpcy5maWVsZHNbZmllbGRdLnZhbGlkYXRvcnM7XG5cdCAgICAgICAgaWYgKHZhbGlkYXRvciAmJiB2YWxpZGF0b3JBcnIgJiYgdmFsaWRhdG9yQXJyW3ZhbGlkYXRvcl0pIHtcblx0ICAgICAgICAgICAgdGhpcy5maWVsZHNbZmllbGRdLnZhbGlkYXRvcnNbdmFsaWRhdG9yXS5lbmFibGVkID0gZW5hYmxlZDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAoIXZhbGlkYXRvcikge1xuXHQgICAgICAgICAgICBPYmplY3Qua2V5cyh2YWxpZGF0b3JBcnIpLmZvckVhY2goZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChfdGhpcy5maWVsZHNbZmllbGRdLnZhbGlkYXRvcnNbdl0uZW5hYmxlZCA9IGVuYWJsZWQpOyB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlRmllbGRTdGF0dXMoZmllbGQsICdOb3RWYWxpZGF0ZWQnLCB2YWxpZGF0b3IpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBDb3JlO1xuXHR9KCkpO1xuXHRmdW5jdGlvbiBmb3JtVmFsaWRhdGlvbihmb3JtLCBvcHRpb25zKSB7XG5cdCAgICB2YXIgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIHtcblx0ICAgICAgICBmaWVsZHM6IHt9LFxuXHQgICAgICAgIGxvY2FsZTogJ2VuX1VTJyxcblx0ICAgICAgICBwbHVnaW5zOiB7fSxcblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoXykgeyB9LFxuXHQgICAgfSwgb3B0aW9ucyk7XG5cdCAgICB2YXIgY29yZSA9IG5ldyBDb3JlKGZvcm0sIG9wdHMuZmllbGRzKTtcblx0ICAgIGNvcmUuc2V0TG9jYWxlKG9wdHMubG9jYWxlLCBvcHRzLmxvY2FsaXphdGlvbik7XG5cdCAgICAvLyBSZWdpc3RlciBwbHVnaW5zXG5cdCAgICBPYmplY3Qua2V5cyhvcHRzLnBsdWdpbnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIGNvcmUucmVnaXN0ZXJQbHVnaW4obmFtZSwgb3B0cy5wbHVnaW5zW25hbWVdKTsgfSk7XG5cdCAgICAvLyBJdCdzIHRoZSBzaW5nbGUgcG9pbnQgdGhhdCB1c2VycyBjYW4gZG8gYSBwYXJ0aWN1bGFyIHRhc2sgYmVmb3JlIGFkZGluZyBmaWVsZHNcblx0ICAgIC8vIFNvbWUgaW5pdGlhbGl6YXRpb24gdGFza3MgbXVzdCBiZSBkb25lIGF0IHRoYXQgcG9pbnRcblx0ICAgIG9wdHMuaW5pdChjb3JlKTtcblx0ICAgIC8vIGFuZCBhZGQgZmllbGRzXG5cdCAgICBPYmplY3Qua2V5cyhvcHRzLmZpZWxkcykuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHsgcmV0dXJuIGNvcmUuYWRkRmllbGQoZmllbGQsIG9wdHMuZmllbGRzW2ZpZWxkXSk7IH0pO1xuXHQgICAgcmV0dXJuIGNvcmU7XG5cdH1cblxuXHQvKipcblx0ICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG5cdCAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuXHQgKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG5cdCAqL1xuXHR2YXIgUGx1Z2luID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gUGx1Z2luKG9wdHMpIHtcblx0ICAgICAgICB0aGlzLm9wdHMgPSBvcHRzO1xuXHQgICAgICAgIHRoaXMuaXNFbmFibGVkID0gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIFBsdWdpbi5wcm90b3R5cGUuc2V0Q29yZSA9IGZ1bmN0aW9uIChjb3JlKSB7XG5cdCAgICAgICAgdGhpcy5jb3JlID0gY29yZTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICBQbHVnaW4ucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLmlzRW5hYmxlZCA9IHRydWU7XG5cdCAgICAgICAgdGhpcy5vbkVuYWJsZWQoKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICBQbHVnaW4ucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5pc0VuYWJsZWQgPSBmYWxzZTtcblx0ICAgICAgICB0aGlzLm9uRGlzYWJsZWQoKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICBQbHVnaW4ucHJvdG90eXBlLmlzUGx1Z2luRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5pc0VuYWJsZWQ7XG5cdCAgICB9O1xuXHQgICAgUGx1Z2luLnByb3RvdHlwZS5vbkVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7IH07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG5cdCAgICBQbHVnaW4ucHJvdG90eXBlLm9uRGlzYWJsZWQgPSBmdW5jdGlvbiAoKSB7IH07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG5cdCAgICBQbHVnaW4ucHJvdG90eXBlLmluc3RhbGwgPSBmdW5jdGlvbiAoKSB7IH07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG5cdCAgICBQbHVnaW4ucHJvdG90eXBlLnVuaW5zdGFsbCA9IGZ1bmN0aW9uICgpIHsgfTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb25cblx0ICAgIHJldHVybiBQbHVnaW47XG5cdH0oKSk7XG5cblx0LyoqXG5cdCAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuXHQgKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcblx0ICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuXHQgKi9cblx0LyoqXG5cdCAqIEV4ZWN1dGUgYSBjYWxsYmFjayBmdW5jdGlvblxuXHQgKlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9uIHwgc3RyaW5nfSBmdW5jdGlvbk5hbWUgQ2FuIGJlXG5cdCAqIC0gbmFtZSBvZiBnbG9iYWwgZnVuY3Rpb25cblx0ICogLSBuYW1lIG9mIG5hbWVzcGFjZSBmdW5jdGlvbiAoc3VjaCBhcyBBLkIuQylcblx0ICogLSBhIGZ1bmN0aW9uXG5cdCAqIEBwYXJhbSB7YW55W119IGFyZ3MgVGhlIGNhbGxiYWNrIGFyZ3VtZW50c1xuXHQgKiBAcmV0dXJuIHthbnl9XG5cdCAqL1xuXHRmdW5jdGlvbiBjYWxsKGZ1bmN0aW9uTmFtZSwgYXJncykge1xuXHQgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBmdW5jdGlvbk5hbWUpIHtcblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb25OYW1lLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBmdW5jdGlvbk5hbWUpIHtcblx0ICAgICAgICAvLyBOb2RlIHRoYXQgaXQgZG9lc24ndCBzdXBwb3J0IG5vZGUuanMgYmFzZWQgZW52aXJvbm1lbnQgYmVjYXVzZSB3ZSBhcmUgdHJ5aW5nIHRvIGFjY2VzcyBgd2luZG93YFxuXHQgICAgICAgIHZhciBuYW1lXzEgPSBmdW5jdGlvbk5hbWU7XG5cdCAgICAgICAgaWYgKCcoKScgPT09IG5hbWVfMS5zdWJzdHJpbmcobmFtZV8xLmxlbmd0aCAtIDIpKSB7XG5cdCAgICAgICAgICAgIG5hbWVfMSA9IG5hbWVfMS5zdWJzdHJpbmcoMCwgbmFtZV8xLmxlbmd0aCAtIDIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgbnMgPSBuYW1lXzEuc3BsaXQoJy4nKTtcblx0ICAgICAgICB2YXIgZnVuYyA9IG5zLnBvcCgpO1xuXHQgICAgICAgIHZhciBjb250ZXh0XzEgPSB3aW5kb3c7XG5cdCAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBuc18xID0gbnM7IF9pIDwgbnNfMS5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgICAgICAgdmFyIHQgPSBuc18xW19pXTtcblx0ICAgICAgICAgICAgY29udGV4dF8xID0gY29udGV4dF8xW3RdO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdHlwZW9mIGNvbnRleHRfMVtmdW5jXSA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogY29udGV4dF8xW2Z1bmNdLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHQgICAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuXHQgKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcblx0ICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuXHQgKi9cblx0dmFyIGFkZENsYXNzID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNsYXNzZXMpIHtcblx0ICAgIGNsYXNzZXMuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uIChjbGF6eikge1xuXHQgICAgICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuXHQgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhenopO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmIChcIiBcIi5jb25jYXQoZWxlbWVudC5jbGFzc05hbWUsIFwiIFwiKS5pbmRleE9mKFwiIFwiLmNvbmNhdChjbGF6eiwgXCIgXCIpKSkge1xuXHQgICAgICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSArPSBcIiBcIi5jb25jYXQoY2xhenopO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHR9O1xuXHR2YXIgcmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3Nlcykge1xuXHQgICAgY2xhc3Nlcy5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKGNsYXp6KSB7XG5cdCAgICAgICAgZWxlbWVudC5jbGFzc0xpc3Rcblx0ICAgICAgICAgICAgPyBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoY2xhenopXG5cdCAgICAgICAgICAgIDogKGVsZW1lbnQuY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWUucmVwbGFjZShjbGF6eiwgJycpKTtcblx0ICAgIH0pO1xuXHR9O1xuXHR2YXIgY2xhc3NTZXQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3Nlcykge1xuXHQgICAgdmFyIGFkZGluZyA9IFtdO1xuXHQgICAgdmFyIHJlbW92aW5nID0gW107XG5cdCAgICBPYmplY3Qua2V5cyhjbGFzc2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChjbGF6eikge1xuXHQgICAgICAgIGlmIChjbGF6eikge1xuXHQgICAgICAgICAgICBjbGFzc2VzW2NsYXp6XSA/IGFkZGluZy5wdXNoKGNsYXp6KSA6IHJlbW92aW5nLnB1c2goY2xhenopO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLy8gQWx3YXlzIHJlbW92ZSBiZWZvcmUgYWRkaW5nIGNsYXNzIGJlY2F1c2UgdGhlcmUgbWlnaHQgYmUgYSBjbGFzcyB3aGljaCBiZWxvbmcgdG8gYm90aCBzZXRzLlxuXHQgICAgLy8gRm9yIGV4YW1wbGUsIHRoZSBlbGVtZW50IHdpbGwgaGF2ZSBjbGFzcyBgYWAgYWZ0ZXIgY2FsbGluZ1xuXHQgICAgLy8gIGBgYFxuXHQgICAgLy8gIGNsYXNzU2V0KGVsZW1lbnQsIHtcblx0ICAgIC8vICAgICAgJ2EgYTEgYTInOiB0cnVlLFxuXHQgICAgLy8gICAgICAnYSBiMSBiMic6IGZhbHNlXG5cdCAgICAvLyAgfSlcblx0ICAgIC8vICBgYGBcblx0ICAgIHJlbW92aW5nLmZvckVhY2goZnVuY3Rpb24gKGNsYXp6KSB7IHJldHVybiByZW1vdmVDbGFzcyhlbGVtZW50LCBjbGF6eik7IH0pO1xuXHQgICAgYWRkaW5nLmZvckVhY2goZnVuY3Rpb24gKGNsYXp6KSB7IHJldHVybiBhZGRDbGFzcyhlbGVtZW50LCBjbGF6eik7IH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcblx0ICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG5cdCAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cblx0ICovXG5cdHZhciBtYXRjaGVzID0gZnVuY3Rpb24gKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG5cdCAgICB2YXIgbmF0aXZlTWF0Y2hlcyA9IGVsZW1lbnQubWF0Y2hlcyB8fFxuXHQgICAgICAgIGVsZW1lbnQud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdCAgICAgICAgZWxlbWVudFsnbW96TWF0Y2hlc1NlbGVjdG9yJ10gfHxcblx0ICAgICAgICBlbGVtZW50Wydtc01hdGNoZXNTZWxlY3RvciddO1xuXHQgICAgaWYgKG5hdGl2ZU1hdGNoZXMpIHtcblx0ICAgICAgICByZXR1cm4gbmF0aXZlTWF0Y2hlcy5jYWxsKGVsZW1lbnQsIHNlbGVjdG9yKTtcblx0ICAgIH1cblx0ICAgIC8vIEluIGNhc2UgYG1hdGNoZXNzZWxlY3RvcmAgaXNuJ3Qgc3VwcG9ydGVkIChzdWNoIGFzIElFMTApXG5cdCAgICAvLyBTZWUgaHR0cDovL2Nhbml1c2UuY29tL21hdGNoZXNzZWxlY3RvclxuXHQgICAgdmFyIG5vZGVzID0gW10uc2xpY2UuY2FsbChlbGVtZW50LnBhcmVudEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xuXHQgICAgcmV0dXJuIG5vZGVzLmluZGV4T2YoZWxlbWVudCkgPj0gMDtcblx0fTtcblx0dmFyIGNsb3Nlc3QgPSBmdW5jdGlvbiAoZWxlbWVudCwgc2VsZWN0b3IpIHtcblx0ICAgIHZhciBlbGUgPSBlbGVtZW50O1xuXHQgICAgd2hpbGUgKGVsZSkge1xuXHQgICAgICAgIGlmIChtYXRjaGVzKGVsZSwgc2VsZWN0b3IpKSB7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbGUgPSBlbGUucGFyZW50RWxlbWVudDtcblx0ICAgIH1cblx0ICAgIHJldHVybiBlbGU7XG5cdH07XG5cblx0LyoqXG5cdCAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuXHQgKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcblx0ICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuXHQgKi9cblx0dmFyIGdlbmVyYXRlU3RyaW5nID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuXHQgICAgcmV0dXJuIEFycmF5KGxlbmd0aClcblx0ICAgICAgICAuZmlsbCgnJylcblx0ICAgICAgICAubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5jaGFyQXQoMik7IH0pXG5cdCAgICAgICAgLmpvaW4oJycpO1xuXHR9O1xuXHR2YXIgZmV0Y2ggPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG5cdCAgICB2YXIgdG9RdWVyeSA9IGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKVxuXHQgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChrKSB7IHJldHVybiBcIlwiLmNvbmNhdChlbmNvZGVVUklDb21wb25lbnQoayksIFwiPVwiKS5jb25jYXQoZW5jb2RlVVJJQ29tcG9uZW50KG9ialtrXSkpOyB9KVxuXHQgICAgICAgICAgICAuam9pbignJicpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgdmFyIG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCB7XG5cdCAgICAgICAgICAgIGNyb3NzRG9tYWluOiBmYWxzZSxcblx0ICAgICAgICAgICAgaGVhZGVyczoge30sXG5cdCAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG5cdCAgICAgICAgICAgIHBhcmFtczoge30sXG5cdCAgICAgICAgfSwgb3B0aW9ucyk7XG5cdCAgICAgICAgLy8gQnVpbGQgdGhlIHBhcmFtcyBmb3IgR0VUIHJlcXVlc3Rcblx0ICAgICAgICB2YXIgcGFyYW1zID0gT2JqZWN0LmtleXMob3B0cy5wYXJhbXMpXG5cdCAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGspIHsgcmV0dXJuIFwiXCIuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudChrKSwgXCI9XCIpLmNvbmNhdChlbmNvZGVVUklDb21wb25lbnQob3B0cy5wYXJhbXNba10pKTsgfSlcblx0ICAgICAgICAgICAgLmpvaW4oJyYnKTtcblx0ICAgICAgICB2YXIgaGFzUXVlcnkgPSB1cmwuaW5kZXhPZignPycpID4gLTE7XG5cdCAgICAgICAgdmFyIHJlcXVlc3RVcmwgPSAnR0VUJyA9PT0gb3B0cy5tZXRob2QgPyBcIlwiLmNvbmNhdCh1cmwpLmNvbmNhdChoYXNRdWVyeSA/ICcmJyA6ICc/JykuY29uY2F0KHBhcmFtcykgOiB1cmw7XG5cdCAgICAgICAgaWYgKG9wdHMuY3Jvc3NEb21haW4pIHtcblx0ICAgICAgICAgICAgLy8gVXNlciBpcyBtYWtpbmcgY3Jvc3MgZG9tYWluIHJlcXVlc3Rcblx0ICAgICAgICAgICAgdmFyIHNjcmlwdF8xID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG5cdCAgICAgICAgICAgIC8vIEluIHNvbWUgdmVyeSBmYXN0IHN5c3RlbXMsIHRoZSBkaWZmZXJlbnQgYERhdGUubm93KClgIGludm9jYXRpb25zIGNhbiByZXR1cm4gdGhlIHNhbWUgdmFsdWVcblx0ICAgICAgICAgICAgLy8gd2hpY2ggbGVhZHMgdG8gdGhlIGlzc3VlIHdoZXJlIHRoZXJlIGFyZSBtdWx0aXBsZSByZW1vdmUgdmFsaWRhdG9ycyBhcmUgdXNlZCwgZm9yIGV4YW1wbGUuXG5cdCAgICAgICAgICAgIC8vIEFwcGVuZGluZyBpdCB3aXRoIGEgZ2VuZXJhdGVkIHJhbmRvbSBzdHJpbmcgY2FuIGZpeCB0aGUgdmFsdWVcblx0ICAgICAgICAgICAgdmFyIGNhbGxiYWNrXzEgPSBcIl9fX0Zvcm1WYWxpZGF0aW9uRmV0Y2hfXCIuY29uY2F0KGdlbmVyYXRlU3RyaW5nKDEyKSwgXCJfX19cIik7XG5cdCAgICAgICAgICAgIHdpbmRvd1tjYWxsYmFja18xXSA9IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICAgICAgICAgICAgICBkZWxldGUgd2luZG93W2NhbGxiYWNrXzFdO1xuXHQgICAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgc2NyaXB0XzEuc3JjID0gXCJcIi5jb25jYXQocmVxdWVzdFVybCkuY29uY2F0KGhhc1F1ZXJ5ID8gJyYnIDogJz8nLCBcImNhbGxiYWNrPVwiKS5jb25jYXQoY2FsbGJhY2tfMSk7XG5cdCAgICAgICAgICAgIHNjcmlwdF8xLmFzeW5jID0gdHJ1ZTtcblx0ICAgICAgICAgICAgc2NyaXB0XzEuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHNjcmlwdF8xLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0XzEpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgc2NyaXB0XzEuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZWplY3Q7IH0pO1xuXHQgICAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdF8xKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHZhciByZXF1ZXN0XzEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblx0ICAgICAgICAgICAgcmVxdWVzdF8xLm9wZW4ob3B0cy5tZXRob2QsIHJlcXVlc3RVcmwpO1xuXHQgICAgICAgICAgICAvLyBTZXQgdGhlIGhlYWRlcnNcblx0ICAgICAgICAgICAgcmVxdWVzdF8xLnNldFJlcXVlc3RIZWFkZXIoJ1gtUmVxdWVzdGVkLVdpdGgnLCAnWE1MSHR0cFJlcXVlc3QnKTtcblx0ICAgICAgICAgICAgaWYgKCdQT1NUJyA9PT0gb3B0cy5tZXRob2QpIHtcblx0ICAgICAgICAgICAgICAgIHJlcXVlc3RfMS5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgT2JqZWN0LmtleXMob3B0cy5oZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7IHJldHVybiByZXF1ZXN0XzEuc2V0UmVxdWVzdEhlYWRlcihrLCBvcHRzLmhlYWRlcnNba10pOyB9KTtcblx0ICAgICAgICAgICAgcmVxdWVzdF8xLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBDYW5ub3QgdXNlIGFycm93IGZ1bmN0aW9uIGhlcmUgZHVlIHRvIHRoZSBgdGhpc2Agc2NvcGVcblx0ICAgICAgICAgICAgICAgIHJlc29sdmUoSlNPTi5wYXJzZSh0aGlzLnJlc3BvbnNlVGV4dCkpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgcmVxdWVzdF8xLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVqZWN0OyB9KTtcblx0ICAgICAgICAgICAgLy8gR0VUIHJlcXVlc3Qgd2lsbCBpZ25vcmUgdGhlIHBhc3NlZCBkYXRhIGhlcmVcblx0ICAgICAgICAgICAgcmVxdWVzdF8xLnNlbmQodG9RdWVyeShvcHRzLnBhcmFtcykpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcblx0ICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG5cdCAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cblx0ICovXG5cdC8qKlxuXHQgKiBGb3JtYXQgYSBzdHJpbmdcblx0ICogSXQncyB1c2VkIHRvIGZvcm1hdCB0aGUgZXJyb3IgbWVzc2FnZVxuXHQgKiBmb3JtYXQoJ1RoZSBmaWVsZCBtdXN0IGJldHdlZW4gJXMgYW5kICVzJywgWzEwLCAyMF0pID0gJ1RoZSBmaWVsZCBtdXN0IGJldHdlZW4gMTAgYW5kIDIwJ1xuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuXHQgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gcGFyYW1ldGVyc1xuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0dmFyIGZvcm1hdCA9IGZ1bmN0aW9uIChtZXNzYWdlLCBwYXJhbWV0ZXJzKSB7XG5cdCAgICB2YXIgcGFyYW1zID0gQXJyYXkuaXNBcnJheShwYXJhbWV0ZXJzKSA/IHBhcmFtZXRlcnMgOiBbcGFyYW1ldGVyc107XG5cdCAgICB2YXIgb3V0cHV0ID0gbWVzc2FnZTtcblx0ICAgIHBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG5cdCAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2UoJyVzJywgcCk7XG5cdCAgICB9KTtcblx0ICAgIHJldHVybiBvdXRwdXQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuXHQgKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcblx0ICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuXHQgKi9cblx0dmFyIGhhc0NsYXNzID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNsYXp6KSB7XG5cdCAgICByZXR1cm4gZWxlbWVudC5jbGFzc0xpc3Rcblx0ICAgICAgICA/IGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXp6KVxuXHQgICAgICAgIDogbmV3IFJlZ0V4cChcIihefCApXCIuY29uY2F0KGNsYXp6LCBcIiggfCQpXCIpLCAnZ2knKS50ZXN0KGVsZW1lbnQuY2xhc3NOYW1lKTtcblx0fTtcblxuXHQvKipcblx0ICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG5cdCAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuXHQgKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG5cdCAqL1xuXHQvKipcblx0ICogVmFsaWRhdGUgYSBkYXRlXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB5ZWFyIFRoZSBmdWxsIHllYXIgaW4gNCBkaWdpdHNcblx0ICogQHBhcmFtIHtzdHJpbmd9IG1vbnRoIFRoZSBtb250aCBudW1iZXJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGRheSBUaGUgZGF5IG51bWJlclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtub3RJbkZ1dHVyZV0gSWYgdHJ1ZSwgdGhlIGRhdGUgbXVzdCBub3QgYmUgaW4gdGhlIGZ1dHVyZVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdHZhciBpc1ZhbGlkRGF0ZSA9IGZ1bmN0aW9uICh5ZWFyLCBtb250aCwgZGF5LCBub3RJbkZ1dHVyZSkge1xuXHQgICAgaWYgKGlzTmFOKHllYXIpIHx8IGlzTmFOKG1vbnRoKSB8fCBpc05hTihkYXkpKSB7XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgICAgaWYgKHllYXIgPCAxMDAwIHx8IHllYXIgPiA5OTk5IHx8IG1vbnRoIDw9IDAgfHwgbW9udGggPiAxMikge1xuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblx0ICAgIHZhciBudW1EYXlzID0gW1xuXHQgICAgICAgIDMxLFxuXHQgICAgICAgIC8vIFVwZGF0ZSB0aGUgbnVtYmVyIG9mIGRheXMgaW4gRmViIG9mIGxlYXAgeWVhclxuXHQgICAgICAgIHllYXIgJSA0MDAgPT09IDAgfHwgKHllYXIgJSAxMDAgIT09IDAgJiYgeWVhciAlIDQgPT09IDApID8gMjkgOiAyOCxcblx0ICAgICAgICAzMSxcblx0ICAgICAgICAzMCxcblx0ICAgICAgICAzMSxcblx0ICAgICAgICAzMCxcblx0ICAgICAgICAzMSxcblx0ICAgICAgICAzMSxcblx0ICAgICAgICAzMCxcblx0ICAgICAgICAzMSxcblx0ICAgICAgICAzMCxcblx0ICAgICAgICAzMSxcblx0ICAgIF07XG5cdCAgICAvLyBDaGVjayB0aGUgZGF5XG5cdCAgICBpZiAoZGF5IDw9IDAgfHwgZGF5ID4gbnVtRGF5c1ttb250aCAtIDFdKSB7XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgICAgaWYgKG5vdEluRnV0dXJlID09PSB0cnVlKSB7XG5cdCAgICAgICAgdmFyIGN1cnJlbnREYXRlID0gbmV3IERhdGUoKTtcblx0ICAgICAgICB2YXIgY3VycmVudFllYXIgPSBjdXJyZW50RGF0ZS5nZXRGdWxsWWVhcigpO1xuXHQgICAgICAgIHZhciBjdXJyZW50TW9udGggPSBjdXJyZW50RGF0ZS5nZXRNb250aCgpO1xuXHQgICAgICAgIHZhciBjdXJyZW50RGF5ID0gY3VycmVudERhdGUuZ2V0RGF0ZSgpO1xuXHQgICAgICAgIHJldHVybiAoeWVhciA8IGN1cnJlbnRZZWFyIHx8XG5cdCAgICAgICAgICAgICh5ZWFyID09PSBjdXJyZW50WWVhciAmJiBtb250aCAtIDEgPCBjdXJyZW50TW9udGgpIHx8XG5cdCAgICAgICAgICAgICh5ZWFyID09PSBjdXJyZW50WWVhciAmJiBtb250aCAtIDEgPT09IGN1cnJlbnRNb250aCAmJiBkYXkgPCBjdXJyZW50RGF5KSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG5cdCAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuXHQgKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG5cdCAqL1xuXHR2YXIgcmVtb3ZlVW5kZWZpbmVkID0gZnVuY3Rpb24gKG9iaikge1xuXHQgICAgcmV0dXJuIG9ialxuXHQgICAgICAgID8gT2JqZWN0LmVudHJpZXMob2JqKS5yZWR1Y2UoZnVuY3Rpb24gKGEsIF9hKSB7XG5cdCAgICAgICAgICAgIHZhciBrID0gX2FbMF0sIHYgPSBfYVsxXTtcblx0ICAgICAgICAgICAgcmV0dXJuICh2ID09PSB1bmRlZmluZWQgPyBhIDogKChhW2tdID0gdiksIGEpKTtcblx0ICAgICAgICB9LCB7fSlcblx0ICAgICAgICA6IHt9O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcblx0ICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG5cdCAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cblx0ICovXG5cdHZhciBpbmRleCA9IHtcblx0ICAgIGNhbGw6IGNhbGwsXG5cdCAgICBjbGFzc1NldDogY2xhc3NTZXQsXG5cdCAgICBjbG9zZXN0OiBjbG9zZXN0LFxuXHQgICAgZmV0Y2g6IGZldGNoLFxuXHQgICAgZm9ybWF0OiBmb3JtYXQsXG5cdCAgICBoYXNDbGFzczogaGFzQ2xhc3MsXG5cdCAgICBpc1ZhbGlkRGF0ZTogaXNWYWxpZERhdGUsXG5cdCAgICByZW1vdmVVbmRlZmluZWQ6IHJlbW92ZVVuZGVmaW5lZCxcblx0fTtcblxuXHRjanMkQi5QbHVnaW4gPSBQbHVnaW47XG5cdGNqcyRCLmFsZ29yaXRobXMgPSBpbmRleCQxO1xuXHRjanMkQi5mb3JtVmFsaWRhdGlvbiA9IGZvcm1WYWxpZGF0aW9uO1xuXHRjanMkQi51dGlscyA9IGluZGV4O1xuXHRyZXR1cm4gY2pzJEI7XG59XG5cbi8qKlxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgIGxpYiRCLmV4cG9ydHMgPSByZXF1aXJlSW5kZXhfbWluJEIoKTtcbn0gZWxzZSB7XG4gICAgbGliJEIuZXhwb3J0cyA9IHJlcXVpcmVDanMkQigpO1xufVxuXG52YXIgbGliRXhwb3J0cyRCID0gbGliJEIuZXhwb3J0cztcblxudmFyIGxpYiRBID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIGluZGV4X21pbiRBID0ge307XG5cbi8qKiBcbiAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG4gKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKlxuICogQGxpY2Vuc2UgaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pby9saWNlbnNlXG4gKiBAcGFja2FnZSBAZm9ybS12YWxpZGF0aW9uL3BsdWdpbi1hbGlhc1xuICogQHZlcnNpb24gMi40LjBcbiAqL1xuXG52YXIgaGFzUmVxdWlyZWRJbmRleF9taW4kQTtcblxuZnVuY3Rpb24gcmVxdWlyZUluZGV4X21pbiRBICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkSW5kZXhfbWluJEEpIHJldHVybiBpbmRleF9taW4kQTtcblx0aGFzUmVxdWlyZWRJbmRleF9taW4kQSA9IDE7XG52YXIgdD1saWJFeHBvcnRzJEIscj1mdW5jdGlvbih0LG8pe3JldHVybiByPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbih0LHIpe3QuX19wcm90b19fPXI7fXx8ZnVuY3Rpb24odCxyKXtmb3IodmFyIG8gaW4gcilPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocixvKSYmKHRbb109cltvXSk7fSxyKHQsbyl9O3ZhciBvPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG8ocil7dmFyIG89dC5jYWxsKHRoaXMscil8fHRoaXM7cmV0dXJuIG8ub3B0cz1yfHx7fSxvLnZhbGlkYXRvck5hbWVGaWx0ZXI9by5nZXRWYWxpZGF0b3JOYW1lLmJpbmQobyksb31yZXR1cm4gZnVuY3Rpb24odCxvKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBvJiZudWxsIT09byl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIitTdHJpbmcobykrXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtmdW5jdGlvbiBlKCl7dGhpcy5jb25zdHJ1Y3Rvcj10O31yKHQsbyksdC5wcm90b3R5cGU9bnVsbD09PW8/T2JqZWN0LmNyZWF0ZShvKTooZS5wcm90b3R5cGU9by5wcm90b3R5cGUsbmV3IGUpO30obyx0KSxvLnByb3RvdHlwZS5pbnN0YWxsPWZ1bmN0aW9uKCl7dGhpcy5jb3JlLnJlZ2lzdGVyRmlsdGVyKFwidmFsaWRhdG9yLW5hbWVcIix0aGlzLnZhbGlkYXRvck5hbWVGaWx0ZXIpO30sby5wcm90b3R5cGUudW5pbnN0YWxsPWZ1bmN0aW9uKCl7dGhpcy5jb3JlLmRlcmVnaXN0ZXJGaWx0ZXIoXCJ2YWxpZGF0b3ItbmFtZVwiLHRoaXMudmFsaWRhdG9yTmFtZUZpbHRlcik7fSxvLnByb3RvdHlwZS5nZXRWYWxpZGF0b3JOYW1lPWZ1bmN0aW9uKHQscil7cmV0dXJuIHRoaXMuaXNFbmFibGVkJiZ0aGlzLm9wdHNbdF18fHR9LG99KHQuUGx1Z2luKTtpbmRleF9taW4kQS5BbGlhcz1vO1xuXHRyZXR1cm4gaW5kZXhfbWluJEE7XG59XG5cbnZhciBjanMkQSA9IHt9O1xuXG52YXIgaGFzUmVxdWlyZWRDanMkQTtcblxuZnVuY3Rpb24gcmVxdWlyZUNqcyRBICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkQ2pzJEEpIHJldHVybiBjanMkQTtcblx0aGFzUmVxdWlyZWRDanMkQSA9IDE7XG5cblx0dmFyIGNvcmUgPSBsaWJFeHBvcnRzJEI7XG5cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5cdENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuXHRQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxuXHRwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5cdFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuXHRSRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuXHRBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcblx0SU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcblx0TE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuXHRPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblx0UEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuXHQqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cdC8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG5cdHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG5cdCAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcblx0ICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcblx0ICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG5cdCAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG5cdCAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG5cdCAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG5cdCAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG5cdCAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuXHQgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG5cdH1cblxuXHQvKipcblx0ICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG5cdCAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuXHQgKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG5cdCAqL1xuXHQvKipcblx0ICogVGhpcyBwbHVnaW4gYWxsb3dzIHRvIHVzZSBtdWx0aXBsZSBpbnN0YW5jZXMgb2YgdGhlIHNhbWUgdmFsaWRhdG9yIGJ5IGRlZmluaW5nIGFsaWFzLlxuXHQgKiBgYGBcblx0ICogIGZvcm1WYWxpZGF0aW9uKGZvcm0sIHtcblx0ICogICAgICBmaWVsZHM6IHtcblx0ICogICAgICAgICAgZW1haWw6IHtcblx0ICogICAgICAgICAgICAgIHZhbGlkYXRvcnM6IHtcblx0ICogICAgICAgICAgICAgICAgICByZXF1aXJlZDogLi4uLFxuXHQgKiAgICAgICAgICAgICAgICAgIHBhdHRlcm46IC4uLixcblx0ICogICAgICAgICAgICAgICAgICByZWdleHA6IC4uLlxuXHQgKiAgICAgICAgICAgICAgfVxuXHQgKiAgICAgICAgICB9XG5cdCAqICAgICAgfSxcblx0ICogICAgICBwbHVnaW5zOiB7XG5cdCAqICAgICAgICAgIGFsaWFzOiBuZXcgQWxpYXMoe1xuXHQgKiAgICAgICAgICAgICAgcmVxdWlyZWQ6ICdub3RFbXB0eScsXG5cdCAqICAgICAgICAgICAgICBwYXR0ZXJuOiAncmVnZXhwJ1xuXHQgKiAgICAgICAgICB9KVxuXHQgKiAgICAgIH1cblx0ICogIH0pXG5cdCAqIGBgYFxuXHQgKiBUaGVuLCB5b3UgY2FuIHVzZSB0aGUgYHJlcXVpcmVkYCwgYHBhdHRlcm5gIGFzIHRoZSBzYW1lIGFzIGBub3RFbXB0eWAsIGByZWdleHBgIHZhbGlkYXRvcnMuXG5cdCAqL1xuXHR2YXIgQWxpYXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoQWxpYXMsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBBbGlhcyhvcHRzKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0cykgfHwgdGhpcztcblx0ICAgICAgICBfdGhpcy5vcHRzID0gb3B0cyB8fCB7fTtcblx0ICAgICAgICBfdGhpcy52YWxpZGF0b3JOYW1lRmlsdGVyID0gX3RoaXMuZ2V0VmFsaWRhdG9yTmFtZS5iaW5kKF90aGlzKTtcblx0ICAgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICB9XG5cdCAgICBBbGlhcy5wcm90b3R5cGUuaW5zdGFsbCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLmNvcmUucmVnaXN0ZXJGaWx0ZXIoJ3ZhbGlkYXRvci1uYW1lJywgdGhpcy52YWxpZGF0b3JOYW1lRmlsdGVyKTtcblx0ICAgIH07XG5cdCAgICBBbGlhcy5wcm90b3R5cGUudW5pbnN0YWxsID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuY29yZS5kZXJlZ2lzdGVyRmlsdGVyKCd2YWxpZGF0b3ItbmFtZScsIHRoaXMudmFsaWRhdG9yTmFtZUZpbHRlcik7XG5cdCAgICB9O1xuXHQgICAgQWxpYXMucHJvdG90eXBlLmdldFZhbGlkYXRvck5hbWUgPSBmdW5jdGlvbiAodmFsaWRhdG9yTmFtZSwgX2ZpZWxkKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuaXNFbmFibGVkID8gdGhpcy5vcHRzW3ZhbGlkYXRvck5hbWVdIHx8IHZhbGlkYXRvck5hbWUgOiB2YWxpZGF0b3JOYW1lO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBBbGlhcztcblx0fShjb3JlLlBsdWdpbikpO1xuXG5cdGNqcyRBLkFsaWFzID0gQWxpYXM7XG5cdHJldHVybiBjanMkQTtcbn1cblxuLyoqXG4gKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcbiAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgbGliJEEuZXhwb3J0cyA9IHJlcXVpcmVJbmRleF9taW4kQSgpO1xufSBlbHNlIHtcbiAgICBsaWIkQS5leHBvcnRzID0gcmVxdWlyZUNqcyRBKCk7XG59XG5cbnZhciBsaWJFeHBvcnRzJEEgPSBsaWIkQS5leHBvcnRzO1xuXG52YXIgbGliJHogPSB7ZXhwb3J0czoge319O1xuXG52YXIgaW5kZXhfbWluJHogPSB7fTtcblxuLyoqIFxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqXG4gKiBAbGljZW5zZSBodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvL2xpY2Vuc2VcbiAqIEBwYWNrYWdlIEBmb3JtLXZhbGlkYXRpb24vcGx1Z2luLWFyaWFcbiAqIEB2ZXJzaW9uIDIuNC4wXG4gKi9cblxudmFyIGhhc1JlcXVpcmVkSW5kZXhfbWluJHo7XG5cbmZ1bmN0aW9uIHJlcXVpcmVJbmRleF9taW4keiAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEluZGV4X21pbiR6KSByZXR1cm4gaW5kZXhfbWluJHo7XG5cdGhhc1JlcXVpcmVkSW5kZXhfbWluJHogPSAxO1xudmFyIGU9bGliRXhwb3J0cyRCLHQ9ZnVuY3Rpb24oZSxpKXtyZXR1cm4gdD1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24oZSx0KXtlLl9fcHJvdG9fXz10O318fGZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBpIGluIHQpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsaSkmJihlW2ldPXRbaV0pO30sdChlLGkpfTt2YXIgaT1mdW5jdGlvbihlKXtmdW5jdGlvbiBpKCl7dmFyIHQ9ZS5jYWxsKHRoaXMse30pfHx0aGlzO3JldHVybiB0LmVsZW1lbnRWYWxpZGF0ZWRIYW5kbGVyPXQub25FbGVtZW50VmFsaWRhdGVkLmJpbmQodCksdC5maWVsZFZhbGlkSGFuZGxlcj10Lm9uRmllbGRWYWxpZC5iaW5kKHQpLHQuZmllbGRJbnZhbGlkSGFuZGxlcj10Lm9uRmllbGRJbnZhbGlkLmJpbmQodCksdC5tZXNzYWdlRGlzcGxheWVkSGFuZGxlcj10Lm9uTWVzc2FnZURpc3BsYXllZC5iaW5kKHQpLHR9cmV0dXJuIGZ1bmN0aW9uKGUsaSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgaSYmbnVsbCE9PWkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIrU3RyaW5nKGkpK1wiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7ZnVuY3Rpb24gbigpe3RoaXMuY29uc3RydWN0b3I9ZTt9dChlLGkpLGUucHJvdG90eXBlPW51bGw9PT1pP09iamVjdC5jcmVhdGUoaSk6KG4ucHJvdG90eXBlPWkucHJvdG90eXBlLG5ldyBuKTt9KGksZSksaS5wcm90b3R5cGUuaW5zdGFsbD1mdW5jdGlvbigpe3RoaXMuY29yZS5vbihcImNvcmUuZmllbGQudmFsaWRcIix0aGlzLmZpZWxkVmFsaWRIYW5kbGVyKS5vbihcImNvcmUuZmllbGQuaW52YWxpZFwiLHRoaXMuZmllbGRJbnZhbGlkSGFuZGxlcikub24oXCJjb3JlLmVsZW1lbnQudmFsaWRhdGVkXCIsdGhpcy5lbGVtZW50VmFsaWRhdGVkSGFuZGxlcikub24oXCJwbHVnaW5zLm1lc3NhZ2UuZGlzcGxheWVkXCIsdGhpcy5tZXNzYWdlRGlzcGxheWVkSGFuZGxlcik7fSxpLnByb3RvdHlwZS51bmluc3RhbGw9ZnVuY3Rpb24oKXt0aGlzLmNvcmUub2ZmKFwiY29yZS5maWVsZC52YWxpZFwiLHRoaXMuZmllbGRWYWxpZEhhbmRsZXIpLm9mZihcImNvcmUuZmllbGQuaW52YWxpZFwiLHRoaXMuZmllbGRJbnZhbGlkSGFuZGxlcikub2ZmKFwiY29yZS5lbGVtZW50LnZhbGlkYXRlZFwiLHRoaXMuZWxlbWVudFZhbGlkYXRlZEhhbmRsZXIpLm9mZihcInBsdWdpbnMubWVzc2FnZS5kaXNwbGF5ZWRcIix0aGlzLm1lc3NhZ2VEaXNwbGF5ZWRIYW5kbGVyKTt9LGkucHJvdG90eXBlLm9uRWxlbWVudFZhbGlkYXRlZD1mdW5jdGlvbihlKXtlLnZhbGlkJiYoZS5lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtaW52YWxpZFwiLFwiZmFsc2VcIiksZS5lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtZGVzY3JpYmVkYnlcIikpO30saS5wcm90b3R5cGUub25GaWVsZFZhbGlkPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuY29yZS5nZXRFbGVtZW50cyhlKTt0JiZ0LmZvckVhY2goKGZ1bmN0aW9uKGUpe2Uuc2V0QXR0cmlidXRlKFwiYXJpYS1pbnZhbGlkXCIsXCJmYWxzZVwiKSxlLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtZGVzY3JpYmVkYnlcIik7fSkpO30saS5wcm90b3R5cGUub25GaWVsZEludmFsaWQ9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5jb3JlLmdldEVsZW1lbnRzKGUpO3QmJnQuZm9yRWFjaCgoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc2V0QXR0cmlidXRlKFwiYXJpYS1pbnZhbGlkXCIsXCJ0cnVlXCIpfSkpO30saS5wcm90b3R5cGUub25NZXNzYWdlRGlzcGxheWVkPWZ1bmN0aW9uKGUpe2UubWVzc2FnZUVsZW1lbnQuc2V0QXR0cmlidXRlKFwicm9sZVwiLFwiYWxlcnRcIiksZS5tZXNzYWdlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLFwiZmFsc2VcIik7dmFyIHQ9dGhpcy5jb3JlLmdldEVsZW1lbnRzKGUuZmllbGQpLGk9dC5pbmRleE9mKGUuZWxlbWVudCksbj1cImpzLWZ2LVwiLmNvbmNhdChlLmZpZWxkLFwiLVwiKS5jb25jYXQoaSxcIi1cIikuY29uY2F0KERhdGUubm93KCksXCItbWVzc2FnZVwiKTtlLm1lc3NhZ2VFbGVtZW50LnNldEF0dHJpYnV0ZShcImlkXCIsbiksZS5lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtZGVzY3JpYmVkYnlcIixuKTt2YXIgYT1lLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidHlwZVwiKTtcInJhZGlvXCIhPT1hJiZcImNoZWNrYm94XCIhPT1hfHx0LmZvckVhY2goKGZ1bmN0aW9uKGUpe3JldHVybiBlLnNldEF0dHJpYnV0ZShcImFyaWEtZGVzY3JpYmVkYnlcIixuKX0pKTt9LGl9KGUuUGx1Z2luKTtpbmRleF9taW4kei5BcmlhPWk7XG5cdHJldHVybiBpbmRleF9taW4kejtcbn1cblxudmFyIGNqcyR6ID0ge307XG5cbnZhciBoYXNSZXF1aXJlZENqcyR6O1xuXG5mdW5jdGlvbiByZXF1aXJlQ2pzJHogKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRDanMkeikgcmV0dXJuIGNqcyR6O1xuXHRoYXNSZXF1aXJlZENqcyR6ID0gMTtcblxuXHR2YXIgY29yZSA9IGxpYkV4cG9ydHMkQjtcblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblx0Q29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5cdFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5cdHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblx0VEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5cdFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5cdEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuXHRJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuXHRMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5cdE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuXHRQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG5cdCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblx0LyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcblx0dmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcblx0ICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuXHQgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuXHQgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcblx0ICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcblx0ICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcblx0ICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcblx0ICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcblx0ICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG5cdCAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcblx0fVxuXG5cdC8qKlxuXHQgKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcblx0ICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG5cdCAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cblx0ICovXG5cdC8qKlxuXHQgKiBUaGlzIHBsdWdpbiBhZGRzIEFSSUEgYXR0cmlidXRlcyBiYXNlZCBvbiB0aGUgZmllbGQgdmFsaWRpdHkuXG5cdCAqIFRoZSBsaXN0IGluY2x1ZGU6XG5cdCAqICAtIGBhcmlhLWludmFsaWRgLCBgYXJpYS1kZXNjcmliZWRieWAgZm9yIGZpZWxkIGVsZW1lbnRcblx0ICogIC0gYGFyaWEtaGlkZGVuYCwgYHJvbGVgIGZvciBhc3NvY2lhdGVkIG1lc3NhZ2UgZWxlbWVudFxuXHQgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FjY2Vzc2liaWxpdHkvQVJJQS9BUklBX1RlY2huaXF1ZXNcblx0ICovXG5cdHZhciBBcmlhID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKEFyaWEsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBBcmlhKCkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHt9KSB8fCB0aGlzO1xuXHQgICAgICAgIF90aGlzLmVsZW1lbnRWYWxpZGF0ZWRIYW5kbGVyID0gX3RoaXMub25FbGVtZW50VmFsaWRhdGVkLmJpbmQoX3RoaXMpO1xuXHQgICAgICAgIF90aGlzLmZpZWxkVmFsaWRIYW5kbGVyID0gX3RoaXMub25GaWVsZFZhbGlkLmJpbmQoX3RoaXMpO1xuXHQgICAgICAgIF90aGlzLmZpZWxkSW52YWxpZEhhbmRsZXIgPSBfdGhpcy5vbkZpZWxkSW52YWxpZC5iaW5kKF90aGlzKTtcblx0ICAgICAgICBfdGhpcy5tZXNzYWdlRGlzcGxheWVkSGFuZGxlciA9IF90aGlzLm9uTWVzc2FnZURpc3BsYXllZC5iaW5kKF90aGlzKTtcblx0ICAgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICB9XG5cdCAgICBBcmlhLnByb3RvdHlwZS5pbnN0YWxsID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuY29yZVxuXHQgICAgICAgICAgICAub24oJ2NvcmUuZmllbGQudmFsaWQnLCB0aGlzLmZpZWxkVmFsaWRIYW5kbGVyKVxuXHQgICAgICAgICAgICAub24oJ2NvcmUuZmllbGQuaW52YWxpZCcsIHRoaXMuZmllbGRJbnZhbGlkSGFuZGxlcilcblx0ICAgICAgICAgICAgLm9uKCdjb3JlLmVsZW1lbnQudmFsaWRhdGVkJywgdGhpcy5lbGVtZW50VmFsaWRhdGVkSGFuZGxlcilcblx0ICAgICAgICAgICAgLm9uKCdwbHVnaW5zLm1lc3NhZ2UuZGlzcGxheWVkJywgdGhpcy5tZXNzYWdlRGlzcGxheWVkSGFuZGxlcik7XG5cdCAgICB9O1xuXHQgICAgQXJpYS5wcm90b3R5cGUudW5pbnN0YWxsID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuY29yZVxuXHQgICAgICAgICAgICAub2ZmKCdjb3JlLmZpZWxkLnZhbGlkJywgdGhpcy5maWVsZFZhbGlkSGFuZGxlcilcblx0ICAgICAgICAgICAgLm9mZignY29yZS5maWVsZC5pbnZhbGlkJywgdGhpcy5maWVsZEludmFsaWRIYW5kbGVyKVxuXHQgICAgICAgICAgICAub2ZmKCdjb3JlLmVsZW1lbnQudmFsaWRhdGVkJywgdGhpcy5lbGVtZW50VmFsaWRhdGVkSGFuZGxlcilcblx0ICAgICAgICAgICAgLm9mZigncGx1Z2lucy5tZXNzYWdlLmRpc3BsYXllZCcsIHRoaXMubWVzc2FnZURpc3BsYXllZEhhbmRsZXIpO1xuXHQgICAgfTtcblx0ICAgIEFyaWEucHJvdG90eXBlLm9uRWxlbWVudFZhbGlkYXRlZCA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgaWYgKGUudmFsaWQpIHtcblx0ICAgICAgICAgICAgZS5lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1pbnZhbGlkJywgJ2ZhbHNlJyk7XG5cdCAgICAgICAgICAgIGUuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgQXJpYS5wcm90b3R5cGUub25GaWVsZFZhbGlkID0gZnVuY3Rpb24gKGZpZWxkKSB7XG5cdCAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5jb3JlLmdldEVsZW1lbnRzKGZpZWxkKTtcblx0ICAgICAgICBpZiAoZWxlbWVudHMpIHtcblx0ICAgICAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG5cdCAgICAgICAgICAgICAgICBlbGUuc2V0QXR0cmlidXRlKCdhcmlhLWludmFsaWQnLCAnZmFsc2UnKTtcblx0ICAgICAgICAgICAgICAgIGVsZS5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknKTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIEFyaWEucHJvdG90eXBlLm9uRmllbGRJbnZhbGlkID0gZnVuY3Rpb24gKGZpZWxkKSB7XG5cdCAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5jb3JlLmdldEVsZW1lbnRzKGZpZWxkKTtcblx0ICAgICAgICBpZiAoZWxlbWVudHMpIHtcblx0ICAgICAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7IHJldHVybiBlbGUuc2V0QXR0cmlidXRlKCdhcmlhLWludmFsaWQnLCAndHJ1ZScpOyB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgQXJpYS5wcm90b3R5cGUub25NZXNzYWdlRGlzcGxheWVkID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICBlLm1lc3NhZ2VFbGVtZW50LnNldEF0dHJpYnV0ZSgncm9sZScsICdhbGVydCcpO1xuXHQgICAgICAgIGUubWVzc2FnZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICdmYWxzZScpO1xuXHQgICAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuY29yZS5nZXRFbGVtZW50cyhlLmZpZWxkKTtcblx0ICAgICAgICB2YXIgaW5kZXggPSBlbGVtZW50cy5pbmRleE9mKGUuZWxlbWVudCk7XG5cdCAgICAgICAgdmFyIGlkID0gXCJqcy1mdi1cIi5jb25jYXQoZS5maWVsZCwgXCItXCIpLmNvbmNhdChpbmRleCwgXCItXCIpLmNvbmNhdChEYXRlLm5vdygpLCBcIi1tZXNzYWdlXCIpO1xuXHQgICAgICAgIGUubWVzc2FnZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIGlkKTtcblx0ICAgICAgICBlLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5JywgaWQpO1xuXHQgICAgICAgIHZhciB0eXBlID0gZS5lbGVtZW50LmdldEF0dHJpYnV0ZSgndHlwZScpO1xuXHQgICAgICAgIGlmICgncmFkaW8nID09PSB0eXBlIHx8ICdjaGVja2JveCcgPT09IHR5cGUpIHtcblx0ICAgICAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7IHJldHVybiBlbGUuc2V0QXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5JywgaWQpOyB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIEFyaWE7XG5cdH0oY29yZS5QbHVnaW4pKTtcblxuXHRjanMkei5BcmlhID0gQXJpYTtcblx0cmV0dXJuIGNqcyR6O1xufVxuXG4vKipcbiAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG4gKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICBsaWIkei5leHBvcnRzID0gcmVxdWlyZUluZGV4X21pbiR6KCk7XG59IGVsc2Uge1xuICAgIGxpYiR6LmV4cG9ydHMgPSByZXF1aXJlQ2pzJHooKTtcbn1cblxudmFyIGxpYkV4cG9ydHMkeiA9IGxpYiR6LmV4cG9ydHM7XG5cbnZhciBsaWIkeSA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBpbmRleF9taW4keSA9IHt9O1xuXG4vKiogXG4gKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcbiAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuICpcbiAqIEBsaWNlbnNlIGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8vbGljZW5zZVxuICogQHBhY2thZ2UgQGZvcm0tdmFsaWRhdGlvbi9wbHVnaW4tZGVjbGFyYXRpdmVcbiAqIEB2ZXJzaW9uIDIuNC4wXG4gKi9cblxudmFyIGhhc1JlcXVpcmVkSW5kZXhfbWluJHk7XG5cbmZ1bmN0aW9uIHJlcXVpcmVJbmRleF9taW4keSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEluZGV4X21pbiR5KSByZXR1cm4gaW5kZXhfbWluJHk7XG5cdGhhc1JlcXVpcmVkSW5kZXhfbWluJHkgPSAxO1xudmFyIGU9bGliRXhwb3J0cyRCLHQ9ZnVuY3Rpb24oZSxhKXtyZXR1cm4gdD1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24oZSx0KXtlLl9fcHJvdG9fXz10O318fGZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBhIGluIHQpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsYSkmJihlW2FdPXRbYV0pO30sdChlLGEpfTt2YXIgYT1mdW5jdGlvbihlKXtmdW5jdGlvbiBhKHQpe3ZhciBhPWUuY2FsbCh0aGlzLHQpfHx0aGlzO3JldHVybiBhLmFkZGVkRmllbGRzPW5ldyBNYXAsYS5vcHRzPU9iamVjdC5hc3NpZ24oe30se2h0bWw1SW5wdXQ6ITEscGx1Z2luUHJlZml4OlwiZGF0YS1mdnAtXCIscHJlZml4OlwiZGF0YS1mdi1cIn0sdCksYS5maWVsZEFkZGVkSGFuZGxlcj1hLm9uRmllbGRBZGRlZC5iaW5kKGEpLGEuZmllbGRSZW1vdmVkSGFuZGxlcj1hLm9uRmllbGRSZW1vdmVkLmJpbmQoYSksYX1yZXR1cm4gZnVuY3Rpb24oZSxhKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBhJiZudWxsIT09YSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIitTdHJpbmcoYSkrXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtmdW5jdGlvbiByKCl7dGhpcy5jb25zdHJ1Y3Rvcj1lO310KGUsYSksZS5wcm90b3R5cGU9bnVsbD09PWE/T2JqZWN0LmNyZWF0ZShhKTooci5wcm90b3R5cGU9YS5wcm90b3R5cGUsbmV3IHIpO30oYSxlKSxhLnByb3RvdHlwZS5pbnN0YWxsPWZ1bmN0aW9uKCl7dmFyIGU9dGhpczt0aGlzLnBhcnNlUGx1Z2lucygpO3ZhciB0PXRoaXMucGFyc2VPcHRpb25zKCk7T2JqZWN0LmtleXModCkuZm9yRWFjaCgoZnVuY3Rpb24oYSl7ZS5hZGRlZEZpZWxkcy5oYXMoYSl8fGUuYWRkZWRGaWVsZHMuc2V0KGEsITApLGUuY29yZS5hZGRGaWVsZChhLHRbYV0pO30pKSx0aGlzLmNvcmUub24oXCJjb3JlLmZpZWxkLmFkZGVkXCIsdGhpcy5maWVsZEFkZGVkSGFuZGxlcikub24oXCJjb3JlLmZpZWxkLnJlbW92ZWRcIix0aGlzLmZpZWxkUmVtb3ZlZEhhbmRsZXIpO30sYS5wcm90b3R5cGUudW5pbnN0YWxsPWZ1bmN0aW9uKCl7dGhpcy5hZGRlZEZpZWxkcy5jbGVhcigpLHRoaXMuY29yZS5vZmYoXCJjb3JlLmZpZWxkLmFkZGVkXCIsdGhpcy5maWVsZEFkZGVkSGFuZGxlcikub2ZmKFwiY29yZS5maWVsZC5yZW1vdmVkXCIsdGhpcy5maWVsZFJlbW92ZWRIYW5kbGVyKTt9LGEucHJvdG90eXBlLm9uRmllbGRBZGRlZD1mdW5jdGlvbihlKXt2YXIgdD10aGlzLGE9ZS5lbGVtZW50czthJiYwIT09YS5sZW5ndGgmJiF0aGlzLmFkZGVkRmllbGRzLmhhcyhlLmZpZWxkKSYmKHRoaXMuYWRkZWRGaWVsZHMuc2V0KGUuZmllbGQsITApLGEuZm9yRWFjaCgoZnVuY3Rpb24oYSl7dmFyIHI9dC5wYXJzZUVsZW1lbnQoYSk7aWYoIXQuaXNFbXB0eU9wdGlvbihyKSl7dmFyIG49e3NlbGVjdG9yOmUub3B0aW9ucy5zZWxlY3Rvcix2YWxpZGF0b3JzOk9iamVjdC5hc3NpZ24oe30sZS5vcHRpb25zLnZhbGlkYXRvcnN8fHt9LHIudmFsaWRhdG9ycyl9O3QuY29yZS5zZXRGaWVsZE9wdGlvbnMoZS5maWVsZCxuKTt9fSkpKTt9LGEucHJvdG90eXBlLm9uRmllbGRSZW1vdmVkPWZ1bmN0aW9uKGUpe2UuZmllbGQmJnRoaXMuYWRkZWRGaWVsZHMuaGFzKGUuZmllbGQpJiZ0aGlzLmFkZGVkRmllbGRzLmRlbGV0ZShlLmZpZWxkKTt9LGEucHJvdG90eXBlLnBhcnNlT3B0aW9ucz1mdW5jdGlvbigpe3ZhciBlPXRoaXMsdD10aGlzLm9wdHMucHJlZml4LGE9e30scj10aGlzLmNvcmUuZ2V0RmllbGRzKCksbj10aGlzLmNvcmUuZ2V0Rm9ybUVsZW1lbnQoKTtyZXR1cm4gW10uc2xpY2UuY2FsbChuLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbmFtZV0sIFtcIi5jb25jYXQodCxcImZpZWxkXVwiKSkpLmZvckVhY2goKGZ1bmN0aW9uKHIpe3ZhciBuPWUucGFyc2VFbGVtZW50KHIpO2lmKCFlLmlzRW1wdHlPcHRpb24obikpe3ZhciBpPXIuZ2V0QXR0cmlidXRlKFwibmFtZVwiKXx8ci5nZXRBdHRyaWJ1dGUoXCJcIi5jb25jYXQodCxcImZpZWxkXCIpKTthW2ldPU9iamVjdC5hc3NpZ24oe30sYVtpXSxuKTt9fSkpLE9iamVjdC5rZXlzKGEpLmZvckVhY2goKGZ1bmN0aW9uKGUpe09iamVjdC5rZXlzKGFbZV0udmFsaWRhdG9ycykuZm9yRWFjaCgoZnVuY3Rpb24odCl7YVtlXS52YWxpZGF0b3JzW3RdLmVuYWJsZWQ9YVtlXS52YWxpZGF0b3JzW3RdLmVuYWJsZWR8fCExLHJbZV0mJnJbZV0udmFsaWRhdG9ycyYmcltlXS52YWxpZGF0b3JzW3RdJiZPYmplY3QuYXNzaWduKGFbZV0udmFsaWRhdG9yc1t0XSxyW2VdLnZhbGlkYXRvcnNbdF0pO30pKTt9KSksT2JqZWN0LmFzc2lnbih7fSxyLGEpfSxhLnByb3RvdHlwZS5jcmVhdGVQbHVnaW5JbnN0YW5jZT1mdW5jdGlvbihlLHQpe2Zvcih2YXIgYT1lLnNwbGl0KFwiLlwiKSxyPXdpbmRvd3x8dGhpcyxuPTAsaT1hLmxlbmd0aDtuPGk7bisrKXI9clthW25dXTtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiByKXRocm93IG5ldyBFcnJvcihcInRoZSBwbHVnaW4gXCIuY29uY2F0KGUsXCIgZG9lc24ndCBleGlzdFwiKSk7cmV0dXJuIG5ldyByKHQpfSxhLnByb3RvdHlwZS5wYXJzZVBsdWdpbnM9ZnVuY3Rpb24oKXtmb3IodmFyIGUsdD10aGlzLGE9dGhpcy5jb3JlLmdldEZvcm1FbGVtZW50KCkscj1uZXcgUmVnRXhwKFwiXlwiLmNvbmNhdCh0aGlzLm9wdHMucGx1Z2luUHJlZml4LFwiKFthLXowLTktXSspKF9fXykqKFthLXowLTktXSspKiRcIikpLG49YS5hdHRyaWJ1dGVzLmxlbmd0aCxpPXt9LHM9MDtzPG47cysrKXt2YXIgbz1hLmF0dHJpYnV0ZXNbc10ubmFtZSxsPWEuYXR0cmlidXRlc1tzXS52YWx1ZSxkPXIuZXhlYyhvKTtpZihkJiY0PT09ZC5sZW5ndGgpe3ZhciBjPXRoaXMudG9DYW1lbENhc2UoZFsxXSk7aVtjXT1PYmplY3QuYXNzaWduKHt9LGRbM10/KChlPXt9KVt0aGlzLnRvQ2FtZWxDYXNlKGRbM10pXT1sLGUpOntlbmFibGVkOlwiXCI9PT1sfHxcInRydWVcIj09PWx9LGlbY10pO319T2JqZWN0LmtleXMoaSkuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dmFyIGE9aVtlXSxyPWEuZW5hYmxlZCxuPWEuY2xhc3M7aWYociYmbil7ZGVsZXRlIGEuZW5hYmxlZCxkZWxldGUgYS5jbGF6ejt2YXIgcz10LmNyZWF0ZVBsdWdpbkluc3RhbmNlKG4sYSk7dC5jb3JlLnJlZ2lzdGVyUGx1Z2luKGUscyk7fX0pKTt9LGEucHJvdG90eXBlLmlzRW1wdHlPcHRpb249ZnVuY3Rpb24oZSl7dmFyIHQ9ZS52YWxpZGF0b3JzO3JldHVybiAwPT09T2JqZWN0LmtleXModCkubGVuZ3RoJiZ0LmNvbnN0cnVjdG9yPT09T2JqZWN0fSxhLnByb3RvdHlwZS5wYXJzZUVsZW1lbnQ9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PW5ldyBSZWdFeHAoXCJeXCIuY29uY2F0KHRoaXMub3B0cy5wcmVmaXgsXCIoW2EtejAtOS1dKykoX19fKSooW2EtejAtOS1dKykqJFwiKSksYT1lLmF0dHJpYnV0ZXMubGVuZ3RoLHI9e30sbj1lLmdldEF0dHJpYnV0ZShcInR5cGVcIiksaT0wO2k8YTtpKyspe3ZhciBzPWUuYXR0cmlidXRlc1tpXS5uYW1lLG89ZS5hdHRyaWJ1dGVzW2ldLnZhbHVlO2lmKHRoaXMub3B0cy5odG1sNUlucHV0KXN3aXRjaCghMCl7Y2FzZVwibWlubGVuZ3RoXCI9PT1zOnIuc3RyaW5nTGVuZ3RoPU9iamVjdC5hc3NpZ24oe30se2VuYWJsZWQ6ITAsbWluOnBhcnNlSW50KG8sMTApfSxyLnN0cmluZ0xlbmd0aCk7YnJlYWs7Y2FzZVwibWF4bGVuZ3RoXCI9PT1zOnIuc3RyaW5nTGVuZ3RoPU9iamVjdC5hc3NpZ24oe30se2VuYWJsZWQ6ITAsbWF4OnBhcnNlSW50KG8sMTApfSxyLnN0cmluZ0xlbmd0aCk7YnJlYWs7Y2FzZVwicGF0dGVyblwiPT09czpyLnJlZ2V4cD1PYmplY3QuYXNzaWduKHt9LHtlbmFibGVkOiEwLHJlZ2V4cDpvfSxyLnJlZ2V4cCk7YnJlYWs7Y2FzZVwicmVxdWlyZWRcIj09PXM6ci5ub3RFbXB0eT1PYmplY3QuYXNzaWduKHt9LHtlbmFibGVkOiEwfSxyLm5vdEVtcHR5KTticmVhaztjYXNlXCJ0eXBlXCI9PT1zJiZcImNvbG9yXCI9PT1vOnIuY29sb3I9T2JqZWN0LmFzc2lnbih7fSx7ZW5hYmxlZDohMCx0eXBlOlwiaGV4XCJ9LHIuY29sb3IpO2JyZWFrO2Nhc2VcInR5cGVcIj09PXMmJlwiZW1haWxcIj09PW86ci5lbWFpbEFkZHJlc3M9T2JqZWN0LmFzc2lnbih7fSx7ZW5hYmxlZDohMH0sci5lbWFpbEFkZHJlc3MpO2JyZWFrO2Nhc2VcInR5cGVcIj09PXMmJlwidXJsXCI9PT1vOnIudXJpPU9iamVjdC5hc3NpZ24oe30se2VuYWJsZWQ6ITB9LHIudXJpKTticmVhaztjYXNlXCJ0eXBlXCI9PT1zJiZcInJhbmdlXCI9PT1vOnIuYmV0d2Vlbj1PYmplY3QuYXNzaWduKHt9LHtlbmFibGVkOiEwLG1heDpwYXJzZUZsb2F0KGUuZ2V0QXR0cmlidXRlKFwibWF4XCIpKSxtaW46cGFyc2VGbG9hdChlLmdldEF0dHJpYnV0ZShcIm1pblwiKSl9LHIuYmV0d2Vlbik7YnJlYWs7Y2FzZVwibWluXCI9PT1zJiZcImRhdGVcIiE9PW4mJlwicmFuZ2VcIiE9PW46ci5ncmVhdGVyVGhhbj1PYmplY3QuYXNzaWduKHt9LHtlbmFibGVkOiEwLG1pbjpwYXJzZUZsb2F0KG8pfSxyLmdyZWF0ZXJUaGFuKTticmVhaztjYXNlXCJtYXhcIj09PXMmJlwiZGF0ZVwiIT09biYmXCJyYW5nZVwiIT09bjpyLmxlc3NUaGFuPU9iamVjdC5hc3NpZ24oe30se2VuYWJsZWQ6ITAsbWF4OnBhcnNlRmxvYXQobyl9LHIubGVzc1RoYW4pO312YXIgbD10LmV4ZWMocyk7aWYobCYmND09PWwubGVuZ3RoKXt2YXIgZD10aGlzLnRvQ2FtZWxDYXNlKGxbMV0pO3JbZF18fChyW2RdPXt9KSxsWzNdP3JbZF1bdGhpcy50b0NhbWVsQ2FzZShsWzNdKV09dGhpcy5ub3JtYWxpemVWYWx1ZShvKTohMD09PXJbZF0uZW5hYmxlZCYmITE9PT1yW2RdLmVuYWJsZWR8fChyW2RdLmVuYWJsZWQ9XCJcIj09PW98fFwidHJ1ZVwiPT09byk7fX1yZXR1cm4ge3ZhbGlkYXRvcnM6cn19LGEucHJvdG90eXBlLm5vcm1hbGl6ZVZhbHVlPWZ1bmN0aW9uKGUpe3JldHVybiBcInRydWVcIj09PWV8fFwiXCI9PT1lfHxcImZhbHNlXCIhPT1lJiZlfSxhLnByb3RvdHlwZS50b1VwcGVyQ2FzZT1mdW5jdGlvbihlKXtyZXR1cm4gZS5jaGFyQXQoMSkudG9VcHBlckNhc2UoKX0sYS5wcm90b3R5cGUudG9DYW1lbENhc2U9ZnVuY3Rpb24oZSl7cmV0dXJuIGUucmVwbGFjZSgvLS4vZyx0aGlzLnRvVXBwZXJDYXNlKX0sYX0oZS5QbHVnaW4pO2luZGV4X21pbiR5LkRlY2xhcmF0aXZlPWE7XG5cdHJldHVybiBpbmRleF9taW4keTtcbn1cblxudmFyIGNqcyR5ID0ge307XG5cbnZhciBoYXNSZXF1aXJlZENqcyR5O1xuXG5mdW5jdGlvbiByZXF1aXJlQ2pzJHkgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRDanMkeSkgcmV0dXJuIGNqcyR5O1xuXHRoYXNSZXF1aXJlZENqcyR5ID0gMTtcblxuXHR2YXIgY29yZSA9IGxpYkV4cG9ydHMkQjtcblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblx0Q29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5cdFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5cdHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblx0VEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5cdFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5cdEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuXHRJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuXHRMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5cdE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuXHRQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG5cdCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblx0LyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcblx0dmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcblx0ICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuXHQgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuXHQgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcblx0ICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcblx0ICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcblx0ICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcblx0ICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcblx0ICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG5cdCAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcblx0fVxuXG5cdC8qKlxuXHQgKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcblx0ICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG5cdCAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cblx0ICovXG5cdC8qKlxuXHQgKiBUaGlzIHBsdWdpbiBwcm92aWRlcyB0aGUgYWJpbGl0eSBvZiBkZWNsYXJpbmcgdmFsaWRhdG9yIG9wdGlvbnMgdmlhIEhUTUwgYXR0cmlidXRlcy5cblx0ICogQWxsIGF0dHJpYnV0ZXMgYXJlIGRlY2xhcmVkIGluIGxvd2VyY2FzZVxuXHQgKiBgYGBcblx0ICogIDxpbnB1dFxuXHQgKiAgICAgIGRhdGEtZnYtZmllbGQ9XCIke2ZpZWxkTmFtZX1cIlxuXHQgKiAgICAgIGRhdGEtZnYte3ZhbGlkYXRvcn09XCJ0cnVlXCJcblx0ICogICAgICBkYXRhLWZ2LXt2YWxpZGF0b3J9X19fe29wdGlvbn09XCIuLi5cIiAvPlxuXHQgKiBgYGBcblx0ICovXG5cdHZhciBEZWNsYXJhdGl2ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhEZWNsYXJhdGl2ZSwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIERlY2xhcmF0aXZlKG9wdHMpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRzKSB8fCB0aGlzO1xuXHQgICAgICAgIF90aGlzLmFkZGVkRmllbGRzID0gbmV3IE1hcCgpO1xuXHQgICAgICAgIF90aGlzLm9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCB7XG5cdCAgICAgICAgICAgIGh0bWw1SW5wdXQ6IGZhbHNlLFxuXHQgICAgICAgICAgICBwbHVnaW5QcmVmaXg6ICdkYXRhLWZ2cC0nLFxuXHQgICAgICAgICAgICBwcmVmaXg6ICdkYXRhLWZ2LScsXG5cdCAgICAgICAgfSwgb3B0cyk7XG5cdCAgICAgICAgX3RoaXMuZmllbGRBZGRlZEhhbmRsZXIgPSBfdGhpcy5vbkZpZWxkQWRkZWQuYmluZChfdGhpcyk7XG5cdCAgICAgICAgX3RoaXMuZmllbGRSZW1vdmVkSGFuZGxlciA9IF90aGlzLm9uRmllbGRSZW1vdmVkLmJpbmQoX3RoaXMpO1xuXHQgICAgICAgIHJldHVybiBfdGhpcztcblx0ICAgIH1cblx0ICAgIERlY2xhcmF0aXZlLnByb3RvdHlwZS5pbnN0YWxsID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgLy8gUGFyc2UgdGhlIHBsdWdpbiBvcHRpb25zXG5cdCAgICAgICAgdGhpcy5wYXJzZVBsdWdpbnMoKTtcblx0ICAgICAgICB2YXIgb3B0cyA9IHRoaXMucGFyc2VPcHRpb25zKCk7XG5cdCAgICAgICAgT2JqZWN0LmtleXMob3B0cykuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcblx0ICAgICAgICAgICAgaWYgKCFfdGhpcy5hZGRlZEZpZWxkcy5oYXMoZmllbGQpKSB7XG5cdCAgICAgICAgICAgICAgICBfdGhpcy5hZGRlZEZpZWxkcy5zZXQoZmllbGQsIHRydWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIF90aGlzLmNvcmUuYWRkRmllbGQoZmllbGQsIG9wdHNbZmllbGRdKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICB0aGlzLmNvcmUub24oJ2NvcmUuZmllbGQuYWRkZWQnLCB0aGlzLmZpZWxkQWRkZWRIYW5kbGVyKS5vbignY29yZS5maWVsZC5yZW1vdmVkJywgdGhpcy5maWVsZFJlbW92ZWRIYW5kbGVyKTtcblx0ICAgIH07XG5cdCAgICBEZWNsYXJhdGl2ZS5wcm90b3R5cGUudW5pbnN0YWxsID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuYWRkZWRGaWVsZHMuY2xlYXIoKTtcblx0ICAgICAgICB0aGlzLmNvcmUub2ZmKCdjb3JlLmZpZWxkLmFkZGVkJywgdGhpcy5maWVsZEFkZGVkSGFuZGxlcikub2ZmKCdjb3JlLmZpZWxkLnJlbW92ZWQnLCB0aGlzLmZpZWxkUmVtb3ZlZEhhbmRsZXIpO1xuXHQgICAgfTtcblx0ICAgIERlY2xhcmF0aXZlLnByb3RvdHlwZS5vbkZpZWxkQWRkZWQgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgdmFyIGVsZW1lbnRzID0gZS5lbGVtZW50cztcblx0ICAgICAgICAvLyBEb24ndCBhZGQgdGhlIGVsZW1lbnQgd2hpY2ggaXMgYWxyZWFkeSBhdmFpbGFibGUgaW4gdGhlIGZpZWxkIGxpc3RzXG5cdCAgICAgICAgLy8gT3RoZXJ3aXNlLCBpdCBjYW4gY2F1c2UgYW4gaW5maW5pdGUgbG9vcFxuXHQgICAgICAgIGlmICghZWxlbWVudHMgfHwgZWxlbWVudHMubGVuZ3RoID09PSAwIHx8IHRoaXMuYWRkZWRGaWVsZHMuaGFzKGUuZmllbGQpKSB7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5hZGRlZEZpZWxkcy5zZXQoZS5maWVsZCwgdHJ1ZSk7XG5cdCAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG5cdCAgICAgICAgICAgIHZhciBkZWNsYXJhdGl2ZU9wdGlvbnMgPSBfdGhpcy5wYXJzZUVsZW1lbnQoZWxlKTtcblx0ICAgICAgICAgICAgaWYgKCFfdGhpcy5pc0VtcHR5T3B0aW9uKGRlY2xhcmF0aXZlT3B0aW9ucykpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB2YWxpZGF0b3Igb3B0aW9uc1xuXHQgICAgICAgICAgICAgICAgdmFyIG1lcmdlT3B0aW9ucyA9IHtcblx0ICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogZS5vcHRpb25zLnNlbGVjdG9yLFxuXHQgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvcnM6IE9iamVjdC5hc3NpZ24oe30sIGUub3B0aW9ucy52YWxpZGF0b3JzIHx8IHt9LCBkZWNsYXJhdGl2ZU9wdGlvbnMudmFsaWRhdG9ycyksXG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgX3RoaXMuY29yZS5zZXRGaWVsZE9wdGlvbnMoZS5maWVsZCwgbWVyZ2VPcHRpb25zKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIERlY2xhcmF0aXZlLnByb3RvdHlwZS5vbkZpZWxkUmVtb3ZlZCA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgaWYgKGUuZmllbGQgJiYgdGhpcy5hZGRlZEZpZWxkcy5oYXMoZS5maWVsZCkpIHtcblx0ICAgICAgICAgICAgdGhpcy5hZGRlZEZpZWxkcy5kZWxldGUoZS5maWVsZCk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIERlY2xhcmF0aXZlLnByb3RvdHlwZS5wYXJzZU9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAvLyBGaW5kIGFsbCBmaWVsZHMgd2hpY2ggaGF2ZSBlaXRoZXIgYG5hbWVgIG9yIGBkYXRhLWZ2LWZpZWxkYCBhdHRyaWJ1dGVcblx0ICAgICAgICB2YXIgcHJlZml4ID0gdGhpcy5vcHRzLnByZWZpeDtcblx0ICAgICAgICB2YXIgb3B0cyA9IHt9O1xuXHQgICAgICAgIHZhciBmaWVsZHMgPSB0aGlzLmNvcmUuZ2V0RmllbGRzKCk7XG5cdCAgICAgICAgdmFyIGZvcm0gPSB0aGlzLmNvcmUuZ2V0Rm9ybUVsZW1lbnQoKTtcblx0ICAgICAgICB2YXIgZWxlbWVudHMgPSBbXS5zbGljZS5jYWxsKGZvcm0ucXVlcnlTZWxlY3RvckFsbChcIltuYW1lXSwgW1wiLmNvbmNhdChwcmVmaXgsIFwiZmllbGRdXCIpKSk7XG5cdCAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG5cdCAgICAgICAgICAgIHZhciB2YWxpZGF0b3JzID0gX3RoaXMucGFyc2VFbGVtZW50KGVsZSk7XG5cdCAgICAgICAgICAgIC8vIERvIG5vdCB0cnkgdG8gbWVyZ2UgdGhlIG9wdGlvbnMgaWYgaXQncyBlbXB0eVxuXHQgICAgICAgICAgICAvLyBGb3IgaW5zdGFuY2UsIHRoZXJlIGFyZSBtdWx0aXBsZSBlbGVtZW50cyBoYXZpbmcgdGhlIHNhbWUgbmFtZSxcblx0ICAgICAgICAgICAgLy8gd2Ugb25seSBzZXQgdGhlIEhUTUwgYXR0cmlidXRlIHRvIG9uZSBvZiB0aGVtXG5cdCAgICAgICAgICAgIGlmICghX3RoaXMuaXNFbXB0eU9wdGlvbih2YWxpZGF0b3JzKSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGZpZWxkID0gZWxlLmdldEF0dHJpYnV0ZSgnbmFtZScpIHx8IGVsZS5nZXRBdHRyaWJ1dGUoXCJcIi5jb25jYXQocHJlZml4LCBcImZpZWxkXCIpKTtcblx0ICAgICAgICAgICAgICAgIG9wdHNbZmllbGRdID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0c1tmaWVsZF0sIHZhbGlkYXRvcnMpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgT2JqZWN0LmtleXMob3B0cykuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcblx0ICAgICAgICAgICAgT2JqZWN0LmtleXMob3B0c1tmaWVsZF0udmFsaWRhdG9ycykuZm9yRWFjaChmdW5jdGlvbiAodikge1xuXHQgICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBgZW5hYmxlZGAga2V5IHRvIGBmYWxzZWAgaWYgaXQgaXNuJ3Qgc2V0XG5cdCAgICAgICAgICAgICAgICAvLyAodGhlIGRhdGEtZnYte3ZhbGlkYXRvcn0gYXR0cmlidXRlIGlzIG1pc3NpbmcsIGZvciBleGFtcGxlKVxuXHQgICAgICAgICAgICAgICAgb3B0c1tmaWVsZF0udmFsaWRhdG9yc1t2XS5lbmFibGVkID0gb3B0c1tmaWVsZF0udmFsaWRhdG9yc1t2XS5lbmFibGVkIHx8IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgLy8gTWl4IHRoZSBvcHRpb25zIGluIGRlY2xhcmF0aXZlIGFuZCBwcm9ncmFtbWF0aWMgbW9kZXNcblx0ICAgICAgICAgICAgICAgIGlmIChmaWVsZHNbZmllbGRdICYmIGZpZWxkc1tmaWVsZF0udmFsaWRhdG9ycyAmJiBmaWVsZHNbZmllbGRdLnZhbGlkYXRvcnNbdl0pIHtcblx0ICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKG9wdHNbZmllbGRdLnZhbGlkYXRvcnNbdl0sIGZpZWxkc1tmaWVsZF0udmFsaWRhdG9yc1t2XSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBmaWVsZHMsIG9wdHMpO1xuXHQgICAgfTtcblx0ICAgIERlY2xhcmF0aXZlLnByb3RvdHlwZS5jcmVhdGVQbHVnaW5JbnN0YW5jZSA9IGZ1bmN0aW9uIChjbGF6eiwgb3B0cykge1xuXHQgICAgICAgIHZhciBhcnIgPSBjbGF6ei5zcGxpdCgnLicpO1xuXHQgICAgICAgIC8vIFRPRE86IEZpbmQgYSBzYWZlciB3YXkgdG8gY3JlYXRlIGEgcGx1Z2luIGluc3RhbmNlIGZyb20gdGhlIGNsYXNzXG5cdCAgICAgICAgLy8gQ3VycmVudGx5LCBJIGhhdmUgdG8gdXNlIGBhbnlgIGhlcmUgaW5zdGVhZCBvZiBhIGNvbnN0cnV0YWJsZSBpbnRlcmZhY2Vcblx0ICAgICAgICB2YXIgZm4gPSB3aW5kb3cgfHwgdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHQgICAgICAgICAgICBmbiA9IGZuW2FycltpXV07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidGhlIHBsdWdpbiBcIi5jb25jYXQoY2xhenosIFwiIGRvZXNuJ3QgZXhpc3RcIikpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbmV3IGZuKG9wdHMpO1xuXHQgICAgfTtcblx0ICAgIERlY2xhcmF0aXZlLnByb3RvdHlwZS5wYXJzZVBsdWdpbnMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIF9hO1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgdmFyIGZvcm0gPSB0aGlzLmNvcmUuZ2V0Rm9ybUVsZW1lbnQoKTtcblx0ICAgICAgICB2YXIgcmVnID0gbmV3IFJlZ0V4cChcIl5cIi5jb25jYXQodGhpcy5vcHRzLnBsdWdpblByZWZpeCwgXCIoW2EtejAtOS1dKykoX19fKSooW2EtejAtOS1dKykqJFwiKSk7XG5cdCAgICAgICAgdmFyIG51bUF0dHJpYnV0ZXMgPSBmb3JtLmF0dHJpYnV0ZXMubGVuZ3RoO1xuXHQgICAgICAgIHZhciBwbHVnaW5zID0ge307XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1BdHRyaWJ1dGVzOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIG5hbWVfMSA9IGZvcm0uYXR0cmlidXRlc1tpXS5uYW1lO1xuXHQgICAgICAgICAgICB2YXIgdmFsdWUgPSBmb3JtLmF0dHJpYnV0ZXNbaV0udmFsdWU7XG5cdCAgICAgICAgICAgIHZhciBpdGVtcyA9IHJlZy5leGVjKG5hbWVfMSk7XG5cdCAgICAgICAgICAgIGlmIChpdGVtcyAmJiBpdGVtcy5sZW5ndGggPT09IDQpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBwbHVnaW5OYW1lID0gdGhpcy50b0NhbWVsQ2FzZShpdGVtc1sxXSk7XG5cdCAgICAgICAgICAgICAgICBwbHVnaW5zW3BsdWdpbk5hbWVdID0gT2JqZWN0LmFzc2lnbih7fSwgaXRlbXNbM10gPyAoX2EgPSB7fSwgX2FbdGhpcy50b0NhbWVsQ2FzZShpdGVtc1szXSldID0gdmFsdWUsIF9hKSA6IHsgZW5hYmxlZDogJycgPT09IHZhbHVlIHx8ICd0cnVlJyA9PT0gdmFsdWUgfSwgcGx1Z2luc1twbHVnaW5OYW1lXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgT2JqZWN0LmtleXMocGx1Z2lucykuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luTmFtZSkge1xuXHQgICAgICAgICAgICB2YXIgb3B0cyA9IHBsdWdpbnNbcGx1Z2luTmFtZV07XG5cdCAgICAgICAgICAgIHZhciBlbmFibGVkID0gb3B0c1snZW5hYmxlZCddO1xuXHQgICAgICAgICAgICB2YXIgY2xhenogPSBvcHRzWydjbGFzcyddO1xuXHQgICAgICAgICAgICBpZiAoZW5hYmxlZCAmJiBjbGF6eikge1xuXHQgICAgICAgICAgICAgICAgZGVsZXRlIG9wdHNbJ2VuYWJsZWQnXTtcblx0ICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRzWydjbGF6eiddO1xuXHQgICAgICAgICAgICAgICAgdmFyIHAgPSBfdGhpcy5jcmVhdGVQbHVnaW5JbnN0YW5jZShjbGF6eiwgb3B0cyk7XG5cdCAgICAgICAgICAgICAgICBfdGhpcy5jb3JlLnJlZ2lzdGVyUGx1Z2luKHBsdWdpbk5hbWUsIHApO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgRGVjbGFyYXRpdmUucHJvdG90eXBlLmlzRW1wdHlPcHRpb24gPSBmdW5jdGlvbiAob3B0cykge1xuXHQgICAgICAgIHZhciB2YWxpZGF0b3JzID0gb3B0cy52YWxpZGF0b3JzO1xuXHQgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWxpZGF0b3JzKS5sZW5ndGggPT09IDAgJiYgdmFsaWRhdG9ycy5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xuXHQgICAgfTtcblx0ICAgIERlY2xhcmF0aXZlLnByb3RvdHlwZS5wYXJzZUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlKSB7XG5cdCAgICAgICAgdmFyIHJlZyA9IG5ldyBSZWdFeHAoXCJeXCIuY29uY2F0KHRoaXMub3B0cy5wcmVmaXgsIFwiKFthLXowLTktXSspKF9fXykqKFthLXowLTktXSspKiRcIikpO1xuXHQgICAgICAgIHZhciBudW1BdHRyaWJ1dGVzID0gZWxlLmF0dHJpYnV0ZXMubGVuZ3RoO1xuXHQgICAgICAgIHZhciBvcHRzID0ge307XG5cdCAgICAgICAgdmFyIHR5cGUgPSBlbGUuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1BdHRyaWJ1dGVzOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIG5hbWVfMiA9IGVsZS5hdHRyaWJ1dGVzW2ldLm5hbWU7XG5cdCAgICAgICAgICAgIHZhciB2YWx1ZSA9IGVsZS5hdHRyaWJ1dGVzW2ldLnZhbHVlO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5vcHRzLmh0bWw1SW5wdXQpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAodHJ1ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ21pbmxlbmd0aCcgPT09IG5hbWVfMjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3B0c1snc3RyaW5nTGVuZ3RoJ10gPSBPYmplY3QuYXNzaWduKHt9LCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluOiBwYXJzZUludCh2YWx1ZSwgMTApLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9LCBvcHRzWydzdHJpbmdMZW5ndGgnXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ21heGxlbmd0aCcgPT09IG5hbWVfMjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3B0c1snc3RyaW5nTGVuZ3RoJ10gPSBPYmplY3QuYXNzaWduKHt9LCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4OiBwYXJzZUludCh2YWx1ZSwgMTApLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9LCBvcHRzWydzdHJpbmdMZW5ndGgnXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3BhdHRlcm4nID09PSBuYW1lXzI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9wdHNbJ3JlZ2V4cCddID0gT2JqZWN0LmFzc2lnbih7fSwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4cDogdmFsdWUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0sIG9wdHNbJ3JlZ2V4cCddKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAncmVxdWlyZWQnID09PSBuYW1lXzI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9wdHNbJ25vdEVtcHR5J10gPSBPYmplY3QuYXNzaWduKHt9LCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9LCBvcHRzWydub3RFbXB0eSddKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAndHlwZScgPT09IG5hbWVfMiAmJiAnY29sb3InID09PSB2YWx1ZTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBhY2NlcHQgNiBoZXggY2hhcmFjdGVyIHZhbHVlcyBkdWUgdG8gdGhlIEhUTUwgNSBzcGVjXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sLW1hcmt1cC9pbnB1dC5jb2xvci5odG1sI2lucHV0LmNvbG9yLmF0dHJzLnZhbHVlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9wdHNbJ2NvbG9yJ10gPSBPYmplY3QuYXNzaWduKHt9LCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2hleCcsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0sIG9wdHNbJ2NvbG9yJ10pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICd0eXBlJyA9PT0gbmFtZV8yICYmICdlbWFpbCcgPT09IHZhbHVlOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvcHRzWydlbWFpbEFkZHJlc3MnXSA9IE9iamVjdC5hc3NpZ24oe30sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0sIG9wdHNbJ2VtYWlsQWRkcmVzcyddKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAndHlwZScgPT09IG5hbWVfMiAmJiAndXJsJyA9PT0gdmFsdWU6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9wdHNbJ3VyaSddID0gT2JqZWN0LmFzc2lnbih7fSwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSwgb3B0c1sndXJpJ10pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICd0eXBlJyA9PT0gbmFtZV8yICYmICdyYW5nZScgPT09IHZhbHVlOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvcHRzWydiZXR3ZWVuJ10gPSBPYmplY3QuYXNzaWduKHt9LCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4OiBwYXJzZUZsb2F0KGVsZS5nZXRBdHRyaWJ1dGUoJ21heCcpKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbjogcGFyc2VGbG9hdChlbGUuZ2V0QXR0cmlidXRlKCdtaW4nKSksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0sIG9wdHNbJ2JldHdlZW4nXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ21pbicgPT09IG5hbWVfMiAmJiB0eXBlICE9PSAnZGF0ZScgJiYgdHlwZSAhPT0gJ3JhbmdlJzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3B0c1snZ3JlYXRlclRoYW4nXSA9IE9iamVjdC5hc3NpZ24oe30sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW46IHBhcnNlRmxvYXQodmFsdWUpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9LCBvcHRzWydncmVhdGVyVGhhbiddKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWF4JyA9PT0gbmFtZV8yICYmIHR5cGUgIT09ICdkYXRlJyAmJiB0eXBlICE9PSAncmFuZ2UnOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvcHRzWydsZXNzVGhhbiddID0gT2JqZWN0LmFzc2lnbih7fSwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heDogcGFyc2VGbG9hdCh2YWx1ZSksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0sIG9wdHNbJ2xlc3NUaGFuJ10pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgaXRlbXMgPSByZWcuZXhlYyhuYW1lXzIpO1xuXHQgICAgICAgICAgICBpZiAoaXRlbXMgJiYgaXRlbXMubGVuZ3RoID09PSA0KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgdiA9IHRoaXMudG9DYW1lbENhc2UoaXRlbXNbMV0pO1xuXHQgICAgICAgICAgICAgICAgaWYgKCFvcHRzW3ZdKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgb3B0c1t2XSA9IHt9O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKGl0ZW1zWzNdKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgb3B0c1t2XVt0aGlzLnRvQ2FtZWxDYXNlKGl0ZW1zWzNdKV0gPSB0aGlzLm5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wdHNbdl1bJ2VuYWJsZWQnXSAhPT0gdHJ1ZSB8fCBvcHRzW3ZdWydlbmFibGVkJ10gIT09IGZhbHNlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgb3B0c1t2XVsnZW5hYmxlZCddID0gJycgPT09IHZhbHVlIHx8ICd0cnVlJyA9PT0gdmFsdWU7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHsgdmFsaWRhdG9yczogb3B0cyB9O1xuXHQgICAgfTtcblx0ICAgIC8vIE1hbnkgdmFsaWRhdG9ycyBhY2NlcHQgYGJvb2xlYW5gIG9wdGlvbnMsIGZvciBleGFtcGxlXG5cdCAgICAvLyBgZGF0YS1mdi1iZXR3ZWVuX19faW5jbHVzaXZlPVwiZmFsc2VcImAgc2hvdWxkIGJlIGlkZW50aWNhbCB0byBgaW5jbHVzaXZlOiBmYWxzZWAsIG5vdCBgaW5jbHVzaXZlOiAnZmFsc2UnYFxuXHQgICAgRGVjbGFyYXRpdmUucHJvdG90eXBlLm5vcm1hbGl6ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIHZhbHVlID09PSAndHJ1ZScgfHwgdmFsdWUgPT09ICcnID8gdHJ1ZSA6IHZhbHVlID09PSAnZmFsc2UnID8gZmFsc2UgOiB2YWx1ZTtcblx0ICAgIH07XG5cdCAgICBEZWNsYXJhdGl2ZS5wcm90b3R5cGUudG9VcHBlckNhc2UgPSBmdW5jdGlvbiAoaW5wdXQpIHtcblx0ICAgICAgICByZXR1cm4gaW5wdXQuY2hhckF0KDEpLnRvVXBwZXJDYXNlKCk7XG5cdCAgICB9O1xuXHQgICAgRGVjbGFyYXRpdmUucHJvdG90eXBlLnRvQ2FtZWxDYXNlID0gZnVuY3Rpb24gKGlucHV0KSB7XG5cdCAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoLy0uL2csIHRoaXMudG9VcHBlckNhc2UpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBEZWNsYXJhdGl2ZTtcblx0fShjb3JlLlBsdWdpbikpO1xuXG5cdGNqcyR5LkRlY2xhcmF0aXZlID0gRGVjbGFyYXRpdmU7XG5cdHJldHVybiBjanMkeTtcbn1cblxuLyoqXG4gKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcbiAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgbGliJHkuZXhwb3J0cyA9IHJlcXVpcmVJbmRleF9taW4keSgpO1xufSBlbHNlIHtcbiAgICBsaWIkeS5leHBvcnRzID0gcmVxdWlyZUNqcyR5KCk7XG59XG5cbnZhciBsaWJFeHBvcnRzJHkgPSBsaWIkeS5leHBvcnRzO1xuXG52YXIgbGliJHggPSB7ZXhwb3J0czoge319O1xuXG52YXIgaW5kZXhfbWluJHggPSB7fTtcblxuLyoqIFxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqXG4gKiBAbGljZW5zZSBodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvL2xpY2Vuc2VcbiAqIEBwYWNrYWdlIEBmb3JtLXZhbGlkYXRpb24vcGx1Z2luLWRlZmF1bHQtc3VibWl0XG4gKiBAdmVyc2lvbiAyLjQuMFxuICovXG5cbnZhciBoYXNSZXF1aXJlZEluZGV4X21pbiR4O1xuXG5mdW5jdGlvbiByZXF1aXJlSW5kZXhfbWluJHggKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRJbmRleF9taW4keCkgcmV0dXJuIGluZGV4X21pbiR4O1xuXHRoYXNSZXF1aXJlZEluZGV4X21pbiR4ID0gMTtcbnZhciB0PWxpYkV4cG9ydHMkQixvPWZ1bmN0aW9uKHQscil7cmV0dXJuIG89T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKHQsbyl7dC5fX3Byb3RvX189bzt9fHxmdW5jdGlvbih0LG8pe2Zvcih2YXIgciBpbiBvKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLHIpJiYodFtyXT1vW3JdKTt9LG8odCxyKX07dmFyIHI9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gcigpe3ZhciBvPXQuY2FsbCh0aGlzLHt9KXx8dGhpcztyZXR1cm4gby5vblZhbGlkSGFuZGxlcj1vLm9uRm9ybVZhbGlkLmJpbmQobyksb31yZXR1cm4gZnVuY3Rpb24odCxyKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiByJiZudWxsIT09cil0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIitTdHJpbmcocikrXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtmdW5jdGlvbiBuKCl7dGhpcy5jb25zdHJ1Y3Rvcj10O31vKHQsciksdC5wcm90b3R5cGU9bnVsbD09PXI/T2JqZWN0LmNyZWF0ZShyKToobi5wcm90b3R5cGU9ci5wcm90b3R5cGUsbmV3IG4pO30ocix0KSxyLnByb3RvdHlwZS5pbnN0YWxsPWZ1bmN0aW9uKCl7aWYodGhpcy5jb3JlLmdldEZvcm1FbGVtZW50KCkucXVlcnlTZWxlY3RvckFsbCgnW3R5cGU9XCJzdWJtaXRcIl1bbmFtZT1cInN1Ym1pdFwiXScpLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJEbyBub3QgdXNlIGBzdWJtaXRgIGZvciB0aGUgbmFtZSBhdHRyaWJ1dGUgb2Ygc3VibWl0IGJ1dHRvblwiKTt0aGlzLmNvcmUub24oXCJjb3JlLmZvcm0udmFsaWRcIix0aGlzLm9uVmFsaWRIYW5kbGVyKTt9LHIucHJvdG90eXBlLnVuaW5zdGFsbD1mdW5jdGlvbigpe3RoaXMuY29yZS5vZmYoXCJjb3JlLmZvcm0udmFsaWRcIix0aGlzLm9uVmFsaWRIYW5kbGVyKTt9LHIucHJvdG90eXBlLm9uRm9ybVZhbGlkPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5jb3JlLmdldEZvcm1FbGVtZW50KCk7dGhpcy5pc0VuYWJsZWQmJnQgaW5zdGFuY2VvZiBIVE1MRm9ybUVsZW1lbnQmJnQuc3VibWl0KCk7fSxyfSh0LlBsdWdpbik7aW5kZXhfbWluJHguRGVmYXVsdFN1Ym1pdD1yO1xuXHRyZXR1cm4gaW5kZXhfbWluJHg7XG59XG5cbnZhciBjanMkeCA9IHt9O1xuXG52YXIgaGFzUmVxdWlyZWRDanMkeDtcblxuZnVuY3Rpb24gcmVxdWlyZUNqcyR4ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkQ2pzJHgpIHJldHVybiBjanMkeDtcblx0aGFzUmVxdWlyZWRDanMkeCA9IDE7XG5cblx0dmFyIGNvcmUgPSBsaWJFeHBvcnRzJEI7XG5cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5cdENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuXHRQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxuXHRwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5cdFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuXHRSRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuXHRBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcblx0SU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcblx0TE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuXHRPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblx0UEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuXHQqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cdC8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG5cdHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG5cdCAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcblx0ICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcblx0ICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG5cdCAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG5cdCAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG5cdCAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG5cdCAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG5cdCAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuXHQgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG5cdH1cblxuXHQvKipcblx0ICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG5cdCAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuXHQgKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG5cdCAqL1xuXHQvKipcblx0ICogVGhpcyBwbHVnaW4gd2lsbCBzdWJtaXQgdGhlIGZvcm0gaWYgYWxsIGZpZWxkcyBhcmUgdmFsaWQgYWZ0ZXIgdmFsaWRhdGluZ1xuXHQgKi9cblx0dmFyIERlZmF1bHRTdWJtaXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoRGVmYXVsdFN1Ym1pdCwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIERlZmF1bHRTdWJtaXQoKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywge30pIHx8IHRoaXM7XG5cdCAgICAgICAgX3RoaXMub25WYWxpZEhhbmRsZXIgPSBfdGhpcy5vbkZvcm1WYWxpZC5iaW5kKF90aGlzKTtcblx0ICAgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICB9XG5cdCAgICBEZWZhdWx0U3VibWl0LnByb3RvdHlwZS5pbnN0YWxsID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBmb3JtID0gdGhpcy5jb3JlLmdldEZvcm1FbGVtZW50KCk7XG5cdCAgICAgICAgaWYgKGZvcm0ucXVlcnlTZWxlY3RvckFsbCgnW3R5cGU9XCJzdWJtaXRcIl1bbmFtZT1cInN1Ym1pdFwiXScpLmxlbmd0aCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RvIG5vdCB1c2UgYHN1Ym1pdGAgZm9yIHRoZSBuYW1lIGF0dHJpYnV0ZSBvZiBzdWJtaXQgYnV0dG9uJyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuY29yZS5vbignY29yZS5mb3JtLnZhbGlkJywgdGhpcy5vblZhbGlkSGFuZGxlcik7XG5cdCAgICB9O1xuXHQgICAgRGVmYXVsdFN1Ym1pdC5wcm90b3R5cGUudW5pbnN0YWxsID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuY29yZS5vZmYoJ2NvcmUuZm9ybS52YWxpZCcsIHRoaXMub25WYWxpZEhhbmRsZXIpO1xuXHQgICAgfTtcblx0ICAgIERlZmF1bHRTdWJtaXQucHJvdG90eXBlLm9uRm9ybVZhbGlkID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBmb3JtID0gdGhpcy5jb3JlLmdldEZvcm1FbGVtZW50KCk7XG5cdCAgICAgICAgaWYgKHRoaXMuaXNFbmFibGVkICYmIGZvcm0gaW5zdGFuY2VvZiBIVE1MRm9ybUVsZW1lbnQpIHtcblx0ICAgICAgICAgICAgZm9ybS5zdWJtaXQoKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIERlZmF1bHRTdWJtaXQ7XG5cdH0oY29yZS5QbHVnaW4pKTtcblxuXHRjanMkeC5EZWZhdWx0U3VibWl0ID0gRGVmYXVsdFN1Ym1pdDtcblx0cmV0dXJuIGNqcyR4O1xufVxuXG4vKipcbiAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG4gKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICBsaWIkeC5leHBvcnRzID0gcmVxdWlyZUluZGV4X21pbiR4KCk7XG59IGVsc2Uge1xuICAgIGxpYiR4LmV4cG9ydHMgPSByZXF1aXJlQ2pzJHgoKTtcbn1cblxudmFyIGxpYkV4cG9ydHMkeCA9IGxpYiR4LmV4cG9ydHM7XG5cbnZhciBsaWIkdyA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBpbmRleF9taW4kdyA9IHt9O1xuXG4vKiogXG4gKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcbiAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuICpcbiAqIEBsaWNlbnNlIGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8vbGljZW5zZVxuICogQHBhY2thZ2UgQGZvcm0tdmFsaWRhdGlvbi9wbHVnaW4tZGVwZW5kZW5jeVxuICogQHZlcnNpb24gMi40LjBcbiAqL1xuXG52YXIgaGFzUmVxdWlyZWRJbmRleF9taW4kdztcblxuZnVuY3Rpb24gcmVxdWlyZUluZGV4X21pbiR3ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkSW5kZXhfbWluJHcpIHJldHVybiBpbmRleF9taW4kdztcblx0aGFzUmVxdWlyZWRJbmRleF9taW4kdyA9IDE7XG52YXIgdD1saWJFeHBvcnRzJEIsZT1mdW5jdGlvbih0LHIpe3JldHVybiBlPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbih0LGUpe3QuX19wcm90b19fPWU7fXx8ZnVuY3Rpb24odCxlKXtmb3IodmFyIHIgaW4gZSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxyKSYmKHRbcl09ZVtyXSk7fSxlKHQscil9O3ZhciByPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIHIoZSl7dmFyIHI9dC5jYWxsKHRoaXMsZSl8fHRoaXM7cmV0dXJuIHIub3B0cz1lfHx7fSxyLnRyaWdnZXJFeGVjdXRlZEhhbmRsZXI9ci5vblRyaWdnZXJFeGVjdXRlZC5iaW5kKHIpLHJ9cmV0dXJuIGZ1bmN0aW9uKHQscil7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgciYmbnVsbCE9PXIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIrU3RyaW5nKHIpK1wiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7ZnVuY3Rpb24gbygpe3RoaXMuY29uc3RydWN0b3I9dDt9ZSh0LHIpLHQucHJvdG90eXBlPW51bGw9PT1yP09iamVjdC5jcmVhdGUocik6KG8ucHJvdG90eXBlPXIucHJvdG90eXBlLG5ldyBvKTt9KHIsdCksci5wcm90b3R5cGUuaW5zdGFsbD1mdW5jdGlvbigpe3RoaXMuY29yZS5vbihcInBsdWdpbnMudHJpZ2dlci5leGVjdXRlZFwiLHRoaXMudHJpZ2dlckV4ZWN1dGVkSGFuZGxlcik7fSxyLnByb3RvdHlwZS51bmluc3RhbGw9ZnVuY3Rpb24oKXt0aGlzLmNvcmUub2ZmKFwicGx1Z2lucy50cmlnZ2VyLmV4ZWN1dGVkXCIsdGhpcy50cmlnZ2VyRXhlY3V0ZWRIYW5kbGVyKTt9LHIucHJvdG90eXBlLm9uVHJpZ2dlckV4ZWN1dGVkPWZ1bmN0aW9uKHQpe2lmKHRoaXMuaXNFbmFibGVkJiZ0aGlzLm9wdHNbdC5maWVsZF0pZm9yKHZhciBlPTAscj10aGlzLm9wdHNbdC5maWVsZF0uc3BsaXQoXCIgXCIpO2U8ci5sZW5ndGg7ZSsrKXt2YXIgbz1yW2VdLnRyaW0oKTt0aGlzLm9wdHNbb10mJnRoaXMuY29yZS5yZXZhbGlkYXRlRmllbGQobyk7fX0scn0odC5QbHVnaW4pO2luZGV4X21pbiR3LkRlcGVuZGVuY3k9cjtcblx0cmV0dXJuIGluZGV4X21pbiR3O1xufVxuXG52YXIgY2pzJHcgPSB7fTtcblxudmFyIGhhc1JlcXVpcmVkQ2pzJHc7XG5cbmZ1bmN0aW9uIHJlcXVpcmVDanMkdyAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZENqcyR3KSByZXR1cm4gY2pzJHc7XG5cdGhhc1JlcXVpcmVkQ2pzJHcgPSAxO1xuXG5cdHZhciBjb3JlID0gbGliRXhwb3J0cyRCO1xuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuXHRDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblx0UGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcblx0cHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuXHRUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblx0UkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcblx0QU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5cdElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5cdExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcblx0T1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5cdFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcblx0KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHQvKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxuXHR2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuXHQgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG5cdCAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG5cdCAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuXHQgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuXHQgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuXHQgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuXHQgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuXHQgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcblx0ICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuXHR9XG5cblx0LyoqXG5cdCAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuXHQgKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcblx0ICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuXHQgKi9cblx0dmFyIERlcGVuZGVuY3kgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoRGVwZW5kZW5jeSwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIERlcGVuZGVuY3kob3B0cykge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdHMpIHx8IHRoaXM7XG5cdCAgICAgICAgX3RoaXMub3B0cyA9IG9wdHMgfHwge307XG5cdCAgICAgICAgX3RoaXMudHJpZ2dlckV4ZWN1dGVkSGFuZGxlciA9IF90aGlzLm9uVHJpZ2dlckV4ZWN1dGVkLmJpbmQoX3RoaXMpO1xuXHQgICAgICAgIHJldHVybiBfdGhpcztcblx0ICAgIH1cblx0ICAgIERlcGVuZGVuY3kucHJvdG90eXBlLmluc3RhbGwgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5jb3JlLm9uKCdwbHVnaW5zLnRyaWdnZXIuZXhlY3V0ZWQnLCB0aGlzLnRyaWdnZXJFeGVjdXRlZEhhbmRsZXIpO1xuXHQgICAgfTtcblx0ICAgIERlcGVuZGVuY3kucHJvdG90eXBlLnVuaW5zdGFsbCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLmNvcmUub2ZmKCdwbHVnaW5zLnRyaWdnZXIuZXhlY3V0ZWQnLCB0aGlzLnRyaWdnZXJFeGVjdXRlZEhhbmRsZXIpO1xuXHQgICAgfTtcblx0ICAgIERlcGVuZGVuY3kucHJvdG90eXBlLm9uVHJpZ2dlckV4ZWN1dGVkID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICBpZiAodGhpcy5pc0VuYWJsZWQgJiYgdGhpcy5vcHRzW2UuZmllbGRdKSB7XG5cdCAgICAgICAgICAgIHZhciBkZXBlbmRlbmNpZXMgPSB0aGlzLm9wdHNbZS5maWVsZF0uc3BsaXQoJyAnKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBkZXBlbmRlbmNpZXNfMSA9IGRlcGVuZGVuY2llczsgX2kgPCBkZXBlbmRlbmNpZXNfMS5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBkID0gZGVwZW5kZW5jaWVzXzFbX2ldO1xuXHQgICAgICAgICAgICAgICAgdmFyIGRlcGVuZGVudEZpZWxkID0gZC50cmltKCk7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRzW2RlcGVuZGVudEZpZWxkXSkge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIFJldmFsaWRhdGUgdGhlIGRlcGVuZGVudCBmaWVsZFxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29yZS5yZXZhbGlkYXRlRmllbGQoZGVwZW5kZW50RmllbGQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIHJldHVybiBEZXBlbmRlbmN5O1xuXHR9KGNvcmUuUGx1Z2luKSk7XG5cblx0Y2pzJHcuRGVwZW5kZW5jeSA9IERlcGVuZGVuY3k7XG5cdHJldHVybiBjanMkdztcbn1cblxuLyoqXG4gKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcbiAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgbGliJHcuZXhwb3J0cyA9IHJlcXVpcmVJbmRleF9taW4kdygpO1xufSBlbHNlIHtcbiAgICBsaWIkdy5leHBvcnRzID0gcmVxdWlyZUNqcyR3KCk7XG59XG5cbnZhciBsaWJFeHBvcnRzJHcgPSBsaWIkdy5leHBvcnRzO1xuXG52YXIgbGliJHYgPSB7ZXhwb3J0czoge319O1xuXG52YXIgaW5kZXhfbWluJHYgPSB7fTtcblxuLyoqIFxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqXG4gKiBAbGljZW5zZSBodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvL2xpY2Vuc2VcbiAqIEBwYWNrYWdlIEBmb3JtLXZhbGlkYXRpb24vcGx1Z2luLWV4Y2x1ZGVkXG4gKiBAdmVyc2lvbiAyLjQuMFxuICovXG5cbnZhciBoYXNSZXF1aXJlZEluZGV4X21pbiR2O1xuXG5mdW5jdGlvbiByZXF1aXJlSW5kZXhfbWluJHYgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRJbmRleF9taW4kdikgcmV0dXJuIGluZGV4X21pbiR2O1xuXHRoYXNSZXF1aXJlZEluZGV4X21pbiR2ID0gMTtcbnZhciB0PWxpYkV4cG9ydHMkQixlPWZ1bmN0aW9uKHQsbil7cmV0dXJuIGU9T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKHQsZSl7dC5fX3Byb3RvX189ZTt9fHxmdW5jdGlvbih0LGUpe2Zvcih2YXIgbiBpbiBlKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLG4pJiYodFtuXT1lW25dKTt9LGUodCxuKX07dmFyIG49dC51dGlscy5yZW1vdmVVbmRlZmluZWQsaT1mdW5jdGlvbih0KXtmdW5jdGlvbiBpKGUpe3ZhciByPXQuY2FsbCh0aGlzLGUpfHx0aGlzO3JldHVybiByLm9wdHM9T2JqZWN0LmFzc2lnbih7fSx7ZXhjbHVkZWQ6aS5kZWZhdWx0SWdub3JlfSxuKGUpKSxyLmlnbm9yZVZhbGlkYXRpb25GaWx0ZXI9ci5pZ25vcmVWYWxpZGF0aW9uLmJpbmQocikscn1yZXR1cm4gZnVuY3Rpb24odCxuKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBuJiZudWxsIT09bil0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIitTdHJpbmcobikrXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtmdW5jdGlvbiBpKCl7dGhpcy5jb25zdHJ1Y3Rvcj10O31lKHQsbiksdC5wcm90b3R5cGU9bnVsbD09PW4/T2JqZWN0LmNyZWF0ZShuKTooaS5wcm90b3R5cGU9bi5wcm90b3R5cGUsbmV3IGkpO30oaSx0KSxpLmRlZmF1bHRJZ25vcmU9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPSEhKGUub2Zmc2V0V2lkdGh8fGUub2Zmc2V0SGVpZ2h0fHxlLmdldENsaWVudFJlY3RzKCkubGVuZ3RoKSxyPWUuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIik7cmV0dXJuIFwiXCI9PT1yfHxcImRpc2FibGVkXCI9PT1yfHxcImhpZGRlblwiPT09ZS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpfHwhaX0saS5wcm90b3R5cGUuaW5zdGFsbD1mdW5jdGlvbigpe3RoaXMuY29yZS5yZWdpc3RlckZpbHRlcihcImVsZW1lbnQtaWdub3JlZFwiLHRoaXMuaWdub3JlVmFsaWRhdGlvbkZpbHRlcik7fSxpLnByb3RvdHlwZS51bmluc3RhbGw9ZnVuY3Rpb24oKXt0aGlzLmNvcmUuZGVyZWdpc3RlckZpbHRlcihcImVsZW1lbnQtaWdub3JlZFwiLHRoaXMuaWdub3JlVmFsaWRhdGlvbkZpbHRlcik7fSxpLnByb3RvdHlwZS5pZ25vcmVWYWxpZGF0aW9uPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gISF0aGlzLmlzRW5hYmxlZCYmdGhpcy5vcHRzLmV4Y2x1ZGVkLmFwcGx5KHRoaXMsW3QsZSxuXSl9LGl9KHQuUGx1Z2luKTtpbmRleF9taW4kdi5FeGNsdWRlZD1pO1xuXHRyZXR1cm4gaW5kZXhfbWluJHY7XG59XG5cbnZhciBjanMkdiA9IHt9O1xuXG52YXIgaGFzUmVxdWlyZWRDanMkdjtcblxuZnVuY3Rpb24gcmVxdWlyZUNqcyR2ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkQ2pzJHYpIHJldHVybiBjanMkdjtcblx0aGFzUmVxdWlyZWRDanMkdiA9IDE7XG5cblx0dmFyIGNvcmUgPSBsaWJFeHBvcnRzJEI7XG5cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5cdENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuXHRQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxuXHRwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5cdFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuXHRSRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuXHRBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcblx0SU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcblx0TE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuXHRPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblx0UEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuXHQqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cdC8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG5cdHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG5cdCAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcblx0ICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcblx0ICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG5cdCAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG5cdCAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG5cdCAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG5cdCAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG5cdCAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuXHQgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG5cdH1cblxuXHQvKipcblx0ICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG5cdCAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuXHQgKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG5cdCAqL1xuXHR2YXIgcmVtb3ZlVW5kZWZpbmVkID0gY29yZS51dGlscy5yZW1vdmVVbmRlZmluZWQ7XG5cdHZhciBFeGNsdWRlZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhFeGNsdWRlZCwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIEV4Y2x1ZGVkKG9wdHMpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRzKSB8fCB0aGlzO1xuXHQgICAgICAgIF90aGlzLm9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCB7IGV4Y2x1ZGVkOiBFeGNsdWRlZC5kZWZhdWx0SWdub3JlIH0sIHJlbW92ZVVuZGVmaW5lZChvcHRzKSk7XG5cdCAgICAgICAgX3RoaXMuaWdub3JlVmFsaWRhdGlvbkZpbHRlciA9IF90aGlzLmlnbm9yZVZhbGlkYXRpb24uYmluZChfdGhpcyk7XG5cdCAgICAgICAgcmV0dXJuIF90aGlzO1xuXHQgICAgfVxuXHQgICAgRXhjbHVkZWQuZGVmYXVsdElnbm9yZSA9IGZ1bmN0aW9uIChfZmllbGQsIGVsZW1lbnQsIF9lbGVtZW50cykge1xuXHQgICAgICAgIHZhciBpc1Zpc2libGUgPSAhIShlbGVtZW50Lm9mZnNldFdpZHRoIHx8IGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IGVsZW1lbnQuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGgpO1xuXHQgICAgICAgIHZhciBkaXNhYmxlZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuXHQgICAgICAgIHJldHVybiBkaXNhYmxlZCA9PT0gJycgfHwgZGlzYWJsZWQgPT09ICdkaXNhYmxlZCcgfHwgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSA9PT0gJ2hpZGRlbicgfHwgIWlzVmlzaWJsZTtcblx0ICAgIH07XG5cdCAgICBFeGNsdWRlZC5wcm90b3R5cGUuaW5zdGFsbCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLmNvcmUucmVnaXN0ZXJGaWx0ZXIoJ2VsZW1lbnQtaWdub3JlZCcsIHRoaXMuaWdub3JlVmFsaWRhdGlvbkZpbHRlcik7XG5cdCAgICB9O1xuXHQgICAgRXhjbHVkZWQucHJvdG90eXBlLnVuaW5zdGFsbCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLmNvcmUuZGVyZWdpc3RlckZpbHRlcignZWxlbWVudC1pZ25vcmVkJywgdGhpcy5pZ25vcmVWYWxpZGF0aW9uRmlsdGVyKTtcblx0ICAgIH07XG5cdCAgICBFeGNsdWRlZC5wcm90b3R5cGUuaWdub3JlVmFsaWRhdGlvbiA9IGZ1bmN0aW9uIChmaWVsZCwgZWxlbWVudCwgZWxlbWVudHMpIHtcblx0ICAgICAgICBpZiAoIXRoaXMuaXNFbmFibGVkKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXMub3B0cy5leGNsdWRlZC5hcHBseSh0aGlzLCBbZmllbGQsIGVsZW1lbnQsIGVsZW1lbnRzXSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIEV4Y2x1ZGVkO1xuXHR9KGNvcmUuUGx1Z2luKSk7XG5cblx0Y2pzJHYuRXhjbHVkZWQgPSBFeGNsdWRlZDtcblx0cmV0dXJuIGNqcyR2O1xufVxuXG4vKipcbiAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG4gKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICBsaWIkdi5leHBvcnRzID0gcmVxdWlyZUluZGV4X21pbiR2KCk7XG59IGVsc2Uge1xuICAgIGxpYiR2LmV4cG9ydHMgPSByZXF1aXJlQ2pzJHYoKTtcbn1cblxudmFyIGxpYkV4cG9ydHMkdiA9IGxpYiR2LmV4cG9ydHM7XG5cbnZhciBsaWIkdSA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBpbmRleF9taW4kdSA9IHt9O1xuXG4vKiogXG4gKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcbiAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuICpcbiAqIEBsaWNlbnNlIGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8vbGljZW5zZVxuICogQHBhY2thZ2UgQGZvcm0tdmFsaWRhdGlvbi9wbHVnaW4tZmllbGQtc3RhdHVzXG4gKiBAdmVyc2lvbiAyLjQuMFxuICovXG5cbnZhciBoYXNSZXF1aXJlZEluZGV4X21pbiR1O1xuXG5mdW5jdGlvbiByZXF1aXJlSW5kZXhfbWluJHUgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRJbmRleF9taW4kdSkgcmV0dXJuIGluZGV4X21pbiR1O1xuXHRoYXNSZXF1aXJlZEluZGV4X21pbiR1ID0gMTtcbnZhciBlPWxpYkV4cG9ydHMkQix0PWZ1bmN0aW9uKGUsbil7cmV0dXJuIHQ9T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKGUsdCl7ZS5fX3Byb3RvX189dDt9fHxmdW5jdGlvbihlLHQpe2Zvcih2YXIgbiBpbiB0KU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG4pJiYoZVtuXT10W25dKTt9LHQoZSxuKX07dmFyIG49ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gbih0KXt2YXIgbj1lLmNhbGwodGhpcyx0KXx8dGhpcztyZXR1cm4gbi5zdGF0dXNlcz1uZXcgTWFwLG4ub3B0cz1PYmplY3QuYXNzaWduKHt9LHtvblN0YXR1c0NoYW5nZWQ6ZnVuY3Rpb24oKXt9fSx0KSxuLmVsZW1lbnRWYWxpZGF0aW5nSGFuZGxlcj1uLm9uRWxlbWVudFZhbGlkYXRpbmcuYmluZChuKSxuLmVsZW1lbnRWYWxpZGF0ZWRIYW5kbGVyPW4ub25FbGVtZW50VmFsaWRhdGVkLmJpbmQobiksbi5lbGVtZW50Tm90VmFsaWRhdGVkSGFuZGxlcj1uLm9uRWxlbWVudE5vdFZhbGlkYXRlZC5iaW5kKG4pLG4uZWxlbWVudElnbm9yZWRIYW5kbGVyPW4ub25FbGVtZW50SWdub3JlZC5iaW5kKG4pLG4uZmllbGRBZGRlZEhhbmRsZXI9bi5vbkZpZWxkQWRkZWQuYmluZChuKSxuLmZpZWxkUmVtb3ZlZEhhbmRsZXI9bi5vbkZpZWxkUmVtb3ZlZC5iaW5kKG4pLG59cmV0dXJuIGZ1bmN0aW9uKGUsbil7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgbiYmbnVsbCE9PW4pdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIrU3RyaW5nKG4pK1wiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7ZnVuY3Rpb24gZCgpe3RoaXMuY29uc3RydWN0b3I9ZTt9dChlLG4pLGUucHJvdG90eXBlPW51bGw9PT1uP09iamVjdC5jcmVhdGUobik6KGQucHJvdG90eXBlPW4ucHJvdG90eXBlLG5ldyBkKTt9KG4sZSksbi5wcm90b3R5cGUuaW5zdGFsbD1mdW5jdGlvbigpe3RoaXMuY29yZS5vbihcImNvcmUuZWxlbWVudC52YWxpZGF0aW5nXCIsdGhpcy5lbGVtZW50VmFsaWRhdGluZ0hhbmRsZXIpLm9uKFwiY29yZS5lbGVtZW50LnZhbGlkYXRlZFwiLHRoaXMuZWxlbWVudFZhbGlkYXRlZEhhbmRsZXIpLm9uKFwiY29yZS5lbGVtZW50Lm5vdHZhbGlkYXRlZFwiLHRoaXMuZWxlbWVudE5vdFZhbGlkYXRlZEhhbmRsZXIpLm9uKFwiY29yZS5lbGVtZW50Lmlnbm9yZWRcIix0aGlzLmVsZW1lbnRJZ25vcmVkSGFuZGxlcikub24oXCJjb3JlLmZpZWxkLmFkZGVkXCIsdGhpcy5maWVsZEFkZGVkSGFuZGxlcikub24oXCJjb3JlLmZpZWxkLnJlbW92ZWRcIix0aGlzLmZpZWxkUmVtb3ZlZEhhbmRsZXIpO30sbi5wcm90b3R5cGUudW5pbnN0YWxsPWZ1bmN0aW9uKCl7dGhpcy5zdGF0dXNlcy5jbGVhcigpLHRoaXMuY29yZS5vZmYoXCJjb3JlLmVsZW1lbnQudmFsaWRhdGluZ1wiLHRoaXMuZWxlbWVudFZhbGlkYXRpbmdIYW5kbGVyKS5vZmYoXCJjb3JlLmVsZW1lbnQudmFsaWRhdGVkXCIsdGhpcy5lbGVtZW50VmFsaWRhdGVkSGFuZGxlcikub2ZmKFwiY29yZS5lbGVtZW50Lm5vdHZhbGlkYXRlZFwiLHRoaXMuZWxlbWVudE5vdFZhbGlkYXRlZEhhbmRsZXIpLm9mZihcImNvcmUuZWxlbWVudC5pZ25vcmVkXCIsdGhpcy5lbGVtZW50SWdub3JlZEhhbmRsZXIpLm9mZihcImNvcmUuZmllbGQuYWRkZWRcIix0aGlzLmZpZWxkQWRkZWRIYW5kbGVyKS5vZmYoXCJjb3JlLmZpZWxkLnJlbW92ZWRcIix0aGlzLmZpZWxkUmVtb3ZlZEhhbmRsZXIpO30sbi5wcm90b3R5cGUuYXJlRmllbGRzVmFsaWQ9ZnVuY3Rpb24oKXtyZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnN0YXR1c2VzLnZhbHVlcygpKS5ldmVyeSgoZnVuY3Rpb24oZSl7cmV0dXJuIFwiVmFsaWRcIj09PWV8fFwiTm90VmFsaWRhdGVkXCI9PT1lfHxcIklnbm9yZWRcIj09PWV9KSl9LG4ucHJvdG90eXBlLmdldFN0YXR1c2VzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNFbmFibGVkP3RoaXMuc3RhdHVzZXM6bmV3IE1hcH0sbi5wcm90b3R5cGUub25GaWVsZEFkZGVkPWZ1bmN0aW9uKGUpe3RoaXMuc3RhdHVzZXMuc2V0KGUuZmllbGQsXCJOb3RWYWxpZGF0ZWRcIik7fSxuLnByb3RvdHlwZS5vbkZpZWxkUmVtb3ZlZD1mdW5jdGlvbihlKXt0aGlzLnN0YXR1c2VzLmhhcyhlLmZpZWxkKSYmdGhpcy5zdGF0dXNlcy5kZWxldGUoZS5maWVsZCksdGhpcy5oYW5kbGVTdGF0dXNDaGFuZ2VkKHRoaXMuYXJlRmllbGRzVmFsaWQoKSk7fSxuLnByb3RvdHlwZS5vbkVsZW1lbnRWYWxpZGF0aW5nPWZ1bmN0aW9uKGUpe3RoaXMuc3RhdHVzZXMuc2V0KGUuZmllbGQsXCJWYWxpZGF0aW5nXCIpLHRoaXMuaGFuZGxlU3RhdHVzQ2hhbmdlZCghMSk7fSxuLnByb3RvdHlwZS5vbkVsZW1lbnRWYWxpZGF0ZWQ9ZnVuY3Rpb24oZSl7dGhpcy5zdGF0dXNlcy5zZXQoZS5maWVsZCxlLnZhbGlkP1wiVmFsaWRcIjpcIkludmFsaWRcIiksZS52YWxpZD90aGlzLmhhbmRsZVN0YXR1c0NoYW5nZWQodGhpcy5hcmVGaWVsZHNWYWxpZCgpKTp0aGlzLmhhbmRsZVN0YXR1c0NoYW5nZWQoITEpO30sbi5wcm90b3R5cGUub25FbGVtZW50Tm90VmFsaWRhdGVkPWZ1bmN0aW9uKGUpe3RoaXMuc3RhdHVzZXMuc2V0KGUuZmllbGQsXCJOb3RWYWxpZGF0ZWRcIiksdGhpcy5oYW5kbGVTdGF0dXNDaGFuZ2VkKCExKTt9LG4ucHJvdG90eXBlLm9uRWxlbWVudElnbm9yZWQ9ZnVuY3Rpb24oZSl7dGhpcy5zdGF0dXNlcy5zZXQoZS5maWVsZCxcIklnbm9yZWRcIiksdGhpcy5oYW5kbGVTdGF0dXNDaGFuZ2VkKHRoaXMuYXJlRmllbGRzVmFsaWQoKSk7fSxuLnByb3RvdHlwZS5oYW5kbGVTdGF0dXNDaGFuZ2VkPWZ1bmN0aW9uKGUpe3RoaXMuaXNFbmFibGVkJiZ0aGlzLm9wdHMub25TdGF0dXNDaGFuZ2VkKGUpO30sbn0oZS5QbHVnaW4pO2luZGV4X21pbiR1LkZpZWxkU3RhdHVzPW47XG5cdHJldHVybiBpbmRleF9taW4kdTtcbn1cblxudmFyIGNqcyR1ID0ge307XG5cbnZhciBoYXNSZXF1aXJlZENqcyR1O1xuXG5mdW5jdGlvbiByZXF1aXJlQ2pzJHUgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRDanMkdSkgcmV0dXJuIGNqcyR1O1xuXHRoYXNSZXF1aXJlZENqcyR1ID0gMTtcblxuXHR2YXIgY29yZSA9IGxpYkV4cG9ydHMkQjtcblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblx0Q29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5cdFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5cdHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblx0VEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5cdFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5cdEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuXHRJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuXHRMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5cdE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuXHRQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG5cdCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblx0LyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcblx0dmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcblx0ICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuXHQgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuXHQgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcblx0ICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcblx0ICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcblx0ICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcblx0ICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcblx0ICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG5cdCAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcblx0fVxuXG5cdC8qKlxuXHQgKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcblx0ICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG5cdCAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cblx0ICovXG5cdHZhciBGaWVsZFN0YXR1cyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhGaWVsZFN0YXR1cywgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIEZpZWxkU3RhdHVzKG9wdHMpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRzKSB8fCB0aGlzO1xuXHQgICAgICAgIF90aGlzLnN0YXR1c2VzID0gbmV3IE1hcCgpO1xuXHQgICAgICAgIF90aGlzLm9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCB7XG5cdCAgICAgICAgICAgIG9uU3RhdHVzQ2hhbmdlZDogZnVuY3Rpb24gKCkgeyB9LFxuXHQgICAgICAgIH0sIG9wdHMpO1xuXHQgICAgICAgIF90aGlzLmVsZW1lbnRWYWxpZGF0aW5nSGFuZGxlciA9IF90aGlzLm9uRWxlbWVudFZhbGlkYXRpbmcuYmluZChfdGhpcyk7XG5cdCAgICAgICAgX3RoaXMuZWxlbWVudFZhbGlkYXRlZEhhbmRsZXIgPSBfdGhpcy5vbkVsZW1lbnRWYWxpZGF0ZWQuYmluZChfdGhpcyk7XG5cdCAgICAgICAgX3RoaXMuZWxlbWVudE5vdFZhbGlkYXRlZEhhbmRsZXIgPSBfdGhpcy5vbkVsZW1lbnROb3RWYWxpZGF0ZWQuYmluZChfdGhpcyk7XG5cdCAgICAgICAgX3RoaXMuZWxlbWVudElnbm9yZWRIYW5kbGVyID0gX3RoaXMub25FbGVtZW50SWdub3JlZC5iaW5kKF90aGlzKTtcblx0ICAgICAgICBfdGhpcy5maWVsZEFkZGVkSGFuZGxlciA9IF90aGlzLm9uRmllbGRBZGRlZC5iaW5kKF90aGlzKTtcblx0ICAgICAgICBfdGhpcy5maWVsZFJlbW92ZWRIYW5kbGVyID0gX3RoaXMub25GaWVsZFJlbW92ZWQuYmluZChfdGhpcyk7XG5cdCAgICAgICAgcmV0dXJuIF90aGlzO1xuXHQgICAgfVxuXHQgICAgRmllbGRTdGF0dXMucHJvdG90eXBlLmluc3RhbGwgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5jb3JlXG5cdCAgICAgICAgICAgIC5vbignY29yZS5lbGVtZW50LnZhbGlkYXRpbmcnLCB0aGlzLmVsZW1lbnRWYWxpZGF0aW5nSGFuZGxlcilcblx0ICAgICAgICAgICAgLm9uKCdjb3JlLmVsZW1lbnQudmFsaWRhdGVkJywgdGhpcy5lbGVtZW50VmFsaWRhdGVkSGFuZGxlcilcblx0ICAgICAgICAgICAgLm9uKCdjb3JlLmVsZW1lbnQubm90dmFsaWRhdGVkJywgdGhpcy5lbGVtZW50Tm90VmFsaWRhdGVkSGFuZGxlcilcblx0ICAgICAgICAgICAgLm9uKCdjb3JlLmVsZW1lbnQuaWdub3JlZCcsIHRoaXMuZWxlbWVudElnbm9yZWRIYW5kbGVyKVxuXHQgICAgICAgICAgICAub24oJ2NvcmUuZmllbGQuYWRkZWQnLCB0aGlzLmZpZWxkQWRkZWRIYW5kbGVyKVxuXHQgICAgICAgICAgICAub24oJ2NvcmUuZmllbGQucmVtb3ZlZCcsIHRoaXMuZmllbGRSZW1vdmVkSGFuZGxlcik7XG5cdCAgICB9O1xuXHQgICAgRmllbGRTdGF0dXMucHJvdG90eXBlLnVuaW5zdGFsbCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLnN0YXR1c2VzLmNsZWFyKCk7XG5cdCAgICAgICAgdGhpcy5jb3JlXG5cdCAgICAgICAgICAgIC5vZmYoJ2NvcmUuZWxlbWVudC52YWxpZGF0aW5nJywgdGhpcy5lbGVtZW50VmFsaWRhdGluZ0hhbmRsZXIpXG5cdCAgICAgICAgICAgIC5vZmYoJ2NvcmUuZWxlbWVudC52YWxpZGF0ZWQnLCB0aGlzLmVsZW1lbnRWYWxpZGF0ZWRIYW5kbGVyKVxuXHQgICAgICAgICAgICAub2ZmKCdjb3JlLmVsZW1lbnQubm90dmFsaWRhdGVkJywgdGhpcy5lbGVtZW50Tm90VmFsaWRhdGVkSGFuZGxlcilcblx0ICAgICAgICAgICAgLm9mZignY29yZS5lbGVtZW50Lmlnbm9yZWQnLCB0aGlzLmVsZW1lbnRJZ25vcmVkSGFuZGxlcilcblx0ICAgICAgICAgICAgLm9mZignY29yZS5maWVsZC5hZGRlZCcsIHRoaXMuZmllbGRBZGRlZEhhbmRsZXIpXG5cdCAgICAgICAgICAgIC5vZmYoJ2NvcmUuZmllbGQucmVtb3ZlZCcsIHRoaXMuZmllbGRSZW1vdmVkSGFuZGxlcik7XG5cdCAgICB9O1xuXHQgICAgRmllbGRTdGF0dXMucHJvdG90eXBlLmFyZUZpZWxkc1ZhbGlkID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuc3RhdHVzZXMudmFsdWVzKCkpLmV2ZXJ5KGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09ICdWYWxpZCcgfHwgdmFsdWUgPT09ICdOb3RWYWxpZGF0ZWQnIHx8IHZhbHVlID09PSAnSWdub3JlZCc7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgRmllbGRTdGF0dXMucHJvdG90eXBlLmdldFN0YXR1c2VzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmlzRW5hYmxlZCA/IHRoaXMuc3RhdHVzZXMgOiBuZXcgTWFwKCk7XG5cdCAgICB9O1xuXHQgICAgRmllbGRTdGF0dXMucHJvdG90eXBlLm9uRmllbGRBZGRlZCA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgdGhpcy5zdGF0dXNlcy5zZXQoZS5maWVsZCwgJ05vdFZhbGlkYXRlZCcpO1xuXHQgICAgfTtcblx0ICAgIEZpZWxkU3RhdHVzLnByb3RvdHlwZS5vbkZpZWxkUmVtb3ZlZCA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuc3RhdHVzZXMuaGFzKGUuZmllbGQpKSB7XG5cdCAgICAgICAgICAgIHRoaXMuc3RhdHVzZXMuZGVsZXRlKGUuZmllbGQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLmhhbmRsZVN0YXR1c0NoYW5nZWQodGhpcy5hcmVGaWVsZHNWYWxpZCgpKTtcblx0ICAgIH07XG5cdCAgICBGaWVsZFN0YXR1cy5wcm90b3R5cGUub25FbGVtZW50VmFsaWRhdGluZyA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgdGhpcy5zdGF0dXNlcy5zZXQoZS5maWVsZCwgJ1ZhbGlkYXRpbmcnKTtcblx0ICAgICAgICB0aGlzLmhhbmRsZVN0YXR1c0NoYW5nZWQoZmFsc2UpO1xuXHQgICAgfTtcblx0ICAgIEZpZWxkU3RhdHVzLnByb3RvdHlwZS5vbkVsZW1lbnRWYWxpZGF0ZWQgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIHRoaXMuc3RhdHVzZXMuc2V0KGUuZmllbGQsIGUudmFsaWQgPyAnVmFsaWQnIDogJ0ludmFsaWQnKTtcblx0ICAgICAgICBpZiAoZS52YWxpZCkge1xuXHQgICAgICAgICAgICB0aGlzLmhhbmRsZVN0YXR1c0NoYW5nZWQodGhpcy5hcmVGaWVsZHNWYWxpZCgpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHRoaXMuaGFuZGxlU3RhdHVzQ2hhbmdlZChmYWxzZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIEZpZWxkU3RhdHVzLnByb3RvdHlwZS5vbkVsZW1lbnROb3RWYWxpZGF0ZWQgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIHRoaXMuc3RhdHVzZXMuc2V0KGUuZmllbGQsICdOb3RWYWxpZGF0ZWQnKTtcblx0ICAgICAgICB0aGlzLmhhbmRsZVN0YXR1c0NoYW5nZWQoZmFsc2UpO1xuXHQgICAgfTtcblx0ICAgIEZpZWxkU3RhdHVzLnByb3RvdHlwZS5vbkVsZW1lbnRJZ25vcmVkID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICB0aGlzLnN0YXR1c2VzLnNldChlLmZpZWxkLCAnSWdub3JlZCcpO1xuXHQgICAgICAgIHRoaXMuaGFuZGxlU3RhdHVzQ2hhbmdlZCh0aGlzLmFyZUZpZWxkc1ZhbGlkKCkpO1xuXHQgICAgfTtcblx0ICAgIEZpZWxkU3RhdHVzLnByb3RvdHlwZS5oYW5kbGVTdGF0dXNDaGFuZ2VkID0gZnVuY3Rpb24gKGFyZUZpZWxkc1ZhbGlkKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuaXNFbmFibGVkKSB7XG5cdCAgICAgICAgICAgIHRoaXMub3B0cy5vblN0YXR1c0NoYW5nZWQoYXJlRmllbGRzVmFsaWQpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICByZXR1cm4gRmllbGRTdGF0dXM7XG5cdH0oY29yZS5QbHVnaW4pKTtcblxuXHRjanMkdS5GaWVsZFN0YXR1cyA9IEZpZWxkU3RhdHVzO1xuXHRyZXR1cm4gY2pzJHU7XG59XG5cbi8qKlxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgIGxpYiR1LmV4cG9ydHMgPSByZXF1aXJlSW5kZXhfbWluJHUoKTtcbn0gZWxzZSB7XG4gICAgbGliJHUuZXhwb3J0cyA9IHJlcXVpcmVDanMkdSgpO1xufVxuXG52YXIgbGliRXhwb3J0cyR1ID0gbGliJHUuZXhwb3J0cztcblxudmFyIGxpYiR0ID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIGluZGV4X21pbiR0ID0ge307XG5cbnZhciBsaWIkcyA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBpbmRleF9taW4kcyA9IHt9O1xuXG4vKiogXG4gKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcbiAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuICpcbiAqIEBsaWNlbnNlIGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8vbGljZW5zZVxuICogQHBhY2thZ2UgQGZvcm0tdmFsaWRhdGlvbi9wbHVnaW4tbWVzc2FnZVxuICogQHZlcnNpb24gMi40LjBcbiAqL1xuXG52YXIgaGFzUmVxdWlyZWRJbmRleF9taW4kdDtcblxuZnVuY3Rpb24gcmVxdWlyZUluZGV4X21pbiR0ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkSW5kZXhfbWluJHQpIHJldHVybiBpbmRleF9taW4kcztcblx0aGFzUmVxdWlyZWRJbmRleF9taW4kdCA9IDE7XG52YXIgZT1saWJFeHBvcnRzJEIsdD1mdW5jdGlvbihlLGEpe3JldHVybiB0PU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihlLHQpe2UuX19wcm90b19fPXQ7fXx8ZnVuY3Rpb24oZSx0KXtmb3IodmFyIGEgaW4gdClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxhKSYmKGVbYV09dFthXSk7fSx0KGUsYSl9O3ZhciBhPWUudXRpbHMuY2xhc3NTZXQsbj1mdW5jdGlvbihlKXtmdW5jdGlvbiBuKHQpe3ZhciBhPWUuY2FsbCh0aGlzLHQpfHx0aGlzO3JldHVybiBhLnVzZURlZmF1bHRDb250YWluZXI9ITEsYS5tZXNzYWdlcz1uZXcgTWFwLGEuZGVmYXVsdENvbnRhaW5lcj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLGEudXNlRGVmYXVsdENvbnRhaW5lcj0hdHx8IXQuY29udGFpbmVyLGEub3B0cz1PYmplY3QuYXNzaWduKHt9LHtjb250YWluZXI6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gYS5kZWZhdWx0Q29udGFpbmVyfX0sdCksYS5lbGVtZW50SWdub3JlZEhhbmRsZXI9YS5vbkVsZW1lbnRJZ25vcmVkLmJpbmQoYSksYS5maWVsZEFkZGVkSGFuZGxlcj1hLm9uRmllbGRBZGRlZC5iaW5kKGEpLGEuZmllbGRSZW1vdmVkSGFuZGxlcj1hLm9uRmllbGRSZW1vdmVkLmJpbmQoYSksYS52YWxpZGF0b3JWYWxpZGF0ZWRIYW5kbGVyPWEub25WYWxpZGF0b3JWYWxpZGF0ZWQuYmluZChhKSxhLnZhbGlkYXRvck5vdFZhbGlkYXRlZEhhbmRsZXI9YS5vblZhbGlkYXRvck5vdFZhbGlkYXRlZC5iaW5kKGEpLGF9cmV0dXJuIGZ1bmN0aW9uKGUsYSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgYSYmbnVsbCE9PWEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIrU3RyaW5nKGEpK1wiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7ZnVuY3Rpb24gbigpe3RoaXMuY29uc3RydWN0b3I9ZTt9dChlLGEpLGUucHJvdG90eXBlPW51bGw9PT1hP09iamVjdC5jcmVhdGUoYSk6KG4ucHJvdG90eXBlPWEucHJvdG90eXBlLG5ldyBuKTt9KG4sZSksbi5nZXRDbG9zZXN0Q29udGFpbmVyPWZ1bmN0aW9uKGUsdCxhKXtmb3IodmFyIG49ZTtuJiZuIT09dCYmKG49bi5wYXJlbnRFbGVtZW50LCFhLnRlc3Qobi5jbGFzc05hbWUpKTspO3JldHVybiBufSxuLnByb3RvdHlwZS5pbnN0YWxsPWZ1bmN0aW9uKCl7dGhpcy51c2VEZWZhdWx0Q29udGFpbmVyJiZ0aGlzLmNvcmUuZ2V0Rm9ybUVsZW1lbnQoKS5hcHBlbmRDaGlsZCh0aGlzLmRlZmF1bHRDb250YWluZXIpLHRoaXMuY29yZS5vbihcImNvcmUuZWxlbWVudC5pZ25vcmVkXCIsdGhpcy5lbGVtZW50SWdub3JlZEhhbmRsZXIpLm9uKFwiY29yZS5maWVsZC5hZGRlZFwiLHRoaXMuZmllbGRBZGRlZEhhbmRsZXIpLm9uKFwiY29yZS5maWVsZC5yZW1vdmVkXCIsdGhpcy5maWVsZFJlbW92ZWRIYW5kbGVyKS5vbihcImNvcmUudmFsaWRhdG9yLnZhbGlkYXRlZFwiLHRoaXMudmFsaWRhdG9yVmFsaWRhdGVkSGFuZGxlcikub24oXCJjb3JlLnZhbGlkYXRvci5ub3R2YWxpZGF0ZWRcIix0aGlzLnZhbGlkYXRvck5vdFZhbGlkYXRlZEhhbmRsZXIpO30sbi5wcm90b3R5cGUudW5pbnN0YWxsPWZ1bmN0aW9uKCl7dGhpcy51c2VEZWZhdWx0Q29udGFpbmVyJiZ0aGlzLmNvcmUuZ2V0Rm9ybUVsZW1lbnQoKS5yZW1vdmVDaGlsZCh0aGlzLmRlZmF1bHRDb250YWluZXIpLHRoaXMubWVzc2FnZXMuZm9yRWFjaCgoZnVuY3Rpb24oZSl7cmV0dXJuIGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlKX0pKSx0aGlzLm1lc3NhZ2VzLmNsZWFyKCksdGhpcy5jb3JlLm9mZihcImNvcmUuZWxlbWVudC5pZ25vcmVkXCIsdGhpcy5lbGVtZW50SWdub3JlZEhhbmRsZXIpLm9mZihcImNvcmUuZmllbGQuYWRkZWRcIix0aGlzLmZpZWxkQWRkZWRIYW5kbGVyKS5vZmYoXCJjb3JlLmZpZWxkLnJlbW92ZWRcIix0aGlzLmZpZWxkUmVtb3ZlZEhhbmRsZXIpLm9mZihcImNvcmUudmFsaWRhdG9yLnZhbGlkYXRlZFwiLHRoaXMudmFsaWRhdG9yVmFsaWRhdGVkSGFuZGxlcikub2ZmKFwiY29yZS52YWxpZGF0b3Iubm90dmFsaWRhdGVkXCIsdGhpcy52YWxpZGF0b3JOb3RWYWxpZGF0ZWRIYW5kbGVyKTt9LG4ucHJvdG90eXBlLm9uRW5hYmxlZD1mdW5jdGlvbigpe3RoaXMubWVzc2FnZXMuZm9yRWFjaCgoZnVuY3Rpb24oZSx0LG4pe2EodCx7XCJmdi1wbHVnaW5zLW1lc3NhZ2UtY29udGFpbmVyLS1lbmFibGVkXCI6ITAsXCJmdi1wbHVnaW5zLW1lc3NhZ2UtY29udGFpbmVyLS1kaXNhYmxlZFwiOiExfSk7fSkpO30sbi5wcm90b3R5cGUub25EaXNhYmxlZD1mdW5jdGlvbigpe3RoaXMubWVzc2FnZXMuZm9yRWFjaCgoZnVuY3Rpb24oZSx0LG4pe2EodCx7XCJmdi1wbHVnaW5zLW1lc3NhZ2UtY29udGFpbmVyLS1lbmFibGVkXCI6ITEsXCJmdi1wbHVnaW5zLW1lc3NhZ2UtY29udGFpbmVyLS1kaXNhYmxlZFwiOiEwfSk7fSkpO30sbi5wcm90b3R5cGUub25GaWVsZEFkZGVkPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMsYT1lLmVsZW1lbnRzO2EmJihhLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciBhPXQubWVzc2FnZXMuZ2V0KGUpO2EmJihhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYSksdC5tZXNzYWdlcy5kZWxldGUoZSkpO30pKSx0aGlzLnByZXBhcmVGaWVsZENvbnRhaW5lcihlLmZpZWxkLGEpKTt9LG4ucHJvdG90eXBlLm9uRmllbGRSZW1vdmVkPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7aWYoZS5lbGVtZW50cy5sZW5ndGgmJmUuZmllbGQpe3ZhciBhPWUuZWxlbWVudHNbMF0uZ2V0QXR0cmlidXRlKFwidHlwZVwiKTsoXCJyYWRpb1wiPT09YXx8XCJjaGVja2JveFwiPT09YT9bZS5lbGVtZW50c1swXV06ZS5lbGVtZW50cykuZm9yRWFjaCgoZnVuY3Rpb24oZSl7aWYodC5tZXNzYWdlcy5oYXMoZSkpe3ZhciBhPXQubWVzc2FnZXMuZ2V0KGUpO2EucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhKSx0Lm1lc3NhZ2VzLmRlbGV0ZShlKTt9fSkpO319LG4ucHJvdG90eXBlLnByZXBhcmVGaWVsZENvbnRhaW5lcj1mdW5jdGlvbihlLHQpe3ZhciBhPXRoaXM7aWYodC5sZW5ndGgpe3ZhciBuPXRbMF0uZ2V0QXR0cmlidXRlKFwidHlwZVwiKTtcInJhZGlvXCI9PT1ufHxcImNoZWNrYm94XCI9PT1uP3RoaXMucHJlcGFyZUVsZW1lbnRDb250YWluZXIoZSx0WzBdLHQpOnQuZm9yRWFjaCgoZnVuY3Rpb24obil7cmV0dXJuIGEucHJlcGFyZUVsZW1lbnRDb250YWluZXIoZSxuLHQpfSkpO319LG4ucHJvdG90eXBlLnByZXBhcmVFbGVtZW50Q29udGFpbmVyPWZ1bmN0aW9uKGUsdCxuKXt2YXIgaTtpZihcInN0cmluZ1wiPT10eXBlb2YgdGhpcy5vcHRzLmNvbnRhaW5lcil7dmFyIG89XCIjXCI9PT10aGlzLm9wdHMuY29udGFpbmVyLmNoYXJBdCgwKT8nW2lkPVwiJy5jb25jYXQodGhpcy5vcHRzLmNvbnRhaW5lci5zdWJzdHJpbmcoMSksJ1wiXScpOnRoaXMub3B0cy5jb250YWluZXI7aT10aGlzLmNvcmUuZ2V0Rm9ybUVsZW1lbnQoKS5xdWVyeVNlbGVjdG9yKG8pO31lbHNlIGk9dGhpcy5vcHRzLmNvbnRhaW5lcihlLHQpO3ZhciByPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7aS5hcHBlbmRDaGlsZChyKSxhKHIse1wiZnYtcGx1Z2lucy1tZXNzYWdlLWNvbnRhaW5lclwiOiEwLFwiZnYtcGx1Z2lucy1tZXNzYWdlLWNvbnRhaW5lci0tZW5hYmxlZFwiOnRoaXMuaXNFbmFibGVkLFwiZnYtcGx1Z2lucy1tZXNzYWdlLWNvbnRhaW5lci0tZGlzYWJsZWRcIjohdGhpcy5pc0VuYWJsZWR9KSx0aGlzLmNvcmUuZW1pdChcInBsdWdpbnMubWVzc2FnZS5wbGFjZWRcIix7ZWxlbWVudDp0LGVsZW1lbnRzOm4sZmllbGQ6ZSxtZXNzYWdlRWxlbWVudDpyfSksdGhpcy5tZXNzYWdlcy5zZXQodCxyKTt9LG4ucHJvdG90eXBlLmdldE1lc3NhZ2U9ZnVuY3Rpb24oZSl7cmV0dXJuIFwic3RyaW5nXCI9PXR5cGVvZiBlLm1lc3NhZ2U/ZS5tZXNzYWdlOmUubWVzc2FnZVt0aGlzLmNvcmUuZ2V0TG9jYWxlKCldfSxuLnByb3RvdHlwZS5vblZhbGlkYXRvclZhbGlkYXRlZD1mdW5jdGlvbihlKXt2YXIgdCxuPWUuZWxlbWVudHMsaT1lLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSxvPShcInJhZGlvXCI9PT1pfHxcImNoZWNrYm94XCI9PT1pKSYmbi5sZW5ndGg+MD9uWzBdOmUuZWxlbWVudDtpZih0aGlzLm1lc3NhZ2VzLmhhcyhvKSl7dmFyIHI9dGhpcy5tZXNzYWdlcy5nZXQobykscz1yLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWZpZWxkPVwiJy5jb25jYXQoZS5maWVsZC5yZXBsYWNlKC9cIi9nLCdcXFxcXCInKSwnXCJdW2RhdGEtdmFsaWRhdG9yPVwiJykuY29uY2F0KGUudmFsaWRhdG9yLnJlcGxhY2UoL1wiL2csJ1xcXFxcIicpLCdcIl0nKSk7aWYoc3x8ZS5yZXN1bHQudmFsaWQpcyYmIWUucmVzdWx0LnZhbGlkPyhzLmlubmVySFRNTD10aGlzLmdldE1lc3NhZ2UoZS5yZXN1bHQpLHRoaXMuY29yZS5lbWl0KFwicGx1Z2lucy5tZXNzYWdlLmRpc3BsYXllZFwiLHtlbGVtZW50OmUuZWxlbWVudCxmaWVsZDplLmZpZWxkLG1lc3NhZ2U6ZS5yZXN1bHQubWVzc2FnZSxtZXNzYWdlRWxlbWVudDpzLG1ldGE6ZS5yZXN1bHQubWV0YSx2YWxpZGF0b3I6ZS52YWxpZGF0b3J9KSk6cyYmZS5yZXN1bHQudmFsaWQmJnIucmVtb3ZlQ2hpbGQocyk7ZWxzZSB7dmFyIGw9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtsLmlubmVySFRNTD10aGlzLmdldE1lc3NhZ2UoZS5yZXN1bHQpLGwuc2V0QXR0cmlidXRlKFwiZGF0YS1maWVsZFwiLGUuZmllbGQpLGwuc2V0QXR0cmlidXRlKFwiZGF0YS12YWxpZGF0b3JcIixlLnZhbGlkYXRvciksdGhpcy5vcHRzLmNsYXp6JiZhKGwsKCh0PXt9KVt0aGlzLm9wdHMuY2xhenpdPSEwLHQpKSxyLmFwcGVuZENoaWxkKGwpLHRoaXMuY29yZS5lbWl0KFwicGx1Z2lucy5tZXNzYWdlLmRpc3BsYXllZFwiLHtlbGVtZW50OmUuZWxlbWVudCxmaWVsZDplLmZpZWxkLG1lc3NhZ2U6ZS5yZXN1bHQubWVzc2FnZSxtZXNzYWdlRWxlbWVudDpsLG1ldGE6ZS5yZXN1bHQubWV0YSx2YWxpZGF0b3I6ZS52YWxpZGF0b3J9KTt9fX0sbi5wcm90b3R5cGUub25WYWxpZGF0b3JOb3RWYWxpZGF0ZWQ9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5lbGVtZW50cyxhPWUuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpLG49XCJyYWRpb1wiPT09YXx8XCJjaGVja2JveFwiPT09YT90WzBdOmUuZWxlbWVudDtpZih0aGlzLm1lc3NhZ2VzLmhhcyhuKSl7dmFyIGk9dGhpcy5tZXNzYWdlcy5nZXQobiksbz1pLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWZpZWxkPVwiJy5jb25jYXQoZS5maWVsZC5yZXBsYWNlKC9cIi9nLCdcXFxcXCInKSwnXCJdW2RhdGEtdmFsaWRhdG9yPVwiJykuY29uY2F0KGUudmFsaWRhdG9yLnJlcGxhY2UoL1wiL2csJ1xcXFxcIicpLCdcIl0nKSk7byYmaS5yZW1vdmVDaGlsZChvKTt9fSxuLnByb3RvdHlwZS5vbkVsZW1lbnRJZ25vcmVkPWZ1bmN0aW9uKGUpe3ZhciB0PWUuZWxlbWVudHMsYT1lLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSxuPVwicmFkaW9cIj09PWF8fFwiY2hlY2tib3hcIj09PWE/dFswXTplLmVsZW1lbnQ7aWYodGhpcy5tZXNzYWdlcy5oYXMobikpe3ZhciBpPXRoaXMubWVzc2FnZXMuZ2V0KG4pO1tdLnNsaWNlLmNhbGwoaS5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1maWVsZD1cIicuY29uY2F0KGUuZmllbGQucmVwbGFjZSgvXCIvZywnXFxcXFwiJyksJ1wiXScpKSkuZm9yRWFjaCgoZnVuY3Rpb24oZSl7aS5yZW1vdmVDaGlsZChlKTt9KSk7fX0sbn0oZS5QbHVnaW4pO2luZGV4X21pbiRzLk1lc3NhZ2U9bjtcblx0cmV0dXJuIGluZGV4X21pbiRzO1xufVxuXG52YXIgY2pzJHQgPSB7fTtcblxudmFyIGhhc1JlcXVpcmVkQ2pzJHQ7XG5cbmZ1bmN0aW9uIHJlcXVpcmVDanMkdCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZENqcyR0KSByZXR1cm4gY2pzJHQ7XG5cdGhhc1JlcXVpcmVkQ2pzJHQgPSAxO1xuXG5cdHZhciBjb3JlID0gbGliRXhwb3J0cyRCO1xuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuXHRDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblx0UGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcblx0cHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuXHRUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblx0UkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcblx0QU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5cdElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5cdExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcblx0T1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5cdFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcblx0KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHQvKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxuXHR2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuXHQgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG5cdCAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG5cdCAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuXHQgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuXHQgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuXHQgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuXHQgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuXHQgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcblx0ICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuXHR9XG5cblx0LyoqXG5cdCAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuXHQgKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcblx0ICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuXHQgKi9cblx0dmFyIGNsYXNzU2V0ID0gY29yZS51dGlscy5jbGFzc1NldDtcblx0dmFyIE1lc3NhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoTWVzc2FnZSwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIE1lc3NhZ2Uob3B0cykge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdHMpIHx8IHRoaXM7XG5cdCAgICAgICAgX3RoaXMudXNlRGVmYXVsdENvbnRhaW5lciA9IGZhbHNlO1xuXHQgICAgICAgIC8vIE1hcCB0aGUgZmllbGQgZWxlbWVudCB0byBtZXNzYWdlIGNvbnRhaW5lclxuXHQgICAgICAgIF90aGlzLm1lc3NhZ2VzID0gbmV3IE1hcCgpO1xuXHQgICAgICAgIC8vIEJ5IGRlZmF1bHQsIHdlIHdpbGwgZGlzcGxheSBlcnJvciBtZXNzYWdlcyBhdCB0aGUgYm90dG9tIG9mIGZvcm1cblx0ICAgICAgICBfdGhpcy5kZWZhdWx0Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdCAgICAgICAgX3RoaXMudXNlRGVmYXVsdENvbnRhaW5lciA9ICFvcHRzIHx8ICFvcHRzLmNvbnRhaW5lcjtcblx0ICAgICAgICBfdGhpcy5vcHRzID0gT2JqZWN0LmFzc2lnbih7fSwge1xuXHQgICAgICAgICAgICBjb250YWluZXI6IGZ1bmN0aW9uIChfZmllbGQsIF9lbGVtZW50KSB7IHJldHVybiBfdGhpcy5kZWZhdWx0Q29udGFpbmVyOyB9LFxuXHQgICAgICAgIH0sIG9wdHMpO1xuXHQgICAgICAgIF90aGlzLmVsZW1lbnRJZ25vcmVkSGFuZGxlciA9IF90aGlzLm9uRWxlbWVudElnbm9yZWQuYmluZChfdGhpcyk7XG5cdCAgICAgICAgX3RoaXMuZmllbGRBZGRlZEhhbmRsZXIgPSBfdGhpcy5vbkZpZWxkQWRkZWQuYmluZChfdGhpcyk7XG5cdCAgICAgICAgX3RoaXMuZmllbGRSZW1vdmVkSGFuZGxlciA9IF90aGlzLm9uRmllbGRSZW1vdmVkLmJpbmQoX3RoaXMpO1xuXHQgICAgICAgIF90aGlzLnZhbGlkYXRvclZhbGlkYXRlZEhhbmRsZXIgPSBfdGhpcy5vblZhbGlkYXRvclZhbGlkYXRlZC5iaW5kKF90aGlzKTtcblx0ICAgICAgICBfdGhpcy52YWxpZGF0b3JOb3RWYWxpZGF0ZWRIYW5kbGVyID0gX3RoaXMub25WYWxpZGF0b3JOb3RWYWxpZGF0ZWQuYmluZChfdGhpcyk7XG5cdCAgICAgICAgcmV0dXJuIF90aGlzO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBEZXRlcm1pbmUgdGhlIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGl0cyBjbGFzcyBtYXRjaGVzIHdpdGggZ2l2ZW4gcGF0dGVybi5cblx0ICAgICAqIEluIHBvcHVsYXIgY2FzZXMsIGFsbCB0aGUgZmllbGRzIG1pZ2h0IGZvbGxvdyB0aGUgc2FtZSBtYXJrdXAsIHNvIHRoYXQgY2xvc2VzdCBlbGVtZW50XG5cdCAgICAgKiBjYW4gYmUgdXNlZCBhcyBtZXNzYWdlIGNvbnRhaW5lci5cblx0ICAgICAqXG5cdCAgICAgKiBGb3IgZXhhbXBsZSwgaWYgd2UgdXNlIHRoZSBCb290c3RyYXAgZnJhbWV3b3JrIHRoZW4gdGhlIGZpZWxkIG9mdGVuIGJlIHBsYWNlZCBpbnNpZGUgYVxuXHQgICAgICogYGNvbC17c2l6ZX0te251bWJlck9mQ29sdW1uc31gIGNsYXNzLCB3ZSBjYW4gcmVnaXN0ZXIgdGhlIHBsdWdpbiBhcyBmb2xsb3dpbmc6XG5cdCAgICAgKiBgYGBcblx0ICAgICAqICBmb3JtVmFsaWRhdGlvbihmb3JtLCB7XG5cdCAgICAgKiAgICAgIHBsdWdpbnM6IHtcblx0ICAgICAqICAgICAgICAgIG1lc3NhZ2U6IG5ldyBNZXNzYWdlKHtcblx0ICAgICAqICAgICAgICAgICAgICBjb250YWluZXI6IGZ1bmN0aW9uKGZpZWxkLCBlbGVtZW50KSB7XG5cdCAgICAgKiAgICAgICAgICAgICAgICAgIHJldHVybiBNZXNzYWdlLmdldENsb3Nlc3RDb250YWluZXIoZWxlbWVudCwgZm9ybSwgL14oLiopKGNvbHxvZmZzZXQpLSh4c3xzbXxtZHxsZyktWzAtOV0rKC4qKSQvKVxuXHQgICAgICogICAgICAgICAgICAgIH1cblx0ICAgICAqICAgICAgICAgIH0pXG5cdCAgICAgKiAgICAgIH1cblx0ICAgICAqICB9KVxuXHQgICAgICogYGBgXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIGVsZW1lbnQgVGhlIGZpZWxkIGVsZW1lbnRcblx0ICAgICAqIEBwYXJhbSB1cHBlciBUaGUgdXBwZXIgZWxlbWVudCwgc28gd2UgZG9uJ3QgaGF2ZSB0byBsb29rIGZvciB0aGUgZW50aXJlIHBhZ2Vcblx0ICAgICAqIEBwYXJhbSBwYXR0ZXJuIFRoZSBwYXR0ZXJuXG5cdCAgICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cblx0ICAgICAqL1xuXHQgICAgTWVzc2FnZS5nZXRDbG9zZXN0Q29udGFpbmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIHVwcGVyLCBwYXR0ZXJuKSB7XG5cdCAgICAgICAgdmFyIGVsZSA9IGVsZW1lbnQ7XG5cdCAgICAgICAgd2hpbGUgKGVsZSkge1xuXHQgICAgICAgICAgICBpZiAoZWxlID09PSB1cHBlcikge1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxlID0gZWxlLnBhcmVudEVsZW1lbnQ7XG5cdCAgICAgICAgICAgIGlmIChwYXR0ZXJuLnRlc3QoZWxlLmNsYXNzTmFtZSkpIHtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBlbGU7XG5cdCAgICB9O1xuXHQgICAgTWVzc2FnZS5wcm90b3R5cGUuaW5zdGFsbCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAodGhpcy51c2VEZWZhdWx0Q29udGFpbmVyKSB7XG5cdCAgICAgICAgICAgIHRoaXMuY29yZS5nZXRGb3JtRWxlbWVudCgpLmFwcGVuZENoaWxkKHRoaXMuZGVmYXVsdENvbnRhaW5lcik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuY29yZVxuXHQgICAgICAgICAgICAub24oJ2NvcmUuZWxlbWVudC5pZ25vcmVkJywgdGhpcy5lbGVtZW50SWdub3JlZEhhbmRsZXIpXG5cdCAgICAgICAgICAgIC5vbignY29yZS5maWVsZC5hZGRlZCcsIHRoaXMuZmllbGRBZGRlZEhhbmRsZXIpXG5cdCAgICAgICAgICAgIC5vbignY29yZS5maWVsZC5yZW1vdmVkJywgdGhpcy5maWVsZFJlbW92ZWRIYW5kbGVyKVxuXHQgICAgICAgICAgICAub24oJ2NvcmUudmFsaWRhdG9yLnZhbGlkYXRlZCcsIHRoaXMudmFsaWRhdG9yVmFsaWRhdGVkSGFuZGxlcilcblx0ICAgICAgICAgICAgLm9uKCdjb3JlLnZhbGlkYXRvci5ub3R2YWxpZGF0ZWQnLCB0aGlzLnZhbGlkYXRvck5vdFZhbGlkYXRlZEhhbmRsZXIpO1xuXHQgICAgfTtcblx0ICAgIE1lc3NhZ2UucHJvdG90eXBlLnVuaW5zdGFsbCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAodGhpcy51c2VEZWZhdWx0Q29udGFpbmVyKSB7XG5cdCAgICAgICAgICAgIHRoaXMuY29yZS5nZXRGb3JtRWxlbWVudCgpLnJlbW92ZUNoaWxkKHRoaXMuZGVmYXVsdENvbnRhaW5lcik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMubWVzc2FnZXMuZm9yRWFjaChmdW5jdGlvbiAobWVzc2FnZSkgeyByZXR1cm4gbWVzc2FnZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG1lc3NhZ2UpOyB9KTtcblx0ICAgICAgICB0aGlzLm1lc3NhZ2VzLmNsZWFyKCk7XG5cdCAgICAgICAgdGhpcy5jb3JlXG5cdCAgICAgICAgICAgIC5vZmYoJ2NvcmUuZWxlbWVudC5pZ25vcmVkJywgdGhpcy5lbGVtZW50SWdub3JlZEhhbmRsZXIpXG5cdCAgICAgICAgICAgIC5vZmYoJ2NvcmUuZmllbGQuYWRkZWQnLCB0aGlzLmZpZWxkQWRkZWRIYW5kbGVyKVxuXHQgICAgICAgICAgICAub2ZmKCdjb3JlLmZpZWxkLnJlbW92ZWQnLCB0aGlzLmZpZWxkUmVtb3ZlZEhhbmRsZXIpXG5cdCAgICAgICAgICAgIC5vZmYoJ2NvcmUudmFsaWRhdG9yLnZhbGlkYXRlZCcsIHRoaXMudmFsaWRhdG9yVmFsaWRhdGVkSGFuZGxlcilcblx0ICAgICAgICAgICAgLm9mZignY29yZS52YWxpZGF0b3Iubm90dmFsaWRhdGVkJywgdGhpcy52YWxpZGF0b3JOb3RWYWxpZGF0ZWRIYW5kbGVyKTtcblx0ICAgIH07XG5cdCAgICBNZXNzYWdlLnByb3RvdHlwZS5vbkVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5tZXNzYWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChfZWxlbWVudCwgbWVzc2FnZSwgX21hcCkge1xuXHQgICAgICAgICAgICBjbGFzc1NldChtZXNzYWdlLCB7XG5cdCAgICAgICAgICAgICAgICAnZnYtcGx1Z2lucy1tZXNzYWdlLWNvbnRhaW5lci0tZW5hYmxlZCc6IHRydWUsXG5cdCAgICAgICAgICAgICAgICAnZnYtcGx1Z2lucy1tZXNzYWdlLWNvbnRhaW5lci0tZGlzYWJsZWQnOiBmYWxzZSxcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgTWVzc2FnZS5wcm90b3R5cGUub25EaXNhYmxlZCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLm1lc3NhZ2VzLmZvckVhY2goZnVuY3Rpb24gKF9lbGVtZW50LCBtZXNzYWdlLCBfbWFwKSB7XG5cdCAgICAgICAgICAgIGNsYXNzU2V0KG1lc3NhZ2UsIHtcblx0ICAgICAgICAgICAgICAgICdmdi1wbHVnaW5zLW1lc3NhZ2UtY29udGFpbmVyLS1lbmFibGVkJzogZmFsc2UsXG5cdCAgICAgICAgICAgICAgICAnZnYtcGx1Z2lucy1tZXNzYWdlLWNvbnRhaW5lci0tZGlzYWJsZWQnOiB0cnVlLFxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICAvLyBQcmVwYXJlIG1lc3NhZ2UgY29udGFpbmVyIGZvciBuZXcgYWRkZWQgZmllbGRcblx0ICAgIE1lc3NhZ2UucHJvdG90eXBlLm9uRmllbGRBZGRlZCA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB2YXIgZWxlbWVudHMgPSBlLmVsZW1lbnRzO1xuXHQgICAgICAgIGlmIChlbGVtZW50cykge1xuXHQgICAgICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBtc2cgPSBfdGhpcy5tZXNzYWdlcy5nZXQoZWxlKTtcblx0ICAgICAgICAgICAgICAgIGlmIChtc2cpIHtcblx0ICAgICAgICAgICAgICAgICAgICBtc2cucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChtc2cpO1xuXHQgICAgICAgICAgICAgICAgICAgIF90aGlzLm1lc3NhZ2VzLmRlbGV0ZShlbGUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgdGhpcy5wcmVwYXJlRmllbGRDb250YWluZXIoZS5maWVsZCwgZWxlbWVudHMpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvLyBXaGVuIGEgZmllbGQgaXMgcmVtb3ZlZCwgd2UgcmVtb3ZlIGFsbCBlcnJvciBtZXNzYWdlcyB0aGF0IGFzc29jaWF0ZXMgd2l0aCB0aGUgZmllbGRcblx0ICAgIE1lc3NhZ2UucHJvdG90eXBlLm9uRmllbGRSZW1vdmVkID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGlmICghZS5lbGVtZW50cy5sZW5ndGggfHwgIWUuZmllbGQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgdHlwZSA9IGUuZWxlbWVudHNbMF0uZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG5cdCAgICAgICAgdmFyIGVsZW1lbnRzID0gJ3JhZGlvJyA9PT0gdHlwZSB8fCAnY2hlY2tib3gnID09PSB0eXBlID8gW2UuZWxlbWVudHNbMF1dIDogZS5lbGVtZW50cztcblx0ICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcblx0ICAgICAgICAgICAgaWYgKF90aGlzLm1lc3NhZ2VzLmhhcyhlbGUpKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyID0gX3RoaXMubWVzc2FnZXMuZ2V0KGVsZSk7XG5cdCAgICAgICAgICAgICAgICBjb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjb250YWluZXIpO1xuXHQgICAgICAgICAgICAgICAgX3RoaXMubWVzc2FnZXMuZGVsZXRlKGVsZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBNZXNzYWdlLnByb3RvdHlwZS5wcmVwYXJlRmllbGRDb250YWluZXIgPSBmdW5jdGlvbiAoZmllbGQsIGVsZW1lbnRzKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgIHZhciB0eXBlID0gZWxlbWVudHNbMF0uZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG5cdCAgICAgICAgICAgIGlmICgncmFkaW8nID09PSB0eXBlIHx8ICdjaGVja2JveCcgPT09IHR5cGUpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMucHJlcGFyZUVsZW1lbnRDb250YWluZXIoZmllbGQsIGVsZW1lbnRzWzBdLCBlbGVtZW50cyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHsgcmV0dXJuIF90aGlzLnByZXBhcmVFbGVtZW50Q29udGFpbmVyKGZpZWxkLCBlbGUsIGVsZW1lbnRzKTsgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgTWVzc2FnZS5wcm90b3R5cGUucHJlcGFyZUVsZW1lbnRDb250YWluZXIgPSBmdW5jdGlvbiAoZmllbGQsIGVsZW1lbnQsIGVsZW1lbnRzKSB7XG5cdCAgICAgICAgdmFyIGNvbnRhaW5lcjtcblx0ICAgICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB0aGlzLm9wdHMuY29udGFpbmVyKSB7XG5cdCAgICAgICAgICAgIHZhciBzZWxlY3RvciA9ICcjJyA9PT0gdGhpcy5vcHRzLmNvbnRhaW5lci5jaGFyQXQoMClcblx0ICAgICAgICAgICAgICAgID8gXCJbaWQ9XFxcIlwiLmNvbmNhdCh0aGlzLm9wdHMuY29udGFpbmVyLnN1YnN0cmluZygxKSwgXCJcXFwiXVwiKVxuXHQgICAgICAgICAgICAgICAgOiB0aGlzLm9wdHMuY29udGFpbmVyO1xuXHQgICAgICAgICAgICBjb250YWluZXIgPSB0aGlzLmNvcmUuZ2V0Rm9ybUVsZW1lbnQoKS5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIGNvbnRhaW5lciA9IHRoaXMub3B0cy5jb250YWluZXIoZmllbGQsIGVsZW1lbnQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgbWVzc2FnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHQgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChtZXNzYWdlKTtcblx0ICAgICAgICBjbGFzc1NldChtZXNzYWdlLCB7XG5cdCAgICAgICAgICAgICdmdi1wbHVnaW5zLW1lc3NhZ2UtY29udGFpbmVyJzogdHJ1ZSxcblx0ICAgICAgICAgICAgJ2Z2LXBsdWdpbnMtbWVzc2FnZS1jb250YWluZXItLWVuYWJsZWQnOiB0aGlzLmlzRW5hYmxlZCxcblx0ICAgICAgICAgICAgJ2Z2LXBsdWdpbnMtbWVzc2FnZS1jb250YWluZXItLWRpc2FibGVkJzogIXRoaXMuaXNFbmFibGVkLFxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHRoaXMuY29yZS5lbWl0KCdwbHVnaW5zLm1lc3NhZ2UucGxhY2VkJywge1xuXHQgICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuXHQgICAgICAgICAgICBlbGVtZW50czogZWxlbWVudHMsXG5cdCAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcblx0ICAgICAgICAgICAgbWVzc2FnZUVsZW1lbnQ6IG1lc3NhZ2UsXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgdGhpcy5tZXNzYWdlcy5zZXQoZWxlbWVudCwgbWVzc2FnZSk7XG5cdCAgICB9O1xuXHQgICAgTWVzc2FnZS5wcm90b3R5cGUuZ2V0TWVzc2FnZSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0ICAgICAgICByZXR1cm4gdHlwZW9mIHJlc3VsdC5tZXNzYWdlID09PSAnc3RyaW5nJyA/IHJlc3VsdC5tZXNzYWdlIDogcmVzdWx0Lm1lc3NhZ2VbdGhpcy5jb3JlLmdldExvY2FsZSgpXTtcblx0ICAgIH07XG5cdCAgICBNZXNzYWdlLnByb3RvdHlwZS5vblZhbGlkYXRvclZhbGlkYXRlZCA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgdmFyIF9hO1xuXHQgICAgICAgIHZhciBlbGVtZW50cyA9IGUuZWxlbWVudHM7XG5cdCAgICAgICAgdmFyIHR5cGUgPSBlLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG5cdCAgICAgICAgdmFyIGVsZW1lbnQgPSAoJ3JhZGlvJyA9PT0gdHlwZSB8fCAnY2hlY2tib3gnID09PSB0eXBlKSAmJiBlbGVtZW50cy5sZW5ndGggPiAwID8gZWxlbWVudHNbMF0gOiBlLmVsZW1lbnQ7XG5cdCAgICAgICAgaWYgKHRoaXMubWVzc2FnZXMuaGFzKGVsZW1lbnQpKSB7XG5cdCAgICAgICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLm1lc3NhZ2VzLmdldChlbGVtZW50KTtcblx0ICAgICAgICAgICAgdmFyIG1lc3NhZ2VFbGUgPSBjb250YWluZXIucXVlcnlTZWxlY3RvcihcIltkYXRhLWZpZWxkPVxcXCJcIi5jb25jYXQoZS5maWVsZC5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJyksIFwiXFxcIl1bZGF0YS12YWxpZGF0b3I9XFxcIlwiKS5jb25jYXQoZS52YWxpZGF0b3IucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpLCBcIlxcXCJdXCIpKTtcblx0ICAgICAgICAgICAgaWYgKCFtZXNzYWdlRWxlICYmICFlLnJlc3VsdC52YWxpZCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGVsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHQgICAgICAgICAgICAgICAgZWxlLmlubmVySFRNTCA9IHRoaXMuZ2V0TWVzc2FnZShlLnJlc3VsdCk7XG5cdCAgICAgICAgICAgICAgICBlbGUuc2V0QXR0cmlidXRlKCdkYXRhLWZpZWxkJywgZS5maWVsZCk7XG5cdCAgICAgICAgICAgICAgICBlbGUuc2V0QXR0cmlidXRlKCdkYXRhLXZhbGlkYXRvcicsIGUudmFsaWRhdG9yKTtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdHMuY2xhenopIHtcblx0ICAgICAgICAgICAgICAgICAgICBjbGFzc1NldChlbGUsIChfYSA9IHt9LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYVt0aGlzLm9wdHMuY2xhenpdID0gdHJ1ZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2EpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbGUpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5jb3JlLmVtaXQoJ3BsdWdpbnMubWVzc2FnZS5kaXNwbGF5ZWQnLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogZS5lbGVtZW50LFxuXHQgICAgICAgICAgICAgICAgICAgIGZpZWxkOiBlLmZpZWxkLFxuXHQgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGUucmVzdWx0Lm1lc3NhZ2UsXG5cdCAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUVsZW1lbnQ6IGVsZSxcblx0ICAgICAgICAgICAgICAgICAgICBtZXRhOiBlLnJlc3VsdC5tZXRhLFxuXHQgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvcjogZS52YWxpZGF0b3IsXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmIChtZXNzYWdlRWxlICYmICFlLnJlc3VsdC52YWxpZCkge1xuXHQgICAgICAgICAgICAgICAgLy8gVGhlIHZhbGlkYXRvciByZXR1cm5zIG5ldyBtZXNzYWdlXG5cdCAgICAgICAgICAgICAgICBtZXNzYWdlRWxlLmlubmVySFRNTCA9IHRoaXMuZ2V0TWVzc2FnZShlLnJlc3VsdCk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvcmUuZW1pdCgncGx1Z2lucy5tZXNzYWdlLmRpc3BsYXllZCcsIHtcblx0ICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBlLmVsZW1lbnQsXG5cdCAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGUuZmllbGQsXG5cdCAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZS5yZXN1bHQubWVzc2FnZSxcblx0ICAgICAgICAgICAgICAgICAgICBtZXNzYWdlRWxlbWVudDogbWVzc2FnZUVsZSxcblx0ICAgICAgICAgICAgICAgICAgICBtZXRhOiBlLnJlc3VsdC5tZXRhLFxuXHQgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvcjogZS52YWxpZGF0b3IsXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmIChtZXNzYWdlRWxlICYmIGUucmVzdWx0LnZhbGlkKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBGaWVsZCBpcyB2YWxpZFxuXHQgICAgICAgICAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKG1lc3NhZ2VFbGUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIE1lc3NhZ2UucHJvdG90eXBlLm9uVmFsaWRhdG9yTm90VmFsaWRhdGVkID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICB2YXIgZWxlbWVudHMgPSBlLmVsZW1lbnRzO1xuXHQgICAgICAgIHZhciB0eXBlID0gZS5lbGVtZW50LmdldEF0dHJpYnV0ZSgndHlwZScpO1xuXHQgICAgICAgIHZhciBlbGVtZW50ID0gJ3JhZGlvJyA9PT0gdHlwZSB8fCAnY2hlY2tib3gnID09PSB0eXBlID8gZWxlbWVudHNbMF0gOiBlLmVsZW1lbnQ7XG5cdCAgICAgICAgaWYgKHRoaXMubWVzc2FnZXMuaGFzKGVsZW1lbnQpKSB7XG5cdCAgICAgICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLm1lc3NhZ2VzLmdldChlbGVtZW50KTtcblx0ICAgICAgICAgICAgdmFyIG1lc3NhZ2VFbGUgPSBjb250YWluZXIucXVlcnlTZWxlY3RvcihcIltkYXRhLWZpZWxkPVxcXCJcIi5jb25jYXQoZS5maWVsZC5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJyksIFwiXFxcIl1bZGF0YS12YWxpZGF0b3I9XFxcIlwiKS5jb25jYXQoZS52YWxpZGF0b3IucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpLCBcIlxcXCJdXCIpKTtcblx0ICAgICAgICAgICAgaWYgKG1lc3NhZ2VFbGUpIHtcblx0ICAgICAgICAgICAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChtZXNzYWdlRWxlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICBNZXNzYWdlLnByb3RvdHlwZS5vbkVsZW1lbnRJZ25vcmVkID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICB2YXIgZWxlbWVudHMgPSBlLmVsZW1lbnRzO1xuXHQgICAgICAgIHZhciB0eXBlID0gZS5lbGVtZW50LmdldEF0dHJpYnV0ZSgndHlwZScpO1xuXHQgICAgICAgIHZhciBlbGVtZW50ID0gJ3JhZGlvJyA9PT0gdHlwZSB8fCAnY2hlY2tib3gnID09PSB0eXBlID8gZWxlbWVudHNbMF0gOiBlLmVsZW1lbnQ7XG5cdCAgICAgICAgaWYgKHRoaXMubWVzc2FnZXMuaGFzKGVsZW1lbnQpKSB7XG5cdCAgICAgICAgICAgIHZhciBjb250YWluZXJfMSA9IHRoaXMubWVzc2FnZXMuZ2V0KGVsZW1lbnQpO1xuXHQgICAgICAgICAgICB2YXIgbWVzc2FnZUVsZW1lbnRzID0gW10uc2xpY2UuY2FsbChjb250YWluZXJfMS5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtZmllbGQ9XFxcIlwiLmNvbmNhdChlLmZpZWxkLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKSwgXCJcXFwiXVwiKSkpO1xuXHQgICAgICAgICAgICBtZXNzYWdlRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobWVzc2FnZUVsZSkge1xuXHQgICAgICAgICAgICAgICAgY29udGFpbmVyXzEucmVtb3ZlQ2hpbGQobWVzc2FnZUVsZSk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICByZXR1cm4gTWVzc2FnZTtcblx0fShjb3JlLlBsdWdpbikpO1xuXG5cdGNqcyR0Lk1lc3NhZ2UgPSBNZXNzYWdlO1xuXHRyZXR1cm4gY2pzJHQ7XG59XG5cbi8qKlxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgIGxpYiRzLmV4cG9ydHMgPSByZXF1aXJlSW5kZXhfbWluJHQoKTtcbn0gZWxzZSB7XG4gICAgbGliJHMuZXhwb3J0cyA9IHJlcXVpcmVDanMkdCgpO1xufVxuXG52YXIgbGliRXhwb3J0cyR0ID0gbGliJHMuZXhwb3J0cztcblxuLyoqIFxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqXG4gKiBAbGljZW5zZSBodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvL2xpY2Vuc2VcbiAqIEBwYWNrYWdlIEBmb3JtLXZhbGlkYXRpb24vcGx1Z2luLWZyYW1ld29ya1xuICogQHZlcnNpb24gMi40LjBcbiAqL1xuXG52YXIgaGFzUmVxdWlyZWRJbmRleF9taW4kcztcblxuZnVuY3Rpb24gcmVxdWlyZUluZGV4X21pbiRzICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkSW5kZXhfbWluJHMpIHJldHVybiBpbmRleF9taW4kdDtcblx0aGFzUmVxdWlyZWRJbmRleF9taW4kcyA9IDE7XG52YXIgZT1saWJFeHBvcnRzJEIsdD1saWJFeHBvcnRzJHQsbz1mdW5jdGlvbihlLHQpe3JldHVybiBvPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihlLHQpe2UuX19wcm90b19fPXQ7fXx8ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG8gaW4gdClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxvKSYmKGVbb109dFtvXSk7fSxvKGUsdCl9O3ZhciBuPWUudXRpbHMuY2xhc3NTZXQscz1lLnV0aWxzLmNsb3Nlc3QsaT1mdW5jdGlvbihlKXtmdW5jdGlvbiBpKHQpe3ZhciBvPWUuY2FsbCh0aGlzLHQpfHx0aGlzO3JldHVybiBvLnJlc3VsdHM9bmV3IE1hcCxvLmNvbnRhaW5lcnM9bmV3IE1hcCxvLm9wdHM9T2JqZWN0LmFzc2lnbih7fSx7ZGVmYXVsdE1lc3NhZ2VDb250YWluZXI6ITAsZWxlSW52YWxpZENsYXNzOlwiXCIsZWxlVmFsaWRDbGFzczpcIlwiLHJvd0NsYXNzZXM6XCJcIixyb3dWYWxpZGF0aW5nQ2xhc3M6XCJcIn0sdCksby5lbGVtZW50SWdub3JlZEhhbmRsZXI9by5vbkVsZW1lbnRJZ25vcmVkLmJpbmQobyksby5lbGVtZW50VmFsaWRhdGluZ0hhbmRsZXI9by5vbkVsZW1lbnRWYWxpZGF0aW5nLmJpbmQobyksby5lbGVtZW50VmFsaWRhdGVkSGFuZGxlcj1vLm9uRWxlbWVudFZhbGlkYXRlZC5iaW5kKG8pLG8uZWxlbWVudE5vdFZhbGlkYXRlZEhhbmRsZXI9by5vbkVsZW1lbnROb3RWYWxpZGF0ZWQuYmluZChvKSxvLmljb25QbGFjZWRIYW5kbGVyPW8ub25JY29uUGxhY2VkLmJpbmQobyksby5maWVsZEFkZGVkSGFuZGxlcj1vLm9uRmllbGRBZGRlZC5iaW5kKG8pLG8uZmllbGRSZW1vdmVkSGFuZGxlcj1vLm9uRmllbGRSZW1vdmVkLmJpbmQobyksby5tZXNzYWdlUGxhY2VkSGFuZGxlcj1vLm9uTWVzc2FnZVBsYWNlZC5iaW5kKG8pLG99cmV0dXJuIGZ1bmN0aW9uKGUsdCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCYmbnVsbCE9PXQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIrU3RyaW5nKHQpK1wiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7ZnVuY3Rpb24gbigpe3RoaXMuY29uc3RydWN0b3I9ZTt9byhlLHQpLGUucHJvdG90eXBlPW51bGw9PT10P09iamVjdC5jcmVhdGUodCk6KG4ucHJvdG90eXBlPXQucHJvdG90eXBlLG5ldyBuKTt9KGksZSksaS5wcm90b3R5cGUuaW5zdGFsbD1mdW5jdGlvbigpe3ZhciBlLG89dGhpcztuKHRoaXMuY29yZS5nZXRGb3JtRWxlbWVudCgpLCgoZT17fSlbdGhpcy5vcHRzLmZvcm1DbGFzc109ITAsZVtcImZ2LXBsdWdpbnMtZnJhbWV3b3JrXCJdPSEwLGUpKSx0aGlzLmNvcmUub24oXCJjb3JlLmVsZW1lbnQuaWdub3JlZFwiLHRoaXMuZWxlbWVudElnbm9yZWRIYW5kbGVyKS5vbihcImNvcmUuZWxlbWVudC52YWxpZGF0aW5nXCIsdGhpcy5lbGVtZW50VmFsaWRhdGluZ0hhbmRsZXIpLm9uKFwiY29yZS5lbGVtZW50LnZhbGlkYXRlZFwiLHRoaXMuZWxlbWVudFZhbGlkYXRlZEhhbmRsZXIpLm9uKFwiY29yZS5lbGVtZW50Lm5vdHZhbGlkYXRlZFwiLHRoaXMuZWxlbWVudE5vdFZhbGlkYXRlZEhhbmRsZXIpLm9uKFwicGx1Z2lucy5pY29uLnBsYWNlZFwiLHRoaXMuaWNvblBsYWNlZEhhbmRsZXIpLm9uKFwiY29yZS5maWVsZC5hZGRlZFwiLHRoaXMuZmllbGRBZGRlZEhhbmRsZXIpLm9uKFwiY29yZS5maWVsZC5yZW1vdmVkXCIsdGhpcy5maWVsZFJlbW92ZWRIYW5kbGVyKSx0aGlzLm9wdHMuZGVmYXVsdE1lc3NhZ2VDb250YWluZXImJih0aGlzLmNvcmUucmVnaXN0ZXJQbHVnaW4oaS5NRVNTQUdFX1BMVUdJTixuZXcgdC5NZXNzYWdlKHtjbGF6ejp0aGlzLm9wdHMubWVzc2FnZUNsYXNzLGNvbnRhaW5lcjpmdW5jdGlvbihlLG4pe3ZhciBpPVwic3RyaW5nXCI9PXR5cGVvZiBvLm9wdHMucm93U2VsZWN0b3I/by5vcHRzLnJvd1NlbGVjdG9yOm8ub3B0cy5yb3dTZWxlY3RvcihlLG4pLGE9cyhuLGkpO3JldHVybiB0Lk1lc3NhZ2UuZ2V0Q2xvc2VzdENvbnRhaW5lcihuLGEsby5vcHRzLnJvd1BhdHRlcm4pfX0pKSx0aGlzLmNvcmUub24oXCJwbHVnaW5zLm1lc3NhZ2UucGxhY2VkXCIsdGhpcy5tZXNzYWdlUGxhY2VkSGFuZGxlcikpO30saS5wcm90b3R5cGUudW5pbnN0YWxsPWZ1bmN0aW9uKCl7dmFyIGU7dGhpcy5yZXN1bHRzLmNsZWFyKCksdGhpcy5jb250YWluZXJzLmNsZWFyKCksbih0aGlzLmNvcmUuZ2V0Rm9ybUVsZW1lbnQoKSwoKGU9e30pW3RoaXMub3B0cy5mb3JtQ2xhc3NdPSExLGVbXCJmdi1wbHVnaW5zLWZyYW1ld29ya1wiXT0hMSxlKSksdGhpcy5jb3JlLm9mZihcImNvcmUuZWxlbWVudC5pZ25vcmVkXCIsdGhpcy5lbGVtZW50SWdub3JlZEhhbmRsZXIpLm9mZihcImNvcmUuZWxlbWVudC52YWxpZGF0aW5nXCIsdGhpcy5lbGVtZW50VmFsaWRhdGluZ0hhbmRsZXIpLm9mZihcImNvcmUuZWxlbWVudC52YWxpZGF0ZWRcIix0aGlzLmVsZW1lbnRWYWxpZGF0ZWRIYW5kbGVyKS5vZmYoXCJjb3JlLmVsZW1lbnQubm90dmFsaWRhdGVkXCIsdGhpcy5lbGVtZW50Tm90VmFsaWRhdGVkSGFuZGxlcikub2ZmKFwicGx1Z2lucy5pY29uLnBsYWNlZFwiLHRoaXMuaWNvblBsYWNlZEhhbmRsZXIpLm9mZihcImNvcmUuZmllbGQuYWRkZWRcIix0aGlzLmZpZWxkQWRkZWRIYW5kbGVyKS5vZmYoXCJjb3JlLmZpZWxkLnJlbW92ZWRcIix0aGlzLmZpZWxkUmVtb3ZlZEhhbmRsZXIpLHRoaXMub3B0cy5kZWZhdWx0TWVzc2FnZUNvbnRhaW5lciYmKHRoaXMuY29yZS5kZXJlZ2lzdGVyUGx1Z2luKGkuTUVTU0FHRV9QTFVHSU4pLHRoaXMuY29yZS5vZmYoXCJwbHVnaW5zLm1lc3NhZ2UucGxhY2VkXCIsdGhpcy5tZXNzYWdlUGxhY2VkSGFuZGxlcikpO30saS5wcm90b3R5cGUub25FbmFibGVkPWZ1bmN0aW9uKCl7dmFyIGU7bih0aGlzLmNvcmUuZ2V0Rm9ybUVsZW1lbnQoKSwoKGU9e30pW3RoaXMub3B0cy5mb3JtQ2xhc3NdPSEwLGUpKSx0aGlzLm9wdHMuZGVmYXVsdE1lc3NhZ2VDb250YWluZXImJnRoaXMuY29yZS5lbmFibGVQbHVnaW4oaS5NRVNTQUdFX1BMVUdJTik7fSxpLnByb3RvdHlwZS5vbkRpc2FibGVkPWZ1bmN0aW9uKCl7dmFyIGU7bih0aGlzLmNvcmUuZ2V0Rm9ybUVsZW1lbnQoKSwoKGU9e30pW3RoaXMub3B0cy5mb3JtQ2xhc3NdPSExLGUpKSx0aGlzLm9wdHMuZGVmYXVsdE1lc3NhZ2VDb250YWluZXImJnRoaXMuY29yZS5kaXNhYmxlUGx1Z2luKGkuTUVTU0FHRV9QTFVHSU4pO30saS5wcm90b3R5cGUub25JY29uUGxhY2VkPWZ1bmN0aW9uKGUpe30saS5wcm90b3R5cGUub25NZXNzYWdlUGxhY2VkPWZ1bmN0aW9uKGUpe30saS5wcm90b3R5cGUub25GaWVsZEFkZGVkPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMsbz1lLmVsZW1lbnRzO28mJihvLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciBvLHM9dC5jb250YWluZXJzLmdldChlKTtzJiYobihzLCgobz17fSlbdC5vcHRzLnJvd0ludmFsaWRDbGFzc109ITEsb1t0Lm9wdHMucm93VmFsaWRhdGluZ0NsYXNzXT0hMSxvW3Qub3B0cy5yb3dWYWxpZENsYXNzXT0hMSxvW1wiZnYtcGx1Z2lucy1pY29uLWNvbnRhaW5lclwiXT0hMSxvKSksdC5jb250YWluZXJzLmRlbGV0ZShlKSk7fSkpLHRoaXMucHJlcGFyZUZpZWxkQ29udGFpbmVyKGUuZmllbGQsbykpO30saS5wcm90b3R5cGUub25GaWVsZFJlbW92ZWQ9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztlLmVsZW1lbnRzLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciBvLHM9dC5jb250YWluZXJzLmdldChlKTtzJiZuKHMsKChvPXt9KVt0Lm9wdHMucm93SW52YWxpZENsYXNzXT0hMSxvW3Qub3B0cy5yb3dWYWxpZGF0aW5nQ2xhc3NdPSExLG9bdC5vcHRzLnJvd1ZhbGlkQ2xhc3NdPSExLG8pKTt9KSk7fSxpLnByb3RvdHlwZS5wcmVwYXJlRmllbGRDb250YWluZXI9ZnVuY3Rpb24oZSx0KXt2YXIgbz10aGlzO2lmKHQubGVuZ3RoKXt2YXIgbj10WzBdLmdldEF0dHJpYnV0ZShcInR5cGVcIik7XCJyYWRpb1wiPT09bnx8XCJjaGVja2JveFwiPT09bj90aGlzLnByZXBhcmVFbGVtZW50Q29udGFpbmVyKGUsdFswXSk6dC5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gby5wcmVwYXJlRWxlbWVudENvbnRhaW5lcihlLHQpfSkpO319LGkucHJvdG90eXBlLnByZXBhcmVFbGVtZW50Q29udGFpbmVyPWZ1bmN0aW9uKGUsdCl7dmFyIG8saT1cInN0cmluZ1wiPT10eXBlb2YgdGhpcy5vcHRzLnJvd1NlbGVjdG9yP3RoaXMub3B0cy5yb3dTZWxlY3Rvcjp0aGlzLm9wdHMucm93U2VsZWN0b3IoZSx0KSxhPXModCxpKTthIT09dCYmKG4oYSwoKG89e30pW3RoaXMub3B0cy5yb3dDbGFzc2VzXT0hMCxvW1wiZnYtcGx1Z2lucy1pY29uLWNvbnRhaW5lclwiXT0hMCxvKSksdGhpcy5jb250YWluZXJzLnNldCh0LGEpKTt9LGkucHJvdG90eXBlLm9uRWxlbWVudFZhbGlkYXRpbmc9ZnVuY3Rpb24oZSl7dGhpcy5yZW1vdmVDbGFzc2VzKGUuZWxlbWVudCxlLmVsZW1lbnRzKTt9LGkucHJvdG90eXBlLm9uRWxlbWVudE5vdFZhbGlkYXRlZD1mdW5jdGlvbihlKXt0aGlzLnJlbW92ZUNsYXNzZXMoZS5lbGVtZW50LGUuZWxlbWVudHMpO30saS5wcm90b3R5cGUub25FbGVtZW50SWdub3JlZD1mdW5jdGlvbihlKXt0aGlzLnJlbW92ZUNsYXNzZXMoZS5lbGVtZW50LGUuZWxlbWVudHMpO30saS5wcm90b3R5cGUucmVtb3ZlQ2xhc3Nlcz1mdW5jdGlvbihlLHQpe3ZhciBvLHM9dGhpcyxpPWUuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSxhPVwicmFkaW9cIj09PWl8fFwiY2hlY2tib3hcIj09PWk/dFswXTplO3QuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dmFyIHQ7bihlLCgodD17fSlbcy5vcHRzLmVsZVZhbGlkQ2xhc3NdPSExLHRbcy5vcHRzLmVsZUludmFsaWRDbGFzc109ITEsdCkpO30pKTt2YXIgbD10aGlzLmNvbnRhaW5lcnMuZ2V0KGEpO2wmJm4obCwoKG89e30pW3RoaXMub3B0cy5yb3dJbnZhbGlkQ2xhc3NdPSExLG9bdGhpcy5vcHRzLnJvd1ZhbGlkYXRpbmdDbGFzc109ITEsb1t0aGlzLm9wdHMucm93VmFsaWRDbGFzc109ITEsbykpO30saS5wcm90b3R5cGUub25FbGVtZW50VmFsaWRhdGVkPWZ1bmN0aW9uKGUpe3ZhciB0LG8scz10aGlzLGk9ZS5lbGVtZW50cyxhPWUuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpLGw9XCJyYWRpb1wiPT09YXx8XCJjaGVja2JveFwiPT09YT9pWzBdOmUuZWxlbWVudDtpLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBvO24odCwoKG89e30pW3Mub3B0cy5lbGVWYWxpZENsYXNzXT1lLnZhbGlkLG9bcy5vcHRzLmVsZUludmFsaWRDbGFzc109IWUudmFsaWQsbykpO30pKTt2YXIgcj10aGlzLmNvbnRhaW5lcnMuZ2V0KGwpO2lmKHIpaWYoZS52YWxpZCl7dGhpcy5yZXN1bHRzLmRlbGV0ZShsKTt2YXIgZD0hMDt0aGlzLmNvbnRhaW5lcnMuZm9yRWFjaCgoZnVuY3Rpb24oZSx0KXtlPT09ciYmITE9PT1zLnJlc3VsdHMuZ2V0KHQpJiYoZD0hMSk7fSkpLGQmJm4ociwoKG89e30pW3RoaXMub3B0cy5yb3dJbnZhbGlkQ2xhc3NdPSExLG9bdGhpcy5vcHRzLnJvd1ZhbGlkYXRpbmdDbGFzc109ITEsb1t0aGlzLm9wdHMucm93VmFsaWRDbGFzc109ITAsbykpO31lbHNlIHRoaXMucmVzdWx0cy5zZXQobCwhMSksbihyLCgodD17fSlbdGhpcy5vcHRzLnJvd0ludmFsaWRDbGFzc109ITAsdFt0aGlzLm9wdHMucm93VmFsaWRhdGluZ0NsYXNzXT0hMSx0W3RoaXMub3B0cy5yb3dWYWxpZENsYXNzXT0hMSx0KSk7fSxpLk1FU1NBR0VfUExVR0lOPVwiX19fZnJhbWV3b3JrTWVzc2FnZVwiLGl9KGUuUGx1Z2luKTtpbmRleF9taW4kdC5GcmFtZXdvcms9aTtcblx0cmV0dXJuIGluZGV4X21pbiR0O1xufVxuXG52YXIgY2pzJHMgPSB7fTtcblxudmFyIGhhc1JlcXVpcmVkQ2pzJHM7XG5cbmZ1bmN0aW9uIHJlcXVpcmVDanMkcyAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZENqcyRzKSByZXR1cm4gY2pzJHM7XG5cdGhhc1JlcXVpcmVkQ2pzJHMgPSAxO1xuXG5cdHZhciBjb3JlID0gbGliRXhwb3J0cyRCO1xuXHR2YXIgcGx1Z2luTWVzc2FnZSA9IGxpYkV4cG9ydHMkdDtcblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblx0Q29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5cdFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5cdHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblx0VEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5cdFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5cdEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuXHRJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuXHRMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5cdE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuXHRQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG5cdCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblx0LyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcblx0dmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcblx0ICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuXHQgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuXHQgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcblx0ICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcblx0ICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcblx0ICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcblx0ICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcblx0ICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG5cdCAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcblx0fVxuXG5cdC8qKlxuXHQgKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcblx0ICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG5cdCAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cblx0ICovXG5cdHZhciBjbGFzc1NldCA9IGNvcmUudXRpbHMuY2xhc3NTZXQsIGNsb3Nlc3QgPSBjb3JlLnV0aWxzLmNsb3Nlc3Q7XG5cdHZhciBGcmFtZXdvcmsgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoRnJhbWV3b3JrLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gRnJhbWV3b3JrKG9wdHMpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRzKSB8fCB0aGlzO1xuXHQgICAgICAgIF90aGlzLnJlc3VsdHMgPSBuZXcgTWFwKCk7XG5cdCAgICAgICAgX3RoaXMuY29udGFpbmVycyA9IG5ldyBNYXAoKTtcblx0ICAgICAgICBfdGhpcy5vcHRzID0gT2JqZWN0LmFzc2lnbih7fSwge1xuXHQgICAgICAgICAgICBkZWZhdWx0TWVzc2FnZUNvbnRhaW5lcjogdHJ1ZSxcblx0ICAgICAgICAgICAgZWxlSW52YWxpZENsYXNzOiAnJyxcblx0ICAgICAgICAgICAgZWxlVmFsaWRDbGFzczogJycsXG5cdCAgICAgICAgICAgIHJvd0NsYXNzZXM6ICcnLFxuXHQgICAgICAgICAgICByb3dWYWxpZGF0aW5nQ2xhc3M6ICcnLFxuXHQgICAgICAgIH0sIG9wdHMpO1xuXHQgICAgICAgIF90aGlzLmVsZW1lbnRJZ25vcmVkSGFuZGxlciA9IF90aGlzLm9uRWxlbWVudElnbm9yZWQuYmluZChfdGhpcyk7XG5cdCAgICAgICAgX3RoaXMuZWxlbWVudFZhbGlkYXRpbmdIYW5kbGVyID0gX3RoaXMub25FbGVtZW50VmFsaWRhdGluZy5iaW5kKF90aGlzKTtcblx0ICAgICAgICBfdGhpcy5lbGVtZW50VmFsaWRhdGVkSGFuZGxlciA9IF90aGlzLm9uRWxlbWVudFZhbGlkYXRlZC5iaW5kKF90aGlzKTtcblx0ICAgICAgICBfdGhpcy5lbGVtZW50Tm90VmFsaWRhdGVkSGFuZGxlciA9IF90aGlzLm9uRWxlbWVudE5vdFZhbGlkYXRlZC5iaW5kKF90aGlzKTtcblx0ICAgICAgICBfdGhpcy5pY29uUGxhY2VkSGFuZGxlciA9IF90aGlzLm9uSWNvblBsYWNlZC5iaW5kKF90aGlzKTtcblx0ICAgICAgICBfdGhpcy5maWVsZEFkZGVkSGFuZGxlciA9IF90aGlzLm9uRmllbGRBZGRlZC5iaW5kKF90aGlzKTtcblx0ICAgICAgICBfdGhpcy5maWVsZFJlbW92ZWRIYW5kbGVyID0gX3RoaXMub25GaWVsZFJlbW92ZWQuYmluZChfdGhpcyk7XG5cdCAgICAgICAgX3RoaXMubWVzc2FnZVBsYWNlZEhhbmRsZXIgPSBfdGhpcy5vbk1lc3NhZ2VQbGFjZWQuYmluZChfdGhpcyk7XG5cdCAgICAgICAgcmV0dXJuIF90aGlzO1xuXHQgICAgfVxuXHQgICAgRnJhbWV3b3JrLnByb3RvdHlwZS5pbnN0YWxsID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBfYTtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGNsYXNzU2V0KHRoaXMuY29yZS5nZXRGb3JtRWxlbWVudCgpLCAoX2EgPSB7fSxcblx0ICAgICAgICAgICAgX2FbdGhpcy5vcHRzLmZvcm1DbGFzc10gPSB0cnVlLFxuXHQgICAgICAgICAgICBfYVsnZnYtcGx1Z2lucy1mcmFtZXdvcmsnXSA9IHRydWUsXG5cdCAgICAgICAgICAgIF9hKSk7XG5cdCAgICAgICAgdGhpcy5jb3JlXG5cdCAgICAgICAgICAgIC5vbignY29yZS5lbGVtZW50Lmlnbm9yZWQnLCB0aGlzLmVsZW1lbnRJZ25vcmVkSGFuZGxlcilcblx0ICAgICAgICAgICAgLm9uKCdjb3JlLmVsZW1lbnQudmFsaWRhdGluZycsIHRoaXMuZWxlbWVudFZhbGlkYXRpbmdIYW5kbGVyKVxuXHQgICAgICAgICAgICAub24oJ2NvcmUuZWxlbWVudC52YWxpZGF0ZWQnLCB0aGlzLmVsZW1lbnRWYWxpZGF0ZWRIYW5kbGVyKVxuXHQgICAgICAgICAgICAub24oJ2NvcmUuZWxlbWVudC5ub3R2YWxpZGF0ZWQnLCB0aGlzLmVsZW1lbnROb3RWYWxpZGF0ZWRIYW5kbGVyKVxuXHQgICAgICAgICAgICAub24oJ3BsdWdpbnMuaWNvbi5wbGFjZWQnLCB0aGlzLmljb25QbGFjZWRIYW5kbGVyKVxuXHQgICAgICAgICAgICAub24oJ2NvcmUuZmllbGQuYWRkZWQnLCB0aGlzLmZpZWxkQWRkZWRIYW5kbGVyKVxuXHQgICAgICAgICAgICAub24oJ2NvcmUuZmllbGQucmVtb3ZlZCcsIHRoaXMuZmllbGRSZW1vdmVkSGFuZGxlcik7XG5cdCAgICAgICAgaWYgKHRoaXMub3B0cy5kZWZhdWx0TWVzc2FnZUNvbnRhaW5lcikge1xuXHQgICAgICAgICAgICB0aGlzLmNvcmUucmVnaXN0ZXJQbHVnaW4oRnJhbWV3b3JrLk1FU1NBR0VfUExVR0lOLCBuZXcgcGx1Z2luTWVzc2FnZS5NZXNzYWdlKHtcblx0ICAgICAgICAgICAgICAgIGNsYXp6OiB0aGlzLm9wdHMubWVzc2FnZUNsYXNzLFxuXHQgICAgICAgICAgICAgICAgY29udGFpbmVyOiBmdW5jdGlvbiAoZmllbGQsIGVsZW1lbnQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSAnc3RyaW5nJyA9PT0gdHlwZW9mIF90aGlzLm9wdHMucm93U2VsZWN0b3Jcblx0ICAgICAgICAgICAgICAgICAgICAgICAgPyBfdGhpcy5vcHRzLnJvd1NlbGVjdG9yXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIDogX3RoaXMub3B0cy5yb3dTZWxlY3RvcihmaWVsZCwgZWxlbWVudCk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwRWxlID0gY2xvc2VzdChlbGVtZW50LCBzZWxlY3Rvcik7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpbk1lc3NhZ2UuTWVzc2FnZS5nZXRDbG9zZXN0Q29udGFpbmVyKGVsZW1lbnQsIGdyb3VwRWxlLCBfdGhpcy5vcHRzLnJvd1BhdHRlcm4pO1xuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB0aGlzLmNvcmUub24oJ3BsdWdpbnMubWVzc2FnZS5wbGFjZWQnLCB0aGlzLm1lc3NhZ2VQbGFjZWRIYW5kbGVyKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgRnJhbWV3b3JrLnByb3RvdHlwZS51bmluc3RhbGwgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIF9hO1xuXHQgICAgICAgIHRoaXMucmVzdWx0cy5jbGVhcigpO1xuXHQgICAgICAgIHRoaXMuY29udGFpbmVycy5jbGVhcigpO1xuXHQgICAgICAgIGNsYXNzU2V0KHRoaXMuY29yZS5nZXRGb3JtRWxlbWVudCgpLCAoX2EgPSB7fSxcblx0ICAgICAgICAgICAgX2FbdGhpcy5vcHRzLmZvcm1DbGFzc10gPSBmYWxzZSxcblx0ICAgICAgICAgICAgX2FbJ2Z2LXBsdWdpbnMtZnJhbWV3b3JrJ10gPSBmYWxzZSxcblx0ICAgICAgICAgICAgX2EpKTtcblx0ICAgICAgICB0aGlzLmNvcmVcblx0ICAgICAgICAgICAgLm9mZignY29yZS5lbGVtZW50Lmlnbm9yZWQnLCB0aGlzLmVsZW1lbnRJZ25vcmVkSGFuZGxlcilcblx0ICAgICAgICAgICAgLm9mZignY29yZS5lbGVtZW50LnZhbGlkYXRpbmcnLCB0aGlzLmVsZW1lbnRWYWxpZGF0aW5nSGFuZGxlcilcblx0ICAgICAgICAgICAgLm9mZignY29yZS5lbGVtZW50LnZhbGlkYXRlZCcsIHRoaXMuZWxlbWVudFZhbGlkYXRlZEhhbmRsZXIpXG5cdCAgICAgICAgICAgIC5vZmYoJ2NvcmUuZWxlbWVudC5ub3R2YWxpZGF0ZWQnLCB0aGlzLmVsZW1lbnROb3RWYWxpZGF0ZWRIYW5kbGVyKVxuXHQgICAgICAgICAgICAub2ZmKCdwbHVnaW5zLmljb24ucGxhY2VkJywgdGhpcy5pY29uUGxhY2VkSGFuZGxlcilcblx0ICAgICAgICAgICAgLm9mZignY29yZS5maWVsZC5hZGRlZCcsIHRoaXMuZmllbGRBZGRlZEhhbmRsZXIpXG5cdCAgICAgICAgICAgIC5vZmYoJ2NvcmUuZmllbGQucmVtb3ZlZCcsIHRoaXMuZmllbGRSZW1vdmVkSGFuZGxlcik7XG5cdCAgICAgICAgaWYgKHRoaXMub3B0cy5kZWZhdWx0TWVzc2FnZUNvbnRhaW5lcikge1xuXHQgICAgICAgICAgICB0aGlzLmNvcmUuZGVyZWdpc3RlclBsdWdpbihGcmFtZXdvcmsuTUVTU0FHRV9QTFVHSU4pO1xuXHQgICAgICAgICAgICB0aGlzLmNvcmUub2ZmKCdwbHVnaW5zLm1lc3NhZ2UucGxhY2VkJywgdGhpcy5tZXNzYWdlUGxhY2VkSGFuZGxlcik7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIEZyYW1ld29yay5wcm90b3R5cGUub25FbmFibGVkID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBfYTtcblx0ICAgICAgICBjbGFzc1NldCh0aGlzLmNvcmUuZ2V0Rm9ybUVsZW1lbnQoKSwgKF9hID0ge30sXG5cdCAgICAgICAgICAgIF9hW3RoaXMub3B0cy5mb3JtQ2xhc3NdID0gdHJ1ZSxcblx0ICAgICAgICAgICAgX2EpKTtcblx0ICAgICAgICBpZiAodGhpcy5vcHRzLmRlZmF1bHRNZXNzYWdlQ29udGFpbmVyKSB7XG5cdCAgICAgICAgICAgIHRoaXMuY29yZS5lbmFibGVQbHVnaW4oRnJhbWV3b3JrLk1FU1NBR0VfUExVR0lOKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgRnJhbWV3b3JrLnByb3RvdHlwZS5vbkRpc2FibGVkID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBfYTtcblx0ICAgICAgICBjbGFzc1NldCh0aGlzLmNvcmUuZ2V0Rm9ybUVsZW1lbnQoKSwgKF9hID0ge30sXG5cdCAgICAgICAgICAgIF9hW3RoaXMub3B0cy5mb3JtQ2xhc3NdID0gZmFsc2UsXG5cdCAgICAgICAgICAgIF9hKSk7XG5cdCAgICAgICAgaWYgKHRoaXMub3B0cy5kZWZhdWx0TWVzc2FnZUNvbnRhaW5lcikge1xuXHQgICAgICAgICAgICB0aGlzLmNvcmUuZGlzYWJsZVBsdWdpbihGcmFtZXdvcmsuTUVTU0FHRV9QTFVHSU4pO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICBGcmFtZXdvcmsucHJvdG90eXBlLm9uSWNvblBsYWNlZCA9IGZ1bmN0aW9uIChfZSkgeyB9OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuXHQgICAgRnJhbWV3b3JrLnByb3RvdHlwZS5vbk1lc3NhZ2VQbGFjZWQgPSBmdW5jdGlvbiAoX2UpIHsgfTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb25cblx0ICAgIEZyYW1ld29yay5wcm90b3R5cGUub25GaWVsZEFkZGVkID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHZhciBlbGVtZW50cyA9IGUuZWxlbWVudHM7XG5cdCAgICAgICAgaWYgKGVsZW1lbnRzKSB7XG5cdCAgICAgICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIF9hO1xuXHQgICAgICAgICAgICAgICAgdmFyIGdyb3VwRWxlID0gX3RoaXMuY29udGFpbmVycy5nZXQoZWxlKTtcblx0ICAgICAgICAgICAgICAgIGlmIChncm91cEVsZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNsYXNzU2V0KGdyb3VwRWxlLCAoX2EgPSB7fSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2FbX3RoaXMub3B0cy5yb3dJbnZhbGlkQ2xhc3NdID0gZmFsc2UsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hW190aGlzLm9wdHMucm93VmFsaWRhdGluZ0NsYXNzXSA9IGZhbHNlLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYVtfdGhpcy5vcHRzLnJvd1ZhbGlkQ2xhc3NdID0gZmFsc2UsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hWydmdi1wbHVnaW5zLWljb24tY29udGFpbmVyJ10gPSBmYWxzZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2EpKTtcblx0ICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb250YWluZXJzLmRlbGV0ZShlbGUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgdGhpcy5wcmVwYXJlRmllbGRDb250YWluZXIoZS5maWVsZCwgZWxlbWVudHMpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICBGcmFtZXdvcmsucHJvdG90eXBlLm9uRmllbGRSZW1vdmVkID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGUuZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG5cdCAgICAgICAgICAgIHZhciBfYTtcblx0ICAgICAgICAgICAgdmFyIGdyb3VwRWxlID0gX3RoaXMuY29udGFpbmVycy5nZXQoZWxlKTtcblx0ICAgICAgICAgICAgaWYgKGdyb3VwRWxlKSB7XG5cdCAgICAgICAgICAgICAgICBjbGFzc1NldChncm91cEVsZSwgKF9hID0ge30sXG5cdCAgICAgICAgICAgICAgICAgICAgX2FbX3RoaXMub3B0cy5yb3dJbnZhbGlkQ2xhc3NdID0gZmFsc2UsXG5cdCAgICAgICAgICAgICAgICAgICAgX2FbX3RoaXMub3B0cy5yb3dWYWxpZGF0aW5nQ2xhc3NdID0gZmFsc2UsXG5cdCAgICAgICAgICAgICAgICAgICAgX2FbX3RoaXMub3B0cy5yb3dWYWxpZENsYXNzXSA9IGZhbHNlLFxuXHQgICAgICAgICAgICAgICAgICAgIF9hKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBGcmFtZXdvcmsucHJvdG90eXBlLnByZXBhcmVGaWVsZENvbnRhaW5lciA9IGZ1bmN0aW9uIChmaWVsZCwgZWxlbWVudHMpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGlmIChlbGVtZW50cy5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgdmFyIHR5cGUgPSBlbGVtZW50c1swXS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcblx0ICAgICAgICAgICAgaWYgKCdyYWRpbycgPT09IHR5cGUgfHwgJ2NoZWNrYm94JyA9PT0gdHlwZSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5wcmVwYXJlRWxlbWVudENvbnRhaW5lcihmaWVsZCwgZWxlbWVudHNbMF0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7IHJldHVybiBfdGhpcy5wcmVwYXJlRWxlbWVudENvbnRhaW5lcihmaWVsZCwgZWxlKTsgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgRnJhbWV3b3JrLnByb3RvdHlwZS5wcmVwYXJlRWxlbWVudENvbnRhaW5lciA9IGZ1bmN0aW9uIChmaWVsZCwgZWxlbWVudCkge1xuXHQgICAgICAgIHZhciBfYTtcblx0ICAgICAgICB2YXIgc2VsZWN0b3IgPSAnc3RyaW5nJyA9PT0gdHlwZW9mIHRoaXMub3B0cy5yb3dTZWxlY3RvciA/IHRoaXMub3B0cy5yb3dTZWxlY3RvciA6IHRoaXMub3B0cy5yb3dTZWxlY3RvcihmaWVsZCwgZWxlbWVudCk7XG5cdCAgICAgICAgdmFyIGdyb3VwRWxlID0gY2xvc2VzdChlbGVtZW50LCBzZWxlY3Rvcik7XG5cdCAgICAgICAgaWYgKGdyb3VwRWxlICE9PSBlbGVtZW50KSB7XG5cdCAgICAgICAgICAgIGNsYXNzU2V0KGdyb3VwRWxlLCAoX2EgPSB7fSxcblx0ICAgICAgICAgICAgICAgIF9hW3RoaXMub3B0cy5yb3dDbGFzc2VzXSA9IHRydWUsXG5cdCAgICAgICAgICAgICAgICBfYVsnZnYtcGx1Z2lucy1pY29uLWNvbnRhaW5lciddID0gdHJ1ZSxcblx0ICAgICAgICAgICAgICAgIF9hKSk7XG5cdCAgICAgICAgICAgIHRoaXMuY29udGFpbmVycy5zZXQoZWxlbWVudCwgZ3JvdXBFbGUpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICBGcmFtZXdvcmsucHJvdG90eXBlLm9uRWxlbWVudFZhbGlkYXRpbmcgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIHRoaXMucmVtb3ZlQ2xhc3NlcyhlLmVsZW1lbnQsIGUuZWxlbWVudHMpO1xuXHQgICAgfTtcblx0ICAgIEZyYW1ld29yay5wcm90b3R5cGUub25FbGVtZW50Tm90VmFsaWRhdGVkID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICB0aGlzLnJlbW92ZUNsYXNzZXMoZS5lbGVtZW50LCBlLmVsZW1lbnRzKTtcblx0ICAgIH07XG5cdCAgICBGcmFtZXdvcmsucHJvdG90eXBlLm9uRWxlbWVudElnbm9yZWQgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIHRoaXMucmVtb3ZlQ2xhc3NlcyhlLmVsZW1lbnQsIGUuZWxlbWVudHMpO1xuXHQgICAgfTtcblx0ICAgIEZyYW1ld29yay5wcm90b3R5cGUucmVtb3ZlQ2xhc3NlcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBlbGVtZW50cykge1xuXHQgICAgICAgIHZhciBfYTtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHZhciB0eXBlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcblx0ICAgICAgICB2YXIgZWxlID0gJ3JhZGlvJyA9PT0gdHlwZSB8fCAnY2hlY2tib3gnID09PSB0eXBlID8gZWxlbWVudHNbMF0gOiBlbGVtZW50O1xuXHQgICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuXHQgICAgICAgICAgICB2YXIgX2E7XG5cdCAgICAgICAgICAgIGNsYXNzU2V0KGVsZSwgKF9hID0ge30sXG5cdCAgICAgICAgICAgICAgICBfYVtfdGhpcy5vcHRzLmVsZVZhbGlkQ2xhc3NdID0gZmFsc2UsXG5cdCAgICAgICAgICAgICAgICBfYVtfdGhpcy5vcHRzLmVsZUludmFsaWRDbGFzc10gPSBmYWxzZSxcblx0ICAgICAgICAgICAgICAgIF9hKSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgdmFyIGdyb3VwRWxlID0gdGhpcy5jb250YWluZXJzLmdldChlbGUpO1xuXHQgICAgICAgIGlmIChncm91cEVsZSkge1xuXHQgICAgICAgICAgICBjbGFzc1NldChncm91cEVsZSwgKF9hID0ge30sXG5cdCAgICAgICAgICAgICAgICBfYVt0aGlzLm9wdHMucm93SW52YWxpZENsYXNzXSA9IGZhbHNlLFxuXHQgICAgICAgICAgICAgICAgX2FbdGhpcy5vcHRzLnJvd1ZhbGlkYXRpbmdDbGFzc10gPSBmYWxzZSxcblx0ICAgICAgICAgICAgICAgIF9hW3RoaXMub3B0cy5yb3dWYWxpZENsYXNzXSA9IGZhbHNlLFxuXHQgICAgICAgICAgICAgICAgX2EpKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgRnJhbWV3b3JrLnByb3RvdHlwZS5vbkVsZW1lbnRWYWxpZGF0ZWQgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIHZhciBfYSwgX2I7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB2YXIgZWxlbWVudHMgPSBlLmVsZW1lbnRzO1xuXHQgICAgICAgIHZhciB0eXBlID0gZS5lbGVtZW50LmdldEF0dHJpYnV0ZSgndHlwZScpO1xuXHQgICAgICAgIHZhciBlbGVtZW50ID0gJ3JhZGlvJyA9PT0gdHlwZSB8fCAnY2hlY2tib3gnID09PSB0eXBlID8gZWxlbWVudHNbMF0gOiBlLmVsZW1lbnQ7XG5cdCAgICAgICAgLy8gU2V0IHRoZSB2YWxpZCBvciBpbnZhbGlkIGNsYXNzIGZvciBhbGwgZWxlbWVudHNcblx0ICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcblx0ICAgICAgICAgICAgdmFyIF9hO1xuXHQgICAgICAgICAgICBjbGFzc1NldChlbGUsIChfYSA9IHt9LFxuXHQgICAgICAgICAgICAgICAgX2FbX3RoaXMub3B0cy5lbGVWYWxpZENsYXNzXSA9IGUudmFsaWQsXG5cdCAgICAgICAgICAgICAgICBfYVtfdGhpcy5vcHRzLmVsZUludmFsaWRDbGFzc10gPSAhZS52YWxpZCxcblx0ICAgICAgICAgICAgICAgIF9hKSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgdmFyIGdyb3VwRWxlID0gdGhpcy5jb250YWluZXJzLmdldChlbGVtZW50KTtcblx0ICAgICAgICBpZiAoZ3JvdXBFbGUpIHtcblx0ICAgICAgICAgICAgaWYgKCFlLnZhbGlkKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdHMuc2V0KGVsZW1lbnQsIGZhbHNlKTtcblx0ICAgICAgICAgICAgICAgIGNsYXNzU2V0KGdyb3VwRWxlLCAoX2EgPSB7fSxcblx0ICAgICAgICAgICAgICAgICAgICBfYVt0aGlzLm9wdHMucm93SW52YWxpZENsYXNzXSA9IHRydWUsXG5cdCAgICAgICAgICAgICAgICAgICAgX2FbdGhpcy5vcHRzLnJvd1ZhbGlkYXRpbmdDbGFzc10gPSBmYWxzZSxcblx0ICAgICAgICAgICAgICAgICAgICBfYVt0aGlzLm9wdHMucm93VmFsaWRDbGFzc10gPSBmYWxzZSxcblx0ICAgICAgICAgICAgICAgICAgICBfYSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHRzLmRlbGV0ZShlbGVtZW50KTtcblx0ICAgICAgICAgICAgICAgIC8vIE1heWJlIHRoZXJlJ3JlIG11bHRpcGxlIGZpZWxkcyBiZWxvbmcgdG8gdGhlIHNhbWUgcm93XG5cdCAgICAgICAgICAgICAgICB2YXIgaXNWYWxpZF8xID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVycy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBncm91cEVsZSAmJiBfdGhpcy5yZXN1bHRzLmdldChrZXkpID09PSBmYWxzZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkXzEgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIC8vIElmIGFsbCBmaWVsZChzKSBiZWxvbmdpbmcgdG8gdGhlIHJvdyBhcmUgdmFsaWRcblx0ICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkXzEpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjbGFzc1NldChncm91cEVsZSwgKF9iID0ge30sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9iW3RoaXMub3B0cy5yb3dJbnZhbGlkQ2xhc3NdID0gZmFsc2UsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9iW3RoaXMub3B0cy5yb3dWYWxpZGF0aW5nQ2xhc3NdID0gZmFsc2UsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9iW3RoaXMub3B0cy5yb3dWYWxpZENsYXNzXSA9IHRydWUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9iKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgRnJhbWV3b3JrLk1FU1NBR0VfUExVR0lOID0gJ19fX2ZyYW1ld29ya01lc3NhZ2UnO1xuXHQgICAgcmV0dXJuIEZyYW1ld29yaztcblx0fShjb3JlLlBsdWdpbikpO1xuXG5cdGNqcyRzLkZyYW1ld29yayA9IEZyYW1ld29yaztcblx0cmV0dXJuIGNqcyRzO1xufVxuXG4vKipcbiAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG4gKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICBsaWIkdC5leHBvcnRzID0gcmVxdWlyZUluZGV4X21pbiRzKCk7XG59IGVsc2Uge1xuICAgIGxpYiR0LmV4cG9ydHMgPSByZXF1aXJlQ2pzJHMoKTtcbn1cblxudmFyIGxpYkV4cG9ydHMkcyA9IGxpYiR0LmV4cG9ydHM7XG5cbnZhciBsaWIkciA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBpbmRleF9taW4kciA9IHt9O1xuXG4vKiogXG4gKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcbiAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuICpcbiAqIEBsaWNlbnNlIGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8vbGljZW5zZVxuICogQHBhY2thZ2UgQGZvcm0tdmFsaWRhdGlvbi9wbHVnaW4taWNvblxuICogQHZlcnNpb24gMi40LjBcbiAqL1xuXG52YXIgaGFzUmVxdWlyZWRJbmRleF9taW4kcjtcblxuZnVuY3Rpb24gcmVxdWlyZUluZGV4X21pbiRyICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkSW5kZXhfbWluJHIpIHJldHVybiBpbmRleF9taW4kcjtcblx0aGFzUmVxdWlyZWRJbmRleF9taW4kciA9IDE7XG52YXIgZT1saWJFeHBvcnRzJEIsdD1mdW5jdGlvbihlLG4pe3JldHVybiB0PU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihlLHQpe2UuX19wcm90b19fPXQ7fXx8ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG4gaW4gdClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxuKSYmKGVbbl09dFtuXSk7fSx0KGUsbil9O3ZhciBuPWUudXRpbHMuY2xhc3NTZXQsaT1mdW5jdGlvbihlKXtmdW5jdGlvbiBpKHQpe3ZhciBuPWUuY2FsbCh0aGlzLHQpfHx0aGlzO3JldHVybiBuLmljb25zPW5ldyBNYXAsbi5vcHRzPU9iamVjdC5hc3NpZ24oe30se2ludmFsaWQ6XCJmdi1wbHVnaW5zLWljb24tLWludmFsaWRcIixvblBsYWNlZDpmdW5jdGlvbigpe30sb25TZXQ6ZnVuY3Rpb24oKXt9LHZhbGlkOlwiZnYtcGx1Z2lucy1pY29uLS12YWxpZFwiLHZhbGlkYXRpbmc6XCJmdi1wbHVnaW5zLWljb24tLXZhbGlkYXRpbmdcIn0sdCksbi5lbGVtZW50VmFsaWRhdGluZ0hhbmRsZXI9bi5vbkVsZW1lbnRWYWxpZGF0aW5nLmJpbmQobiksbi5lbGVtZW50VmFsaWRhdGVkSGFuZGxlcj1uLm9uRWxlbWVudFZhbGlkYXRlZC5iaW5kKG4pLG4uZWxlbWVudE5vdFZhbGlkYXRlZEhhbmRsZXI9bi5vbkVsZW1lbnROb3RWYWxpZGF0ZWQuYmluZChuKSxuLmVsZW1lbnRJZ25vcmVkSGFuZGxlcj1uLm9uRWxlbWVudElnbm9yZWQuYmluZChuKSxuLmZpZWxkQWRkZWRIYW5kbGVyPW4ub25GaWVsZEFkZGVkLmJpbmQobiksbn1yZXR1cm4gZnVuY3Rpb24oZSxuKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBuJiZudWxsIT09bil0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIitTdHJpbmcobikrXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtmdW5jdGlvbiBpKCl7dGhpcy5jb25zdHJ1Y3Rvcj1lO310KGUsbiksZS5wcm90b3R5cGU9bnVsbD09PW4/T2JqZWN0LmNyZWF0ZShuKTooaS5wcm90b3R5cGU9bi5wcm90b3R5cGUsbmV3IGkpO30oaSxlKSxpLnByb3RvdHlwZS5pbnN0YWxsPWZ1bmN0aW9uKCl7dGhpcy5jb3JlLm9uKFwiY29yZS5lbGVtZW50LnZhbGlkYXRpbmdcIix0aGlzLmVsZW1lbnRWYWxpZGF0aW5nSGFuZGxlcikub24oXCJjb3JlLmVsZW1lbnQudmFsaWRhdGVkXCIsdGhpcy5lbGVtZW50VmFsaWRhdGVkSGFuZGxlcikub24oXCJjb3JlLmVsZW1lbnQubm90dmFsaWRhdGVkXCIsdGhpcy5lbGVtZW50Tm90VmFsaWRhdGVkSGFuZGxlcikub24oXCJjb3JlLmVsZW1lbnQuaWdub3JlZFwiLHRoaXMuZWxlbWVudElnbm9yZWRIYW5kbGVyKS5vbihcImNvcmUuZmllbGQuYWRkZWRcIix0aGlzLmZpZWxkQWRkZWRIYW5kbGVyKTt9LGkucHJvdG90eXBlLnVuaW5zdGFsbD1mdW5jdGlvbigpe3RoaXMuaWNvbnMuZm9yRWFjaCgoZnVuY3Rpb24oZSl7cmV0dXJuIGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlKX0pKSx0aGlzLmljb25zLmNsZWFyKCksdGhpcy5jb3JlLm9mZihcImNvcmUuZWxlbWVudC52YWxpZGF0aW5nXCIsdGhpcy5lbGVtZW50VmFsaWRhdGluZ0hhbmRsZXIpLm9mZihcImNvcmUuZWxlbWVudC52YWxpZGF0ZWRcIix0aGlzLmVsZW1lbnRWYWxpZGF0ZWRIYW5kbGVyKS5vZmYoXCJjb3JlLmVsZW1lbnQubm90dmFsaWRhdGVkXCIsdGhpcy5lbGVtZW50Tm90VmFsaWRhdGVkSGFuZGxlcikub2ZmKFwiY29yZS5lbGVtZW50Lmlnbm9yZWRcIix0aGlzLmVsZW1lbnRJZ25vcmVkSGFuZGxlcikub2ZmKFwiY29yZS5maWVsZC5hZGRlZFwiLHRoaXMuZmllbGRBZGRlZEhhbmRsZXIpO30saS5wcm90b3R5cGUub25FbmFibGVkPWZ1bmN0aW9uKCl7dGhpcy5pY29ucy5mb3JFYWNoKChmdW5jdGlvbihlLHQsaSl7bih0LHtcImZ2LXBsdWdpbnMtaWNvbi0tZW5hYmxlZFwiOiEwLFwiZnYtcGx1Z2lucy1pY29uLS1kaXNhYmxlZFwiOiExfSk7fSkpO30saS5wcm90b3R5cGUub25EaXNhYmxlZD1mdW5jdGlvbigpe3RoaXMuaWNvbnMuZm9yRWFjaCgoZnVuY3Rpb24oZSx0LGkpe24odCx7XCJmdi1wbHVnaW5zLWljb24tLWVuYWJsZWRcIjohMSxcImZ2LXBsdWdpbnMtaWNvbi0tZGlzYWJsZWRcIjohMH0pO30pKTt9LGkucHJvdG90eXBlLm9uRmllbGRBZGRlZD1mdW5jdGlvbihlKXt2YXIgdD10aGlzLG49ZS5lbGVtZW50cztuJiYobi5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgbj10Lmljb25zLmdldChlKTtuJiYobi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG4pLHQuaWNvbnMuZGVsZXRlKGUpKTt9KSksdGhpcy5wcmVwYXJlRmllbGRJY29uKGUuZmllbGQsbikpO30saS5wcm90b3R5cGUucHJlcGFyZUZpZWxkSWNvbj1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7aWYodC5sZW5ndGgpe3ZhciBpPXRbMF0uZ2V0QXR0cmlidXRlKFwidHlwZVwiKTtcInJhZGlvXCI9PT1pfHxcImNoZWNrYm94XCI9PT1pP3RoaXMucHJlcGFyZUVsZW1lbnRJY29uKGUsdFswXSk6dC5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gbi5wcmVwYXJlRWxlbWVudEljb24oZSx0KX0pKTt9fSxpLnByb3RvdHlwZS5wcmVwYXJlRWxlbWVudEljb249ZnVuY3Rpb24oZSx0KXt2YXIgaT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaVwiKTtpLnNldEF0dHJpYnV0ZShcImRhdGEtZmllbGRcIixlKSx0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGksdC5uZXh0U2libGluZyksbihpLHtcImZ2LXBsdWdpbnMtaWNvblwiOiEwLFwiZnYtcGx1Z2lucy1pY29uLS1lbmFibGVkXCI6dGhpcy5pc0VuYWJsZWQsXCJmdi1wbHVnaW5zLWljb24tLWRpc2FibGVkXCI6IXRoaXMuaXNFbmFibGVkfSk7dmFyIG89e2NsYXNzZXM6e2ludmFsaWQ6dGhpcy5vcHRzLmludmFsaWQsdmFsaWQ6dGhpcy5vcHRzLnZhbGlkLHZhbGlkYXRpbmc6dGhpcy5vcHRzLnZhbGlkYXRpbmd9LGVsZW1lbnQ6dCxmaWVsZDplLGljb25FbGVtZW50Oml9O3RoaXMuY29yZS5lbWl0KFwicGx1Z2lucy5pY29uLnBsYWNlZFwiLG8pLHRoaXMub3B0cy5vblBsYWNlZChvKSx0aGlzLmljb25zLnNldCh0LGkpO30saS5wcm90b3R5cGUub25FbGVtZW50VmFsaWRhdGluZz1mdW5jdGlvbihlKXt2YXIgdCxuPXRoaXMuc2V0Q2xhc3NlcyhlLmZpZWxkLGUuZWxlbWVudCxlLmVsZW1lbnRzLCgodD17fSlbdGhpcy5vcHRzLmludmFsaWRdPSExLHRbdGhpcy5vcHRzLnZhbGlkXT0hMSx0W3RoaXMub3B0cy52YWxpZGF0aW5nXT0hMCx0KSksaT17ZWxlbWVudDplLmVsZW1lbnQsZmllbGQ6ZS5maWVsZCxpY29uRWxlbWVudDpuLHN0YXR1czpcIlZhbGlkYXRpbmdcIn07dGhpcy5jb3JlLmVtaXQoXCJwbHVnaW5zLmljb24uc2V0XCIsaSksdGhpcy5vcHRzLm9uU2V0KGkpO30saS5wcm90b3R5cGUub25FbGVtZW50VmFsaWRhdGVkPWZ1bmN0aW9uKGUpe3ZhciB0LG49dGhpcy5zZXRDbGFzc2VzKGUuZmllbGQsZS5lbGVtZW50LGUuZWxlbWVudHMsKCh0PXt9KVt0aGlzLm9wdHMuaW52YWxpZF09IWUudmFsaWQsdFt0aGlzLm9wdHMudmFsaWRdPWUudmFsaWQsdFt0aGlzLm9wdHMudmFsaWRhdGluZ109ITEsdCkpLGk9e2VsZW1lbnQ6ZS5lbGVtZW50LGZpZWxkOmUuZmllbGQsaWNvbkVsZW1lbnQ6bixzdGF0dXM6ZS52YWxpZD9cIlZhbGlkXCI6XCJJbnZhbGlkXCJ9O3RoaXMuY29yZS5lbWl0KFwicGx1Z2lucy5pY29uLnNldFwiLGkpLHRoaXMub3B0cy5vblNldChpKTt9LGkucHJvdG90eXBlLm9uRWxlbWVudE5vdFZhbGlkYXRlZD1mdW5jdGlvbihlKXt2YXIgdCxuPXRoaXMuc2V0Q2xhc3NlcyhlLmZpZWxkLGUuZWxlbWVudCxlLmVsZW1lbnRzLCgodD17fSlbdGhpcy5vcHRzLmludmFsaWRdPSExLHRbdGhpcy5vcHRzLnZhbGlkXT0hMSx0W3RoaXMub3B0cy52YWxpZGF0aW5nXT0hMSx0KSksaT17ZWxlbWVudDplLmVsZW1lbnQsZmllbGQ6ZS5maWVsZCxpY29uRWxlbWVudDpuLHN0YXR1czpcIk5vdFZhbGlkYXRlZFwifTt0aGlzLmNvcmUuZW1pdChcInBsdWdpbnMuaWNvbi5zZXRcIixpKSx0aGlzLm9wdHMub25TZXQoaSk7fSxpLnByb3RvdHlwZS5vbkVsZW1lbnRJZ25vcmVkPWZ1bmN0aW9uKGUpe3ZhciB0LG49dGhpcy5zZXRDbGFzc2VzKGUuZmllbGQsZS5lbGVtZW50LGUuZWxlbWVudHMsKCh0PXt9KVt0aGlzLm9wdHMuaW52YWxpZF09ITEsdFt0aGlzLm9wdHMudmFsaWRdPSExLHRbdGhpcy5vcHRzLnZhbGlkYXRpbmddPSExLHQpKSxpPXtlbGVtZW50OmUuZWxlbWVudCxmaWVsZDplLmZpZWxkLGljb25FbGVtZW50Om4sc3RhdHVzOlwiSWdub3JlZFwifTt0aGlzLmNvcmUuZW1pdChcInBsdWdpbnMuaWNvbi5zZXRcIixpKSx0aGlzLm9wdHMub25TZXQoaSk7fSxpLnByb3RvdHlwZS5zZXRDbGFzc2VzPWZ1bmN0aW9uKGUsdCxpLG8pe3ZhciBsPXQuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSxhPVwicmFkaW9cIj09PWx8fFwiY2hlY2tib3hcIj09PWw/aVswXTp0O2lmKHRoaXMuaWNvbnMuaGFzKGEpKXt2YXIgcz10aGlzLmljb25zLmdldChhKTtyZXR1cm4gbihzLG8pLHN9cmV0dXJuIG51bGx9LGl9KGUuUGx1Z2luKTtpbmRleF9taW4kci5JY29uPWk7XG5cdHJldHVybiBpbmRleF9taW4kcjtcbn1cblxudmFyIGNqcyRyID0ge307XG5cbnZhciBoYXNSZXF1aXJlZENqcyRyO1xuXG5mdW5jdGlvbiByZXF1aXJlQ2pzJHIgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRDanMkcikgcmV0dXJuIGNqcyRyO1xuXHRoYXNSZXF1aXJlZENqcyRyID0gMTtcblxuXHR2YXIgY29yZSA9IGxpYkV4cG9ydHMkQjtcblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblx0Q29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5cdFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5cdHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblx0VEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5cdFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5cdEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuXHRJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuXHRMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5cdE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuXHRQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG5cdCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblx0LyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcblx0dmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcblx0ICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuXHQgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuXHQgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcblx0ICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcblx0ICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcblx0ICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcblx0ICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcblx0ICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG5cdCAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcblx0fVxuXG5cdC8qKlxuXHQgKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcblx0ICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG5cdCAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cblx0ICovXG5cdHZhciBjbGFzc1NldCA9IGNvcmUudXRpbHMuY2xhc3NTZXQ7XG5cdHZhciBJY29uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKEljb24sIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBJY29uKG9wdHMpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRzKSB8fCB0aGlzO1xuXHQgICAgICAgIC8vIE1hcCB0aGUgZmllbGQgZWxlbWVudCB3aXRoIGljb25cblx0ICAgICAgICBfdGhpcy5pY29ucyA9IG5ldyBNYXAoKTtcblx0ICAgICAgICBfdGhpcy5vcHRzID0gT2JqZWN0LmFzc2lnbih7fSwge1xuXHQgICAgICAgICAgICBpbnZhbGlkOiAnZnYtcGx1Z2lucy1pY29uLS1pbnZhbGlkJyxcblx0ICAgICAgICAgICAgb25QbGFjZWQ6IGZ1bmN0aW9uICgpIHsgfSxcblx0ICAgICAgICAgICAgb25TZXQ6IGZ1bmN0aW9uICgpIHsgfSxcblx0ICAgICAgICAgICAgdmFsaWQ6ICdmdi1wbHVnaW5zLWljb24tLXZhbGlkJyxcblx0ICAgICAgICAgICAgdmFsaWRhdGluZzogJ2Z2LXBsdWdpbnMtaWNvbi0tdmFsaWRhdGluZycsXG5cdCAgICAgICAgfSwgb3B0cyk7XG5cdCAgICAgICAgX3RoaXMuZWxlbWVudFZhbGlkYXRpbmdIYW5kbGVyID0gX3RoaXMub25FbGVtZW50VmFsaWRhdGluZy5iaW5kKF90aGlzKTtcblx0ICAgICAgICBfdGhpcy5lbGVtZW50VmFsaWRhdGVkSGFuZGxlciA9IF90aGlzLm9uRWxlbWVudFZhbGlkYXRlZC5iaW5kKF90aGlzKTtcblx0ICAgICAgICBfdGhpcy5lbGVtZW50Tm90VmFsaWRhdGVkSGFuZGxlciA9IF90aGlzLm9uRWxlbWVudE5vdFZhbGlkYXRlZC5iaW5kKF90aGlzKTtcblx0ICAgICAgICBfdGhpcy5lbGVtZW50SWdub3JlZEhhbmRsZXIgPSBfdGhpcy5vbkVsZW1lbnRJZ25vcmVkLmJpbmQoX3RoaXMpO1xuXHQgICAgICAgIF90aGlzLmZpZWxkQWRkZWRIYW5kbGVyID0gX3RoaXMub25GaWVsZEFkZGVkLmJpbmQoX3RoaXMpO1xuXHQgICAgICAgIHJldHVybiBfdGhpcztcblx0ICAgIH1cblx0ICAgIEljb24ucHJvdG90eXBlLmluc3RhbGwgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5jb3JlXG5cdCAgICAgICAgICAgIC5vbignY29yZS5lbGVtZW50LnZhbGlkYXRpbmcnLCB0aGlzLmVsZW1lbnRWYWxpZGF0aW5nSGFuZGxlcilcblx0ICAgICAgICAgICAgLm9uKCdjb3JlLmVsZW1lbnQudmFsaWRhdGVkJywgdGhpcy5lbGVtZW50VmFsaWRhdGVkSGFuZGxlcilcblx0ICAgICAgICAgICAgLm9uKCdjb3JlLmVsZW1lbnQubm90dmFsaWRhdGVkJywgdGhpcy5lbGVtZW50Tm90VmFsaWRhdGVkSGFuZGxlcilcblx0ICAgICAgICAgICAgLm9uKCdjb3JlLmVsZW1lbnQuaWdub3JlZCcsIHRoaXMuZWxlbWVudElnbm9yZWRIYW5kbGVyKVxuXHQgICAgICAgICAgICAub24oJ2NvcmUuZmllbGQuYWRkZWQnLCB0aGlzLmZpZWxkQWRkZWRIYW5kbGVyKTtcblx0ICAgIH07XG5cdCAgICBJY29uLnByb3RvdHlwZS51bmluc3RhbGwgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5pY29ucy5mb3JFYWNoKGZ1bmN0aW9uIChpY29uKSB7IHJldHVybiBpY29uLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaWNvbik7IH0pO1xuXHQgICAgICAgIHRoaXMuaWNvbnMuY2xlYXIoKTtcblx0ICAgICAgICB0aGlzLmNvcmVcblx0ICAgICAgICAgICAgLm9mZignY29yZS5lbGVtZW50LnZhbGlkYXRpbmcnLCB0aGlzLmVsZW1lbnRWYWxpZGF0aW5nSGFuZGxlcilcblx0ICAgICAgICAgICAgLm9mZignY29yZS5lbGVtZW50LnZhbGlkYXRlZCcsIHRoaXMuZWxlbWVudFZhbGlkYXRlZEhhbmRsZXIpXG5cdCAgICAgICAgICAgIC5vZmYoJ2NvcmUuZWxlbWVudC5ub3R2YWxpZGF0ZWQnLCB0aGlzLmVsZW1lbnROb3RWYWxpZGF0ZWRIYW5kbGVyKVxuXHQgICAgICAgICAgICAub2ZmKCdjb3JlLmVsZW1lbnQuaWdub3JlZCcsIHRoaXMuZWxlbWVudElnbm9yZWRIYW5kbGVyKVxuXHQgICAgICAgICAgICAub2ZmKCdjb3JlLmZpZWxkLmFkZGVkJywgdGhpcy5maWVsZEFkZGVkSGFuZGxlcik7XG5cdCAgICB9O1xuXHQgICAgSWNvbi5wcm90b3R5cGUub25FbmFibGVkID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuaWNvbnMuZm9yRWFjaChmdW5jdGlvbiAoX2VsZW1lbnQsIGksIF9tYXApIHtcblx0ICAgICAgICAgICAgY2xhc3NTZXQoaSwge1xuXHQgICAgICAgICAgICAgICAgJ2Z2LXBsdWdpbnMtaWNvbi0tZW5hYmxlZCc6IHRydWUsXG5cdCAgICAgICAgICAgICAgICAnZnYtcGx1Z2lucy1pY29uLS1kaXNhYmxlZCc6IGZhbHNlLFxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBJY29uLnByb3RvdHlwZS5vbkRpc2FibGVkID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuaWNvbnMuZm9yRWFjaChmdW5jdGlvbiAoX2VsZW1lbnQsIGksIF9tYXApIHtcblx0ICAgICAgICAgICAgY2xhc3NTZXQoaSwge1xuXHQgICAgICAgICAgICAgICAgJ2Z2LXBsdWdpbnMtaWNvbi0tZW5hYmxlZCc6IGZhbHNlLFxuXHQgICAgICAgICAgICAgICAgJ2Z2LXBsdWdpbnMtaWNvbi0tZGlzYWJsZWQnOiB0cnVlLFxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBJY29uLnByb3RvdHlwZS5vbkZpZWxkQWRkZWQgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgdmFyIGVsZW1lbnRzID0gZS5lbGVtZW50cztcblx0ICAgICAgICBpZiAoZWxlbWVudHMpIHtcblx0ICAgICAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgaWNvbiA9IF90aGlzLmljb25zLmdldChlbGUpO1xuXHQgICAgICAgICAgICAgICAgaWYgKGljb24pIHtcblx0ICAgICAgICAgICAgICAgICAgICBpY29uLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaWNvbik7XG5cdCAgICAgICAgICAgICAgICAgICAgX3RoaXMuaWNvbnMuZGVsZXRlKGVsZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB0aGlzLnByZXBhcmVGaWVsZEljb24oZS5maWVsZCwgZWxlbWVudHMpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICBJY29uLnByb3RvdHlwZS5wcmVwYXJlRmllbGRJY29uID0gZnVuY3Rpb24gKGZpZWxkLCBlbGVtZW50cykge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCkge1xuXHQgICAgICAgICAgICB2YXIgdHlwZSA9IGVsZW1lbnRzWzBdLmdldEF0dHJpYnV0ZSgndHlwZScpO1xuXHQgICAgICAgICAgICBpZiAoJ3JhZGlvJyA9PT0gdHlwZSB8fCAnY2hlY2tib3gnID09PSB0eXBlKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnByZXBhcmVFbGVtZW50SWNvbihmaWVsZCwgZWxlbWVudHNbMF0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7IHJldHVybiBfdGhpcy5wcmVwYXJlRWxlbWVudEljb24oZmllbGQsIGVsZSk7IH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIEljb24ucHJvdG90eXBlLnByZXBhcmVFbGVtZW50SWNvbiA9IGZ1bmN0aW9uIChmaWVsZCwgZWxlKSB7XG5cdCAgICAgICAgdmFyIGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpJyk7XG5cdCAgICAgICAgaS5zZXRBdHRyaWJ1dGUoJ2RhdGEtZmllbGQnLCBmaWVsZCk7XG5cdCAgICAgICAgLy8gQXBwZW5kIHRoZSBpY29uIHJpZ2h0IGFmdGVyIHRoZSBmaWVsZCBlbGVtZW50XG5cdCAgICAgICAgZWxlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGksIGVsZS5uZXh0U2libGluZyk7XG5cdCAgICAgICAgY2xhc3NTZXQoaSwge1xuXHQgICAgICAgICAgICAnZnYtcGx1Z2lucy1pY29uJzogdHJ1ZSxcblx0ICAgICAgICAgICAgJ2Z2LXBsdWdpbnMtaWNvbi0tZW5hYmxlZCc6IHRoaXMuaXNFbmFibGVkLFxuXHQgICAgICAgICAgICAnZnYtcGx1Z2lucy1pY29uLS1kaXNhYmxlZCc6ICF0aGlzLmlzRW5hYmxlZCxcblx0ICAgICAgICB9KTtcblx0ICAgICAgICB2YXIgZSA9IHtcblx0ICAgICAgICAgICAgY2xhc3Nlczoge1xuXHQgICAgICAgICAgICAgICAgaW52YWxpZDogdGhpcy5vcHRzLmludmFsaWQsXG5cdCAgICAgICAgICAgICAgICB2YWxpZDogdGhpcy5vcHRzLnZhbGlkLFxuXHQgICAgICAgICAgICAgICAgdmFsaWRhdGluZzogdGhpcy5vcHRzLnZhbGlkYXRpbmcsXG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIGVsZW1lbnQ6IGVsZSxcblx0ICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuXHQgICAgICAgICAgICBpY29uRWxlbWVudDogaSxcblx0ICAgICAgICB9O1xuXHQgICAgICAgIHRoaXMuY29yZS5lbWl0KCdwbHVnaW5zLmljb24ucGxhY2VkJywgZSk7XG5cdCAgICAgICAgdGhpcy5vcHRzLm9uUGxhY2VkKGUpO1xuXHQgICAgICAgIHRoaXMuaWNvbnMuc2V0KGVsZSwgaSk7XG5cdCAgICB9O1xuXHQgICAgSWNvbi5wcm90b3R5cGUub25FbGVtZW50VmFsaWRhdGluZyA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgdmFyIF9hO1xuXHQgICAgICAgIHZhciBpY29uID0gdGhpcy5zZXRDbGFzc2VzKGUuZmllbGQsIGUuZWxlbWVudCwgZS5lbGVtZW50cywgKF9hID0ge30sXG5cdCAgICAgICAgICAgIF9hW3RoaXMub3B0cy5pbnZhbGlkXSA9IGZhbHNlLFxuXHQgICAgICAgICAgICBfYVt0aGlzLm9wdHMudmFsaWRdID0gZmFsc2UsXG5cdCAgICAgICAgICAgIF9hW3RoaXMub3B0cy52YWxpZGF0aW5nXSA9IHRydWUsXG5cdCAgICAgICAgICAgIF9hKSk7XG5cdCAgICAgICAgdmFyIGV2dCA9IHtcblx0ICAgICAgICAgICAgZWxlbWVudDogZS5lbGVtZW50LFxuXHQgICAgICAgICAgICBmaWVsZDogZS5maWVsZCxcblx0ICAgICAgICAgICAgaWNvbkVsZW1lbnQ6IGljb24sXG5cdCAgICAgICAgICAgIHN0YXR1czogJ1ZhbGlkYXRpbmcnLFxuXHQgICAgICAgIH07XG5cdCAgICAgICAgdGhpcy5jb3JlLmVtaXQoJ3BsdWdpbnMuaWNvbi5zZXQnLCBldnQpO1xuXHQgICAgICAgIHRoaXMub3B0cy5vblNldChldnQpO1xuXHQgICAgfTtcblx0ICAgIEljb24ucHJvdG90eXBlLm9uRWxlbWVudFZhbGlkYXRlZCA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgdmFyIF9hO1xuXHQgICAgICAgIHZhciBpY29uID0gdGhpcy5zZXRDbGFzc2VzKGUuZmllbGQsIGUuZWxlbWVudCwgZS5lbGVtZW50cywgKF9hID0ge30sXG5cdCAgICAgICAgICAgIF9hW3RoaXMub3B0cy5pbnZhbGlkXSA9ICFlLnZhbGlkLFxuXHQgICAgICAgICAgICBfYVt0aGlzLm9wdHMudmFsaWRdID0gZS52YWxpZCxcblx0ICAgICAgICAgICAgX2FbdGhpcy5vcHRzLnZhbGlkYXRpbmddID0gZmFsc2UsXG5cdCAgICAgICAgICAgIF9hKSk7XG5cdCAgICAgICAgdmFyIGV2dCA9IHtcblx0ICAgICAgICAgICAgZWxlbWVudDogZS5lbGVtZW50LFxuXHQgICAgICAgICAgICBmaWVsZDogZS5maWVsZCxcblx0ICAgICAgICAgICAgaWNvbkVsZW1lbnQ6IGljb24sXG5cdCAgICAgICAgICAgIHN0YXR1czogZS52YWxpZCA/ICdWYWxpZCcgOiAnSW52YWxpZCcsXG5cdCAgICAgICAgfTtcblx0ICAgICAgICB0aGlzLmNvcmUuZW1pdCgncGx1Z2lucy5pY29uLnNldCcsIGV2dCk7XG5cdCAgICAgICAgdGhpcy5vcHRzLm9uU2V0KGV2dCk7XG5cdCAgICB9O1xuXHQgICAgSWNvbi5wcm90b3R5cGUub25FbGVtZW50Tm90VmFsaWRhdGVkID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICB2YXIgX2E7XG5cdCAgICAgICAgdmFyIGljb24gPSB0aGlzLnNldENsYXNzZXMoZS5maWVsZCwgZS5lbGVtZW50LCBlLmVsZW1lbnRzLCAoX2EgPSB7fSxcblx0ICAgICAgICAgICAgX2FbdGhpcy5vcHRzLmludmFsaWRdID0gZmFsc2UsXG5cdCAgICAgICAgICAgIF9hW3RoaXMub3B0cy52YWxpZF0gPSBmYWxzZSxcblx0ICAgICAgICAgICAgX2FbdGhpcy5vcHRzLnZhbGlkYXRpbmddID0gZmFsc2UsXG5cdCAgICAgICAgICAgIF9hKSk7XG5cdCAgICAgICAgdmFyIGV2dCA9IHtcblx0ICAgICAgICAgICAgZWxlbWVudDogZS5lbGVtZW50LFxuXHQgICAgICAgICAgICBmaWVsZDogZS5maWVsZCxcblx0ICAgICAgICAgICAgaWNvbkVsZW1lbnQ6IGljb24sXG5cdCAgICAgICAgICAgIHN0YXR1czogJ05vdFZhbGlkYXRlZCcsXG5cdCAgICAgICAgfTtcblx0ICAgICAgICB0aGlzLmNvcmUuZW1pdCgncGx1Z2lucy5pY29uLnNldCcsIGV2dCk7XG5cdCAgICAgICAgdGhpcy5vcHRzLm9uU2V0KGV2dCk7XG5cdCAgICB9O1xuXHQgICAgSWNvbi5wcm90b3R5cGUub25FbGVtZW50SWdub3JlZCA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgdmFyIF9hO1xuXHQgICAgICAgIHZhciBpY29uID0gdGhpcy5zZXRDbGFzc2VzKGUuZmllbGQsIGUuZWxlbWVudCwgZS5lbGVtZW50cywgKF9hID0ge30sXG5cdCAgICAgICAgICAgIF9hW3RoaXMub3B0cy5pbnZhbGlkXSA9IGZhbHNlLFxuXHQgICAgICAgICAgICBfYVt0aGlzLm9wdHMudmFsaWRdID0gZmFsc2UsXG5cdCAgICAgICAgICAgIF9hW3RoaXMub3B0cy52YWxpZGF0aW5nXSA9IGZhbHNlLFxuXHQgICAgICAgICAgICBfYSkpO1xuXHQgICAgICAgIHZhciBldnQgPSB7XG5cdCAgICAgICAgICAgIGVsZW1lbnQ6IGUuZWxlbWVudCxcblx0ICAgICAgICAgICAgZmllbGQ6IGUuZmllbGQsXG5cdCAgICAgICAgICAgIGljb25FbGVtZW50OiBpY29uLFxuXHQgICAgICAgICAgICBzdGF0dXM6ICdJZ25vcmVkJyxcblx0ICAgICAgICB9O1xuXHQgICAgICAgIHRoaXMuY29yZS5lbWl0KCdwbHVnaW5zLmljb24uc2V0JywgZXZ0KTtcblx0ICAgICAgICB0aGlzLm9wdHMub25TZXQoZXZ0KTtcblx0ICAgIH07XG5cdCAgICBJY29uLnByb3RvdHlwZS5zZXRDbGFzc2VzID0gZnVuY3Rpb24gKF9maWVsZCwgZWxlbWVudCwgZWxlbWVudHMsIGNsYXNzZXMpIHtcblx0ICAgICAgICB2YXIgdHlwZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG5cdCAgICAgICAgdmFyIGVsZSA9ICdyYWRpbycgPT09IHR5cGUgfHwgJ2NoZWNrYm94JyA9PT0gdHlwZSA/IGVsZW1lbnRzWzBdIDogZWxlbWVudDtcblx0ICAgICAgICBpZiAodGhpcy5pY29ucy5oYXMoZWxlKSkge1xuXHQgICAgICAgICAgICB2YXIgaWNvbiA9IHRoaXMuaWNvbnMuZ2V0KGVsZSk7XG5cdCAgICAgICAgICAgIGNsYXNzU2V0KGljb24sIGNsYXNzZXMpO1xuXHQgICAgICAgICAgICByZXR1cm4gaWNvbjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICByZXR1cm4gSWNvbjtcblx0fShjb3JlLlBsdWdpbikpO1xuXG5cdGNqcyRyLkljb24gPSBJY29uO1xuXHRyZXR1cm4gY2pzJHI7XG59XG5cbi8qKlxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgIGxpYiRyLmV4cG9ydHMgPSByZXF1aXJlSW5kZXhfbWluJHIoKTtcbn0gZWxzZSB7XG4gICAgbGliJHIuZXhwb3J0cyA9IHJlcXVpcmVDanMkcigpO1xufVxuXG52YXIgbGliRXhwb3J0cyRyID0gbGliJHIuZXhwb3J0cztcblxudmFyIGxpYiRxID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIGluZGV4X21pbiRxID0ge307XG5cbi8qKiBcbiAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG4gKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKlxuICogQGxpY2Vuc2UgaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pby9saWNlbnNlXG4gKiBAcGFja2FnZSBAZm9ybS12YWxpZGF0aW9uL3BsdWdpbi1zZXF1ZW5jZVxuICogQHZlcnNpb24gMi40LjBcbiAqL1xuXG52YXIgaGFzUmVxdWlyZWRJbmRleF9taW4kcTtcblxuZnVuY3Rpb24gcmVxdWlyZUluZGV4X21pbiRxICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkSW5kZXhfbWluJHEpIHJldHVybiBpbmRleF9taW4kcTtcblx0aGFzUmVxdWlyZWRJbmRleF9taW4kcSA9IDE7XG52YXIgZT1saWJFeHBvcnRzJEIsdD1mdW5jdGlvbihlLGkpe3JldHVybiB0PU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihlLHQpe2UuX19wcm90b19fPXQ7fXx8ZnVuY3Rpb24oZSx0KXtmb3IodmFyIGkgaW4gdClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxpKSYmKGVbaV09dFtpXSk7fSx0KGUsaSl9O3ZhciBpPWUudXRpbHMucmVtb3ZlVW5kZWZpbmVkLGw9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gbCh0KXt2YXIgbD1lLmNhbGwodGhpcyx0KXx8dGhpcztyZXR1cm4gbC5pbnZhbGlkRmllbGRzPW5ldyBNYXAsbC5vcHRzPU9iamVjdC5hc3NpZ24oe30se2VuYWJsZWQ6ITB9LGkodCkpLGwudmFsaWRhdG9ySGFuZGxlcj1sLm9uVmFsaWRhdG9yVmFsaWRhdGVkLmJpbmQobCksbC5zaG91bGRWYWxpZGF0ZUZpbHRlcj1sLnNob3VsZFZhbGlkYXRlLmJpbmQobCksbC5maWVsZEFkZGVkSGFuZGxlcj1sLm9uRmllbGRBZGRlZC5iaW5kKGwpLGwuZWxlbWVudE5vdFZhbGlkYXRlZEhhbmRsZXI9bC5vbkVsZW1lbnROb3RWYWxpZGF0ZWQuYmluZChsKSxsLmVsZW1lbnRWYWxpZGF0aW5nSGFuZGxlcj1sLm9uRWxlbWVudFZhbGlkYXRpbmcuYmluZChsKSxsfXJldHVybiBmdW5jdGlvbihlLGkpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGkmJm51bGwhPT1pKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiK1N0cmluZyhpKStcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO2Z1bmN0aW9uIGwoKXt0aGlzLmNvbnN0cnVjdG9yPWU7fXQoZSxpKSxlLnByb3RvdHlwZT1udWxsPT09aT9PYmplY3QuY3JlYXRlKGkpOihsLnByb3RvdHlwZT1pLnByb3RvdHlwZSxuZXcgbCk7fShsLGUpLGwucHJvdG90eXBlLmluc3RhbGw9ZnVuY3Rpb24oKXt0aGlzLmNvcmUub24oXCJjb3JlLnZhbGlkYXRvci52YWxpZGF0ZWRcIix0aGlzLnZhbGlkYXRvckhhbmRsZXIpLm9uKFwiY29yZS5maWVsZC5hZGRlZFwiLHRoaXMuZmllbGRBZGRlZEhhbmRsZXIpLm9uKFwiY29yZS5lbGVtZW50Lm5vdHZhbGlkYXRlZFwiLHRoaXMuZWxlbWVudE5vdFZhbGlkYXRlZEhhbmRsZXIpLm9uKFwiY29yZS5lbGVtZW50LnZhbGlkYXRpbmdcIix0aGlzLmVsZW1lbnRWYWxpZGF0aW5nSGFuZGxlcikucmVnaXN0ZXJGaWx0ZXIoXCJmaWVsZC1zaG91bGQtdmFsaWRhdGVcIix0aGlzLnNob3VsZFZhbGlkYXRlRmlsdGVyKTt9LGwucHJvdG90eXBlLnVuaW5zdGFsbD1mdW5jdGlvbigpe3RoaXMuaW52YWxpZEZpZWxkcy5jbGVhcigpLHRoaXMuY29yZS5vZmYoXCJjb3JlLnZhbGlkYXRvci52YWxpZGF0ZWRcIix0aGlzLnZhbGlkYXRvckhhbmRsZXIpLm9mZihcImNvcmUuZmllbGQuYWRkZWRcIix0aGlzLmZpZWxkQWRkZWRIYW5kbGVyKS5vZmYoXCJjb3JlLmVsZW1lbnQubm90dmFsaWRhdGVkXCIsdGhpcy5lbGVtZW50Tm90VmFsaWRhdGVkSGFuZGxlcikub2ZmKFwiY29yZS5lbGVtZW50LnZhbGlkYXRpbmdcIix0aGlzLmVsZW1lbnRWYWxpZGF0aW5nSGFuZGxlcikuZGVyZWdpc3RlckZpbHRlcihcImZpZWxkLXNob3VsZC12YWxpZGF0ZVwiLHRoaXMuc2hvdWxkVmFsaWRhdGVGaWx0ZXIpO30sbC5wcm90b3R5cGUuc2hvdWxkVmFsaWRhdGU9ZnVuY3Rpb24oZSx0LGksbCl7cmV0dXJuICF0aGlzLmlzRW5hYmxlZHx8ISgoITA9PT10aGlzLm9wdHMuZW5hYmxlZHx8ITA9PT10aGlzLm9wdHMuZW5hYmxlZFtlXSkmJnRoaXMuaW52YWxpZEZpZWxkcy5oYXModCkmJiEhdGhpcy5pbnZhbGlkRmllbGRzLmdldCh0KS5sZW5ndGgmJi0xPT09dGhpcy5pbnZhbGlkRmllbGRzLmdldCh0KS5pbmRleE9mKGwpKX0sbC5wcm90b3R5cGUub25WYWxpZGF0b3JWYWxpZGF0ZWQ9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5pbnZhbGlkRmllbGRzLmhhcyhlLmVsZW1lbnQpP3RoaXMuaW52YWxpZEZpZWxkcy5nZXQoZS5lbGVtZW50KTpbXSxpPXQuaW5kZXhPZihlLnZhbGlkYXRvcik7ZS5yZXN1bHQudmFsaWQmJmk+PTA/dC5zcGxpY2UoaSwxKTplLnJlc3VsdC52YWxpZHx8LTEhPT1pfHx0LnB1c2goZS52YWxpZGF0b3IpLHRoaXMuaW52YWxpZEZpZWxkcy5zZXQoZS5lbGVtZW50LHQpO30sbC5wcm90b3R5cGUub25GaWVsZEFkZGVkPWZ1bmN0aW9uKGUpe2UuZWxlbWVudHMmJnRoaXMuY2xlYXJJbnZhbGlkRmllbGRzKGUuZWxlbWVudHMpO30sbC5wcm90b3R5cGUub25FbGVtZW50Tm90VmFsaWRhdGVkPWZ1bmN0aW9uKGUpe3RoaXMuY2xlYXJJbnZhbGlkRmllbGRzKGUuZWxlbWVudHMpO30sbC5wcm90b3R5cGUub25FbGVtZW50VmFsaWRhdGluZz1mdW5jdGlvbihlKXt0aGlzLmNsZWFySW52YWxpZEZpZWxkcyhlLmVsZW1lbnRzKTt9LGwucHJvdG90eXBlLmNsZWFySW52YWxpZEZpZWxkcz1mdW5jdGlvbihlKXt2YXIgdD10aGlzO2UuZm9yRWFjaCgoZnVuY3Rpb24oZSl7cmV0dXJuIHQuaW52YWxpZEZpZWxkcy5kZWxldGUoZSl9KSk7fSxsfShlLlBsdWdpbik7aW5kZXhfbWluJHEuU2VxdWVuY2U9bDtcblx0cmV0dXJuIGluZGV4X21pbiRxO1xufVxuXG52YXIgY2pzJHEgPSB7fTtcblxudmFyIGhhc1JlcXVpcmVkQ2pzJHE7XG5cbmZ1bmN0aW9uIHJlcXVpcmVDanMkcSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZENqcyRxKSByZXR1cm4gY2pzJHE7XG5cdGhhc1JlcXVpcmVkQ2pzJHEgPSAxO1xuXG5cdHZhciBjb3JlID0gbGliRXhwb3J0cyRCO1xuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuXHRDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblx0UGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcblx0cHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuXHRUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblx0UkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcblx0QU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5cdElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5cdExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcblx0T1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5cdFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcblx0KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHQvKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxuXHR2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuXHQgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG5cdCAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG5cdCAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuXHQgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuXHQgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuXHQgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuXHQgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuXHQgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcblx0ICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuXHR9XG5cblx0LyoqXG5cdCAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuXHQgKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcblx0ICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuXHQgKi9cblx0dmFyIHJlbW92ZVVuZGVmaW5lZCA9IGNvcmUudXRpbHMucmVtb3ZlVW5kZWZpbmVkO1xuXHQvKipcblx0ICogYGBgXG5cdCAqICBuZXcgQ29yZShmb3JtLCB7IC4uLiB9KVxuXHQgKiAgICAgIC5yZWdpc3RlclBsdWdpbignc2VxdWVuY2UnLCBuZXcgU2VxdWVuY2Uoe1xuXHQgKiAgICAgICAgICBlbmFibGVkOiBmYWxzZSAvLyBEZWZhdWx0IHZhbHVlIGlzIGB0cnVlYFxuXHQgKiAgICAgIH0pKTtcblx0ICogYGBgXG5cdCAqXG5cdCAqIFRoZSBgZW5hYmxlZGAgb3B0aW9uIGNhbiBiZTpcblx0ICogLSBgdHJ1ZWAgKGRlZmF1bHQpOiBXaGVuIGEgZmllbGQgaGFzIG11bHRpcGxlIHZhbGlkYXRvcnMsIGFsbCBvZiB0aGVtIHdpbGwgYmUgY2hlY2tlZCByZXNwZWN0aXZlbHkuXG5cdCAqIElmIGVycm9ycyBvY2N1ciBpbiBtdWx0aXBsZSB2YWxpZGF0b3JzLCBhbGwgb2YgdGhlbSB3aWxsIGJlIGRpc3BsYXllZCB0byB0aGUgdXNlclxuXHQgKiAtIGBmYWxzZWA6IFdoZW4gYSBmaWVsZCBoYXMgbXVsdGlwbGUgdmFsaWRhdG9ycywgdmFsaWRhdGlvbiBmb3IgdGhpcyBmaWVsZCB3aWxsIGJlIHRlcm1pbmF0ZWQgdXBvbiB0aGVcblx0ICogZmlyc3QgZW5jb3VudGVyZWQgZXJyb3IuXG5cdCAqIFRodXMsIG9ubHkgdGhlIHZlcnkgZmlyc3QgZXJyb3IgbWVzc2FnZSByZWxhdGVkIHRvIHRoaXMgZmllbGQgd2lsbCBiZSBkaXNwbGF5ZWQgdG8gdGhlIHVzZXJcblx0ICpcblx0ICogVXNlciBjYW4gc2V0IHRoZSBgZW5hYmxlZGAgb3B0aW9uIHRvIGFsbCBmaWVsZHMgYXMgc2FtcGxlIGNvZGUgYWJvdmUsIG9yIGFwcGx5IGl0IGZvciBzcGVjaWZpYyBmaWVsZHMgYXMgZm9sbG93aW5nOlxuXHQgKiBgYGBcblx0ICogIG5ldyBDb3JlKGZvcm0sIHsgLi4uIH0pXG5cdCAqICAgICAgLnJlZ2lzdGVyUGx1Z2luKCdzZXF1ZW5jZScsIG5ldyBTZXF1ZW5jZSh7XG5cdCAqICAgICAgICAgIGVuYWJsZWQ6IHtcblx0ICogICAgICAgICAgICAgIGZ1bGxOYW1lOiB0cnVlLCAvLyBJdCdzIG5vdCBuZWNlc3Nhcnkgc2luY2UgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYHRydWVgXG5cdCAqICAgICAgICAgICAgICB1c2VybmFtZTogZmFsc2UsXG5cdCAqICAgICAgICAgICAgICBlbWFpbDogZmFsc2Vcblx0ICogICAgICAgICAgfVxuXHQgKiAgICAgIH0pKTtcblx0ICogYGBgXG5cdCAqL1xuXHR2YXIgU2VxdWVuY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoU2VxdWVuY2UsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBTZXF1ZW5jZShvcHRzKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0cykgfHwgdGhpcztcblx0ICAgICAgICBfdGhpcy5pbnZhbGlkRmllbGRzID0gbmV3IE1hcCgpO1xuXHQgICAgICAgIF90aGlzLm9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCB7IGVuYWJsZWQ6IHRydWUgfSwgcmVtb3ZlVW5kZWZpbmVkKG9wdHMpKTtcblx0ICAgICAgICBfdGhpcy52YWxpZGF0b3JIYW5kbGVyID0gX3RoaXMub25WYWxpZGF0b3JWYWxpZGF0ZWQuYmluZChfdGhpcyk7XG5cdCAgICAgICAgX3RoaXMuc2hvdWxkVmFsaWRhdGVGaWx0ZXIgPSBfdGhpcy5zaG91bGRWYWxpZGF0ZS5iaW5kKF90aGlzKTtcblx0ICAgICAgICBfdGhpcy5maWVsZEFkZGVkSGFuZGxlciA9IF90aGlzLm9uRmllbGRBZGRlZC5iaW5kKF90aGlzKTtcblx0ICAgICAgICBfdGhpcy5lbGVtZW50Tm90VmFsaWRhdGVkSGFuZGxlciA9IF90aGlzLm9uRWxlbWVudE5vdFZhbGlkYXRlZC5iaW5kKF90aGlzKTtcblx0ICAgICAgICBfdGhpcy5lbGVtZW50VmFsaWRhdGluZ0hhbmRsZXIgPSBfdGhpcy5vbkVsZW1lbnRWYWxpZGF0aW5nLmJpbmQoX3RoaXMpO1xuXHQgICAgICAgIHJldHVybiBfdGhpcztcblx0ICAgIH1cblx0ICAgIFNlcXVlbmNlLnByb3RvdHlwZS5pbnN0YWxsID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuY29yZVxuXHQgICAgICAgICAgICAub24oJ2NvcmUudmFsaWRhdG9yLnZhbGlkYXRlZCcsIHRoaXMudmFsaWRhdG9ySGFuZGxlcilcblx0ICAgICAgICAgICAgLm9uKCdjb3JlLmZpZWxkLmFkZGVkJywgdGhpcy5maWVsZEFkZGVkSGFuZGxlcilcblx0ICAgICAgICAgICAgLm9uKCdjb3JlLmVsZW1lbnQubm90dmFsaWRhdGVkJywgdGhpcy5lbGVtZW50Tm90VmFsaWRhdGVkSGFuZGxlcilcblx0ICAgICAgICAgICAgLm9uKCdjb3JlLmVsZW1lbnQudmFsaWRhdGluZycsIHRoaXMuZWxlbWVudFZhbGlkYXRpbmdIYW5kbGVyKVxuXHQgICAgICAgICAgICAucmVnaXN0ZXJGaWx0ZXIoJ2ZpZWxkLXNob3VsZC12YWxpZGF0ZScsIHRoaXMuc2hvdWxkVmFsaWRhdGVGaWx0ZXIpO1xuXHQgICAgfTtcblx0ICAgIFNlcXVlbmNlLnByb3RvdHlwZS51bmluc3RhbGwgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5pbnZhbGlkRmllbGRzLmNsZWFyKCk7XG5cdCAgICAgICAgdGhpcy5jb3JlXG5cdCAgICAgICAgICAgIC5vZmYoJ2NvcmUudmFsaWRhdG9yLnZhbGlkYXRlZCcsIHRoaXMudmFsaWRhdG9ySGFuZGxlcilcblx0ICAgICAgICAgICAgLm9mZignY29yZS5maWVsZC5hZGRlZCcsIHRoaXMuZmllbGRBZGRlZEhhbmRsZXIpXG5cdCAgICAgICAgICAgIC5vZmYoJ2NvcmUuZWxlbWVudC5ub3R2YWxpZGF0ZWQnLCB0aGlzLmVsZW1lbnROb3RWYWxpZGF0ZWRIYW5kbGVyKVxuXHQgICAgICAgICAgICAub2ZmKCdjb3JlLmVsZW1lbnQudmFsaWRhdGluZycsIHRoaXMuZWxlbWVudFZhbGlkYXRpbmdIYW5kbGVyKVxuXHQgICAgICAgICAgICAuZGVyZWdpc3RlckZpbHRlcignZmllbGQtc2hvdWxkLXZhbGlkYXRlJywgdGhpcy5zaG91bGRWYWxpZGF0ZUZpbHRlcik7XG5cdCAgICB9O1xuXHQgICAgU2VxdWVuY2UucHJvdG90eXBlLnNob3VsZFZhbGlkYXRlID0gZnVuY3Rpb24gKGZpZWxkLCBlbGVtZW50LCBfdmFsdWUsIHZhbGlkYXRvcikge1xuXHQgICAgICAgIGlmICghdGhpcy5pc0VuYWJsZWQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIFN0b3AgdmFsaWRhdGluZ1xuXHQgICAgICAgIC8vIGlmIHRoZSBgZW5hYmxlZGAgb3B0aW9uIGlzIHNldCB0byBgZmFsc2VgXG5cdCAgICAgICAgLy8gYW5kIHRoZXJlJ3MgYXQgbGVhc3Qgb25lIHZhbGlkYXRvciB0aGF0IGZpZWxkIGRvZXNuJ3QgcGFzc1xuXHQgICAgICAgIHZhciBzdG9wID0gKHRoaXMub3B0cy5lbmFibGVkID09PSB0cnVlIHx8IHRoaXMub3B0cy5lbmFibGVkW2ZpZWxkXSA9PT0gdHJ1ZSkgJiZcblx0ICAgICAgICAgICAgdGhpcy5pbnZhbGlkRmllbGRzLmhhcyhlbGVtZW50KSAmJlxuXHQgICAgICAgICAgICAhIXRoaXMuaW52YWxpZEZpZWxkcy5nZXQoZWxlbWVudCkubGVuZ3RoICYmXG5cdCAgICAgICAgICAgIHRoaXMuaW52YWxpZEZpZWxkcy5nZXQoZWxlbWVudCkuaW5kZXhPZih2YWxpZGF0b3IpID09PSAtMTtcblx0ICAgICAgICByZXR1cm4gIXN0b3A7XG5cdCAgICB9O1xuXHQgICAgU2VxdWVuY2UucHJvdG90eXBlLm9uVmFsaWRhdG9yVmFsaWRhdGVkID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICB2YXIgdmFsaWRhdG9ycyA9IHRoaXMuaW52YWxpZEZpZWxkcy5oYXMoZS5lbGVtZW50KSA/IHRoaXMuaW52YWxpZEZpZWxkcy5nZXQoZS5lbGVtZW50KSA6IFtdO1xuXHQgICAgICAgIHZhciBpbmRleCA9IHZhbGlkYXRvcnMuaW5kZXhPZihlLnZhbGlkYXRvcik7XG5cdCAgICAgICAgaWYgKGUucmVzdWx0LnZhbGlkICYmIGluZGV4ID49IDApIHtcblx0ICAgICAgICAgICAgdmFsaWRhdG9ycy5zcGxpY2UoaW5kZXgsIDEpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmICghZS5yZXN1bHQudmFsaWQgJiYgaW5kZXggPT09IC0xKSB7XG5cdCAgICAgICAgICAgIHZhbGlkYXRvcnMucHVzaChlLnZhbGlkYXRvcik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuaW52YWxpZEZpZWxkcy5zZXQoZS5lbGVtZW50LCB2YWxpZGF0b3JzKTtcblx0ICAgIH07XG5cdCAgICBTZXF1ZW5jZS5wcm90b3R5cGUub25GaWVsZEFkZGVkID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAvLyBSZW1vdmUgdGhlIGZpZWxkIGVsZW1lbnQgZnJvbSBzZXQgb2YgaW52YWxpZCBlbGVtZW50c1xuXHQgICAgICAgIGlmIChlLmVsZW1lbnRzKSB7XG5cdCAgICAgICAgICAgIHRoaXMuY2xlYXJJbnZhbGlkRmllbGRzKGUuZWxlbWVudHMpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICBTZXF1ZW5jZS5wcm90b3R5cGUub25FbGVtZW50Tm90VmFsaWRhdGVkID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICB0aGlzLmNsZWFySW52YWxpZEZpZWxkcyhlLmVsZW1lbnRzKTtcblx0ICAgIH07XG5cdCAgICBTZXF1ZW5jZS5wcm90b3R5cGUub25FbGVtZW50VmFsaWRhdGluZyA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgdGhpcy5jbGVhckludmFsaWRGaWVsZHMoZS5lbGVtZW50cyk7XG5cdCAgICB9O1xuXHQgICAgU2VxdWVuY2UucHJvdG90eXBlLmNsZWFySW52YWxpZEZpZWxkcyA9IGZ1bmN0aW9uIChlbGVtZW50cykge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7IHJldHVybiBfdGhpcy5pbnZhbGlkRmllbGRzLmRlbGV0ZShlbGUpOyB9KTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gU2VxdWVuY2U7XG5cdH0oY29yZS5QbHVnaW4pKTtcblxuXHRjanMkcS5TZXF1ZW5jZSA9IFNlcXVlbmNlO1xuXHRyZXR1cm4gY2pzJHE7XG59XG5cbi8qKlxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgIGxpYiRxLmV4cG9ydHMgPSByZXF1aXJlSW5kZXhfbWluJHEoKTtcbn0gZWxzZSB7XG4gICAgbGliJHEuZXhwb3J0cyA9IHJlcXVpcmVDanMkcSgpO1xufVxuXG52YXIgbGliRXhwb3J0cyRxID0gbGliJHEuZXhwb3J0cztcblxudmFyIGxpYiRwID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIGluZGV4X21pbiRwID0ge307XG5cbi8qKiBcbiAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG4gKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKlxuICogQGxpY2Vuc2UgaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pby9saWNlbnNlXG4gKiBAcGFja2FnZSBAZm9ybS12YWxpZGF0aW9uL3BsdWdpbi1zdWJtaXQtYnV0dG9uXG4gKiBAdmVyc2lvbiAyLjQuMFxuICovXG5cbnZhciBoYXNSZXF1aXJlZEluZGV4X21pbiRwO1xuXG5mdW5jdGlvbiByZXF1aXJlSW5kZXhfbWluJHAgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRJbmRleF9taW4kcCkgcmV0dXJuIGluZGV4X21pbiRwO1xuXHRoYXNSZXF1aXJlZEluZGV4X21pbiRwID0gMTtcbnZhciB0PWxpYkV4cG9ydHMkQixlPWZ1bmN0aW9uKHQsaSl7cmV0dXJuIGU9T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKHQsZSl7dC5fX3Byb3RvX189ZTt9fHxmdW5jdGlvbih0LGUpe2Zvcih2YXIgaSBpbiBlKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLGkpJiYodFtpXT1lW2ldKTt9LGUodCxpKX07dmFyIGk9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gaShlKXt2YXIgaT10LmNhbGwodGhpcyxlKXx8dGhpcztyZXR1cm4gaS5pc0Zvcm1WYWxpZD0hMSxpLmlzQnV0dG9uQ2xpY2tlZD0hMSxpLm9wdHM9T2JqZWN0LmFzc2lnbih7fSx7YXNwTmV0QnV0dG9uOiExLGJ1dHRvbnM6ZnVuY3Rpb24odCl7cmV0dXJuIFtdLnNsaWNlLmNhbGwodC5xdWVyeVNlbGVjdG9yQWxsKCdbdHlwZT1cInN1Ym1pdFwiXTpub3QoW2Zvcm1ub3ZhbGlkYXRlXSknKSl9LGxpdmVNb2RlOiEwfSxlKSxpLnN1Ym1pdEhhbmRsZXI9aS5oYW5kbGVTdWJtaXRFdmVudC5iaW5kKGkpLGkuYnV0dG9uQ2xpY2tIYW5kbGVyPWkuaGFuZGxlQ2xpY2tFdmVudC5iaW5kKGkpLGkuaWdub3JlVmFsaWRhdGlvbkZpbHRlcj1pLmlnbm9yZVZhbGlkYXRpb24uYmluZChpKSxpfXJldHVybiBmdW5jdGlvbih0LGkpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGkmJm51bGwhPT1pKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiK1N0cmluZyhpKStcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO2Z1bmN0aW9uIG4oKXt0aGlzLmNvbnN0cnVjdG9yPXQ7fWUodCxpKSx0LnByb3RvdHlwZT1udWxsPT09aT9PYmplY3QuY3JlYXRlKGkpOihuLnByb3RvdHlwZT1pLnByb3RvdHlwZSxuZXcgbik7fShpLHQpLGkucHJvdG90eXBlLmluc3RhbGw9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO2lmKHRoaXMuY29yZS5nZXRGb3JtRWxlbWVudCgpaW5zdGFuY2VvZiBIVE1MRm9ybUVsZW1lbnQpe3ZhciBlPXRoaXMuY29yZS5nZXRGb3JtRWxlbWVudCgpO3RoaXMuc3VibWl0QnV0dG9ucz10aGlzLm9wdHMuYnV0dG9ucyhlKSxlLnNldEF0dHJpYnV0ZShcIm5vdmFsaWRhdGVcIixcIm5vdmFsaWRhdGVcIiksZS5hZGRFdmVudExpc3RlbmVyKFwic3VibWl0XCIsdGhpcy5zdWJtaXRIYW5kbGVyKSx0aGlzLmhpZGRlbkNsaWNrZWRFbGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpLHRoaXMuaGlkZGVuQ2xpY2tlZEVsZS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsXCJoaWRkZW5cIiksZS5hcHBlbmRDaGlsZCh0aGlzLmhpZGRlbkNsaWNrZWRFbGUpLHRoaXMuc3VibWl0QnV0dG9ucy5mb3JFYWNoKChmdW5jdGlvbihlKXtlLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHQuYnV0dG9uQ2xpY2tIYW5kbGVyKTt9KSksdGhpcy5jb3JlLnJlZ2lzdGVyRmlsdGVyKFwiZWxlbWVudC1pZ25vcmVkXCIsdGhpcy5pZ25vcmVWYWxpZGF0aW9uRmlsdGVyKTt9fSxpLnByb3RvdHlwZS51bmluc3RhbGw9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dGhpcy5jb3JlLmdldEZvcm1FbGVtZW50KCk7ZSBpbnN0YW5jZW9mIEhUTUxGb3JtRWxlbWVudCYmZS5yZW1vdmVFdmVudExpc3RlbmVyKFwic3VibWl0XCIsdGhpcy5zdWJtaXRIYW5kbGVyKSx0aGlzLnN1Ym1pdEJ1dHRvbnMuZm9yRWFjaCgoZnVuY3Rpb24oZSl7ZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIix0LmJ1dHRvbkNsaWNrSGFuZGxlcik7fSkpLHRoaXMuaGlkZGVuQ2xpY2tlZEVsZS5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuaGlkZGVuQ2xpY2tlZEVsZSksdGhpcy5jb3JlLmRlcmVnaXN0ZXJGaWx0ZXIoXCJlbGVtZW50LWlnbm9yZWRcIix0aGlzLmlnbm9yZVZhbGlkYXRpb25GaWx0ZXIpO30saS5wcm90b3R5cGUuaGFuZGxlU3VibWl0RXZlbnQ9ZnVuY3Rpb24odCl7dGhpcy52YWxpZGF0ZUZvcm0odCk7fSxpLnByb3RvdHlwZS5oYW5kbGVDbGlja0V2ZW50PWZ1bmN0aW9uKHQpe3ZhciBlPXQuY3VycmVudFRhcmdldDtpZih0aGlzLmlzQnV0dG9uQ2xpY2tlZD0hMCxlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpaWYodGhpcy5vcHRzLmFzcE5ldEJ1dHRvbiYmITA9PT10aGlzLmlzRm9ybVZhbGlkKTtlbHNlIHt0aGlzLmNvcmUuZ2V0Rm9ybUVsZW1lbnQoKS5yZW1vdmVFdmVudExpc3RlbmVyKFwic3VibWl0XCIsdGhpcy5zdWJtaXRIYW5kbGVyKSx0aGlzLmNsaWNrZWRCdXR0b249dC50YXJnZXQ7dmFyIGk9dGhpcy5jbGlja2VkQnV0dG9uLmdldEF0dHJpYnV0ZShcIm5hbWVcIiksbj10aGlzLmNsaWNrZWRCdXR0b24uZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7aSYmbiYmKHRoaXMuaGlkZGVuQ2xpY2tlZEVsZS5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsaSksdGhpcy5oaWRkZW5DbGlja2VkRWxlLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsbikpLHRoaXMudmFsaWRhdGVGb3JtKHQpO319LGkucHJvdG90eXBlLnZhbGlkYXRlRm9ybT1mdW5jdGlvbih0KXt2YXIgZT10aGlzO3RoaXMuaXNFbmFibGVkJiYodC5wcmV2ZW50RGVmYXVsdCgpLHRoaXMuY29yZS52YWxpZGF0ZSgpLnRoZW4oKGZ1bmN0aW9uKHQpe1wiVmFsaWRcIj09PXQmJmUub3B0cy5hc3BOZXRCdXR0b24mJiFlLmlzRm9ybVZhbGlkJiZlLmNsaWNrZWRCdXR0b24mJihlLmlzRm9ybVZhbGlkPSEwLGUuY2xpY2tlZEJ1dHRvbi5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIixlLmJ1dHRvbkNsaWNrSGFuZGxlciksZS5jbGlja2VkQnV0dG9uLmNsaWNrKCkpO30pKSk7fSxpLnByb3RvdHlwZS5pZ25vcmVWYWxpZGF0aW9uPWZ1bmN0aW9uKHQsZSxpKXtyZXR1cm4gISF0aGlzLmlzRW5hYmxlZCYmKCF0aGlzLm9wdHMubGl2ZU1vZGUmJiF0aGlzLmlzQnV0dG9uQ2xpY2tlZCl9LGl9KHQuUGx1Z2luKTtpbmRleF9taW4kcC5TdWJtaXRCdXR0b249aTtcblx0cmV0dXJuIGluZGV4X21pbiRwO1xufVxuXG52YXIgY2pzJHAgPSB7fTtcblxudmFyIGhhc1JlcXVpcmVkQ2pzJHA7XG5cbmZ1bmN0aW9uIHJlcXVpcmVDanMkcCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZENqcyRwKSByZXR1cm4gY2pzJHA7XG5cdGhhc1JlcXVpcmVkQ2pzJHAgPSAxO1xuXG5cdHZhciBjb3JlID0gbGliRXhwb3J0cyRCO1xuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuXHRDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblx0UGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcblx0cHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuXHRUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblx0UkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcblx0QU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5cdElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5cdExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcblx0T1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5cdFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcblx0KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHQvKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxuXHR2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuXHQgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG5cdCAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG5cdCAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuXHQgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuXHQgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuXHQgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuXHQgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuXHQgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcblx0ICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuXHR9XG5cblx0LyoqXG5cdCAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuXHQgKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcblx0ICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuXHQgKi9cblx0dmFyIFN1Ym1pdEJ1dHRvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhTdWJtaXRCdXR0b24sIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBTdWJtaXRCdXR0b24ob3B0cykge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdHMpIHx8IHRoaXM7XG5cdCAgICAgICAgX3RoaXMuaXNGb3JtVmFsaWQgPSBmYWxzZTtcblx0ICAgICAgICBfdGhpcy5pc0J1dHRvbkNsaWNrZWQgPSBmYWxzZTtcblx0ICAgICAgICBfdGhpcy5vcHRzID0gT2JqZWN0LmFzc2lnbih7fSwge1xuXHQgICAgICAgICAgICAvLyBTZXQgaXQgdG8gYHRydWVgIHRvIHN1cHBvcnQgY2xhc3NpY2FsIEFTUC5OZXQgZm9ybVxuXHQgICAgICAgICAgICBhc3BOZXRCdXR0b246IGZhbHNlLFxuXHQgICAgICAgICAgICAvLyBCeSBkZWZhdWx0LCBkb24ndCBwZXJmb3JtIHZhbGlkYXRpb24gd2hlbiBjbGlja2luZyBvblxuXHQgICAgICAgICAgICAvLyB0aGUgc3VibWl0IGJ1dHRvbi9pbnB1dCB3aGljaCBoYXZlIGBmb3Jtbm92YWxpZGF0ZWAgYXR0cmlidXRlXG5cdCAgICAgICAgICAgIGJ1dHRvbnM6IGZ1bmN0aW9uIChmb3JtKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gW10uc2xpY2UuY2FsbChmb3JtLnF1ZXJ5U2VsZWN0b3JBbGwoJ1t0eXBlPVwic3VibWl0XCJdOm5vdChbZm9ybW5vdmFsaWRhdGVdKScpKTtcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgbGl2ZU1vZGU6IHRydWUsXG5cdCAgICAgICAgfSwgb3B0cyk7XG5cdCAgICAgICAgX3RoaXMuc3VibWl0SGFuZGxlciA9IF90aGlzLmhhbmRsZVN1Ym1pdEV2ZW50LmJpbmQoX3RoaXMpO1xuXHQgICAgICAgIF90aGlzLmJ1dHRvbkNsaWNrSGFuZGxlciA9IF90aGlzLmhhbmRsZUNsaWNrRXZlbnQuYmluZChfdGhpcyk7XG5cdCAgICAgICAgX3RoaXMuaWdub3JlVmFsaWRhdGlvbkZpbHRlciA9IF90aGlzLmlnbm9yZVZhbGlkYXRpb24uYmluZChfdGhpcyk7XG5cdCAgICAgICAgcmV0dXJuIF90aGlzO1xuXHQgICAgfVxuXHQgICAgU3VibWl0QnV0dG9uLnByb3RvdHlwZS5pbnN0YWxsID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgaWYgKCEodGhpcy5jb3JlLmdldEZvcm1FbGVtZW50KCkgaW5zdGFuY2VvZiBIVE1MRm9ybUVsZW1lbnQpKSB7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGZvcm0gPSB0aGlzLmNvcmUuZ2V0Rm9ybUVsZW1lbnQoKTtcblx0ICAgICAgICB0aGlzLnN1Ym1pdEJ1dHRvbnMgPSB0aGlzLm9wdHMuYnV0dG9ucyhmb3JtKTtcblx0ICAgICAgICAvLyBEaXNhYmxlIGNsaWVudCBzaWRlIHZhbGlkYXRpb24gaW4gSFRNTCA1XG5cdCAgICAgICAgZm9ybS5zZXRBdHRyaWJ1dGUoJ25vdmFsaWRhdGUnLCAnbm92YWxpZGF0ZScpO1xuXHQgICAgICAgIC8vIERpc2FibGUgdGhlIGRlZmF1bHQgc3VibWlzc2lvbiBmaXJzdFxuXHQgICAgICAgIGZvcm0uYWRkRXZlbnRMaXN0ZW5lcignc3VibWl0JywgdGhpcy5zdWJtaXRIYW5kbGVyKTtcblx0ICAgICAgICB0aGlzLmhpZGRlbkNsaWNrZWRFbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuXHQgICAgICAgIHRoaXMuaGlkZGVuQ2xpY2tlZEVsZS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnaGlkZGVuJyk7XG5cdCAgICAgICAgZm9ybS5hcHBlbmRDaGlsZCh0aGlzLmhpZGRlbkNsaWNrZWRFbGUpO1xuXHQgICAgICAgIHRoaXMuc3VibWl0QnV0dG9ucy5mb3JFYWNoKGZ1bmN0aW9uIChidXR0b24pIHtcblx0ICAgICAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgX3RoaXMuYnV0dG9uQ2xpY2tIYW5kbGVyKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICB0aGlzLmNvcmUucmVnaXN0ZXJGaWx0ZXIoJ2VsZW1lbnQtaWdub3JlZCcsIHRoaXMuaWdub3JlVmFsaWRhdGlvbkZpbHRlcik7XG5cdCAgICB9O1xuXHQgICAgU3VibWl0QnV0dG9uLnByb3RvdHlwZS51bmluc3RhbGwgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB2YXIgZm9ybSA9IHRoaXMuY29yZS5nZXRGb3JtRWxlbWVudCgpO1xuXHQgICAgICAgIGlmIChmb3JtIGluc3RhbmNlb2YgSFRNTEZvcm1FbGVtZW50KSB7XG5cdCAgICAgICAgICAgIGZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3VibWl0JywgdGhpcy5zdWJtaXRIYW5kbGVyKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5zdWJtaXRCdXR0b25zLmZvckVhY2goZnVuY3Rpb24gKGJ1dHRvbikge1xuXHQgICAgICAgICAgICBidXR0b24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBfdGhpcy5idXR0b25DbGlja0hhbmRsZXIpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHRoaXMuaGlkZGVuQ2xpY2tlZEVsZS5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuaGlkZGVuQ2xpY2tlZEVsZSk7XG5cdCAgICAgICAgdGhpcy5jb3JlLmRlcmVnaXN0ZXJGaWx0ZXIoJ2VsZW1lbnQtaWdub3JlZCcsIHRoaXMuaWdub3JlVmFsaWRhdGlvbkZpbHRlcik7XG5cdCAgICB9O1xuXHQgICAgU3VibWl0QnV0dG9uLnByb3RvdHlwZS5oYW5kbGVTdWJtaXRFdmVudCA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgdGhpcy52YWxpZGF0ZUZvcm0oZSk7XG5cdCAgICB9O1xuXHQgICAgU3VibWl0QnV0dG9uLnByb3RvdHlwZS5oYW5kbGVDbGlja0V2ZW50ID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICB2YXIgdGFyZ2V0ID0gZS5jdXJyZW50VGFyZ2V0O1xuXHQgICAgICAgIHRoaXMuaXNCdXR0b25DbGlja2VkID0gdHJ1ZTtcblx0ICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5hc3BOZXRCdXR0b24gJiYgdGhpcy5pc0Zvcm1WYWxpZCA9PT0gdHJ1ZSkgO1xuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHZhciBmb3JtID0gdGhpcy5jb3JlLmdldEZvcm1FbGVtZW50KCk7XG5cdCAgICAgICAgICAgICAgICBmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3N1Ym1pdCcsIHRoaXMuc3VibWl0SGFuZGxlcik7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmNsaWNrZWRCdXR0b24gPSBlLnRhcmdldDtcblx0ICAgICAgICAgICAgICAgIHZhciBuYW1lXzEgPSB0aGlzLmNsaWNrZWRCdXR0b24uZ2V0QXR0cmlidXRlKCduYW1lJyk7XG5cdCAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmNsaWNrZWRCdXR0b24uZ2V0QXR0cmlidXRlKCd2YWx1ZScpO1xuXHQgICAgICAgICAgICAgICAgaWYgKG5hbWVfMSAmJiB2YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZGVuQ2xpY2tlZEVsZS5zZXRBdHRyaWJ1dGUoJ25hbWUnLCBuYW1lXzEpO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZGVuQ2xpY2tlZEVsZS5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgdmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUZvcm0oZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgU3VibWl0QnV0dG9uLnByb3RvdHlwZS52YWxpZGF0ZUZvcm0gPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgaWYgKCF0aGlzLmlzRW5hYmxlZCkge1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblx0ICAgICAgICB0aGlzLmNvcmUudmFsaWRhdGUoKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0ICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gJ1ZhbGlkJyAmJiBfdGhpcy5vcHRzLmFzcE5ldEJ1dHRvbiAmJiAhX3RoaXMuaXNGb3JtVmFsaWQgJiYgX3RoaXMuY2xpY2tlZEJ1dHRvbikge1xuXHQgICAgICAgICAgICAgICAgX3RoaXMuaXNGb3JtVmFsaWQgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgX3RoaXMuY2xpY2tlZEJ1dHRvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIF90aGlzLmJ1dHRvbkNsaWNrSGFuZGxlcik7XG5cdCAgICAgICAgICAgICAgICAvLyBJdCdzIHRoZSB0aW1lIGZvciBBU1AuTmV0IHN1Ym1pdCBidXR0b24gdG8gZG8gaXRzIG93biBzdWJtaXNzaW9uXG5cdCAgICAgICAgICAgICAgICBfdGhpcy5jbGlja2VkQnV0dG9uLmNsaWNrKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBTdWJtaXRCdXR0b24ucHJvdG90eXBlLmlnbm9yZVZhbGlkYXRpb24gPSBmdW5jdGlvbiAoX2ZpZWxkLCBfZWxlbWVudCwgX2VsZW1lbnRzKSB7XG5cdCAgICAgICAgaWYgKCF0aGlzLmlzRW5hYmxlZCkge1xuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzLm9wdHMubGl2ZU1vZGUgPyBmYWxzZSA6ICF0aGlzLmlzQnV0dG9uQ2xpY2tlZDtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gU3VibWl0QnV0dG9uO1xuXHR9KGNvcmUuUGx1Z2luKSk7XG5cblx0Y2pzJHAuU3VibWl0QnV0dG9uID0gU3VibWl0QnV0dG9uO1xuXHRyZXR1cm4gY2pzJHA7XG59XG5cbi8qKlxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgIGxpYiRwLmV4cG9ydHMgPSByZXF1aXJlSW5kZXhfbWluJHAoKTtcbn0gZWxzZSB7XG4gICAgbGliJHAuZXhwb3J0cyA9IHJlcXVpcmVDanMkcCgpO1xufVxuXG52YXIgbGliRXhwb3J0cyRwID0gbGliJHAuZXhwb3J0cztcblxudmFyIGxpYiRvID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIGluZGV4X21pbiRvID0ge307XG5cbi8qKiBcbiAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG4gKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKlxuICogQGxpY2Vuc2UgaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pby9saWNlbnNlXG4gKiBAcGFja2FnZSBAZm9ybS12YWxpZGF0aW9uL3BsdWdpbi10b29sdGlwXG4gKiBAdmVyc2lvbiAyLjQuMFxuICovXG5cbnZhciBoYXNSZXF1aXJlZEluZGV4X21pbiRvO1xuXG5mdW5jdGlvbiByZXF1aXJlSW5kZXhfbWluJG8gKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRJbmRleF9taW4kbykgcmV0dXJuIGluZGV4X21pbiRvO1xuXHRoYXNSZXF1aXJlZEluZGV4X21pbiRvID0gMTtcbnZhciB0PWxpYkV4cG9ydHMkQixlPWZ1bmN0aW9uKHQsaSl7cmV0dXJuIGU9T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKHQsZSl7dC5fX3Byb3RvX189ZTt9fHxmdW5jdGlvbih0LGUpe2Zvcih2YXIgaSBpbiBlKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLGkpJiYodFtpXT1lW2ldKTt9LGUodCxpKX07dmFyIGk9dC51dGlscy5jbGFzc1NldCxvPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG8oZSl7dmFyIGk9dC5jYWxsKHRoaXMsZSl8fHRoaXM7cmV0dXJuIGkubWVzc2FnZXM9bmV3IE1hcCxpLm9wdHM9T2JqZWN0LmFzc2lnbih7fSx7cGxhY2VtZW50OlwidG9wXCIsdHJpZ2dlcjpcImNsaWNrXCJ9LGUpLGkuaWNvblBsYWNlZEhhbmRsZXI9aS5vbkljb25QbGFjZWQuYmluZChpKSxpLnZhbGlkYXRvclZhbGlkYXRlZEhhbmRsZXI9aS5vblZhbGlkYXRvclZhbGlkYXRlZC5iaW5kKGkpLGkuZWxlbWVudFZhbGlkYXRlZEhhbmRsZXI9aS5vbkVsZW1lbnRWYWxpZGF0ZWQuYmluZChpKSxpLmRvY3VtZW50Q2xpY2tIYW5kbGVyPWkub25Eb2N1bWVudENsaWNrZWQuYmluZChpKSxpfXJldHVybiBmdW5jdGlvbih0LGkpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGkmJm51bGwhPT1pKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiK1N0cmluZyhpKStcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO2Z1bmN0aW9uIG8oKXt0aGlzLmNvbnN0cnVjdG9yPXQ7fWUodCxpKSx0LnByb3RvdHlwZT1udWxsPT09aT9PYmplY3QuY3JlYXRlKGkpOihvLnByb3RvdHlwZT1pLnByb3RvdHlwZSxuZXcgbyk7fShvLHQpLG8ucHJvdG90eXBlLmluc3RhbGw9ZnVuY3Rpb24oKXt2YXIgdDt0aGlzLnRpcD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLGkodGhpcy50aXAsKCh0PXtcImZ2LXBsdWdpbnMtdG9vbHRpcFwiOiEwfSlbXCJmdi1wbHVnaW5zLXRvb2x0aXAtLVwiLmNvbmNhdCh0aGlzLm9wdHMucGxhY2VtZW50KV09ITAsdCkpLGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy50aXApLHRoaXMuY29yZS5vbihcInBsdWdpbnMuaWNvbi5wbGFjZWRcIix0aGlzLmljb25QbGFjZWRIYW5kbGVyKS5vbihcImNvcmUudmFsaWRhdG9yLnZhbGlkYXRlZFwiLHRoaXMudmFsaWRhdG9yVmFsaWRhdGVkSGFuZGxlcikub24oXCJjb3JlLmVsZW1lbnQudmFsaWRhdGVkXCIsdGhpcy5lbGVtZW50VmFsaWRhdGVkSGFuZGxlciksXCJjbGlja1wiPT09dGhpcy5vcHRzLnRyaWdnZXImJmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHRoaXMuZG9jdW1lbnRDbGlja0hhbmRsZXIpO30sby5wcm90b3R5cGUudW5pbnN0YWxsPWZ1bmN0aW9uKCl7dGhpcy5tZXNzYWdlcy5jbGVhcigpLGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy50aXApLHRoaXMuY29yZS5vZmYoXCJwbHVnaW5zLmljb24ucGxhY2VkXCIsdGhpcy5pY29uUGxhY2VkSGFuZGxlcikub2ZmKFwiY29yZS52YWxpZGF0b3IudmFsaWRhdGVkXCIsdGhpcy52YWxpZGF0b3JWYWxpZGF0ZWRIYW5kbGVyKS5vZmYoXCJjb3JlLmVsZW1lbnQudmFsaWRhdGVkXCIsdGhpcy5lbGVtZW50VmFsaWRhdGVkSGFuZGxlciksXCJjbGlja1wiPT09dGhpcy5vcHRzLnRyaWdnZXImJmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHRoaXMuZG9jdW1lbnRDbGlja0hhbmRsZXIpO30sby5wcm90b3R5cGUub25JY29uUGxhY2VkPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7aWYoaSh0Lmljb25FbGVtZW50LHtcImZ2LXBsdWdpbnMtdG9vbHRpcC1pY29uXCI6ITB9KSxcImhvdmVyXCI9PT10aGlzLm9wdHMudHJpZ2dlcil0Lmljb25FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsKGZ1bmN0aW9uKGkpe3JldHVybiBlLnNob3codC5lbGVtZW50LGkpfSkpLHQuaWNvbkVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwoZnVuY3Rpb24odCl7cmV0dXJuIGUuaGlkZSgpfSkpO2Vsc2UgdC5pY29uRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwoZnVuY3Rpb24oaSl7cmV0dXJuIGUuc2hvdyh0LmVsZW1lbnQsaSl9KSk7fSxvLnByb3RvdHlwZS5vblZhbGlkYXRvclZhbGlkYXRlZD1mdW5jdGlvbih0KXtpZighdC5yZXN1bHQudmFsaWQpe3ZhciBlPXQuZWxlbWVudHMsaT10LmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSxvPVwicmFkaW9cIj09PWl8fFwiY2hlY2tib3hcIj09PWk/ZVswXTp0LmVsZW1lbnQsbj1cInN0cmluZ1wiPT10eXBlb2YgdC5yZXN1bHQubWVzc2FnZT90LnJlc3VsdC5tZXNzYWdlOnQucmVzdWx0Lm1lc3NhZ2VbdGhpcy5jb3JlLmdldExvY2FsZSgpXTt0aGlzLm1lc3NhZ2VzLnNldChvLG4pO319LG8ucHJvdG90eXBlLm9uRWxlbWVudFZhbGlkYXRlZD1mdW5jdGlvbih0KXtpZih0LnZhbGlkKXt2YXIgZT10LmVsZW1lbnRzLGk9dC5lbGVtZW50LmdldEF0dHJpYnV0ZShcInR5cGVcIiksbz1cInJhZGlvXCI9PT1pfHxcImNoZWNrYm94XCI9PT1pP2VbMF06dC5lbGVtZW50O3RoaXMubWVzc2FnZXMuZGVsZXRlKG8pO319LG8ucHJvdG90eXBlLm9uRG9jdW1lbnRDbGlja2VkPWZ1bmN0aW9uKHQpe3RoaXMuaGlkZSgpO30sby5wcm90b3R5cGUuc2hvdz1mdW5jdGlvbih0LGUpe2lmKHRoaXMuaXNFbmFibGVkJiYoZS5wcmV2ZW50RGVmYXVsdCgpLGUuc3RvcFByb3BhZ2F0aW9uKCksdGhpcy5tZXNzYWdlcy5oYXModCkpKXtpKHRoaXMudGlwLHtcImZ2LXBsdWdpbnMtdG9vbHRpcC0taGlkZVwiOiExfSksdGhpcy50aXAuaW5uZXJIVE1MPSc8ZGl2IGNsYXNzPVwiZnYtcGx1Z2lucy10b29sdGlwX19jb250ZW50XCI+Jy5jb25jYXQodGhpcy5tZXNzYWdlcy5nZXQodCksXCI8L2Rpdj5cIik7dmFyIG89ZS50YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksbj10aGlzLnRpcC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxsPW4uaGVpZ2h0LGE9bi53aWR0aCxzPTAscj0wO3N3aXRjaCh0aGlzLm9wdHMucGxhY2VtZW50KXtjYXNlXCJib3R0b21cIjpzPW8udG9wK28uaGVpZ2h0LHI9by5sZWZ0K28ud2lkdGgvMi1hLzI7YnJlYWs7Y2FzZVwiYm90dG9tLWxlZnRcIjpzPW8udG9wK28uaGVpZ2h0LHI9by5sZWZ0O2JyZWFrO2Nhc2VcImJvdHRvbS1yaWdodFwiOnM9by50b3Arby5oZWlnaHQscj1vLmxlZnQrby53aWR0aC1hO2JyZWFrO2Nhc2VcImxlZnRcIjpzPW8udG9wK28uaGVpZ2h0LzItbC8yLHI9by5sZWZ0LWE7YnJlYWs7Y2FzZVwicmlnaHRcIjpzPW8udG9wK28uaGVpZ2h0LzItbC8yLHI9by5sZWZ0K28ud2lkdGg7YnJlYWs7Y2FzZVwidG9wLWxlZnRcIjpzPW8udG9wLWwscj1vLmxlZnQ7YnJlYWs7Y2FzZVwidG9wLXJpZ2h0XCI6cz1vLnRvcC1sLHI9by5sZWZ0K28ud2lkdGgtYTticmVhaztkZWZhdWx0OnM9by50b3AtbCxyPW8ubGVmdCtvLndpZHRoLzItYS8yO31zKz13aW5kb3cuc2Nyb2xsWXx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcHx8ZG9jdW1lbnQuYm9keS5zY3JvbGxUb3B8fDAscis9d2luZG93LnNjcm9sbFh8fGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0fHxkb2N1bWVudC5ib2R5LnNjcm9sbExlZnR8fDAsdGhpcy50aXAuc2V0QXR0cmlidXRlKFwic3R5bGVcIixcInRvcDogXCIuY29uY2F0KHMsXCJweDsgbGVmdDogXCIpLmNvbmNhdChyLFwicHhcIikpO319LG8ucHJvdG90eXBlLmhpZGU9ZnVuY3Rpb24oKXt0aGlzLmlzRW5hYmxlZCYmaSh0aGlzLnRpcCx7XCJmdi1wbHVnaW5zLXRvb2x0aXAtLWhpZGVcIjohMH0pO30sb30odC5QbHVnaW4pO2luZGV4X21pbiRvLlRvb2x0aXA9bztcblx0cmV0dXJuIGluZGV4X21pbiRvO1xufVxuXG52YXIgY2pzJG8gPSB7fTtcblxudmFyIGhhc1JlcXVpcmVkQ2pzJG87XG5cbmZ1bmN0aW9uIHJlcXVpcmVDanMkbyAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZENqcyRvKSByZXR1cm4gY2pzJG87XG5cdGhhc1JlcXVpcmVkQ2pzJG8gPSAxO1xuXG5cdHZhciBjb3JlID0gbGliRXhwb3J0cyRCO1xuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuXHRDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblx0UGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcblx0cHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuXHRUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblx0UkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcblx0QU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5cdElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5cdExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcblx0T1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5cdFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcblx0KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHQvKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxuXHR2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuXHQgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG5cdCAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG5cdCAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuXHQgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuXHQgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuXHQgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuXHQgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuXHQgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcblx0ICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuXHR9XG5cblx0LyoqXG5cdCAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuXHQgKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcblx0ICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuXHQgKi9cblx0dmFyIGNsYXNzU2V0ID0gY29yZS51dGlscy5jbGFzc1NldDtcblx0dmFyIFRvb2x0aXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoVG9vbHRpcCwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIFRvb2x0aXAob3B0cykge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdHMpIHx8IHRoaXM7XG5cdCAgICAgICAgLy8gTWFwIHRoZSBlbGVtZW50IHdpdGggbWVzc2FnZVxuXHQgICAgICAgIF90aGlzLm1lc3NhZ2VzID0gbmV3IE1hcCgpO1xuXHQgICAgICAgIF90aGlzLm9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCB7XG5cdCAgICAgICAgICAgIHBsYWNlbWVudDogJ3RvcCcsXG5cdCAgICAgICAgICAgIHRyaWdnZXI6ICdjbGljaycsXG5cdCAgICAgICAgfSwgb3B0cyk7XG5cdCAgICAgICAgX3RoaXMuaWNvblBsYWNlZEhhbmRsZXIgPSBfdGhpcy5vbkljb25QbGFjZWQuYmluZChfdGhpcyk7XG5cdCAgICAgICAgX3RoaXMudmFsaWRhdG9yVmFsaWRhdGVkSGFuZGxlciA9IF90aGlzLm9uVmFsaWRhdG9yVmFsaWRhdGVkLmJpbmQoX3RoaXMpO1xuXHQgICAgICAgIF90aGlzLmVsZW1lbnRWYWxpZGF0ZWRIYW5kbGVyID0gX3RoaXMub25FbGVtZW50VmFsaWRhdGVkLmJpbmQoX3RoaXMpO1xuXHQgICAgICAgIF90aGlzLmRvY3VtZW50Q2xpY2tIYW5kbGVyID0gX3RoaXMub25Eb2N1bWVudENsaWNrZWQuYmluZChfdGhpcyk7XG5cdCAgICAgICAgcmV0dXJuIF90aGlzO1xuXHQgICAgfVxuXHQgICAgVG9vbHRpcC5wcm90b3R5cGUuaW5zdGFsbCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgX2E7XG5cdCAgICAgICAgdGhpcy50aXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0ICAgICAgICBjbGFzc1NldCh0aGlzLnRpcCwgKF9hID0ge1xuXHQgICAgICAgICAgICAgICAgJ2Z2LXBsdWdpbnMtdG9vbHRpcCc6IHRydWVcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgX2FbXCJmdi1wbHVnaW5zLXRvb2x0aXAtLVwiLmNvbmNhdCh0aGlzLm9wdHMucGxhY2VtZW50KV0gPSB0cnVlLFxuXHQgICAgICAgICAgICBfYSkpO1xuXHQgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy50aXApO1xuXHQgICAgICAgIHRoaXMuY29yZVxuXHQgICAgICAgICAgICAub24oJ3BsdWdpbnMuaWNvbi5wbGFjZWQnLCB0aGlzLmljb25QbGFjZWRIYW5kbGVyKVxuXHQgICAgICAgICAgICAub24oJ2NvcmUudmFsaWRhdG9yLnZhbGlkYXRlZCcsIHRoaXMudmFsaWRhdG9yVmFsaWRhdGVkSGFuZGxlcilcblx0ICAgICAgICAgICAgLm9uKCdjb3JlLmVsZW1lbnQudmFsaWRhdGVkJywgdGhpcy5lbGVtZW50VmFsaWRhdGVkSGFuZGxlcik7XG5cdCAgICAgICAgaWYgKCdjbGljaycgPT09IHRoaXMub3B0cy50cmlnZ2VyKSB7XG5cdCAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5kb2N1bWVudENsaWNrSGFuZGxlcik7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIFRvb2x0aXAucHJvdG90eXBlLnVuaW5zdGFsbCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLm1lc3NhZ2VzLmNsZWFyKCk7XG5cdCAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLnRpcCk7XG5cdCAgICAgICAgdGhpcy5jb3JlXG5cdCAgICAgICAgICAgIC5vZmYoJ3BsdWdpbnMuaWNvbi5wbGFjZWQnLCB0aGlzLmljb25QbGFjZWRIYW5kbGVyKVxuXHQgICAgICAgICAgICAub2ZmKCdjb3JlLnZhbGlkYXRvci52YWxpZGF0ZWQnLCB0aGlzLnZhbGlkYXRvclZhbGlkYXRlZEhhbmRsZXIpXG5cdCAgICAgICAgICAgIC5vZmYoJ2NvcmUuZWxlbWVudC52YWxpZGF0ZWQnLCB0aGlzLmVsZW1lbnRWYWxpZGF0ZWRIYW5kbGVyKTtcblx0ICAgICAgICBpZiAoJ2NsaWNrJyA9PT0gdGhpcy5vcHRzLnRyaWdnZXIpIHtcblx0ICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmRvY3VtZW50Q2xpY2tIYW5kbGVyKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgVG9vbHRpcC5wcm90b3R5cGUub25JY29uUGxhY2VkID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGNsYXNzU2V0KGUuaWNvbkVsZW1lbnQsIHtcblx0ICAgICAgICAgICAgJ2Z2LXBsdWdpbnMtdG9vbHRpcC1pY29uJzogdHJ1ZSxcblx0ICAgICAgICB9KTtcblx0ICAgICAgICBzd2l0Y2ggKHRoaXMub3B0cy50cmlnZ2VyKSB7XG5cdCAgICAgICAgICAgIGNhc2UgJ2hvdmVyJzpcblx0ICAgICAgICAgICAgICAgIGUuaWNvbkVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIGZ1bmN0aW9uIChldnQpIHsgcmV0dXJuIF90aGlzLnNob3coZS5lbGVtZW50LCBldnQpOyB9KTtcblx0ICAgICAgICAgICAgICAgIGUuaWNvbkVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIGZ1bmN0aW9uIChfZXZ0KSB7IHJldHVybiBfdGhpcy5oaWRlKCk7IH0pO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgJ2NsaWNrJzpcblx0ICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgIGUuaWNvbkVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZXZ0KSB7IHJldHVybiBfdGhpcy5zaG93KGUuZWxlbWVudCwgZXZ0KTsgfSk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgVG9vbHRpcC5wcm90b3R5cGUub25WYWxpZGF0b3JWYWxpZGF0ZWQgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIGlmICghZS5yZXN1bHQudmFsaWQpIHtcblx0ICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gZS5lbGVtZW50cztcblx0ICAgICAgICAgICAgdmFyIHR5cGUgPSBlLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG5cdCAgICAgICAgICAgIHZhciBlbGUgPSAncmFkaW8nID09PSB0eXBlIHx8ICdjaGVja2JveCcgPT09IHR5cGUgPyBlbGVtZW50c1swXSA6IGUuZWxlbWVudDtcblx0ICAgICAgICAgICAgLy8gR2V0IHRoZSBtZXNzYWdlXG5cdCAgICAgICAgICAgIHZhciBtZXNzYWdlID0gdHlwZW9mIGUucmVzdWx0Lm1lc3NhZ2UgPT09ICdzdHJpbmcnID8gZS5yZXN1bHQubWVzc2FnZSA6IGUucmVzdWx0Lm1lc3NhZ2VbdGhpcy5jb3JlLmdldExvY2FsZSgpXTtcblx0ICAgICAgICAgICAgdGhpcy5tZXNzYWdlcy5zZXQoZWxlLCBtZXNzYWdlKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgVG9vbHRpcC5wcm90b3R5cGUub25FbGVtZW50VmFsaWRhdGVkID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICBpZiAoZS52YWxpZCkge1xuXHQgICAgICAgICAgICAvLyBDbGVhciB0aGUgbWVzc2FnZVxuXHQgICAgICAgICAgICB2YXIgZWxlbWVudHMgPSBlLmVsZW1lbnRzO1xuXHQgICAgICAgICAgICB2YXIgdHlwZSA9IGUuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcblx0ICAgICAgICAgICAgdmFyIGVsZSA9ICdyYWRpbycgPT09IHR5cGUgfHwgJ2NoZWNrYm94JyA9PT0gdHlwZSA/IGVsZW1lbnRzWzBdIDogZS5lbGVtZW50O1xuXHQgICAgICAgICAgICB0aGlzLm1lc3NhZ2VzLmRlbGV0ZShlbGUpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICBUb29sdGlwLnByb3RvdHlwZS5vbkRvY3VtZW50Q2xpY2tlZCA9IGZ1bmN0aW9uIChfZSkge1xuXHQgICAgICAgIHRoaXMuaGlkZSgpO1xuXHQgICAgfTtcblx0ICAgIFRvb2x0aXAucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoZWxlLCBlKSB7XG5cdCAgICAgICAgaWYgKCF0aGlzLmlzRW5hYmxlZCkge1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblx0ICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHQgICAgICAgIGlmICghdGhpcy5tZXNzYWdlcy5oYXMoZWxlKSkge1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNsYXNzU2V0KHRoaXMudGlwLCB7XG5cdCAgICAgICAgICAgICdmdi1wbHVnaW5zLXRvb2x0aXAtLWhpZGUnOiBmYWxzZSxcblx0ICAgICAgICB9KTtcblx0ICAgICAgICB0aGlzLnRpcC5pbm5lckhUTUwgPSBcIjxkaXYgY2xhc3M9XFxcImZ2LXBsdWdpbnMtdG9vbHRpcF9fY29udGVudFxcXCI+XCIuY29uY2F0KHRoaXMubWVzc2FnZXMuZ2V0KGVsZSksIFwiPC9kaXY+XCIpO1xuXHQgICAgICAgIC8vIENhbGN1bGF0ZSBwb3NpdGlvbiBvZiB0aGUgaWNvbiBlbGVtZW50XG5cdCAgICAgICAgdmFyIGljb24gPSBlLnRhcmdldDtcblx0ICAgICAgICB2YXIgdGFyZ2V0UmVjdCA9IGljb24uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdCAgICAgICAgdmFyIF9hID0gdGhpcy50aXAuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGhlaWdodCA9IF9hLmhlaWdodCwgd2lkdGggPSBfYS53aWR0aDtcblx0ICAgICAgICB2YXIgdG9wID0gMDtcblx0ICAgICAgICB2YXIgbGVmdCA9IDA7XG5cdCAgICAgICAgc3dpdGNoICh0aGlzLm9wdHMucGxhY2VtZW50KSB7XG5cdCAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG5cdCAgICAgICAgICAgICAgICB0b3AgPSB0YXJnZXRSZWN0LnRvcCArIHRhcmdldFJlY3QuaGVpZ2h0O1xuXHQgICAgICAgICAgICAgICAgbGVmdCA9IHRhcmdldFJlY3QubGVmdCArIHRhcmdldFJlY3Qud2lkdGggLyAyIC0gd2lkdGggLyAyO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgJ2JvdHRvbS1sZWZ0Jzpcblx0ICAgICAgICAgICAgICAgIHRvcCA9IHRhcmdldFJlY3QudG9wICsgdGFyZ2V0UmVjdC5oZWlnaHQ7XG5cdCAgICAgICAgICAgICAgICBsZWZ0ID0gdGFyZ2V0UmVjdC5sZWZ0O1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgJ2JvdHRvbS1yaWdodCc6XG5cdCAgICAgICAgICAgICAgICB0b3AgPSB0YXJnZXRSZWN0LnRvcCArIHRhcmdldFJlY3QuaGVpZ2h0O1xuXHQgICAgICAgICAgICAgICAgbGVmdCA9IHRhcmdldFJlY3QubGVmdCArIHRhcmdldFJlY3Qud2lkdGggLSB3aWR0aDtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlICdsZWZ0Jzpcblx0ICAgICAgICAgICAgICAgIHRvcCA9IHRhcmdldFJlY3QudG9wICsgdGFyZ2V0UmVjdC5oZWlnaHQgLyAyIC0gaGVpZ2h0IC8gMjtcblx0ICAgICAgICAgICAgICAgIGxlZnQgPSB0YXJnZXRSZWN0LmxlZnQgLSB3aWR0aDtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlICdyaWdodCc6XG5cdCAgICAgICAgICAgICAgICB0b3AgPSB0YXJnZXRSZWN0LnRvcCArIHRhcmdldFJlY3QuaGVpZ2h0IC8gMiAtIGhlaWdodCAvIDI7XG5cdCAgICAgICAgICAgICAgICBsZWZ0ID0gdGFyZ2V0UmVjdC5sZWZ0ICsgdGFyZ2V0UmVjdC53aWR0aDtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlICd0b3AtbGVmdCc6XG5cdCAgICAgICAgICAgICAgICB0b3AgPSB0YXJnZXRSZWN0LnRvcCAtIGhlaWdodDtcblx0ICAgICAgICAgICAgICAgIGxlZnQgPSB0YXJnZXRSZWN0LmxlZnQ7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSAndG9wLXJpZ2h0Jzpcblx0ICAgICAgICAgICAgICAgIHRvcCA9IHRhcmdldFJlY3QudG9wIC0gaGVpZ2h0O1xuXHQgICAgICAgICAgICAgICAgbGVmdCA9IHRhcmdldFJlY3QubGVmdCArIHRhcmdldFJlY3Qud2lkdGggLSB3aWR0aDtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlICd0b3AnOlxuXHQgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgdG9wID0gdGFyZ2V0UmVjdC50b3AgLSBoZWlnaHQ7XG5cdCAgICAgICAgICAgICAgICBsZWZ0ID0gdGFyZ2V0UmVjdC5sZWZ0ICsgdGFyZ2V0UmVjdC53aWR0aCAvIDIgLSB3aWR0aCAvIDI7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHNjcm9sbFRvcCA9IHdpbmRvdy5zY3JvbGxZIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgfHwgMDtcblx0ICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IHdpbmRvdy5zY3JvbGxYIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCB8fCAwO1xuXHQgICAgICAgIHRvcCA9IHRvcCArIHNjcm9sbFRvcDtcblx0ICAgICAgICBsZWZ0ID0gbGVmdCArIHNjcm9sbExlZnQ7XG5cdCAgICAgICAgdGhpcy50aXAuc2V0QXR0cmlidXRlKCdzdHlsZScsIFwidG9wOiBcIi5jb25jYXQodG9wLCBcInB4OyBsZWZ0OiBcIikuY29uY2F0KGxlZnQsIFwicHhcIikpO1xuXHQgICAgfTtcblx0ICAgIFRvb2x0aXAucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuaXNFbmFibGVkKSB7XG5cdCAgICAgICAgICAgIGNsYXNzU2V0KHRoaXMudGlwLCB7XG5cdCAgICAgICAgICAgICAgICAnZnYtcGx1Z2lucy10b29sdGlwLS1oaWRlJzogdHJ1ZSxcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb29sdGlwO1xuXHR9KGNvcmUuUGx1Z2luKSk7XG5cblx0Y2pzJG8uVG9vbHRpcCA9IFRvb2x0aXA7XG5cdHJldHVybiBjanMkbztcbn1cblxuLyoqXG4gKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcbiAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgbGliJG8uZXhwb3J0cyA9IHJlcXVpcmVJbmRleF9taW4kbygpO1xufSBlbHNlIHtcbiAgICBsaWIkby5leHBvcnRzID0gcmVxdWlyZUNqcyRvKCk7XG59XG5cbnZhciBsaWJFeHBvcnRzJG8gPSBsaWIkby5leHBvcnRzO1xuXG52YXIgbGliJG4gPSB7ZXhwb3J0czoge319O1xuXG52YXIgaW5kZXhfbWluJG4gPSB7fTtcblxuLyoqIFxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqXG4gKiBAbGljZW5zZSBodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvL2xpY2Vuc2VcbiAqIEBwYWNrYWdlIEBmb3JtLXZhbGlkYXRpb24vcGx1Z2luLXRyaWdnZXJcbiAqIEB2ZXJzaW9uIDIuNC4wXG4gKi9cblxudmFyIGhhc1JlcXVpcmVkSW5kZXhfbWluJG47XG5cbmZ1bmN0aW9uIHJlcXVpcmVJbmRleF9taW4kbiAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEluZGV4X21pbiRuKSByZXR1cm4gaW5kZXhfbWluJG47XG5cdGhhc1JlcXVpcmVkSW5kZXhfbWluJG4gPSAxO1xudmFyIGU9bGliRXhwb3J0cyRCLHQ9ZnVuY3Rpb24oZSxuKXtyZXR1cm4gdD1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24oZSx0KXtlLl9fcHJvdG9fXz10O318fGZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuIGluIHQpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbikmJihlW25dPXRbbl0pO30sdChlLG4pfTt2YXIgbj1mdW5jdGlvbihlKXtmdW5jdGlvbiBuKHQpe3ZhciBuPWUuY2FsbCh0aGlzLHQpfHx0aGlzO24uaGFuZGxlcnM9W10sbi50aW1lcnM9bmV3IE1hcDt2YXIgcj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO3JldHVybiBuLmRlZmF1bHRFdmVudD1cIm9uaW5wdXRcImluIHI/XCJpbnB1dFwiOlwia2V5dXBcIixuLm9wdHM9T2JqZWN0LmFzc2lnbih7fSx7ZGVsYXk6MCxldmVudDpuLmRlZmF1bHRFdmVudCx0aHJlc2hvbGQ6MH0sdCksbi5maWVsZEFkZGVkSGFuZGxlcj1uLm9uRmllbGRBZGRlZC5iaW5kKG4pLG4uZmllbGRSZW1vdmVkSGFuZGxlcj1uLm9uRmllbGRSZW1vdmVkLmJpbmQobiksbn1yZXR1cm4gZnVuY3Rpb24oZSxuKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBuJiZudWxsIT09bil0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIitTdHJpbmcobikrXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtmdW5jdGlvbiByKCl7dGhpcy5jb25zdHJ1Y3Rvcj1lO310KGUsbiksZS5wcm90b3R5cGU9bnVsbD09PW4/T2JqZWN0LmNyZWF0ZShuKTooci5wcm90b3R5cGU9bi5wcm90b3R5cGUsbmV3IHIpO30obixlKSxuLnByb3RvdHlwZS5pbnN0YWxsPWZ1bmN0aW9uKCl7dGhpcy5jb3JlLm9uKFwiY29yZS5maWVsZC5hZGRlZFwiLHRoaXMuZmllbGRBZGRlZEhhbmRsZXIpLm9uKFwiY29yZS5maWVsZC5yZW1vdmVkXCIsdGhpcy5maWVsZFJlbW92ZWRIYW5kbGVyKTt9LG4ucHJvdG90eXBlLnVuaW5zdGFsbD1mdW5jdGlvbigpe3RoaXMuaGFuZGxlcnMuZm9yRWFjaCgoZnVuY3Rpb24oZSl7cmV0dXJuIGUuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGUuZXZlbnQsZS5oYW5kbGVyKX0pKSx0aGlzLmhhbmRsZXJzPVtdLHRoaXMudGltZXJzLmZvckVhY2goKGZ1bmN0aW9uKGUpe3JldHVybiB3aW5kb3cuY2xlYXJUaW1lb3V0KGUpfSkpLHRoaXMudGltZXJzLmNsZWFyKCksdGhpcy5jb3JlLm9mZihcImNvcmUuZmllbGQuYWRkZWRcIix0aGlzLmZpZWxkQWRkZWRIYW5kbGVyKS5vZmYoXCJjb3JlLmZpZWxkLnJlbW92ZWRcIix0aGlzLmZpZWxkUmVtb3ZlZEhhbmRsZXIpO30sbi5wcm90b3R5cGUucHJlcGFyZUhhbmRsZXI9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3QuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIHI9W107aWYobi5vcHRzLmV2ZW50JiYhMT09PW4ub3B0cy5ldmVudFtlXSlyPVtdO2Vsc2UgaWYobi5vcHRzLmV2ZW50JiZuLm9wdHMuZXZlbnRbZV0mJlwiZnVuY3Rpb25cIiE9dHlwZW9mIG4ub3B0cy5ldmVudFtlXSlyPW4ub3B0cy5ldmVudFtlXS5zcGxpdChcIiBcIik7ZWxzZSBpZihcInN0cmluZ1wiPT10eXBlb2Ygbi5vcHRzLmV2ZW50JiZuLm9wdHMuZXZlbnQhPT1uLmRlZmF1bHRFdmVudClyPW4ub3B0cy5ldmVudC5zcGxpdChcIiBcIik7ZWxzZSB7dmFyIG89dC5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpLGk9dC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7cj1bXCJyYWRpb1wiPT09b3x8XCJjaGVja2JveFwiPT09b3x8XCJmaWxlXCI9PT1vfHxcInNlbGVjdFwiPT09aT9cImNoYW5nZVwiOm4uaWVWZXJzaW9uPj0xMCYmdC5nZXRBdHRyaWJ1dGUoXCJwbGFjZWhvbGRlclwiKT9cImtleXVwXCI6bi5kZWZhdWx0RXZlbnRdO31yLmZvckVhY2goKGZ1bmN0aW9uKHIpe3ZhciBvPWZ1bmN0aW9uKHIpe3JldHVybiBuLmhhbmRsZUV2ZW50KHIsZSx0KX07bi5oYW5kbGVycy5wdXNoKHtlbGVtZW50OnQsZXZlbnQ6cixmaWVsZDplLGhhbmRsZXI6b30pLHQuYWRkRXZlbnRMaXN0ZW5lcihyLG8pO30pKTt9KSk7fSxuLnByb3RvdHlwZS5oYW5kbGVFdmVudD1mdW5jdGlvbihlLHQsbil7dmFyIHI9dGhpcztpZih0aGlzLmlzRW5hYmxlZCYmdGhpcy5leGNlZWRUaHJlc2hvbGQodCxuKSYmdGhpcy5jb3JlLmV4ZWN1dGVGaWx0ZXIoXCJwbHVnaW5zLXRyaWdnZXItc2hvdWxkLXZhbGlkYXRlXCIsITAsW3Qsbl0pKXt2YXIgbz1mdW5jdGlvbigpe3JldHVybiByLmNvcmUudmFsaWRhdGVFbGVtZW50KHQsbikudGhlbigoZnVuY3Rpb24obyl7ci5jb3JlLmVtaXQoXCJwbHVnaW5zLnRyaWdnZXIuZXhlY3V0ZWRcIix7ZWxlbWVudDpuLGV2ZW50OmUsZmllbGQ6dH0pO30pKX0saT10aGlzLm9wdHMuZGVsYXlbdF18fHRoaXMub3B0cy5kZWxheTtpZigwPT09aSlvKCk7ZWxzZSB7dmFyIGw9dGhpcy50aW1lcnMuZ2V0KG4pO2wmJndpbmRvdy5jbGVhclRpbWVvdXQobCksdGhpcy50aW1lcnMuc2V0KG4sd2luZG93LnNldFRpbWVvdXQobywxZTMqaSkpO319fSxuLnByb3RvdHlwZS5vbkZpZWxkQWRkZWQ9ZnVuY3Rpb24oZSl7dGhpcy5oYW5kbGVycy5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmZpZWxkPT09ZS5maWVsZH0pKS5mb3JFYWNoKChmdW5jdGlvbihlKXtyZXR1cm4gZS5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZS5ldmVudCxlLmhhbmRsZXIpfSkpLHRoaXMucHJlcGFyZUhhbmRsZXIoZS5maWVsZCxlLmVsZW1lbnRzKTt9LG4ucHJvdG90eXBlLm9uRmllbGRSZW1vdmVkPWZ1bmN0aW9uKGUpe3RoaXMuaGFuZGxlcnMuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gdC5maWVsZD09PWUuZmllbGQmJmUuZWxlbWVudHMuaW5kZXhPZih0LmVsZW1lbnQpPj0wfSkpLmZvckVhY2goKGZ1bmN0aW9uKGUpe3JldHVybiBlLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLmV2ZW50LGUuaGFuZGxlcil9KSk7fSxuLnByb3RvdHlwZS5leGNlZWRUaHJlc2hvbGQ9ZnVuY3Rpb24oZSx0KXt2YXIgbj0wIT09dGhpcy5vcHRzLnRocmVzaG9sZFtlXSYmMCE9PXRoaXMub3B0cy50aHJlc2hvbGQmJih0aGlzLm9wdHMudGhyZXNob2xkW2VdfHx0aGlzLm9wdHMudGhyZXNob2xkKTtpZighbilyZXR1cm4gITA7dmFyIHI9dC5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpO3JldHVybiAtMSE9PVtcImJ1dHRvblwiLFwiY2hlY2tib3hcIixcImZpbGVcIixcImhpZGRlblwiLFwiaW1hZ2VcIixcInJhZGlvXCIsXCJyZXNldFwiLFwic3VibWl0XCJdLmluZGV4T2Yocil8fHRoaXMuY29yZS5nZXRFbGVtZW50VmFsdWUoZSx0KS5sZW5ndGg+PW59LG59KGUuUGx1Z2luKTtpbmRleF9taW4kbi5UcmlnZ2VyPW47XG5cdHJldHVybiBpbmRleF9taW4kbjtcbn1cblxudmFyIGNqcyRuID0ge307XG5cbnZhciBoYXNSZXF1aXJlZENqcyRuO1xuXG5mdW5jdGlvbiByZXF1aXJlQ2pzJG4gKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRDanMkbikgcmV0dXJuIGNqcyRuO1xuXHRoYXNSZXF1aXJlZENqcyRuID0gMTtcblxuXHR2YXIgY29yZSA9IGxpYkV4cG9ydHMkQjtcblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblx0Q29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5cdFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5cdHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblx0VEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5cdFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5cdEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuXHRJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuXHRMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5cdE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuXHRQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG5cdCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblx0LyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcblx0dmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcblx0ICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuXHQgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuXHQgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcblx0ICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcblx0ICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcblx0ICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcblx0ICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcblx0ICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG5cdCAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcblx0fVxuXG5cdC8qKlxuXHQgKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcblx0ICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG5cdCAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cblx0ICovXG5cdC8qKlxuXHQgKiBJbmRpY2F0ZSB0aGUgZXZlbnRzIHdoaWNoIHRoZSB2YWxpZGF0aW9uIHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGVzZSBldmVudHMgYXJlIHRyaWdnZXJlZFxuXHQgKlxuXHQgKiBgYGBcblx0ICogIGNvbnN0IGZ2ID0gZm9ybVZhbGlkYXRpb24oZm9ybSwge1xuXHQgKiAgICAgIGZpZWxkczoge1xuXHQgKiAgICAgICAgICBmdWxsTmFtZToge30sXG5cdCAqICAgICAgICAgIGVtYWlsOiB7fSxcblx0ICogICAgICB9LFxuXHQgKiAgfSk7XG5cdCAqXG5cdCAqICAvLyBWYWxpZGF0ZSBmaWVsZHMgd2hlbiB0aGUgYGJsdXJgIGV2ZW50cyBhcmUgdHJpZ2dlcmVkXG5cdCAqICBmdi5yZWdpc3RlclBsdWdpbihUcmlnZ2VyLCB7XG5cdCAqICAgICAgZXZlbnQ6ICdibHVyJyxcblx0ICogIH0pO1xuXHQgKlxuXHQgKiAgLy8gV2UgY2FuIGluZGljYXRlIGRpZmZlcmVudCBldmVudHMgZm9yIGVhY2ggcGFydGljdWxhciBmaWVsZFxuXHQgKiAgZnYucmVnaXN0ZXJQbHVnaW4oVHJpZ2dlciwge1xuXHQgKiAgICAgIGV2ZW50OiB7XG5cdCAqICAgICAgICAgIGZ1bGxOYW1lOiAnYmx1cicsXG5cdCAqICAgICAgICAgIGVtYWlsOiAnY2hhbmdlJyxcblx0ICogICAgICB9LFxuXHQgKiAgfSk7XG5cdCAqXG5cdCAqICAvLyBJZiB3ZSBkb24ndCB3YW50IHRoZSBmaWVsZCB0byBiZSB2YWxpZGF0ZWQgYXV0b21hdGljYWxseSwgc2V0IHRoZSBhc3NvY2lhdGUgdmFsdWUgdG8gYGZhbHNlYFxuXHQgKiAgZnYucmVnaXN0ZXJQbHVnaW4oVHJpZ2dlciwge1xuXHQgKiAgICAgIGV2ZW50OiB7XG5cdCAqICAgICAgICAgIGVtYWlsOiBmYWxzZSwgICAgLy8gVGhlIGZpZWxkIGlzIG9ubHkgdmFsaWRhdGVkIHdoZW4gd2UgY2xpY2sgdGhlIHN1Ym1pdCBidXR0b24gb2YgZm9ybVxuXHQgKiAgICAgIH0sXG5cdCAqICB9KTtcblx0ICogYGBgXG5cdCAqL1xuXHR2YXIgVHJpZ2dlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhUcmlnZ2VyLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gVHJpZ2dlcihvcHRzKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0cykgfHwgdGhpcztcblx0ICAgICAgICBfdGhpcy5oYW5kbGVycyA9IFtdO1xuXHQgICAgICAgIF90aGlzLnRpbWVycyA9IG5ldyBNYXAoKTtcblx0ICAgICAgICB2YXIgZWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdCAgICAgICAgX3RoaXMuZGVmYXVsdEV2ZW50ID0gISgnb25pbnB1dCcgaW4gZWxlKSA/ICdrZXl1cCcgOiAnaW5wdXQnO1xuXHQgICAgICAgIF90aGlzLm9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCB7XG5cdCAgICAgICAgICAgIGRlbGF5OiAwLFxuXHQgICAgICAgICAgICBldmVudDogX3RoaXMuZGVmYXVsdEV2ZW50LFxuXHQgICAgICAgICAgICB0aHJlc2hvbGQ6IDAsXG5cdCAgICAgICAgfSwgb3B0cyk7XG5cdCAgICAgICAgX3RoaXMuZmllbGRBZGRlZEhhbmRsZXIgPSBfdGhpcy5vbkZpZWxkQWRkZWQuYmluZChfdGhpcyk7XG5cdCAgICAgICAgX3RoaXMuZmllbGRSZW1vdmVkSGFuZGxlciA9IF90aGlzLm9uRmllbGRSZW1vdmVkLmJpbmQoX3RoaXMpO1xuXHQgICAgICAgIHJldHVybiBfdGhpcztcblx0ICAgIH1cblx0ICAgIFRyaWdnZXIucHJvdG90eXBlLmluc3RhbGwgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5jb3JlLm9uKCdjb3JlLmZpZWxkLmFkZGVkJywgdGhpcy5maWVsZEFkZGVkSGFuZGxlcikub24oJ2NvcmUuZmllbGQucmVtb3ZlZCcsIHRoaXMuZmllbGRSZW1vdmVkSGFuZGxlcik7XG5cdCAgICB9O1xuXHQgICAgVHJpZ2dlci5wcm90b3R5cGUudW5pbnN0YWxsID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoaXRlbS5ldmVudCwgaXRlbS5oYW5kbGVyKTsgfSk7XG5cdCAgICAgICAgdGhpcy5oYW5kbGVycyA9IFtdO1xuXHQgICAgICAgIHRoaXMudGltZXJzLmZvckVhY2goZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHdpbmRvdy5jbGVhclRpbWVvdXQodCk7IH0pO1xuXHQgICAgICAgIHRoaXMudGltZXJzLmNsZWFyKCk7XG5cdCAgICAgICAgdGhpcy5jb3JlLm9mZignY29yZS5maWVsZC5hZGRlZCcsIHRoaXMuZmllbGRBZGRlZEhhbmRsZXIpLm9mZignY29yZS5maWVsZC5yZW1vdmVkJywgdGhpcy5maWVsZFJlbW92ZWRIYW5kbGVyKTtcblx0ICAgIH07XG5cdCAgICBUcmlnZ2VyLnByb3RvdHlwZS5wcmVwYXJlSGFuZGxlciA9IGZ1bmN0aW9uIChmaWVsZCwgZWxlbWVudHMpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuXHQgICAgICAgICAgICB2YXIgZXZlbnRzID0gW107XG5cdCAgICAgICAgICAgIGlmICghIV90aGlzLm9wdHMuZXZlbnQgJiYgX3RoaXMub3B0cy5ldmVudFtmaWVsZF0gPT09IGZhbHNlKSB7XG5cdCAgICAgICAgICAgICAgICBldmVudHMgPSBbXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmICghIV90aGlzLm9wdHMuZXZlbnQgJiYgISFfdGhpcy5vcHRzLmV2ZW50W2ZpZWxkXSAmJiB0eXBlb2YgX3RoaXMub3B0cy5ldmVudFtmaWVsZF0gIT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFRvIGZpeCB0aGUgY2FzZSB3aGVyZSBgZmllbGRgIGlzIGEgc3BlY2lhbCBwcm9wZXJ0eSBvZiBTdHJpbmdcblx0ICAgICAgICAgICAgICAgIC8vIEZvciBleGFtcGxlLCBgbGlua2AgaXMgdGhlIHNwZWNpYWwgZnVuY3Rpb24gb2YgYFN0cmluZy5wcm90b3R5cGVgXG5cdCAgICAgICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIGB0aGlzLm9wdHMuZXZlbnRbZmllbGRdYCBpcyBhIGZ1bmN0aW9uLCBub3QgYSBzdHJpbmdcblx0ICAgICAgICAgICAgICAgIGV2ZW50cyA9IF90aGlzLm9wdHMuZXZlbnRbZmllbGRdLnNwbGl0KCcgJyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBfdGhpcy5vcHRzLmV2ZW50ICYmIF90aGlzLm9wdHMuZXZlbnQgIT09IF90aGlzLmRlZmF1bHRFdmVudCkge1xuXHQgICAgICAgICAgICAgICAgZXZlbnRzID0gX3RoaXMub3B0cy5ldmVudC5zcGxpdCgnICcpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBlbGUuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG5cdCAgICAgICAgICAgICAgICB2YXIgdGFnTmFtZSA9IGVsZS50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdCAgICAgICAgICAgICAgICAvLyBJRTEwLzExIGZpcmVzIHRoZSBgaW5wdXRgIGV2ZW50IHdoZW4gZm9jdXMgb24gdGhlIGZpZWxkIGhhdmluZyBhIHBsYWNlaG9sZGVyXG5cdCAgICAgICAgICAgICAgICB2YXIgZXZlbnRfMSA9ICdyYWRpbycgPT09IHR5cGUgfHwgJ2NoZWNrYm94JyA9PT0gdHlwZSB8fCAnZmlsZScgPT09IHR5cGUgfHwgJ3NlbGVjdCcgPT09IHRhZ05hbWVcblx0ICAgICAgICAgICAgICAgICAgICA/ICdjaGFuZ2UnXG5cdCAgICAgICAgICAgICAgICAgICAgOiBfdGhpcy5pZVZlcnNpb24gPj0gMTAgJiYgZWxlLmdldEF0dHJpYnV0ZSgncGxhY2Vob2xkZXInKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICA/ICdrZXl1cCdcblx0ICAgICAgICAgICAgICAgICAgICAgICAgOiBfdGhpcy5kZWZhdWx0RXZlbnQ7XG5cdCAgICAgICAgICAgICAgICBldmVudHMgPSBbZXZlbnRfMV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2dCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGV2dEhhbmRsZXIgPSBmdW5jdGlvbiAoZSkgeyByZXR1cm4gX3RoaXMuaGFuZGxlRXZlbnQoZSwgZmllbGQsIGVsZSk7IH07XG5cdCAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVycy5wdXNoKHtcblx0ICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBlbGUsXG5cdCAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGV2dCxcblx0ICAgICAgICAgICAgICAgICAgICBmaWVsZDogZmllbGQsXG5cdCAgICAgICAgICAgICAgICAgICAgaGFuZGxlcjogZXZ0SGFuZGxlcixcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgZWxlLmFkZEV2ZW50TGlzdGVuZXIoZXZ0LCBldnRIYW5kbGVyKTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgVHJpZ2dlci5wcm90b3R5cGUuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiAoZSwgZmllbGQsIGVsZSkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgaWYgKHRoaXMuaXNFbmFibGVkICYmXG5cdCAgICAgICAgICAgIHRoaXMuZXhjZWVkVGhyZXNob2xkKGZpZWxkLCBlbGUpICYmXG5cdCAgICAgICAgICAgIHRoaXMuY29yZS5leGVjdXRlRmlsdGVyKCdwbHVnaW5zLXRyaWdnZXItc2hvdWxkLXZhbGlkYXRlJywgdHJ1ZSwgW2ZpZWxkLCBlbGVdKSkge1xuXHQgICAgICAgICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5jb3JlLnZhbGlkYXRlRWxlbWVudChmaWVsZCwgZWxlKS50aGVuKGZ1bmN0aW9uIChfKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29yZS5lbWl0KCdwbHVnaW5zLnRyaWdnZXIuZXhlY3V0ZWQnLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB2YXIgZGVsYXkgPSB0aGlzLm9wdHMuZGVsYXlbZmllbGRdIHx8IHRoaXMub3B0cy5kZWxheTtcblx0ICAgICAgICAgICAgaWYgKGRlbGF5ID09PSAwKSB7XG5cdCAgICAgICAgICAgICAgICBoYW5kbGVyKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgdGltZXIgPSB0aGlzLnRpbWVycy5nZXQoZWxlKTtcblx0ICAgICAgICAgICAgICAgIGlmICh0aW1lcikge1xuXHQgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZXIpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdGhpcy50aW1lcnMuc2V0KGVsZSwgd2luZG93LnNldFRpbWVvdXQoaGFuZGxlciwgZGVsYXkgKiAxMDAwKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgVHJpZ2dlci5wcm90b3R5cGUub25GaWVsZEFkZGVkID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICB0aGlzLmhhbmRsZXJzXG5cdCAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0uZmllbGQgPT09IGUuZmllbGQ7IH0pXG5cdCAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihpdGVtLmV2ZW50LCBpdGVtLmhhbmRsZXIpOyB9KTtcblx0ICAgICAgICB0aGlzLnByZXBhcmVIYW5kbGVyKGUuZmllbGQsIGUuZWxlbWVudHMpO1xuXHQgICAgfTtcblx0ICAgIFRyaWdnZXIucHJvdG90eXBlLm9uRmllbGRSZW1vdmVkID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICB0aGlzLmhhbmRsZXJzXG5cdCAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0uZmllbGQgPT09IGUuZmllbGQgJiYgZS5lbGVtZW50cy5pbmRleE9mKGl0ZW0uZWxlbWVudCkgPj0gMDsgfSlcblx0ICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0uZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGl0ZW0uZXZlbnQsIGl0ZW0uaGFuZGxlcik7IH0pO1xuXHQgICAgfTtcblx0ICAgIFRyaWdnZXIucHJvdG90eXBlLmV4Y2VlZFRocmVzaG9sZCA9IGZ1bmN0aW9uIChmaWVsZCwgZWxlbWVudCkge1xuXHQgICAgICAgIHZhciB0aHJlc2hvbGQgPSB0aGlzLm9wdHMudGhyZXNob2xkW2ZpZWxkXSA9PT0gMCB8fCB0aGlzLm9wdHMudGhyZXNob2xkID09PSAwXG5cdCAgICAgICAgICAgID8gZmFsc2Vcblx0ICAgICAgICAgICAgOiB0aGlzLm9wdHMudGhyZXNob2xkW2ZpZWxkXSB8fCB0aGlzLm9wdHMudGhyZXNob2xkO1xuXHQgICAgICAgIGlmICghdGhyZXNob2xkKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBMaXN0IG9mIGlucHV0IHR5cGUgd2hpY2ggdXNlciBjYW4ndCB0eXBlIGluXG5cdCAgICAgICAgdmFyIHR5cGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgndHlwZScpO1xuXHQgICAgICAgIGlmIChbJ2J1dHRvbicsICdjaGVja2JveCcsICdmaWxlJywgJ2hpZGRlbicsICdpbWFnZScsICdyYWRpbycsICdyZXNldCcsICdzdWJtaXQnXS5pbmRleE9mKHR5cGUpICE9PSAtMSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5jb3JlLmdldEVsZW1lbnRWYWx1ZShmaWVsZCwgZWxlbWVudCk7XG5cdCAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA+PSB0aHJlc2hvbGQ7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRyaWdnZXI7XG5cdH0oY29yZS5QbHVnaW4pKTtcblxuXHRjanMkbi5UcmlnZ2VyID0gVHJpZ2dlcjtcblx0cmV0dXJuIGNqcyRuO1xufVxuXG4vKipcbiAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG4gKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICBsaWIkbi5leHBvcnRzID0gcmVxdWlyZUluZGV4X21pbiRuKCk7XG59IGVsc2Uge1xuICAgIGxpYiRuLmV4cG9ydHMgPSByZXF1aXJlQ2pzJG4oKTtcbn1cblxudmFyIGxpYkV4cG9ydHMkbiA9IGxpYiRuLmV4cG9ydHM7XG5cbnZhciBsaWIkbSA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBpbmRleF9taW4kbSA9IHt9O1xuXG4vKiogXG4gKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcbiAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuICpcbiAqIEBsaWNlbnNlIGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8vbGljZW5zZVxuICogQHBhY2thZ2UgQGZvcm0tdmFsaWRhdGlvbi92YWxpZGF0b3ItYmV0d2VlblxuICogQHZlcnNpb24gMi40LjBcbiAqL1xuXG52YXIgaGFzUmVxdWlyZWRJbmRleF9taW4kbTtcblxuZnVuY3Rpb24gcmVxdWlyZUluZGV4X21pbiRtICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkSW5kZXhfbWluJG0pIHJldHVybiBpbmRleF9taW4kbTtcblx0aGFzUmVxdWlyZWRJbmRleF9taW4kbSA9IDE7XG52YXIgZT1saWJFeHBvcnRzJEIsYT1lLnV0aWxzLmZvcm1hdCxuPWUudXRpbHMucmVtb3ZlVW5kZWZpbmVkO2luZGV4X21pbiRtLmJldHdlZW49ZnVuY3Rpb24oKXt2YXIgZT1mdW5jdGlvbihlKXtyZXR1cm4gcGFyc2VGbG9hdChcIlwiLmNvbmNhdChlKS5yZXBsYWNlKFwiLFwiLFwiLlwiKSl9O3JldHVybiB7dmFsaWRhdGU6ZnVuY3Rpb24odCl7dmFyIHM9dC52YWx1ZTtpZihcIlwiPT09cylyZXR1cm4ge3ZhbGlkOiEwfTt2YXIgcj1PYmplY3QuYXNzaWduKHt9LHtpbmNsdXNpdmU6ITAsbWVzc2FnZTpcIlwifSxuKHQub3B0aW9ucykpLGk9ZShyLm1pbiksbD1lKHIubWF4KTtyZXR1cm4gci5pbmNsdXNpdmU/e21lc3NhZ2U6YSh0LmwxMG4/ci5tZXNzYWdlfHx0LmwxMG4uYmV0d2Vlbi5kZWZhdWx0OnIubWVzc2FnZSxbXCJcIi5jb25jYXQoaSksXCJcIi5jb25jYXQobCldKSx2YWxpZDpwYXJzZUZsb2F0KHMpPj1pJiZwYXJzZUZsb2F0KHMpPD1sfTp7bWVzc2FnZTphKHQubDEwbj9yLm1lc3NhZ2V8fHQubDEwbi5iZXR3ZWVuLm5vdEluY2x1c2l2ZTpyLm1lc3NhZ2UsW1wiXCIuY29uY2F0KGkpLFwiXCIuY29uY2F0KGwpXSksdmFsaWQ6cGFyc2VGbG9hdChzKT5pJiZwYXJzZUZsb2F0KHMpPGx9fX19O1xuXHRyZXR1cm4gaW5kZXhfbWluJG07XG59XG5cbnZhciBjanMkbSA9IHt9O1xuXG52YXIgaGFzUmVxdWlyZWRDanMkbTtcblxuZnVuY3Rpb24gcmVxdWlyZUNqcyRtICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkQ2pzJG0pIHJldHVybiBjanMkbTtcblx0aGFzUmVxdWlyZWRDanMkbSA9IDE7XG5cblx0dmFyIGNvcmUgPSBsaWJFeHBvcnRzJEI7XG5cblx0LyoqXG5cdCAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuXHQgKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcblx0ICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuXHQgKi9cblx0dmFyIGZvcm1hdCA9IGNvcmUudXRpbHMuZm9ybWF0LCByZW1vdmVVbmRlZmluZWQgPSBjb3JlLnV0aWxzLnJlbW92ZVVuZGVmaW5lZDtcblx0ZnVuY3Rpb24gYmV0d2VlbigpIHtcblx0ICAgIHZhciBmb3JtYXRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KFwiXCIuY29uY2F0KHZhbHVlKS5yZXBsYWNlKCcsJywgJy4nKSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKGlucHV0KSB7XG5cdCAgICAgICAgICAgIHZhciB2YWx1ZSA9IGlucHV0LnZhbHVlO1xuXHQgICAgICAgICAgICBpZiAodmFsdWUgPT09ICcnKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSB9O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgeyBpbmNsdXNpdmU6IHRydWUsIG1lc3NhZ2U6ICcnIH0sIHJlbW92ZVVuZGVmaW5lZChpbnB1dC5vcHRpb25zKSk7XG5cdCAgICAgICAgICAgIHZhciBtaW5WYWx1ZSA9IGZvcm1hdFZhbHVlKG9wdHMubWluKTtcblx0ICAgICAgICAgICAgdmFyIG1heFZhbHVlID0gZm9ybWF0VmFsdWUob3B0cy5tYXgpO1xuXHQgICAgICAgICAgICByZXR1cm4gb3B0cy5pbmNsdXNpdmVcblx0ICAgICAgICAgICAgICAgID8ge1xuXHQgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGZvcm1hdChpbnB1dC5sMTBuID8gb3B0cy5tZXNzYWdlIHx8IGlucHV0LmwxMG4uYmV0d2Vlbi5kZWZhdWx0IDogb3B0cy5tZXNzYWdlLCBbXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwiXCIuY29uY2F0KG1pblZhbHVlKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJcIi5jb25jYXQobWF4VmFsdWUpLFxuXHQgICAgICAgICAgICAgICAgICAgIF0pLFxuXHQgICAgICAgICAgICAgICAgICAgIHZhbGlkOiBwYXJzZUZsb2F0KHZhbHVlKSA+PSBtaW5WYWx1ZSAmJiBwYXJzZUZsb2F0KHZhbHVlKSA8PSBtYXhWYWx1ZSxcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIDoge1xuXHQgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGZvcm1hdChpbnB1dC5sMTBuID8gb3B0cy5tZXNzYWdlIHx8IGlucHV0LmwxMG4uYmV0d2Vlbi5ub3RJbmNsdXNpdmUgOiBvcHRzLm1lc3NhZ2UsIFtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJcIi5jb25jYXQobWluVmFsdWUpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcIlwiLmNvbmNhdChtYXhWYWx1ZSksXG5cdCAgICAgICAgICAgICAgICAgICAgXSksXG5cdCAgICAgICAgICAgICAgICAgICAgdmFsaWQ6IHBhcnNlRmxvYXQodmFsdWUpID4gbWluVmFsdWUgJiYgcGFyc2VGbG9hdCh2YWx1ZSkgPCBtYXhWYWx1ZSxcblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgfSxcblx0ICAgIH07XG5cdH1cblxuXHRjanMkbS5iZXR3ZWVuID0gYmV0d2Vlbjtcblx0cmV0dXJuIGNqcyRtO1xufVxuXG4vKipcbiAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG4gKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICBsaWIkbS5leHBvcnRzID0gcmVxdWlyZUluZGV4X21pbiRtKCk7XG59IGVsc2Uge1xuICAgIGxpYiRtLmV4cG9ydHMgPSByZXF1aXJlQ2pzJG0oKTtcbn1cblxudmFyIGxpYkV4cG9ydHMkbSA9IGxpYiRtLmV4cG9ydHM7XG5cbnZhciBsaWIkbCA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBpbmRleF9taW4kbCA9IHt9O1xuXG4vKiogXG4gKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcbiAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuICpcbiAqIEBsaWNlbnNlIGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8vbGljZW5zZVxuICogQHBhY2thZ2UgQGZvcm0tdmFsaWRhdGlvbi92YWxpZGF0b3ItYmxhbmtcbiAqIEB2ZXJzaW9uIDIuNC4wXG4gKi9cblxudmFyIGhhc1JlcXVpcmVkSW5kZXhfbWluJGw7XG5cbmZ1bmN0aW9uIHJlcXVpcmVJbmRleF9taW4kbCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEluZGV4X21pbiRsKSByZXR1cm4gaW5kZXhfbWluJGw7XG5cdGhhc1JlcXVpcmVkSW5kZXhfbWluJGwgPSAxO1xuaW5kZXhfbWluJGwuYmxhbms9ZnVuY3Rpb24oKXtyZXR1cm4ge3ZhbGlkYXRlOmZ1bmN0aW9uKHQpe3JldHVybiB7dmFsaWQ6ITB9fX19O1xuXHRyZXR1cm4gaW5kZXhfbWluJGw7XG59XG5cbnZhciBjanMkbCA9IHt9O1xuXG52YXIgaGFzUmVxdWlyZWRDanMkbDtcblxuZnVuY3Rpb24gcmVxdWlyZUNqcyRsICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkQ2pzJGwpIHJldHVybiBjanMkbDtcblx0aGFzUmVxdWlyZWRDanMkbCA9IDE7XG5cblx0LyoqXG5cdCAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuXHQgKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcblx0ICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuXHQgKi9cblx0LyoqXG5cdCAqIFRoaXMgdmFsaWRhdG9yIGFsd2F5cyByZXR1cm5zIHZhbGlkLlxuXHQgKiBJdCBjYW4gYmUgdXNlZCB3aGVuIHdlIHdhbnQgdG8gc2hvdyB0aGUgY3VzdG9tIG1lc3NhZ2UgcmV0dXJuZWQgZnJvbSBzZXJ2ZXJcblx0ICovXG5cdGZ1bmN0aW9uIGJsYW5rKCkge1xuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKF9pbnB1dCkge1xuXHQgICAgICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSB9O1xuXHQgICAgICAgIH0sXG5cdCAgICB9O1xuXHR9XG5cblx0Y2pzJGwuYmxhbmsgPSBibGFuaztcblx0cmV0dXJuIGNqcyRsO1xufVxuXG4vKipcbiAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG4gKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICBsaWIkbC5leHBvcnRzID0gcmVxdWlyZUluZGV4X21pbiRsKCk7XG59IGVsc2Uge1xuICAgIGxpYiRsLmV4cG9ydHMgPSByZXF1aXJlQ2pzJGwoKTtcbn1cblxudmFyIGxpYkV4cG9ydHMkbCA9IGxpYiRsLmV4cG9ydHM7XG5cbnZhciBsaWIkayA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBpbmRleF9taW4kayA9IHt9O1xuXG4vKiogXG4gKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcbiAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuICpcbiAqIEBsaWNlbnNlIGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8vbGljZW5zZVxuICogQHBhY2thZ2UgQGZvcm0tdmFsaWRhdGlvbi92YWxpZGF0b3ItY2FsbGJhY2tcbiAqIEB2ZXJzaW9uIDIuNC4wXG4gKi9cblxudmFyIGhhc1JlcXVpcmVkSW5kZXhfbWluJGs7XG5cbmZ1bmN0aW9uIHJlcXVpcmVJbmRleF9taW4kayAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEluZGV4X21pbiRrKSByZXR1cm4gaW5kZXhfbWluJGs7XG5cdGhhc1JlcXVpcmVkSW5kZXhfbWluJGsgPSAxO1xudmFyIGE9bGliRXhwb3J0cyRCLnV0aWxzLmNhbGw7aW5kZXhfbWluJGsuY2FsbGJhY2s9ZnVuY3Rpb24oKXtyZXR1cm4ge3ZhbGlkYXRlOmZ1bmN0aW9uKHIpe3ZhciB0PWEoci5vcHRpb25zLmNhbGxiYWNrLFtyXSk7cmV0dXJuIFwiYm9vbGVhblwiPT10eXBlb2YgdD97dmFsaWQ6dH06dH19fTtcblx0cmV0dXJuIGluZGV4X21pbiRrO1xufVxuXG52YXIgY2pzJGsgPSB7fTtcblxudmFyIGhhc1JlcXVpcmVkQ2pzJGs7XG5cbmZ1bmN0aW9uIHJlcXVpcmVDanMkayAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZENqcyRrKSByZXR1cm4gY2pzJGs7XG5cdGhhc1JlcXVpcmVkQ2pzJGsgPSAxO1xuXG5cdHZhciBjb3JlID0gbGliRXhwb3J0cyRCO1xuXG5cdC8qKlxuXHQgKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcblx0ICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG5cdCAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cblx0ICovXG5cdHZhciBjYWxsID0gY29yZS51dGlscy5jYWxsO1xuXHRmdW5jdGlvbiBjYWxsYmFjaygpIHtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChpbnB1dCkge1xuXHQgICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSBjYWxsKGlucHV0Lm9wdGlvbnMuY2FsbGJhY2ssIFtpbnB1dF0pO1xuXHQgICAgICAgICAgICByZXR1cm4gJ2Jvb2xlYW4nID09PSB0eXBlb2YgcmVzcG9uc2Vcblx0ICAgICAgICAgICAgICAgID8geyB2YWxpZDogcmVzcG9uc2UgfSAvLyBEZXByZWNhdGVkXG5cdCAgICAgICAgICAgICAgICA6IHJlc3BvbnNlO1xuXHQgICAgICAgIH0sXG5cdCAgICB9O1xuXHR9XG5cblx0Y2pzJGsuY2FsbGJhY2sgPSBjYWxsYmFjaztcblx0cmV0dXJuIGNqcyRrO1xufVxuXG4vKipcbiAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG4gKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICBsaWIkay5leHBvcnRzID0gcmVxdWlyZUluZGV4X21pbiRrKCk7XG59IGVsc2Uge1xuICAgIGxpYiRrLmV4cG9ydHMgPSByZXF1aXJlQ2pzJGsoKTtcbn1cblxudmFyIGxpYkV4cG9ydHMkayA9IGxpYiRrLmV4cG9ydHM7XG5cbnZhciBsaWIkaiA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBpbmRleF9taW4kaiA9IHt9O1xuXG4vKiogXG4gKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcbiAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuICpcbiAqIEBsaWNlbnNlIGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8vbGljZW5zZVxuICogQHBhY2thZ2UgQGZvcm0tdmFsaWRhdGlvbi92YWxpZGF0b3ItY2hvaWNlXG4gKiBAdmVyc2lvbiAyLjQuMFxuICovXG5cbnZhciBoYXNSZXF1aXJlZEluZGV4X21pbiRqO1xuXG5mdW5jdGlvbiByZXF1aXJlSW5kZXhfbWluJGogKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRJbmRleF9taW4kaikgcmV0dXJuIGluZGV4X21pbiRqO1xuXHRoYXNSZXF1aXJlZEluZGV4X21pbiRqID0gMTtcbnZhciBlPWxpYkV4cG9ydHMkQi51dGlscy5mb3JtYXQ7aW5kZXhfbWluJGouY2hvaWNlPWZ1bmN0aW9uKCl7cmV0dXJuIHt2YWxpZGF0ZTpmdW5jdGlvbihuKXt2YXIgdD1cInNlbGVjdFwiPT09bi5lbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKT9uLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcIm9wdGlvbjpjaGVja2VkXCIpLmxlbmd0aDpuLmVsZW1lbnRzLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIGUuY2hlY2tlZH0pKS5sZW5ndGgsbz1uLm9wdGlvbnMubWluP1wiXCIuY29uY2F0KG4ub3B0aW9ucy5taW4pOlwiXCIscz1uLm9wdGlvbnMubWF4P1wiXCIuY29uY2F0KG4ub3B0aW9ucy5tYXgpOlwiXCIsYT1uLmwxMG4/bi5vcHRpb25zLm1lc3NhZ2V8fG4ubDEwbi5jaG9pY2UuZGVmYXVsdDpuLm9wdGlvbnMubWVzc2FnZSxjPSEobyYmdDxwYXJzZUludChvLDEwKXx8cyYmdD5wYXJzZUludChzLDEwKSk7c3dpdGNoKCEwKXtjYXNlISFvJiYhIXM6YT1lKG4ubDEwbj9uLmwxMG4uY2hvaWNlLmJldHdlZW46bi5vcHRpb25zLm1lc3NhZ2UsW28sc10pO2JyZWFrO2Nhc2UhIW86YT1lKG4ubDEwbj9uLmwxMG4uY2hvaWNlLm1vcmU6bi5vcHRpb25zLm1lc3NhZ2Usbyk7YnJlYWs7Y2FzZSEhczphPWUobi5sMTBuP24ubDEwbi5jaG9pY2UubGVzczpuLm9wdGlvbnMubWVzc2FnZSxzKTt9cmV0dXJuIHttZXNzYWdlOmEsdmFsaWQ6Y319fX07XG5cdHJldHVybiBpbmRleF9taW4kajtcbn1cblxudmFyIGNqcyRqID0ge307XG5cbnZhciBoYXNSZXF1aXJlZENqcyRqO1xuXG5mdW5jdGlvbiByZXF1aXJlQ2pzJGogKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRDanMkaikgcmV0dXJuIGNqcyRqO1xuXHRoYXNSZXF1aXJlZENqcyRqID0gMTtcblxuXHR2YXIgY29yZSA9IGxpYkV4cG9ydHMkQjtcblxuXHQvKipcblx0ICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG5cdCAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuXHQgKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG5cdCAqL1xuXHR2YXIgZm9ybWF0ID0gY29yZS51dGlscy5mb3JtYXQ7XG5cdGZ1bmN0aW9uIGNob2ljZSgpIHtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChpbnB1dCkge1xuXHQgICAgICAgICAgICB2YXIgbnVtQ2hvaWNlcyA9ICdzZWxlY3QnID09PSBpbnB1dC5lbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKVxuXHQgICAgICAgICAgICAgICAgPyBpbnB1dC5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ29wdGlvbjpjaGVja2VkJykubGVuZ3RoXG5cdCAgICAgICAgICAgICAgICA6IGlucHV0LmVsZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAoZWxlKSB7IHJldHVybiBlbGUuY2hlY2tlZDsgfSkubGVuZ3RoO1xuXHQgICAgICAgICAgICB2YXIgbWluID0gaW5wdXQub3B0aW9ucy5taW4gPyBcIlwiLmNvbmNhdChpbnB1dC5vcHRpb25zLm1pbikgOiAnJztcblx0ICAgICAgICAgICAgdmFyIG1heCA9IGlucHV0Lm9wdGlvbnMubWF4ID8gXCJcIi5jb25jYXQoaW5wdXQub3B0aW9ucy5tYXgpIDogJyc7XG5cdCAgICAgICAgICAgIHZhciBtc2cgPSBpbnB1dC5sMTBuID8gaW5wdXQub3B0aW9ucy5tZXNzYWdlIHx8IGlucHV0LmwxMG4uY2hvaWNlLmRlZmF1bHQgOiBpbnB1dC5vcHRpb25zLm1lc3NhZ2U7XG5cdCAgICAgICAgICAgIHZhciBpc1ZhbGlkID0gISgobWluICYmIG51bUNob2ljZXMgPCBwYXJzZUludChtaW4sIDEwKSkgfHwgKG1heCAmJiBudW1DaG9pY2VzID4gcGFyc2VJbnQobWF4LCAxMCkpKTtcblx0ICAgICAgICAgICAgc3dpdGNoICh0cnVlKSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlICEhbWluICYmICEhbWF4OlxuXHQgICAgICAgICAgICAgICAgICAgIG1zZyA9IGZvcm1hdChpbnB1dC5sMTBuID8gaW5wdXQubDEwbi5jaG9pY2UuYmV0d2VlbiA6IGlucHV0Lm9wdGlvbnMubWVzc2FnZSwgW21pbiwgbWF4XSk7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlICEhbWluOlxuXHQgICAgICAgICAgICAgICAgICAgIG1zZyA9IGZvcm1hdChpbnB1dC5sMTBuID8gaW5wdXQubDEwbi5jaG9pY2UubW9yZSA6IGlucHV0Lm9wdGlvbnMubWVzc2FnZSwgbWluKTtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgISFtYXg6XG5cdCAgICAgICAgICAgICAgICAgICAgbXNnID0gZm9ybWF0KGlucHV0LmwxMG4gPyBpbnB1dC5sMTBuLmNob2ljZS5sZXNzIDogaW5wdXQub3B0aW9ucy5tZXNzYWdlLCBtYXgpO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICBtZXNzYWdlOiBtc2csXG5cdCAgICAgICAgICAgICAgICB2YWxpZDogaXNWYWxpZCxcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9LFxuXHQgICAgfTtcblx0fVxuXG5cdGNqcyRqLmNob2ljZSA9IGNob2ljZTtcblx0cmV0dXJuIGNqcyRqO1xufVxuXG4vKipcbiAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG4gKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICBsaWIkai5leHBvcnRzID0gcmVxdWlyZUluZGV4X21pbiRqKCk7XG59IGVsc2Uge1xuICAgIGxpYiRqLmV4cG9ydHMgPSByZXF1aXJlQ2pzJGooKTtcbn1cblxudmFyIGxpYkV4cG9ydHMkaiA9IGxpYiRqLmV4cG9ydHM7XG5cbnZhciBsaWIkaSA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBpbmRleF9taW4kaSA9IHt9O1xuXG4vKiogXG4gKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcbiAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuICpcbiAqIEBsaWNlbnNlIGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8vbGljZW5zZVxuICogQHBhY2thZ2UgQGZvcm0tdmFsaWRhdGlvbi92YWxpZGF0b3ItY3JlZGl0LWNhcmRcbiAqIEB2ZXJzaW9uIDIuNC4wXG4gKi9cblxudmFyIGhhc1JlcXVpcmVkSW5kZXhfbWluJGk7XG5cbmZ1bmN0aW9uIHJlcXVpcmVJbmRleF9taW4kaSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEluZGV4X21pbiRpKSByZXR1cm4gaW5kZXhfbWluJGk7XG5cdGhhc1JlcXVpcmVkSW5kZXhfbWluJGkgPSAxO1xudmFyIGU9bGliRXhwb3J0cyRCLmFsZ29yaXRobXMubHVobixyPXtBTUVSSUNBTl9FWFBSRVNTOntsZW5ndGg6WzE1XSxwcmVmaXg6W1wiMzRcIixcIjM3XCJdfSxEQU5LT1JUOntsZW5ndGg6WzE2XSxwcmVmaXg6W1wiNTAxOVwiXX0sRElORVJTX0NMVUI6e2xlbmd0aDpbMTRdLHByZWZpeDpbXCIzMDBcIixcIjMwMVwiLFwiMzAyXCIsXCIzMDNcIixcIjMwNFwiLFwiMzA1XCIsXCIzNlwiXX0sRElORVJTX0NMVUJfVVM6e2xlbmd0aDpbMTZdLHByZWZpeDpbXCI1NFwiLFwiNTVcIl19LERJU0NPVkVSOntsZW5ndGg6WzE2XSxwcmVmaXg6W1wiNjAxMVwiLFwiNjIyMTI2XCIsXCI2MjIxMjdcIixcIjYyMjEyOFwiLFwiNjIyMTI5XCIsXCI2MjIxM1wiLFwiNjIyMTRcIixcIjYyMjE1XCIsXCI2MjIxNlwiLFwiNjIyMTdcIixcIjYyMjE4XCIsXCI2MjIxOVwiLFwiNjIyMlwiLFwiNjIyM1wiLFwiNjIyNFwiLFwiNjIyNVwiLFwiNjIyNlwiLFwiNjIyN1wiLFwiNjIyOFwiLFwiNjIyOTBcIixcIjYyMjkxXCIsXCI2MjI5MjBcIixcIjYyMjkyMVwiLFwiNjIyOTIyXCIsXCI2MjI5MjNcIixcIjYyMjkyNFwiLFwiNjIyOTI1XCIsXCI2NDRcIixcIjY0NVwiLFwiNjQ2XCIsXCI2NDdcIixcIjY0OFwiLFwiNjQ5XCIsXCI2NVwiXX0sRUxPOntsZW5ndGg6WzE2XSxwcmVmaXg6W1wiNDAxMVwiLFwiNDMxMlwiLFwiNDM4OVwiLFwiNDUxNFwiLFwiNDU3M1wiLFwiNDU3NlwiLFwiNTA0MVwiLFwiNTA2NlwiLFwiNTA2N1wiLFwiNTA5XCIsXCI2Mjc3XCIsXCI2MzYyXCIsXCI2MzYzXCIsXCI2NTBcIixcIjY1MTZcIixcIjY1NTBcIl19LEZPUkJSVUdTRk9SRU5JTkdFTjp7bGVuZ3RoOlsxNl0scHJlZml4OltcIjYwMDcyMlwiXX0sSkNCOntsZW5ndGg6WzE2XSxwcmVmaXg6W1wiMzUyOFwiLFwiMzUyOVwiLFwiMzUzXCIsXCIzNTRcIixcIjM1NVwiLFwiMzU2XCIsXCIzNTdcIixcIjM1OFwiXX0sTEFTRVI6e2xlbmd0aDpbMTYsMTcsMTgsMTldLHByZWZpeDpbXCI2MzA0XCIsXCI2NzA2XCIsXCI2NzcxXCIsXCI2NzA5XCJdfSxNQUVTVFJPOntsZW5ndGg6WzEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5XSxwcmVmaXg6W1wiNTAxOFwiLFwiNTAyMFwiLFwiNTAzOFwiLFwiNTg2OFwiLFwiNjMwNFwiLFwiNjc1OVwiLFwiNjc2MVwiLFwiNjc2MlwiLFwiNjc2M1wiLFwiNjc2NFwiLFwiNjc2NVwiLFwiNjc2NlwiXX0sTUFTVEVSQ0FSRDp7bGVuZ3RoOlsxNl0scHJlZml4OltcIjUxXCIsXCI1MlwiLFwiNTNcIixcIjU0XCIsXCI1NVwiXX0sU09MTzp7bGVuZ3RoOlsxNiwxOCwxOV0scHJlZml4OltcIjYzMzRcIixcIjY3NjdcIl19LFVOSU9OUEFZOntsZW5ndGg6WzE2LDE3LDE4LDE5XSxwcmVmaXg6W1wiNjIyMTI2XCIsXCI2MjIxMjdcIixcIjYyMjEyOFwiLFwiNjIyMTI5XCIsXCI2MjIxM1wiLFwiNjIyMTRcIixcIjYyMjE1XCIsXCI2MjIxNlwiLFwiNjIyMTdcIixcIjYyMjE4XCIsXCI2MjIxOVwiLFwiNjIyMlwiLFwiNjIyM1wiLFwiNjIyNFwiLFwiNjIyNVwiLFwiNjIyNlwiLFwiNjIyN1wiLFwiNjIyOFwiLFwiNjIyOTBcIixcIjYyMjkxXCIsXCI2MjI5MjBcIixcIjYyMjkyMVwiLFwiNjIyOTIyXCIsXCI2MjI5MjNcIixcIjYyMjkyNFwiLFwiNjIyOTI1XCJdfSxWSVNBOntsZW5ndGg6WzE2XSxwcmVmaXg6W1wiNFwiXX0sVklTQV9FTEVDVFJPTjp7bGVuZ3RoOlsxNl0scHJlZml4OltcIjQwMjZcIixcIjQxNzUwMFwiLFwiNDQwNVwiLFwiNDUwOFwiLFwiNDg0NFwiLFwiNDkxM1wiLFwiNDkxN1wiXX19O2luZGV4X21pbiRpLkNSRURJVF9DQVJEX1RZUEVTPXIsaW5kZXhfbWluJGkuY3JlZGl0Q2FyZD1mdW5jdGlvbigpe3JldHVybiB7dmFsaWRhdGU6ZnVuY3Rpb24odCl7aWYoXCJcIj09PXQudmFsdWUpcmV0dXJuIHttZXRhOnt0eXBlOm51bGx9LHZhbGlkOiEwfTtpZigvW14wLTktXFxzXSsvLnRlc3QodC52YWx1ZSkpcmV0dXJuIHttZXRhOnt0eXBlOm51bGx9LHZhbGlkOiExfTt2YXIgbD10LnZhbHVlLnJlcGxhY2UoL1xcRC9nLFwiXCIpO2lmKCFlKGwpKXJldHVybiB7bWV0YTp7dHlwZTpudWxsfSx2YWxpZDohMX07Zm9yKHZhciBpPTAsbj1PYmplY3Qua2V5cyhyKTtpPG4ubGVuZ3RoO2krKyl7dmFyIGY9bltpXTtmb3IodmFyIGEgaW4gcltmXS5wcmVmaXgpaWYodC52YWx1ZS5zdWJzdHIoMCxyW2ZdLnByZWZpeFthXS5sZW5ndGgpPT09cltmXS5wcmVmaXhbYV0mJi0xIT09cltmXS5sZW5ndGguaW5kZXhPZihsLmxlbmd0aCkpcmV0dXJuIHttZXRhOnt0eXBlOmZ9LHZhbGlkOiEwfX1yZXR1cm4ge21ldGE6e3R5cGU6bnVsbH0sdmFsaWQ6ITF9fX19O1xuXHRyZXR1cm4gaW5kZXhfbWluJGk7XG59XG5cbnZhciBjanMkaSA9IHt9O1xuXG52YXIgaGFzUmVxdWlyZWRDanMkaTtcblxuZnVuY3Rpb24gcmVxdWlyZUNqcyRpICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkQ2pzJGkpIHJldHVybiBjanMkaTtcblx0aGFzUmVxdWlyZWRDanMkaSA9IDE7XG5cblx0dmFyIGNvcmUgPSBsaWJFeHBvcnRzJEI7XG5cblx0LyoqXG5cdCAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuXHQgKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcblx0ICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuXHQgKi9cblx0dmFyIGx1aG4gPSBjb3JlLmFsZ29yaXRobXMubHVobjtcblx0dmFyIENSRURJVF9DQVJEX1RZUEVTID0ge1xuXHQgICAgQU1FUklDQU5fRVhQUkVTUzoge1xuXHQgICAgICAgIGxlbmd0aDogWzE1XSxcblx0ICAgICAgICBwcmVmaXg6IFsnMzQnLCAnMzcnXSxcblx0ICAgIH0sXG5cdCAgICBEQU5LT1JUOiB7XG5cdCAgICAgICAgbGVuZ3RoOiBbMTZdLFxuXHQgICAgICAgIHByZWZpeDogWyc1MDE5J10sXG5cdCAgICB9LFxuXHQgICAgRElORVJTX0NMVUI6IHtcblx0ICAgICAgICBsZW5ndGg6IFsxNF0sXG5cdCAgICAgICAgcHJlZml4OiBbJzMwMCcsICczMDEnLCAnMzAyJywgJzMwMycsICczMDQnLCAnMzA1JywgJzM2J10sXG5cdCAgICB9LFxuXHQgICAgRElORVJTX0NMVUJfVVM6IHtcblx0ICAgICAgICBsZW5ndGg6IFsxNl0sXG5cdCAgICAgICAgcHJlZml4OiBbJzU0JywgJzU1J10sXG5cdCAgICB9LFxuXHQgICAgRElTQ09WRVI6IHtcblx0ICAgICAgICBsZW5ndGg6IFsxNl0sXG5cdCAgICAgICAgcHJlZml4OiBbXG5cdCAgICAgICAgICAgICc2MDExJyxcblx0ICAgICAgICAgICAgJzYyMjEyNicsXG5cdCAgICAgICAgICAgICc2MjIxMjcnLFxuXHQgICAgICAgICAgICAnNjIyMTI4Jyxcblx0ICAgICAgICAgICAgJzYyMjEyOScsXG5cdCAgICAgICAgICAgICc2MjIxMycsXG5cdCAgICAgICAgICAgICc2MjIxNCcsXG5cdCAgICAgICAgICAgICc2MjIxNScsXG5cdCAgICAgICAgICAgICc2MjIxNicsXG5cdCAgICAgICAgICAgICc2MjIxNycsXG5cdCAgICAgICAgICAgICc2MjIxOCcsXG5cdCAgICAgICAgICAgICc2MjIxOScsXG5cdCAgICAgICAgICAgICc2MjIyJyxcblx0ICAgICAgICAgICAgJzYyMjMnLFxuXHQgICAgICAgICAgICAnNjIyNCcsXG5cdCAgICAgICAgICAgICc2MjI1Jyxcblx0ICAgICAgICAgICAgJzYyMjYnLFxuXHQgICAgICAgICAgICAnNjIyNycsXG5cdCAgICAgICAgICAgICc2MjI4Jyxcblx0ICAgICAgICAgICAgJzYyMjkwJyxcblx0ICAgICAgICAgICAgJzYyMjkxJyxcblx0ICAgICAgICAgICAgJzYyMjkyMCcsXG5cdCAgICAgICAgICAgICc2MjI5MjEnLFxuXHQgICAgICAgICAgICAnNjIyOTIyJyxcblx0ICAgICAgICAgICAgJzYyMjkyMycsXG5cdCAgICAgICAgICAgICc2MjI5MjQnLFxuXHQgICAgICAgICAgICAnNjIyOTI1Jyxcblx0ICAgICAgICAgICAgJzY0NCcsXG5cdCAgICAgICAgICAgICc2NDUnLFxuXHQgICAgICAgICAgICAnNjQ2Jyxcblx0ICAgICAgICAgICAgJzY0NycsXG5cdCAgICAgICAgICAgICc2NDgnLFxuXHQgICAgICAgICAgICAnNjQ5Jyxcblx0ICAgICAgICAgICAgJzY1Jyxcblx0ICAgICAgICBdLFxuXHQgICAgfSxcblx0ICAgIEVMTzoge1xuXHQgICAgICAgIGxlbmd0aDogWzE2XSxcblx0ICAgICAgICBwcmVmaXg6IFtcblx0ICAgICAgICAgICAgJzQwMTEnLFxuXHQgICAgICAgICAgICAnNDMxMicsXG5cdCAgICAgICAgICAgICc0Mzg5Jyxcblx0ICAgICAgICAgICAgJzQ1MTQnLFxuXHQgICAgICAgICAgICAnNDU3MycsXG5cdCAgICAgICAgICAgICc0NTc2Jyxcblx0ICAgICAgICAgICAgJzUwNDEnLFxuXHQgICAgICAgICAgICAnNTA2NicsXG5cdCAgICAgICAgICAgICc1MDY3Jyxcblx0ICAgICAgICAgICAgJzUwOScsXG5cdCAgICAgICAgICAgICc2Mjc3Jyxcblx0ICAgICAgICAgICAgJzYzNjInLFxuXHQgICAgICAgICAgICAnNjM2MycsXG5cdCAgICAgICAgICAgICc2NTAnLFxuXHQgICAgICAgICAgICAnNjUxNicsXG5cdCAgICAgICAgICAgICc2NTUwJyxcblx0ICAgICAgICBdLFxuXHQgICAgfSxcblx0ICAgIEZPUkJSVUdTRk9SRU5JTkdFTjoge1xuXHQgICAgICAgIGxlbmd0aDogWzE2XSxcblx0ICAgICAgICBwcmVmaXg6IFsnNjAwNzIyJ10sXG5cdCAgICB9LFxuXHQgICAgSkNCOiB7XG5cdCAgICAgICAgbGVuZ3RoOiBbMTZdLFxuXHQgICAgICAgIHByZWZpeDogWyczNTI4JywgJzM1MjknLCAnMzUzJywgJzM1NCcsICczNTUnLCAnMzU2JywgJzM1NycsICczNTgnXSxcblx0ICAgIH0sXG5cdCAgICBMQVNFUjoge1xuXHQgICAgICAgIGxlbmd0aDogWzE2LCAxNywgMTgsIDE5XSxcblx0ICAgICAgICBwcmVmaXg6IFsnNjMwNCcsICc2NzA2JywgJzY3NzEnLCAnNjcwOSddLFxuXHQgICAgfSxcblx0ICAgIE1BRVNUUk86IHtcblx0ICAgICAgICBsZW5ndGg6IFsxMiwgMTMsIDE0LCAxNSwgMTYsIDE3LCAxOCwgMTldLFxuXHQgICAgICAgIHByZWZpeDogWyc1MDE4JywgJzUwMjAnLCAnNTAzOCcsICc1ODY4JywgJzYzMDQnLCAnNjc1OScsICc2NzYxJywgJzY3NjInLCAnNjc2MycsICc2NzY0JywgJzY3NjUnLCAnNjc2NiddLFxuXHQgICAgfSxcblx0ICAgIE1BU1RFUkNBUkQ6IHtcblx0ICAgICAgICBsZW5ndGg6IFsxNl0sXG5cdCAgICAgICAgcHJlZml4OiBbJzUxJywgJzUyJywgJzUzJywgJzU0JywgJzU1J10sXG5cdCAgICB9LFxuXHQgICAgU09MTzoge1xuXHQgICAgICAgIGxlbmd0aDogWzE2LCAxOCwgMTldLFxuXHQgICAgICAgIHByZWZpeDogWyc2MzM0JywgJzY3NjcnXSxcblx0ICAgIH0sXG5cdCAgICBVTklPTlBBWToge1xuXHQgICAgICAgIGxlbmd0aDogWzE2LCAxNywgMTgsIDE5XSxcblx0ICAgICAgICBwcmVmaXg6IFtcblx0ICAgICAgICAgICAgJzYyMjEyNicsXG5cdCAgICAgICAgICAgICc2MjIxMjcnLFxuXHQgICAgICAgICAgICAnNjIyMTI4Jyxcblx0ICAgICAgICAgICAgJzYyMjEyOScsXG5cdCAgICAgICAgICAgICc2MjIxMycsXG5cdCAgICAgICAgICAgICc2MjIxNCcsXG5cdCAgICAgICAgICAgICc2MjIxNScsXG5cdCAgICAgICAgICAgICc2MjIxNicsXG5cdCAgICAgICAgICAgICc2MjIxNycsXG5cdCAgICAgICAgICAgICc2MjIxOCcsXG5cdCAgICAgICAgICAgICc2MjIxOScsXG5cdCAgICAgICAgICAgICc2MjIyJyxcblx0ICAgICAgICAgICAgJzYyMjMnLFxuXHQgICAgICAgICAgICAnNjIyNCcsXG5cdCAgICAgICAgICAgICc2MjI1Jyxcblx0ICAgICAgICAgICAgJzYyMjYnLFxuXHQgICAgICAgICAgICAnNjIyNycsXG5cdCAgICAgICAgICAgICc2MjI4Jyxcblx0ICAgICAgICAgICAgJzYyMjkwJyxcblx0ICAgICAgICAgICAgJzYyMjkxJyxcblx0ICAgICAgICAgICAgJzYyMjkyMCcsXG5cdCAgICAgICAgICAgICc2MjI5MjEnLFxuXHQgICAgICAgICAgICAnNjIyOTIyJyxcblx0ICAgICAgICAgICAgJzYyMjkyMycsXG5cdCAgICAgICAgICAgICc2MjI5MjQnLFxuXHQgICAgICAgICAgICAnNjIyOTI1Jyxcblx0ICAgICAgICBdLFxuXHQgICAgfSxcblx0ICAgIFZJU0E6IHtcblx0ICAgICAgICBsZW5ndGg6IFsxNl0sXG5cdCAgICAgICAgcHJlZml4OiBbJzQnXSxcblx0ICAgIH0sXG5cdCAgICBWSVNBX0VMRUNUUk9OOiB7XG5cdCAgICAgICAgbGVuZ3RoOiBbMTZdLFxuXHQgICAgICAgIHByZWZpeDogWyc0MDI2JywgJzQxNzUwMCcsICc0NDA1JywgJzQ1MDgnLCAnNDg0NCcsICc0OTEzJywgJzQ5MTcnXSxcblx0ICAgIH0sXG5cdH07XG5cdGZ1bmN0aW9uIGNyZWRpdENhcmQoKSB7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSBpbnB1dCB2YWx1ZSBpcyB2YWxpZCBjcmVkaXQgY2FyZCBudW1iZXJcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKGlucHV0KSB7XG5cdCAgICAgICAgICAgIGlmIChpbnB1dC52YWx1ZSA9PT0gJycpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgbWV0YToge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBudWxsLFxuXHQgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgdmFsaWQ6IHRydWUsXG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vIEFjY2VwdCBvbmx5IGRpZ2l0cywgZGFzaGVzIG9yIHNwYWNlc1xuXHQgICAgICAgICAgICBpZiAoL1teMC05LVxcc10rLy50ZXN0KGlucHV0LnZhbHVlKSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICBtZXRhOiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG51bGwsXG5cdCAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICB2YWxpZDogZmFsc2UsXG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciB2ID0gaW5wdXQudmFsdWUucmVwbGFjZSgvXFxEL2csICcnKTtcblx0ICAgICAgICAgICAgaWYgKCFsdWhuKHYpKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgIG1ldGE6IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogbnVsbCxcblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgIHZhbGlkOiBmYWxzZSxcblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5rZXlzKENSRURJVF9DQVJEX1RZUEVTKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciB0cGUgPSBfYVtfaV07XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIENSRURJVF9DQVJEX1RZUEVTW3RwZV0ucHJlZml4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIHByZWZpeCBhbmQgbGVuZ3RoXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnZhbHVlLnN1YnN0cigwLCBDUkVESVRfQ0FSRF9UWVBFU1t0cGVdLnByZWZpeFtpXS5sZW5ndGgpID09PVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBDUkVESVRfQ0FSRF9UWVBFU1t0cGVdLnByZWZpeFtpXSAmJlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBDUkVESVRfQ0FSRF9UWVBFU1t0cGVdLmxlbmd0aC5pbmRleE9mKHYubGVuZ3RoKSAhPT0gLTEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGE6IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0cGUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQ6IHRydWUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICBtZXRhOiB7XG5cdCAgICAgICAgICAgICAgICAgICAgdHlwZTogbnVsbCxcblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICB2YWxpZDogZmFsc2UsXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfSxcblx0ICAgIH07XG5cdH1cblxuXHRjanMkaS5DUkVESVRfQ0FSRF9UWVBFUyA9IENSRURJVF9DQVJEX1RZUEVTO1xuXHRjanMkaS5jcmVkaXRDYXJkID0gY3JlZGl0Q2FyZDtcblx0cmV0dXJuIGNqcyRpO1xufVxuXG4vKipcbiAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG4gKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICBsaWIkaS5leHBvcnRzID0gcmVxdWlyZUluZGV4X21pbiRpKCk7XG59IGVsc2Uge1xuICAgIGxpYiRpLmV4cG9ydHMgPSByZXF1aXJlQ2pzJGkoKTtcbn1cblxudmFyIGxpYkV4cG9ydHMkaSA9IGxpYiRpLmV4cG9ydHM7XG5cbnZhciBsaWIkaCA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBpbmRleF9taW4kaCA9IHt9O1xuXG4vKiogXG4gKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcbiAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuICpcbiAqIEBsaWNlbnNlIGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8vbGljZW5zZVxuICogQHBhY2thZ2UgQGZvcm0tdmFsaWRhdGlvbi92YWxpZGF0b3ItZGF0ZVxuICogQHZlcnNpb24gMi40LjBcbiAqL1xuXG52YXIgaGFzUmVxdWlyZWRJbmRleF9taW4kaDtcblxuZnVuY3Rpb24gcmVxdWlyZUluZGV4X21pbiRoICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkSW5kZXhfbWluJGgpIHJldHVybiBpbmRleF9taW4kaDtcblx0aGFzUmVxdWlyZWRJbmRleF9taW4kaCA9IDE7XG52YXIgZT1saWJFeHBvcnRzJEIsdD1lLnV0aWxzLmZvcm1hdCxuPWUudXRpbHMuaXNWYWxpZERhdGUsYT1lLnV0aWxzLnJlbW92ZVVuZGVmaW5lZCxyPWZ1bmN0aW9uKGUsdCxuKXt2YXIgYT10LmluZGV4T2YoXCJZWVlZXCIpLHI9dC5pbmRleE9mKFwiTU1cIiksbD10LmluZGV4T2YoXCJERFwiKTtpZigtMT09PWF8fC0xPT09cnx8LTE9PT1sKXJldHVybiBudWxsO3ZhciBzPWUuc3BsaXQoXCIgXCIpLGk9c1swXS5zcGxpdChuKTtpZihpLmxlbmd0aDwzKXJldHVybiBudWxsO3ZhciBjPW5ldyBEYXRlKHBhcnNlSW50KGlbYV0sMTApLHBhcnNlSW50KGlbcl0sMTApLTEscGFyc2VJbnQoaVtsXSwxMCkpLG89cy5sZW5ndGg+Mj9zWzJdOm51bGw7aWYocy5sZW5ndGg+MSl7dmFyIGc9c1sxXS5zcGxpdChcIjpcIiksdT1nLmxlbmd0aD4wP3BhcnNlSW50KGdbMF0sMTApOjA7Yy5zZXRIb3VycyhvJiZcIlBNXCI9PT1vLnRvVXBwZXJDYXNlKCkmJnU8MTI/dSsxMjp1KSxjLnNldE1pbnV0ZXMoZy5sZW5ndGg+MT9wYXJzZUludChnWzFdLDEwKTowKSxjLnNldFNlY29uZHMoZy5sZW5ndGg+Mj9wYXJzZUludChnWzJdLDEwKTowKTt9cmV0dXJuIGN9LGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LnJlcGxhY2UoL1kvZyxcInlcIikucmVwbGFjZSgvTS9nLFwibVwiKS5yZXBsYWNlKC9EL2csXCJkXCIpLnJlcGxhY2UoLzptL2csXCI6TVwiKS5yZXBsYWNlKC86bW0vZyxcIjpNTVwiKS5yZXBsYWNlKC86Uy8sXCI6c1wiKS5yZXBsYWNlKC86U1MvLFwiOnNzXCIpLGE9ZS5nZXREYXRlKCkscj1hPDEwP1wiMFwiLmNvbmNhdChhKTphLGw9ZS5nZXRNb250aCgpKzEscz1sPDEwP1wiMFwiLmNvbmNhdChsKTpsLGk9XCJcIi5jb25jYXQoZS5nZXRGdWxsWWVhcigpKS5zdWJzdHIoMiksYz1lLmdldEZ1bGxZZWFyKCksbz1lLmdldEhvdXJzKCklMTJ8fDEyLGc9bzwxMD9cIjBcIi5jb25jYXQobyk6byx1PWUuZ2V0SG91cnMoKSxkPXU8MTA/XCIwXCIuY29uY2F0KHUpOnUsZj1lLmdldE1pbnV0ZXMoKSxtPWY8MTA/XCIwXCIuY29uY2F0KGYpOmYscD1lLmdldFNlY29uZHMoKSxoPXA8MTA/XCIwXCIuY29uY2F0KHApOnAsdj17SDpcIlwiLmNvbmNhdCh1KSxISDpcIlwiLmNvbmNhdChkKSxNOlwiXCIuY29uY2F0KGYpLE1NOlwiXCIuY29uY2F0KG0pLGQ6XCJcIi5jb25jYXQoYSksZGQ6XCJcIi5jb25jYXQociksaDpcIlwiLmNvbmNhdChvKSxoaDpcIlwiLmNvbmNhdChnKSxtOlwiXCIuY29uY2F0KGwpLG1tOlwiXCIuY29uY2F0KHMpLHM6XCJcIi5jb25jYXQocCksc3M6XCJcIi5jb25jYXQoaCkseXk6XCJcIi5jb25jYXQoaSkseXl5eTpcIlwiLmNvbmNhdChjKX07cmV0dXJuIG4ucmVwbGFjZSgvZHsxLDR9fG17MSw0fXx5eSg/Onl5KT98KFtIaE1zXSlcXDE/fFwiW15cIl0qXCJ8J1teJ10qJy9nLChmdW5jdGlvbihlKXtyZXR1cm4gdltlXT92W2VdOmUuc2xpY2UoMSxlLmxlbmd0aC0xKX0pKX07aW5kZXhfbWluJGguZGF0ZT1mdW5jdGlvbigpe3JldHVybiB7dmFsaWRhdGU6ZnVuY3Rpb24oZSl7aWYoXCJcIj09PWUudmFsdWUpcmV0dXJuIHttZXRhOntkYXRlOm51bGx9LHZhbGlkOiEwfTt2YXIgcz1PYmplY3QuYXNzaWduKHt9LHtmb3JtYXQ6ZS5lbGVtZW50JiZcImRhdGVcIj09PWUuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpP1wiWVlZWS1NTS1ERFwiOlwiTU0vREQvWVlZWVwiLG1lc3NhZ2U6XCJcIn0sYShlLm9wdGlvbnMpKSxpPWUubDEwbj9lLmwxMG4uZGF0ZS5kZWZhdWx0OnMubWVzc2FnZSxjPXttZXNzYWdlOlwiXCIuY29uY2F0KGkpLG1ldGE6e2RhdGU6bnVsbH0sdmFsaWQ6ITF9LG89cy5mb3JtYXQuc3BsaXQoXCIgXCIpLGc9by5sZW5ndGg+MT9vWzFdOm51bGwsdT1vLmxlbmd0aD4yP29bMl06bnVsbCxkPWUudmFsdWUuc3BsaXQoXCIgXCIpLGY9ZFswXSxtPWQubGVuZ3RoPjE/ZFsxXTpudWxsLHA9ZC5sZW5ndGg+Mj9kWzJdOm51bGw7aWYoby5sZW5ndGghPT1kLmxlbmd0aClyZXR1cm4gYzt2YXIgaD1zLnNlcGFyYXRvcnx8KC0xIT09Zi5pbmRleE9mKFwiL1wiKT9cIi9cIjotMSE9PWYuaW5kZXhPZihcIi1cIik/XCItXCI6LTEhPT1mLmluZGV4T2YoXCIuXCIpP1wiLlwiOlwiL1wiKTtpZihudWxsPT09aHx8LTE9PT1mLmluZGV4T2YoaCkpcmV0dXJuIGM7dmFyIHY9Zi5zcGxpdChoKSxNPW9bMF0uc3BsaXQoaCk7aWYodi5sZW5ndGghPT1NLmxlbmd0aClyZXR1cm4gYzt2YXIgWT12W00uaW5kZXhPZihcIllZWVlcIildLEQ9dltNLmluZGV4T2YoXCJNTVwiKV0seD12W00uaW5kZXhPZihcIkREXCIpXTtpZighL15cXGQrJC8udGVzdChZKXx8IS9eXFxkKyQvLnRlc3QoRCl8fCEvXlxcZCskLy50ZXN0KHgpfHxZLmxlbmd0aD40fHxELmxlbmd0aD4yfHx4Lmxlbmd0aD4yKXJldHVybiBjO3ZhciB5PXBhcnNlSW50KFksMTApLEk9cGFyc2VJbnQoRCwxMCksTz1wYXJzZUludCh4LDEwKTtpZighbih5LEksTykpcmV0dXJuIGM7dmFyIEg9bmV3IERhdGUoeSxJLTEsTyk7aWYoZyl7dmFyIFQ9bS5zcGxpdChcIjpcIik7aWYoZy5zcGxpdChcIjpcIikubGVuZ3RoIT09VC5sZW5ndGgpcmV0dXJuIGM7dmFyIFM9VC5sZW5ndGg+MD9UWzBdLmxlbmd0aDw9MiYmL15cXGQrJC8udGVzdChUWzBdKT9wYXJzZUludChUWzBdLDEwKTotMTowLCQ9VC5sZW5ndGg+MT9UWzFdLmxlbmd0aDw9MiYmL15cXGQrJC8udGVzdChUWzFdKT9wYXJzZUludChUWzFdLDEwKTotMTowLGI9VC5sZW5ndGg+Mj9UWzJdLmxlbmd0aDw9MiYmL15cXGQrJC8udGVzdChUWzJdKT9wYXJzZUludChUWzJdLDEwKTotMTowO2lmKC0xPT09U3x8LTE9PT0kfHwtMT09PWIpcmV0dXJuIGM7aWYoYjwwfHxiPjYwKXJldHVybiBjO2lmKFM8MHx8Uz49MjR8fHUmJlM+MTIpcmV0dXJuIGM7aWYoJDwwfHwkPjU5KXJldHVybiBjO0guc2V0SG91cnMocCYmXCJQTVwiPT09cC50b1VwcGVyQ2FzZSgpJiZTPDEyP1MrMTI6UyksSC5zZXRNaW51dGVzKCQpLEguc2V0U2Vjb25kcyhiKTt9dmFyIHc9XCJmdW5jdGlvblwiPT10eXBlb2Ygcy5taW4/cy5taW4oKTpzLm1pbixVPXcgaW5zdGFuY2VvZiBEYXRlP3c6dz9yKHcsTSxoKTpILEM9XCJmdW5jdGlvblwiPT10eXBlb2Ygcy5tYXg/cy5tYXgoKTpzLm1heCxGPUMgaW5zdGFuY2VvZiBEYXRlP0M6Qz9yKEMsTSxoKTpILFA9dyBpbnN0YW5jZW9mIERhdGU/bChVLHMuZm9ybWF0KTp3LGo9QyBpbnN0YW5jZW9mIERhdGU/bChGLHMuZm9ybWF0KTpDO3N3aXRjaCghMCl7Y2FzZSEhUCYmIWo6cmV0dXJuIHttZXNzYWdlOnQoZS5sMTBuP2UubDEwbi5kYXRlLm1pbjppLFApLG1ldGE6e2RhdGU6SH0sdmFsaWQ6SC5nZXRUaW1lKCk+PVUuZ2V0VGltZSgpfTtjYXNlISFqJiYhUDpyZXR1cm4ge21lc3NhZ2U6dChlLmwxMG4/ZS5sMTBuLmRhdGUubWF4OmksaiksbWV0YTp7ZGF0ZTpIfSx2YWxpZDpILmdldFRpbWUoKTw9Ri5nZXRUaW1lKCl9O2Nhc2UhIWomJiEhUDpyZXR1cm4ge21lc3NhZ2U6dChlLmwxMG4/ZS5sMTBuLmRhdGUucmFuZ2U6aSxbUCxqXSksbWV0YTp7ZGF0ZTpIfSx2YWxpZDpILmdldFRpbWUoKTw9Ri5nZXRUaW1lKCkmJkguZ2V0VGltZSgpPj1VLmdldFRpbWUoKX07ZGVmYXVsdDpyZXR1cm4ge21lc3NhZ2U6XCJcIi5jb25jYXQoaSksbWV0YTp7ZGF0ZTpIfSx2YWxpZDohMH19fX19O1xuXHRyZXR1cm4gaW5kZXhfbWluJGg7XG59XG5cbnZhciBjanMkaCA9IHt9O1xuXG52YXIgaGFzUmVxdWlyZWRDanMkaDtcblxuZnVuY3Rpb24gcmVxdWlyZUNqcyRoICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkQ2pzJGgpIHJldHVybiBjanMkaDtcblx0aGFzUmVxdWlyZWRDanMkaCA9IDE7XG5cblx0dmFyIGNvcmUgPSBsaWJFeHBvcnRzJEI7XG5cblx0LyoqXG5cdCAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuXHQgKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcblx0ICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuXHQgKi9cblx0dmFyIGZvcm1hdCA9IGNvcmUudXRpbHMuZm9ybWF0LCBpc1ZhbGlkRGF0ZSA9IGNvcmUudXRpbHMuaXNWYWxpZERhdGUsIHJlbW92ZVVuZGVmaW5lZCA9IGNvcmUudXRpbHMucmVtb3ZlVW5kZWZpbmVkO1xuXHQvKipcblx0ICogUmV0dXJuIGEgZGF0ZSBvYmplY3QgYWZ0ZXIgcGFyc2luZyB0aGUgZGF0ZSBzdHJpbmdcblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IGlucHV0IFRoZSBkYXRlIHRvIHBhcnNlXG5cdCAqIEBwYXJhbSB7c3RyaW5nW119IGlucHV0Rm9ybWF0IFRoZSBkYXRlIGZvcm1hdFxuXHQgKiBUaGUgZm9ybWF0IGNhbiBiZTpcblx0ICogLSBkYXRlOiBDb25zaXN0IG9mIERELCBNTSwgWVlZWSBwYXJ0cyB3aGljaCBhcmUgc2VwYXJhdGVkIGJ5IHRoZSBzZXBhcmF0b3Igb3B0aW9uXG5cdCAqIC0gZGF0ZSBhbmQgdGltZTogVGhlIHRpbWUgY2FuIGNvbnNpc3Qgb2YgaCwgbSwgcyBwYXJ0cyB3aGljaCBhcmUgc2VwYXJhdGVkIGJ5IDpcblx0ICogQHBhcmFtIHtzdHJpbmd9IHNlcGFyYXRvciBUaGUgc2VwYXJhdG9yIHVzZWQgdG8gc2VwYXJhdGUgdGhlIGRhdGUsIG1vbnRoLCBhbmQgeWVhclxuXHQgKiBAcmV0dXJuIHtEYXRlfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0dmFyIHBhcnNlRGF0ZSA9IGZ1bmN0aW9uIChpbnB1dCwgaW5wdXRGb3JtYXQsIHNlcGFyYXRvcikge1xuXHQgICAgLy8gRW5zdXJlIHRoYXQgdGhlIGZvcm1hdCBtdXN0IGNvbnNpc3Qgb2YgeWVhciwgbW9udGggYW5kIGRheSBwYXR0ZXJuc1xuXHQgICAgdmFyIHllYXJJbmRleCA9IGlucHV0Rm9ybWF0LmluZGV4T2YoJ1lZWVknKTtcblx0ICAgIHZhciBtb250aEluZGV4ID0gaW5wdXRGb3JtYXQuaW5kZXhPZignTU0nKTtcblx0ICAgIHZhciBkYXlJbmRleCA9IGlucHV0Rm9ybWF0LmluZGV4T2YoJ0REJyk7XG5cdCAgICBpZiAoeWVhckluZGV4ID09PSAtMSB8fCBtb250aEluZGV4ID09PSAtMSB8fCBkYXlJbmRleCA9PT0gLTEpIHtcblx0ICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgIH1cblx0ICAgIHZhciBzZWN0aW9ucyA9IGlucHV0LnNwbGl0KCcgJyk7XG5cdCAgICB2YXIgZGF0ZVNlY3Rpb24gPSBzZWN0aW9uc1swXS5zcGxpdChzZXBhcmF0b3IpO1xuXHQgICAgaWYgKGRhdGVTZWN0aW9uLmxlbmd0aCA8IDMpIHtcblx0ICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgIH1cblx0ICAgIHZhciBkID0gbmV3IERhdGUocGFyc2VJbnQoZGF0ZVNlY3Rpb25beWVhckluZGV4XSwgMTApLCBwYXJzZUludChkYXRlU2VjdGlvblttb250aEluZGV4XSwgMTApIC0gMSwgcGFyc2VJbnQoZGF0ZVNlY3Rpb25bZGF5SW5kZXhdLCAxMCkpO1xuXHQgICAgdmFyIGFtUG1TZWN0aW9uID0gc2VjdGlvbnMubGVuZ3RoID4gMiA/IHNlY3Rpb25zWzJdIDogbnVsbDtcblx0ICAgIGlmIChzZWN0aW9ucy5sZW5ndGggPiAxKSB7XG5cdCAgICAgICAgdmFyIHRpbWVTZWN0aW9uID0gc2VjdGlvbnNbMV0uc3BsaXQoJzonKTtcblx0ICAgICAgICB2YXIgaCA9IHRpbWVTZWN0aW9uLmxlbmd0aCA+IDAgPyBwYXJzZUludCh0aW1lU2VjdGlvblswXSwgMTApIDogMDtcblx0ICAgICAgICBkLnNldEhvdXJzKGFtUG1TZWN0aW9uICYmIGFtUG1TZWN0aW9uLnRvVXBwZXJDYXNlKCkgPT09ICdQTScgJiYgaCA8IDEyID8gaCArIDEyIDogaCk7XG5cdCAgICAgICAgZC5zZXRNaW51dGVzKHRpbWVTZWN0aW9uLmxlbmd0aCA+IDEgPyBwYXJzZUludCh0aW1lU2VjdGlvblsxXSwgMTApIDogMCk7XG5cdCAgICAgICAgZC5zZXRTZWNvbmRzKHRpbWVTZWN0aW9uLmxlbmd0aCA+IDIgPyBwYXJzZUludCh0aW1lU2VjdGlvblsyXSwgMTApIDogMCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gZDtcblx0fTtcblx0LyoqXG5cdCAqIEZvcm1hdCBkYXRlXG5cdCAqXG5cdCAqIEBwYXJhbSB7RGF0ZX0gaW5wdXQgVGhlIGRhdGUgb2JqZWN0IHRvIGZvcm1hdFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRGb3JtYXQgVGhlIGRhdGUgZm9ybWF0XG5cdCAqIFRoZSBmb3JtYXQgY2FuIGNvbnNpc3Qgb2YgdGhlIGZvbGxvd2luZyB0b2tlbnM6XG5cdCAqICAgICAgZCAgICAgICBEYXkgb2YgdGhlIG1vbnRoIHdpdGhvdXQgbGVhZGluZyB6ZXJvcyAoMSB0aHJvdWdoIDMxKVxuXHQgKiAgICAgIGRkICAgICAgRGF5IG9mIHRoZSBtb250aCB3aXRoIGxlYWRpbmcgemVyb3MgKDAxIHRocm91Z2ggMzEpXG5cdCAqICAgICAgbSAgICAgICBNb250aCB3aXRob3V0IGxlYWRpbmcgemVyb3MgKDEgdGhyb3VnaCAxMilcblx0ICogICAgICBtbSAgICAgIE1vbnRoIHdpdGggbGVhZGluZyB6ZXJvcyAoMDEgdGhyb3VnaCAxMilcblx0ICogICAgICB5eSAgICAgIExhc3QgdHdvIGRpZ2l0cyBvZiB5ZWFyIChmb3IgZXhhbXBsZTogMTQpXG5cdCAqICAgICAgeXl5eSAgICBGdWxsIGZvdXIgZGlnaXRzIG9mIHllYXIgKGZvciBleGFtcGxlOiAyMDE0KVxuXHQgKiAgICAgIGggICAgICAgSG91cnMgd2l0aG91dCBsZWFkaW5nIHplcm9zICgxIHRocm91Z2ggMTIpXG5cdCAqICAgICAgaGggICAgICBIb3VycyB3aXRoIGxlYWRpbmcgemVyb3MgKDAxIHRocm91Z2ggMTIpXG5cdCAqICAgICAgSCAgICAgICBIb3VycyB3aXRob3V0IGxlYWRpbmcgemVyb3MgKDAgdGhyb3VnaCAyMylcblx0ICogICAgICBISCAgICAgIEhvdXJzIHdpdGggbGVhZGluZyB6ZXJvcyAoMDAgdGhyb3VnaCAyMylcblx0ICogICAgICBNICAgICAgIE1pbnV0ZXMgd2l0aG91dCBsZWFkaW5nIHplcm9zICgwIHRocm91Z2ggNTkpXG5cdCAqICAgICAgTU0gICAgICBNaW51dGVzIHdpdGggbGVhZGluZyB6ZXJvcyAoMDAgdGhyb3VnaCA1OSlcblx0ICogICAgICBzICAgICAgIFNlY29uZHMgd2l0aG91dCBsZWFkaW5nIHplcm9zICgwIHRocm91Z2ggNTkpXG5cdCAqICAgICAgc3MgICAgICBTZWNvbmRzIHdpdGggbGVhZGluZyB6ZXJvcyAoMDAgdGhyb3VnaCA1OSlcblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0dmFyIGZvcm1hdERhdGUgPSBmdW5jdGlvbiAoaW5wdXQsIGlucHV0Rm9ybWF0KSB7XG5cdCAgICB2YXIgZGF0ZUZvcm1hdCA9IGlucHV0Rm9ybWF0XG5cdCAgICAgICAgLnJlcGxhY2UoL1kvZywgJ3knKVxuXHQgICAgICAgIC5yZXBsYWNlKC9NL2csICdtJylcblx0ICAgICAgICAucmVwbGFjZSgvRC9nLCAnZCcpXG5cdCAgICAgICAgLnJlcGxhY2UoLzptL2csICc6TScpXG5cdCAgICAgICAgLnJlcGxhY2UoLzptbS9nLCAnOk1NJylcblx0ICAgICAgICAucmVwbGFjZSgvOlMvLCAnOnMnKVxuXHQgICAgICAgIC5yZXBsYWNlKC86U1MvLCAnOnNzJyk7XG5cdCAgICB2YXIgZCA9IGlucHV0LmdldERhdGUoKTtcblx0ICAgIHZhciBkZCA9IGQgPCAxMCA/IFwiMFwiLmNvbmNhdChkKSA6IGQ7XG5cdCAgICB2YXIgbSA9IGlucHV0LmdldE1vbnRoKCkgKyAxO1xuXHQgICAgdmFyIG1tID0gbSA8IDEwID8gXCIwXCIuY29uY2F0KG0pIDogbTtcblx0ICAgIHZhciB5eSA9IFwiXCIuY29uY2F0KGlucHV0LmdldEZ1bGxZZWFyKCkpLnN1YnN0cigyKTtcblx0ICAgIHZhciB5eXl5ID0gaW5wdXQuZ2V0RnVsbFllYXIoKTtcblx0ICAgIHZhciBoID0gaW5wdXQuZ2V0SG91cnMoKSAlIDEyIHx8IDEyO1xuXHQgICAgdmFyIGhoID0gaCA8IDEwID8gXCIwXCIuY29uY2F0KGgpIDogaDtcblx0ICAgIHZhciBIID0gaW5wdXQuZ2V0SG91cnMoKTtcblx0ICAgIHZhciBISCA9IEggPCAxMCA/IFwiMFwiLmNvbmNhdChIKSA6IEg7XG5cdCAgICB2YXIgTSA9IGlucHV0LmdldE1pbnV0ZXMoKTtcblx0ICAgIHZhciBNTSA9IE0gPCAxMCA/IFwiMFwiLmNvbmNhdChNKSA6IE07XG5cdCAgICB2YXIgcyA9IGlucHV0LmdldFNlY29uZHMoKTtcblx0ICAgIHZhciBzcyA9IHMgPCAxMCA/IFwiMFwiLmNvbmNhdChzKSA6IHM7XG5cdCAgICB2YXIgcmVwbGFjZXIgPSB7XG5cdCAgICAgICAgSDogXCJcIi5jb25jYXQoSCksXG5cdCAgICAgICAgSEg6IFwiXCIuY29uY2F0KEhIKSxcblx0ICAgICAgICBNOiBcIlwiLmNvbmNhdChNKSxcblx0ICAgICAgICBNTTogXCJcIi5jb25jYXQoTU0pLFxuXHQgICAgICAgIGQ6IFwiXCIuY29uY2F0KGQpLFxuXHQgICAgICAgIGRkOiBcIlwiLmNvbmNhdChkZCksXG5cdCAgICAgICAgaDogXCJcIi5jb25jYXQoaCksXG5cdCAgICAgICAgaGg6IFwiXCIuY29uY2F0KGhoKSxcblx0ICAgICAgICBtOiBcIlwiLmNvbmNhdChtKSxcblx0ICAgICAgICBtbTogXCJcIi5jb25jYXQobW0pLFxuXHQgICAgICAgIHM6IFwiXCIuY29uY2F0KHMpLFxuXHQgICAgICAgIHNzOiBcIlwiLmNvbmNhdChzcyksXG5cdCAgICAgICAgeXk6IFwiXCIuY29uY2F0KHl5KSxcblx0ICAgICAgICB5eXl5OiBcIlwiLmNvbmNhdCh5eXl5KSxcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZGF0ZUZvcm1hdC5yZXBsYWNlKC9kezEsNH18bXsxLDR9fHl5KD86eXkpP3woW0hoTXNdKVxcMT98XCJbXlwiXSpcInwnW14nXSonL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuXHQgICAgICAgIHJldHVybiByZXBsYWNlclttYXRjaF0gPyByZXBsYWNlclttYXRjaF0gOiBtYXRjaC5zbGljZSgxLCBtYXRjaC5sZW5ndGggLSAxKTtcblx0ICAgIH0pO1xuXHR9O1xuXHR2YXIgZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChpbnB1dCkge1xuXHQgICAgICAgICAgICBpZiAoaW5wdXQudmFsdWUgPT09ICcnKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgIG1ldGE6IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZTogbnVsbCxcblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgIHZhbGlkOiB0cnVlLFxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIHtcblx0ICAgICAgICAgICAgICAgIC8vIEZvcmNlIHRoZSBmb3JtYXQgdG8gYFlZWVktTU0tRERgIGFzIHRoZSBkZWZhdWx0IGJyb3dzZXIgYmVoYXZpb3VyIHdoZW4gdXNpbmcgdHlwZT1cImRhdGVcIiBhdHRyaWJ1dGVcblx0ICAgICAgICAgICAgICAgIGZvcm1hdDogaW5wdXQuZWxlbWVudCAmJiBpbnB1dC5lbGVtZW50LmdldEF0dHJpYnV0ZSgndHlwZScpID09PSAnZGF0ZScgPyAnWVlZWS1NTS1ERCcgOiAnTU0vREQvWVlZWScsXG5cdCAgICAgICAgICAgICAgICBtZXNzYWdlOiAnJyxcblx0ICAgICAgICAgICAgfSwgcmVtb3ZlVW5kZWZpbmVkKGlucHV0Lm9wdGlvbnMpKTtcblx0ICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBpbnB1dC5sMTBuID8gaW5wdXQubDEwbi5kYXRlLmRlZmF1bHQgOiBvcHRzLm1lc3NhZ2U7XG5cdCAgICAgICAgICAgIHZhciBpbnZhbGlkUmVzdWx0ID0ge1xuXHQgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJcIi5jb25jYXQobWVzc2FnZSksXG5cdCAgICAgICAgICAgICAgICBtZXRhOiB7XG5cdCAgICAgICAgICAgICAgICAgICAgZGF0ZTogbnVsbCxcblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICB2YWxpZDogZmFsc2UsXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIHZhciBmb3JtYXRzID0gb3B0cy5mb3JtYXQuc3BsaXQoJyAnKTtcblx0ICAgICAgICAgICAgdmFyIHRpbWVGb3JtYXQgPSBmb3JtYXRzLmxlbmd0aCA+IDEgPyBmb3JtYXRzWzFdIDogbnVsbDtcblx0ICAgICAgICAgICAgdmFyIGFtT3JQbSA9IGZvcm1hdHMubGVuZ3RoID4gMiA/IGZvcm1hdHNbMl0gOiBudWxsO1xuXHQgICAgICAgICAgICB2YXIgc2VjdGlvbnMgPSBpbnB1dC52YWx1ZS5zcGxpdCgnICcpO1xuXHQgICAgICAgICAgICB2YXIgZGF0ZVNlY3Rpb24gPSBzZWN0aW9uc1swXTtcblx0ICAgICAgICAgICAgdmFyIHRpbWVTZWN0aW9uID0gc2VjdGlvbnMubGVuZ3RoID4gMSA/IHNlY3Rpb25zWzFdIDogbnVsbDtcblx0ICAgICAgICAgICAgdmFyIGFtUG1TZWN0aW9uID0gc2VjdGlvbnMubGVuZ3RoID4gMiA/IHNlY3Rpb25zWzJdIDogbnVsbDtcblx0ICAgICAgICAgICAgaWYgKGZvcm1hdHMubGVuZ3RoICE9PSBzZWN0aW9ucy5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBpbnZhbGlkUmVzdWx0O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vIERldGVybWluZSB0aGUgc2VwYXJhdG9yXG5cdCAgICAgICAgICAgIHZhciBzZXBhcmF0b3IgPSBvcHRzLnNlcGFyYXRvciB8fFxuXHQgICAgICAgICAgICAgICAgKGRhdGVTZWN0aW9uLmluZGV4T2YoJy8nKSAhPT0gLTFcblx0ICAgICAgICAgICAgICAgICAgICA/ICcvJ1xuXHQgICAgICAgICAgICAgICAgICAgIDogZGF0ZVNlY3Rpb24uaW5kZXhPZignLScpICE9PSAtMVxuXHQgICAgICAgICAgICAgICAgICAgICAgICA/ICctJ1xuXHQgICAgICAgICAgICAgICAgICAgICAgICA6IGRhdGVTZWN0aW9uLmluZGV4T2YoJy4nKSAhPT0gLTFcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJy4nXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICcvJyk7XG5cdCAgICAgICAgICAgIGlmIChzZXBhcmF0b3IgPT09IG51bGwgfHwgZGF0ZVNlY3Rpb24uaW5kZXhPZihzZXBhcmF0b3IpID09PSAtMSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGludmFsaWRSZXN1bHQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBkYXRlXG5cdCAgICAgICAgICAgIHZhciBkYXRlU3RyID0gZGF0ZVNlY3Rpb24uc3BsaXQoc2VwYXJhdG9yKTtcblx0ICAgICAgICAgICAgdmFyIGRhdGVGb3JtYXQgPSBmb3JtYXRzWzBdLnNwbGl0KHNlcGFyYXRvcik7XG5cdCAgICAgICAgICAgIGlmIChkYXRlU3RyLmxlbmd0aCAhPT0gZGF0ZUZvcm1hdC5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBpbnZhbGlkUmVzdWx0O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciB5ZWFyU3RyID0gZGF0ZVN0cltkYXRlRm9ybWF0LmluZGV4T2YoJ1lZWVknKV07XG5cdCAgICAgICAgICAgIHZhciBtb250aFN0ciA9IGRhdGVTdHJbZGF0ZUZvcm1hdC5pbmRleE9mKCdNTScpXTtcblx0ICAgICAgICAgICAgdmFyIGRheVN0ciA9IGRhdGVTdHJbZGF0ZUZvcm1hdC5pbmRleE9mKCdERCcpXTtcblx0ICAgICAgICAgICAgaWYgKCEvXlxcZCskLy50ZXN0KHllYXJTdHIpIHx8XG5cdCAgICAgICAgICAgICAgICAhL15cXGQrJC8udGVzdChtb250aFN0cikgfHxcblx0ICAgICAgICAgICAgICAgICEvXlxcZCskLy50ZXN0KGRheVN0cikgfHxcblx0ICAgICAgICAgICAgICAgIHllYXJTdHIubGVuZ3RoID4gNCB8fFxuXHQgICAgICAgICAgICAgICAgbW9udGhTdHIubGVuZ3RoID4gMiB8fFxuXHQgICAgICAgICAgICAgICAgZGF5U3RyLmxlbmd0aCA+IDIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBpbnZhbGlkUmVzdWx0O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciB5ZWFyID0gcGFyc2VJbnQoeWVhclN0ciwgMTApO1xuXHQgICAgICAgICAgICB2YXIgbW9udGggPSBwYXJzZUludChtb250aFN0ciwgMTApO1xuXHQgICAgICAgICAgICB2YXIgZGF5ID0gcGFyc2VJbnQoZGF5U3RyLCAxMCk7XG5cdCAgICAgICAgICAgIGlmICghaXNWYWxpZERhdGUoeWVhciwgbW9udGgsIGRheSkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBpbnZhbGlkUmVzdWx0O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vIERldGVybWluZSB0aGUgdGltZVxuXHQgICAgICAgICAgICB2YXIgZCA9IG5ldyBEYXRlKHllYXIsIG1vbnRoIC0gMSwgZGF5KTtcblx0ICAgICAgICAgICAgaWYgKHRpbWVGb3JtYXQpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBobXMgPSB0aW1lU2VjdGlvbi5zcGxpdCgnOicpO1xuXHQgICAgICAgICAgICAgICAgaWYgKHRpbWVGb3JtYXQuc3BsaXQoJzonKS5sZW5ndGggIT09IGhtcy5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW52YWxpZFJlc3VsdDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHZhciBoID0gaG1zLmxlbmd0aCA+IDAgPyAoaG1zWzBdLmxlbmd0aCA8PSAyICYmIC9eXFxkKyQvLnRlc3QoaG1zWzBdKSA/IHBhcnNlSW50KGhtc1swXSwgMTApIDogLTEpIDogMDtcblx0ICAgICAgICAgICAgICAgIHZhciBtID0gaG1zLmxlbmd0aCA+IDEgPyAoaG1zWzFdLmxlbmd0aCA8PSAyICYmIC9eXFxkKyQvLnRlc3QoaG1zWzFdKSA/IHBhcnNlSW50KGhtc1sxXSwgMTApIDogLTEpIDogMDtcblx0ICAgICAgICAgICAgICAgIHZhciBzID0gaG1zLmxlbmd0aCA+IDIgPyAoaG1zWzJdLmxlbmd0aCA8PSAyICYmIC9eXFxkKyQvLnRlc3QoaG1zWzJdKSA/IHBhcnNlSW50KGhtc1syXSwgMTApIDogLTEpIDogMDtcblx0ICAgICAgICAgICAgICAgIGlmIChoID09PSAtMSB8fCBtID09PSAtMSB8fCBzID09PSAtMSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnZhbGlkUmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgLy8gVmFsaWRhdGUgc2Vjb25kc1xuXHQgICAgICAgICAgICAgICAgaWYgKHMgPCAwIHx8IHMgPiA2MCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnZhbGlkUmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgLy8gVmFsaWRhdGUgaG91cnNcblx0ICAgICAgICAgICAgICAgIGlmIChoIDwgMCB8fCBoID49IDI0IHx8IChhbU9yUG0gJiYgaCA+IDEyKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnZhbGlkUmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgLy8gVmFsaWRhdGUgbWludXRlc1xuXHQgICAgICAgICAgICAgICAgaWYgKG0gPCAwIHx8IG0gPiA1OSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnZhbGlkUmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZC5zZXRIb3VycyhhbVBtU2VjdGlvbiAmJiBhbVBtU2VjdGlvbi50b1VwcGVyQ2FzZSgpID09PSAnUE0nICYmIGggPCAxMiA/IGggKyAxMiA6IGgpO1xuXHQgICAgICAgICAgICAgICAgZC5zZXRNaW51dGVzKG0pO1xuXHQgICAgICAgICAgICAgICAgZC5zZXRTZWNvbmRzKHMpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vIFZhbGlkYXRlIGRheSwgbW9udGgsIGFuZCB5ZWFyXG5cdCAgICAgICAgICAgIHZhciBtaW5PcHRpb24gPSB0eXBlb2Ygb3B0cy5taW4gPT09ICdmdW5jdGlvbicgPyBvcHRzLm1pbigpIDogb3B0cy5taW47XG5cdCAgICAgICAgICAgIHZhciBtaW4gPSBtaW5PcHRpb24gaW5zdGFuY2VvZiBEYXRlXG5cdCAgICAgICAgICAgICAgICA/IG1pbk9wdGlvblxuXHQgICAgICAgICAgICAgICAgOiBtaW5PcHRpb25cblx0ICAgICAgICAgICAgICAgICAgICA/IHBhcnNlRGF0ZShtaW5PcHRpb24sIGRhdGVGb3JtYXQsIHNlcGFyYXRvcilcblx0ICAgICAgICAgICAgICAgICAgICA6IGQ7XG5cdCAgICAgICAgICAgIHZhciBtYXhPcHRpb24gPSB0eXBlb2Ygb3B0cy5tYXggPT09ICdmdW5jdGlvbicgPyBvcHRzLm1heCgpIDogb3B0cy5tYXg7XG5cdCAgICAgICAgICAgIHZhciBtYXggPSBtYXhPcHRpb24gaW5zdGFuY2VvZiBEYXRlXG5cdCAgICAgICAgICAgICAgICA/IG1heE9wdGlvblxuXHQgICAgICAgICAgICAgICAgOiBtYXhPcHRpb25cblx0ICAgICAgICAgICAgICAgICAgICA/IHBhcnNlRGF0ZShtYXhPcHRpb24sIGRhdGVGb3JtYXQsIHNlcGFyYXRvcilcblx0ICAgICAgICAgICAgICAgICAgICA6IGQ7XG5cdCAgICAgICAgICAgIC8vIEluIG9yZGVyIHRvIGF2b2lkIGRpc3BsYXlpbmcgYSBkYXRlIHN0cmluZyBsaWtlIFwiTW9uIERlYyAwOCAyMDE0IDE5OjE0OjEyIEdNVCswMDAwIChXRVQpXCJcblx0ICAgICAgICAgICAgdmFyIG1pbk9wdGlvblN0ciA9IG1pbk9wdGlvbiBpbnN0YW5jZW9mIERhdGUgPyBmb3JtYXREYXRlKG1pbiwgb3B0cy5mb3JtYXQpIDogbWluT3B0aW9uO1xuXHQgICAgICAgICAgICB2YXIgbWF4T3B0aW9uU3RyID0gbWF4T3B0aW9uIGluc3RhbmNlb2YgRGF0ZSA/IGZvcm1hdERhdGUobWF4LCBvcHRzLmZvcm1hdCkgOiBtYXhPcHRpb247XG5cdCAgICAgICAgICAgIHN3aXRjaCAodHJ1ZSkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSAhIW1pbk9wdGlvblN0ciAmJiAhbWF4T3B0aW9uU3RyOlxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGZvcm1hdChpbnB1dC5sMTBuID8gaW5wdXQubDEwbi5kYXRlLm1pbiA6IG1lc3NhZ2UsIG1pbk9wdGlvblN0ciksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG1ldGE6IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGU6IGQsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkOiBkLmdldFRpbWUoKSA+PSBtaW4uZ2V0VGltZSgpLFxuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICBjYXNlICEhbWF4T3B0aW9uU3RyICYmICFtaW5PcHRpb25TdHI6XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZm9ybWF0KGlucHV0LmwxMG4gPyBpbnB1dC5sMTBuLmRhdGUubWF4IDogbWVzc2FnZSwgbWF4T3B0aW9uU3RyKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbWV0YToge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZTogZCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQ6IGQuZ2V0VGltZSgpIDw9IG1heC5nZXRUaW1lKCksXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgISFtYXhPcHRpb25TdHIgJiYgISFtaW5PcHRpb25TdHI6XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZm9ybWF0KGlucHV0LmwxMG4gPyBpbnB1dC5sMTBuLmRhdGUucmFuZ2UgOiBtZXNzYWdlLCBbbWluT3B0aW9uU3RyLCBtYXhPcHRpb25TdHJdKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbWV0YToge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZTogZCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQ6IGQuZ2V0VGltZSgpIDw9IG1heC5nZXRUaW1lKCkgJiYgZC5nZXRUaW1lKCkgPj0gbWluLmdldFRpbWUoKSxcblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIlwiLmNvbmNhdChtZXNzYWdlKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbWV0YToge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZTogZCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQ6IHRydWUsXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICB9O1xuXHR9O1xuXG5cdGNqcyRoLmRhdGUgPSBkYXRlO1xuXHRyZXR1cm4gY2pzJGg7XG59XG5cbi8qKlxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgIGxpYiRoLmV4cG9ydHMgPSByZXF1aXJlSW5kZXhfbWluJGgoKTtcbn0gZWxzZSB7XG4gICAgbGliJGguZXhwb3J0cyA9IHJlcXVpcmVDanMkaCgpO1xufVxuXG52YXIgbGliRXhwb3J0cyRoID0gbGliJGguZXhwb3J0cztcblxudmFyIGxpYiRnID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIGluZGV4X21pbiRnID0ge307XG5cbi8qKiBcbiAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG4gKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKlxuICogQGxpY2Vuc2UgaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pby9saWNlbnNlXG4gKiBAcGFja2FnZSBAZm9ybS12YWxpZGF0aW9uL3ZhbGlkYXRvci1kaWZmZXJlbnRcbiAqIEB2ZXJzaW9uIDIuNC4wXG4gKi9cblxudmFyIGhhc1JlcXVpcmVkSW5kZXhfbWluJGc7XG5cbmZ1bmN0aW9uIHJlcXVpcmVJbmRleF9taW4kZyAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEluZGV4X21pbiRnKSByZXR1cm4gaW5kZXhfbWluJGc7XG5cdGhhc1JlcXVpcmVkSW5kZXhfbWluJGcgPSAxO1xuaW5kZXhfbWluJGcuZGlmZmVyZW50PWZ1bmN0aW9uKCl7cmV0dXJuIHt2YWxpZGF0ZTpmdW5jdGlvbih0KXt2YXIgbz1cImZ1bmN0aW9uXCI9PXR5cGVvZiB0Lm9wdGlvbnMuY29tcGFyZT90Lm9wdGlvbnMuY29tcGFyZS5jYWxsKHRoaXMpOnQub3B0aW9ucy5jb21wYXJlO3JldHVybiB7dmFsaWQ6XCJcIj09PW98fHQudmFsdWUhPT1vfX19fTtcblx0cmV0dXJuIGluZGV4X21pbiRnO1xufVxuXG52YXIgY2pzJGcgPSB7fTtcblxudmFyIGhhc1JlcXVpcmVkQ2pzJGc7XG5cbmZ1bmN0aW9uIHJlcXVpcmVDanMkZyAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZENqcyRnKSByZXR1cm4gY2pzJGc7XG5cdGhhc1JlcXVpcmVkQ2pzJGcgPSAxO1xuXG5cdC8qKlxuXHQgKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcblx0ICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG5cdCAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZmZlcmVudCgpIHtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChpbnB1dCkge1xuXHQgICAgICAgICAgICB2YXIgY29tcGFyZVdpdGggPSAnZnVuY3Rpb24nID09PSB0eXBlb2YgaW5wdXQub3B0aW9ucy5jb21wYXJlXG5cdCAgICAgICAgICAgICAgICA/IGlucHV0Lm9wdGlvbnMuY29tcGFyZS5jYWxsKHRoaXMpXG5cdCAgICAgICAgICAgICAgICA6IGlucHV0Lm9wdGlvbnMuY29tcGFyZTtcblx0ICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgIHZhbGlkOiBjb21wYXJlV2l0aCA9PT0gJycgfHwgaW5wdXQudmFsdWUgIT09IGNvbXBhcmVXaXRoLFxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH0sXG5cdCAgICB9O1xuXHR9XG5cblx0Y2pzJGcuZGlmZmVyZW50ID0gZGlmZmVyZW50O1xuXHRyZXR1cm4gY2pzJGc7XG59XG5cbi8qKlxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgIGxpYiRnLmV4cG9ydHMgPSByZXF1aXJlSW5kZXhfbWluJGcoKTtcbn0gZWxzZSB7XG4gICAgbGliJGcuZXhwb3J0cyA9IHJlcXVpcmVDanMkZygpO1xufVxuXG52YXIgbGliRXhwb3J0cyRnID0gbGliJGcuZXhwb3J0cztcblxudmFyIGxpYiRmID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIGluZGV4X21pbiRmID0ge307XG5cbi8qKiBcbiAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG4gKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKlxuICogQGxpY2Vuc2UgaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pby9saWNlbnNlXG4gKiBAcGFja2FnZSBAZm9ybS12YWxpZGF0aW9uL3ZhbGlkYXRvci1kaWdpdHNcbiAqIEB2ZXJzaW9uIDIuNC4wXG4gKi9cblxudmFyIGhhc1JlcXVpcmVkSW5kZXhfbWluJGY7XG5cbmZ1bmN0aW9uIHJlcXVpcmVJbmRleF9taW4kZiAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEluZGV4X21pbiRmKSByZXR1cm4gaW5kZXhfbWluJGY7XG5cdGhhc1JlcXVpcmVkSW5kZXhfbWluJGYgPSAxO1xuaW5kZXhfbWluJGYuZGlnaXRzPWZ1bmN0aW9uKCl7cmV0dXJuIHt2YWxpZGF0ZTpmdW5jdGlvbih0KXtyZXR1cm4ge3ZhbGlkOlwiXCI9PT10LnZhbHVlfHwvXlxcZCskLy50ZXN0KHQudmFsdWUpfX19fTtcblx0cmV0dXJuIGluZGV4X21pbiRmO1xufVxuXG52YXIgY2pzJGYgPSB7fTtcblxudmFyIGhhc1JlcXVpcmVkQ2pzJGY7XG5cbmZ1bmN0aW9uIHJlcXVpcmVDanMkZiAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZENqcyRmKSByZXR1cm4gY2pzJGY7XG5cdGhhc1JlcXVpcmVkQ2pzJGYgPSAxO1xuXG5cdC8qKlxuXHQgKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcblx0ICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG5cdCAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0cygpIHtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmV0dXJuIHRydWUgaWYgdGhlIGlucHV0IHZhbHVlIGNvbnRhaW5zIGRpZ2l0cyBvbmx5XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChpbnB1dCkge1xuXHQgICAgICAgICAgICByZXR1cm4geyB2YWxpZDogaW5wdXQudmFsdWUgPT09ICcnIHx8IC9eXFxkKyQvLnRlc3QoaW5wdXQudmFsdWUpIH07XG5cdCAgICAgICAgfSxcblx0ICAgIH07XG5cdH1cblxuXHRjanMkZi5kaWdpdHMgPSBkaWdpdHM7XG5cdHJldHVybiBjanMkZjtcbn1cblxuLyoqXG4gKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcbiAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgbGliJGYuZXhwb3J0cyA9IHJlcXVpcmVJbmRleF9taW4kZigpO1xufSBlbHNlIHtcbiAgICBsaWIkZi5leHBvcnRzID0gcmVxdWlyZUNqcyRmKCk7XG59XG5cbnZhciBsaWJFeHBvcnRzJGYgPSBsaWIkZi5leHBvcnRzO1xuXG52YXIgbGliJGUgPSB7ZXhwb3J0czoge319O1xuXG52YXIgaW5kZXhfbWluJGUgPSB7fTtcblxuLyoqIFxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqXG4gKiBAbGljZW5zZSBodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvL2xpY2Vuc2VcbiAqIEBwYWNrYWdlIEBmb3JtLXZhbGlkYXRpb24vdmFsaWRhdG9yLWVtYWlsLWFkZHJlc3NcbiAqIEB2ZXJzaW9uIDIuNC4wXG4gKi9cblxudmFyIGhhc1JlcXVpcmVkSW5kZXhfbWluJGU7XG5cbmZ1bmN0aW9uIHJlcXVpcmVJbmRleF9taW4kZSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEluZGV4X21pbiRlKSByZXR1cm4gaW5kZXhfbWluJGU7XG5cdGhhc1JlcXVpcmVkSW5kZXhfbWluJGUgPSAxO1xudmFyIGU9bGliRXhwb3J0cyRCLnV0aWxzLnJlbW92ZVVuZGVmaW5lZCxhPS9eKChbXjw+KClbXFxdXFxcXC4sOzpcXHNAXCJdKyhcXC5bXjw+KClbXFxdXFxcXC4sOzpcXHNAXCJdKykqKXwoXCIuK1wiKSlAW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSokLyxyPS9eKChbXjw+KClbXFxdXFxcXC4sOzpcXHNAXCJdKyhcXC5bXjw+KClbXFxdXFxcXC4sOzpcXHNAXCJdKykqKXwoXCIuK1wiKSlAW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSskLztpbmRleF9taW4kZS5lbWFpbEFkZHJlc3M9ZnVuY3Rpb24oKXtyZXR1cm4ge3ZhbGlkYXRlOmZ1bmN0aW9uKHQpe2lmKFwiXCI9PT10LnZhbHVlKXJldHVybiB7dmFsaWQ6ITB9O3ZhciBpPU9iamVjdC5hc3NpZ24oe30se211bHRpcGxlOiExLHJlcXVpcmVHbG9iYWxEb21haW46ITEsc2VwYXJhdG9yOi9bLDtdL30sZSh0Lm9wdGlvbnMpKSxsPWkucmVxdWlyZUdsb2JhbERvbWFpbj9yOmE7aWYoITA9PT1pLm11bHRpcGxlfHxcInRydWVcIj09PVwiXCIuY29uY2F0KGkubXVsdGlwbGUpKXtmb3IodmFyIHM9aS5zZXBhcmF0b3J8fC9bLDtdLyx1PWZ1bmN0aW9uKGUsYSl7Zm9yKHZhciByPWUuc3BsaXQoL1wiLyksdD1yLmxlbmd0aCxpPVtdLGw9XCJcIixzPTA7czx0O3MrKylpZihzJTI9PTApe3ZhciB1PXJbc10uc3BsaXQoYSksbj11Lmxlbmd0aDtpZigxPT09bilsKz11WzBdO2Vsc2Uge2kucHVzaChsK3VbMF0pO2Zvcih2YXIgbz0xO288bi0xO28rKylpLnB1c2godVtvXSk7bD11W24tMV07fX1lbHNlIGwrPSdcIicrcltzXSxzPHQtMSYmKGwrPSdcIicpO3JldHVybiBpLnB1c2gobCksaX0odC52YWx1ZSxzKSxuPXUubGVuZ3RoLG89MDtvPG47bysrKWlmKCFsLnRlc3QodVtvXSkpcmV0dXJuIHt2YWxpZDohMX07cmV0dXJuIHt2YWxpZDohMH19cmV0dXJuIHt2YWxpZDpsLnRlc3QodC52YWx1ZSl9fX19O1xuXHRyZXR1cm4gaW5kZXhfbWluJGU7XG59XG5cbnZhciBjanMkZSA9IHt9O1xuXG52YXIgaGFzUmVxdWlyZWRDanMkZTtcblxuZnVuY3Rpb24gcmVxdWlyZUNqcyRlICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkQ2pzJGUpIHJldHVybiBjanMkZTtcblx0aGFzUmVxdWlyZWRDanMkZSA9IDE7XG5cblx0dmFyIGNvcmUgPSBsaWJFeHBvcnRzJEI7XG5cblx0LyoqXG5cdCAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuXHQgKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcblx0ICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuXHQgKi9cblx0dmFyIHJlbW92ZVVuZGVmaW5lZCA9IGNvcmUudXRpbHMucmVtb3ZlVW5kZWZpbmVkO1xuXHQvLyBFbWFpbCBhZGRyZXNzIHJlZ3VsYXIgZXhwcmVzc2lvblxuXHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ2MTU1L3ZhbGlkYXRlLWVtYWlsLWFkZHJlc3MtaW4tamF2YXNjcmlwdFxuXHR2YXIgR0xPQkFMX0RPTUFJTl9PUFRJT05BTCA9IC9eKChbXjw+KClbXFxdXFxcXC4sOzpcXHNAXCJdKyhcXC5bXjw+KClbXFxdXFxcXC4sOzpcXHNAXCJdKykqKXwoXCIuK1wiKSlAW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSokLztcblx0dmFyIEdMT0JBTF9ET01BSU5fUkVRVUlSRUQgPSAvXigoW148PigpW1xcXVxcXFwuLDs6XFxzQFwiXSsoXFwuW148PigpW1xcXVxcXFwuLDs6XFxzQFwiXSspKil8KFwiLitcIikpQFthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcLlthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPykrJC87XG5cdGZ1bmN0aW9uIGVtYWlsQWRkcmVzcygpIHtcblx0ICAgIHZhciBzcGxpdEVtYWlsQWRkcmVzc2VzID0gZnVuY3Rpb24gKGVtYWlsQWRkcmVzc2VzLCBzZXBhcmF0b3IpIHtcblx0ICAgICAgICB2YXIgcXVvdGVkRnJhZ21lbnRzID0gZW1haWxBZGRyZXNzZXMuc3BsaXQoL1wiLyk7XG5cdCAgICAgICAgdmFyIHF1b3RlZEZyYWdtZW50Q291bnQgPSBxdW90ZWRGcmFnbWVudHMubGVuZ3RoO1xuXHQgICAgICAgIHZhciBlbWFpbEFkZHJlc3NBcnJheSA9IFtdO1xuXHQgICAgICAgIHZhciBuZXh0RW1haWxBZGRyZXNzID0gJyc7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdW90ZWRGcmFnbWVudENvdW50OyBpKyspIHtcblx0ICAgICAgICAgICAgaWYgKGkgJSAyID09PSAwKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgc3BsaXRFbWFpbEFkZHJlc3NGcmFnbWVudHMgPSBxdW90ZWRGcmFnbWVudHNbaV0uc3BsaXQoc2VwYXJhdG9yKTtcblx0ICAgICAgICAgICAgICAgIHZhciBzcGxpdEVtYWlsQWRkcmVzc0ZyYWdtZW50Q291bnQgPSBzcGxpdEVtYWlsQWRkcmVzc0ZyYWdtZW50cy5sZW5ndGg7XG5cdCAgICAgICAgICAgICAgICBpZiAoc3BsaXRFbWFpbEFkZHJlc3NGcmFnbWVudENvdW50ID09PSAxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbmV4dEVtYWlsQWRkcmVzcyArPSBzcGxpdEVtYWlsQWRkcmVzc0ZyYWdtZW50c1swXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIGVtYWlsQWRkcmVzc0FycmF5LnB1c2gobmV4dEVtYWlsQWRkcmVzcyArIHNwbGl0RW1haWxBZGRyZXNzRnJhZ21lbnRzWzBdKTtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IHNwbGl0RW1haWxBZGRyZXNzRnJhZ21lbnRDb3VudCAtIDE7IGorKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbWFpbEFkZHJlc3NBcnJheS5wdXNoKHNwbGl0RW1haWxBZGRyZXNzRnJhZ21lbnRzW2pdKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgbmV4dEVtYWlsQWRkcmVzcyA9IHNwbGl0RW1haWxBZGRyZXNzRnJhZ21lbnRzW3NwbGl0RW1haWxBZGRyZXNzRnJhZ21lbnRDb3VudCAtIDFdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgbmV4dEVtYWlsQWRkcmVzcyArPSAnXCInICsgcXVvdGVkRnJhZ21lbnRzW2ldO1xuXHQgICAgICAgICAgICAgICAgaWYgKGkgPCBxdW90ZWRGcmFnbWVudENvdW50IC0gMSkge1xuXHQgICAgICAgICAgICAgICAgICAgIG5leHRFbWFpbEFkZHJlc3MgKz0gJ1wiJztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBlbWFpbEFkZHJlc3NBcnJheS5wdXNoKG5leHRFbWFpbEFkZHJlc3MpO1xuXHQgICAgICAgIHJldHVybiBlbWFpbEFkZHJlc3NBcnJheTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJldHVybiB0cnVlIGlmIGFuZCBvbmx5IGlmIHRoZSBpbnB1dCB2YWx1ZSBpcyBhIHZhbGlkIGVtYWlsIGFkZHJlc3Ncblx0ICAgICAgICAgKi9cblx0ICAgICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKGlucHV0KSB7XG5cdCAgICAgICAgICAgIGlmIChpbnB1dC52YWx1ZSA9PT0gJycpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlIH07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCB7XG5cdCAgICAgICAgICAgICAgICBtdWx0aXBsZTogZmFsc2UsXG5cdCAgICAgICAgICAgICAgICByZXF1aXJlR2xvYmFsRG9tYWluOiBmYWxzZSxcblx0ICAgICAgICAgICAgICAgIHNlcGFyYXRvcjogL1ssO10vLFxuXHQgICAgICAgICAgICB9LCByZW1vdmVVbmRlZmluZWQoaW5wdXQub3B0aW9ucykpO1xuXHQgICAgICAgICAgICB2YXIgZW1haWxSZWdFeHAgPSBvcHRzLnJlcXVpcmVHbG9iYWxEb21haW4gPyBHTE9CQUxfRE9NQUlOX1JFUVVJUkVEIDogR0xPQkFMX0RPTUFJTl9PUFRJT05BTDtcblx0ICAgICAgICAgICAgdmFyIGFsbG93TXVsdGlwbGUgPSBvcHRzLm11bHRpcGxlID09PSB0cnVlIHx8IFwiXCIuY29uY2F0KG9wdHMubXVsdGlwbGUpID09PSAndHJ1ZSc7XG5cdCAgICAgICAgICAgIGlmIChhbGxvd011bHRpcGxlKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgc2VwYXJhdG9yID0gb3B0cy5zZXBhcmF0b3IgfHwgL1ssO10vO1xuXHQgICAgICAgICAgICAgICAgdmFyIGFkZHJlc3NlcyA9IHNwbGl0RW1haWxBZGRyZXNzZXMoaW5wdXQudmFsdWUsIHNlcGFyYXRvcik7XG5cdCAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoXzEgPSBhZGRyZXNzZXMubGVuZ3RoO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGhfMTsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFlbWFpbFJlZ0V4cC50ZXN0KGFkZHJlc3Nlc1tpXSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUgfTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBlbWFpbFJlZ0V4cC50ZXN0KGlucHV0LnZhbHVlKSB9O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgIH07XG5cdH1cblxuXHRjanMkZS5lbWFpbEFkZHJlc3MgPSBlbWFpbEFkZHJlc3M7XG5cdHJldHVybiBjanMkZTtcbn1cblxuLyoqXG4gKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcbiAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgbGliJGUuZXhwb3J0cyA9IHJlcXVpcmVJbmRleF9taW4kZSgpO1xufSBlbHNlIHtcbiAgICBsaWIkZS5leHBvcnRzID0gcmVxdWlyZUNqcyRlKCk7XG59XG5cbnZhciBsaWJFeHBvcnRzJGUgPSBsaWIkZS5leHBvcnRzO1xuXG52YXIgbGliJGQgPSB7ZXhwb3J0czoge319O1xuXG52YXIgaW5kZXhfbWluJGQgPSB7fTtcblxuLyoqIFxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqXG4gKiBAbGljZW5zZSBodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvL2xpY2Vuc2VcbiAqIEBwYWNrYWdlIEBmb3JtLXZhbGlkYXRpb24vdmFsaWRhdG9yLWZpbGVcbiAqIEB2ZXJzaW9uIDIuNC4wXG4gKi9cblxudmFyIGhhc1JlcXVpcmVkSW5kZXhfbWluJGQ7XG5cbmZ1bmN0aW9uIHJlcXVpcmVJbmRleF9taW4kZCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEluZGV4X21pbiRkKSByZXR1cm4gaW5kZXhfbWluJGQ7XG5cdGhhc1JlcXVpcmVkSW5kZXhfbWluJGQgPSAxO1xudmFyIGU9ZnVuY3Rpb24oZSl7cmV0dXJuIC0xPT09ZS5pbmRleE9mKFwiLlwiKT9lOmUuc3BsaXQoXCIuXCIpLnNsaWNlKDAsLTEpLmpvaW4oXCIuXCIpfTtpbmRleF9taW4kZC5maWxlPWZ1bmN0aW9uKCl7cmV0dXJuIHt2YWxpZGF0ZTpmdW5jdGlvbih0KXtpZihcIlwiPT09dC52YWx1ZSlyZXR1cm4ge3ZhbGlkOiEwfTt2YXIgaSxuLGE9dC5vcHRpb25zLmV4dGVuc2lvbj90Lm9wdGlvbnMuZXh0ZW5zaW9uLnRvTG93ZXJDYXNlKCkuc3BsaXQoXCIsXCIpLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIGUudHJpbSgpfSkpOltdLHI9dC5vcHRpb25zLnR5cGU/dC5vcHRpb25zLnR5cGUudG9Mb3dlckNhc2UoKS5zcGxpdChcIixcIikubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gZS50cmltKCl9KSk6W107aWYod2luZG93LkZpbGUmJndpbmRvdy5GaWxlTGlzdCYmd2luZG93LkZpbGVSZWFkZXIpe3ZhciBvPXQuZWxlbWVudC5maWxlcyxzPW8ubGVuZ3RoLGw9MDtpZih0Lm9wdGlvbnMubWF4RmlsZXMmJnM+cGFyc2VJbnQoXCJcIi5jb25jYXQodC5vcHRpb25zLm1heEZpbGVzKSwxMCkpcmV0dXJuIHttZXRhOntlcnJvcjpcIklOVkFMSURfTUFYX0ZJTEVTXCJ9LHZhbGlkOiExfTtpZih0Lm9wdGlvbnMubWluRmlsZXMmJnM8cGFyc2VJbnQoXCJcIi5jb25jYXQodC5vcHRpb25zLm1pbkZpbGVzKSwxMCkpcmV0dXJuIHttZXRhOntlcnJvcjpcIklOVkFMSURfTUlOX0ZJTEVTXCJ9LHZhbGlkOiExfTtmb3IodmFyIEk9e30scD0wO3A8cztwKyspe2lmKGwrPW9bcF0uc2l6ZSxJPXtleHQ6aT1vW3BdLm5hbWUuc3Vic3RyKG9bcF0ubmFtZS5sYXN0SW5kZXhPZihcIi5cIikrMSksZmlsZTpvW3BdLHNpemU6b1twXS5zaXplLHR5cGU6b1twXS50eXBlfSx0Lm9wdGlvbnMubWluU2l6ZSYmb1twXS5zaXplPHBhcnNlSW50KFwiXCIuY29uY2F0KHQub3B0aW9ucy5taW5TaXplKSwxMCkpcmV0dXJuIHttZXRhOk9iamVjdC5hc3NpZ24oe30se2Vycm9yOlwiSU5WQUxJRF9NSU5fU0laRVwifSxJKSx2YWxpZDohMX07aWYodC5vcHRpb25zLm1heFNpemUmJm9bcF0uc2l6ZT5wYXJzZUludChcIlwiLmNvbmNhdCh0Lm9wdGlvbnMubWF4U2l6ZSksMTApKXJldHVybiB7bWV0YTpPYmplY3QuYXNzaWduKHt9LHtlcnJvcjpcIklOVkFMSURfTUFYX1NJWkVcIn0sSSksdmFsaWQ6ITF9O2lmKGEubGVuZ3RoPjAmJi0xPT09YS5pbmRleE9mKGkudG9Mb3dlckNhc2UoKSkpcmV0dXJuIHttZXRhOk9iamVjdC5hc3NpZ24oe30se2Vycm9yOlwiSU5WQUxJRF9FWFRFTlNJT05cIn0sSSksdmFsaWQ6ITF9O2lmKHIubGVuZ3RoPjAmJm9bcF0udHlwZSYmLTE9PT1yLmluZGV4T2Yob1twXS50eXBlLnRvTG93ZXJDYXNlKCkpKXJldHVybiB7bWV0YTpPYmplY3QuYXNzaWduKHt9LHtlcnJvcjpcIklOVkFMSURfVFlQRVwifSxJKSx2YWxpZDohMX07aWYodC5vcHRpb25zLnZhbGlkYXRlRmlsZU5hbWUmJiF0Lm9wdGlvbnMudmFsaWRhdGVGaWxlTmFtZShlKG9bcF0ubmFtZSkpKXJldHVybiB7bWV0YTpPYmplY3QuYXNzaWduKHt9LHtlcnJvcjpcIklOVkFMSURfTkFNRVwifSxJKSx2YWxpZDohMX19aWYodC5vcHRpb25zLm1heFRvdGFsU2l6ZSYmbD5wYXJzZUludChcIlwiLmNvbmNhdCh0Lm9wdGlvbnMubWF4VG90YWxTaXplKSwxMCkpcmV0dXJuIHttZXRhOk9iamVjdC5hc3NpZ24oe30se2Vycm9yOlwiSU5WQUxJRF9NQVhfVE9UQUxfU0laRVwiLHRvdGFsU2l6ZTpsfSxJKSx2YWxpZDohMX07aWYodC5vcHRpb25zLm1pblRvdGFsU2l6ZSYmbDxwYXJzZUludChcIlwiLmNvbmNhdCh0Lm9wdGlvbnMubWluVG90YWxTaXplKSwxMCkpcmV0dXJuIHttZXRhOk9iamVjdC5hc3NpZ24oe30se2Vycm9yOlwiSU5WQUxJRF9NSU5fVE9UQUxfU0laRVwiLHRvdGFsU2l6ZTpsfSxJKSx2YWxpZDohMX19ZWxzZSB7aWYoaT10LnZhbHVlLnN1YnN0cih0LnZhbHVlLmxhc3RJbmRleE9mKFwiLlwiKSsxKSxhLmxlbmd0aD4wJiYtMT09PWEuaW5kZXhPZihpLnRvTG93ZXJDYXNlKCkpKXJldHVybiB7bWV0YTp7ZXJyb3I6XCJJTlZBTElEX0VYVEVOU0lPTlwiLGV4dDppfSx2YWxpZDohMX07aWYobj1lKHQudmFsdWUpLHQub3B0aW9ucy52YWxpZGF0ZUZpbGVOYW1lJiYhdC5vcHRpb25zLnZhbGlkYXRlRmlsZU5hbWUobikpcmV0dXJuIHttZXRhOntlcnJvcjpcIklOVkFMSURfTkFNRVwiLG5hbWU6bn0sdmFsaWQ6ITF9fXJldHVybiB7dmFsaWQ6ITB9fX19O1xuXHRyZXR1cm4gaW5kZXhfbWluJGQ7XG59XG5cbnZhciBjanMkZCA9IHt9O1xuXG52YXIgaGFzUmVxdWlyZWRDanMkZDtcblxuZnVuY3Rpb24gcmVxdWlyZUNqcyRkICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkQ2pzJGQpIHJldHVybiBjanMkZDtcblx0aGFzUmVxdWlyZWRDanMkZCA9IDE7XG5cblx0LyoqXG5cdCAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuXHQgKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcblx0ICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuXHQgKi9cblx0Ly8gR2V0IHRoZSBmaWxlIG5hbWUgd2l0aG91dCBleHRlbnNpb25cblx0dmFyIGdldEZpbGVOYW1lID0gZnVuY3Rpb24gKGZpbGVOYW1lKSB7XG5cdCAgICByZXR1cm4gZmlsZU5hbWUuaW5kZXhPZignLicpID09PSAtMSA/IGZpbGVOYW1lIDogZmlsZU5hbWUuc3BsaXQoJy4nKS5zbGljZSgwLCAtMSkuam9pbignLicpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcblx0ICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG5cdCAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cblx0ICovXG5cdGZ1bmN0aW9uIGZpbGUoKSB7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoaW5wdXQpIHtcblx0ICAgICAgICAgICAgaWYgKGlucHV0LnZhbHVlID09PSAnJykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUgfTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgZXh0ZW5zaW9uO1xuXHQgICAgICAgICAgICB2YXIgbmFtZTtcblx0ICAgICAgICAgICAgdmFyIGV4dGVuc2lvbnMgPSBpbnB1dC5vcHRpb25zLmV4dGVuc2lvblxuXHQgICAgICAgICAgICAgICAgPyBpbnB1dC5vcHRpb25zLmV4dGVuc2lvblxuXHQgICAgICAgICAgICAgICAgICAgIC50b0xvd2VyQ2FzZSgpXG5cdCAgICAgICAgICAgICAgICAgICAgLnNwbGl0KCcsJylcblx0ICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtLnRyaW0oKTsgfSlcblx0ICAgICAgICAgICAgICAgIDogW107XG5cdCAgICAgICAgICAgIHZhciB0eXBlcyA9IGlucHV0Lm9wdGlvbnMudHlwZVxuXHQgICAgICAgICAgICAgICAgPyBpbnB1dC5vcHRpb25zLnR5cGVcblx0ICAgICAgICAgICAgICAgICAgICAudG9Mb3dlckNhc2UoKVxuXHQgICAgICAgICAgICAgICAgICAgIC5zcGxpdCgnLCcpXG5cdCAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS50cmltKCk7IH0pXG5cdCAgICAgICAgICAgICAgICA6IFtdO1xuXHQgICAgICAgICAgICB2YXIgaHRtbDUgPSB3aW5kb3dbJ0ZpbGUnXSAmJiB3aW5kb3dbJ0ZpbGVMaXN0J10gJiYgd2luZG93WydGaWxlUmVhZGVyJ107XG5cdCAgICAgICAgICAgIGlmIChodG1sNSkge1xuXHQgICAgICAgICAgICAgICAgLy8gR2V0IEZpbGVMaXN0IGluc3RhbmNlXG5cdCAgICAgICAgICAgICAgICB2YXIgZmlsZXMgPSBpbnB1dC5lbGVtZW50LmZpbGVzO1xuXHQgICAgICAgICAgICAgICAgdmFyIHRvdGFsID0gZmlsZXMubGVuZ3RoO1xuXHQgICAgICAgICAgICAgICAgdmFyIGFsbFNpemUgPSAwO1xuXHQgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIG1heEZpbGVzXG5cdCAgICAgICAgICAgICAgICBpZiAoaW5wdXQub3B0aW9ucy5tYXhGaWxlcyAmJiB0b3RhbCA+IHBhcnNlSW50KFwiXCIuY29uY2F0KGlucHV0Lm9wdGlvbnMubWF4RmlsZXMpLCAxMCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBtZXRhOiB7IGVycm9yOiAnSU5WQUxJRF9NQVhfRklMRVMnIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkOiBmYWxzZSxcblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIG1pbkZpbGVzXG5cdCAgICAgICAgICAgICAgICBpZiAoaW5wdXQub3B0aW9ucy5taW5GaWxlcyAmJiB0b3RhbCA8IHBhcnNlSW50KFwiXCIuY29uY2F0KGlucHV0Lm9wdGlvbnMubWluRmlsZXMpLCAxMCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBtZXRhOiB7IGVycm9yOiAnSU5WQUxJRF9NSU5fRklMRVMnIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkOiBmYWxzZSxcblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdmFyIG1ldGFEYXRhID0ge307XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdGFsOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBhbGxTaXplICs9IGZpbGVzW2ldLnNpemU7XG5cdCAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uID0gZmlsZXNbaV0ubmFtZS5zdWJzdHIoZmlsZXNbaV0ubmFtZS5sYXN0SW5kZXhPZignLicpICsgMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgbWV0YURhdGEgPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV4dDogZXh0ZW5zaW9uLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmaWxlOiBmaWxlc1tpXSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogZmlsZXNbaV0uc2l6ZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogZmlsZXNbaV0udHlwZSxcblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoZSBtaW5TaXplXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0Lm9wdGlvbnMubWluU2l6ZSAmJiBmaWxlc1tpXS5zaXplIDwgcGFyc2VJbnQoXCJcIi5jb25jYXQoaW5wdXQub3B0aW9ucy5taW5TaXplKSwgMTApKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhOiBPYmplY3QuYXNzaWduKHt9LCB7IGVycm9yOiAnSU5WQUxJRF9NSU5fU0laRScgfSwgbWV0YURhdGEpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQ6IGZhbHNlLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGUgbWF4U2l6ZVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5vcHRpb25zLm1heFNpemUgJiYgZmlsZXNbaV0uc2l6ZSA+IHBhcnNlSW50KFwiXCIuY29uY2F0KGlucHV0Lm9wdGlvbnMubWF4U2l6ZSksIDEwKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YTogT2JqZWN0LmFzc2lnbih7fSwgeyBlcnJvcjogJ0lOVkFMSURfTUFYX1NJWkUnIH0sIG1ldGFEYXRhKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkOiBmYWxzZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZmlsZSBleHRlbnNpb25cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZXh0ZW5zaW9ucy5sZW5ndGggPiAwICYmIGV4dGVuc2lvbnMuaW5kZXhPZihleHRlbnNpb24udG9Mb3dlckNhc2UoKSkgPT09IC0xKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhOiBPYmplY3QuYXNzaWduKHt9LCB7IGVycm9yOiAnSU5WQUxJRF9FWFRFTlNJT04nIH0sIG1ldGFEYXRhKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkOiBmYWxzZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZmlsZSB0eXBlXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVzLmxlbmd0aCA+IDAgJiYgZmlsZXNbaV0udHlwZSAmJiB0eXBlcy5pbmRleE9mKGZpbGVzW2ldLnR5cGUudG9Mb3dlckNhc2UoKSkgPT09IC0xKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhOiBPYmplY3QuYXNzaWduKHt9LCB7IGVycm9yOiAnSU5WQUxJRF9UWVBFJyB9LCBtZXRhRGF0YSksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZDogZmFsc2UsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGZpbGUgbmFtZVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5vcHRpb25zLnZhbGlkYXRlRmlsZU5hbWUgJiYgIWlucHV0Lm9wdGlvbnMudmFsaWRhdGVGaWxlTmFtZShnZXRGaWxlTmFtZShmaWxlc1tpXS5uYW1lKSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGE6IE9iamVjdC5hc3NpZ24oe30sIHsgZXJyb3I6ICdJTlZBTElEX05BTUUnIH0sIG1ldGFEYXRhKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkOiBmYWxzZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGUgbWF4VG90YWxTaXplXG5cdCAgICAgICAgICAgICAgICBpZiAoaW5wdXQub3B0aW9ucy5tYXhUb3RhbFNpemUgJiYgYWxsU2l6ZSA+IHBhcnNlSW50KFwiXCIuY29uY2F0KGlucHV0Lm9wdGlvbnMubWF4VG90YWxTaXplKSwgMTApKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbWV0YTogT2JqZWN0LmFzc2lnbih7fSwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6ICdJTlZBTElEX01BWF9UT1RBTF9TSVpFJyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsU2l6ZTogYWxsU2l6ZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSwgbWV0YURhdGEpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZDogZmFsc2UsXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoZSBtaW5Ub3RhbFNpemVcblx0ICAgICAgICAgICAgICAgIGlmIChpbnB1dC5vcHRpb25zLm1pblRvdGFsU2l6ZSAmJiBhbGxTaXplIDwgcGFyc2VJbnQoXCJcIi5jb25jYXQoaW5wdXQub3B0aW9ucy5taW5Ub3RhbFNpemUpLCAxMCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBtZXRhOiBPYmplY3QuYXNzaWduKHt9LCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogJ0lOVkFMSURfTUlOX1RPVEFMX1NJWkUnLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxTaXplOiBhbGxTaXplLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9LCBtZXRhRGF0YSksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkOiBmYWxzZSxcblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZmlsZSBleHRlbnNpb25cblx0ICAgICAgICAgICAgICAgIGV4dGVuc2lvbiA9IGlucHV0LnZhbHVlLnN1YnN0cihpbnB1dC52YWx1ZS5sYXN0SW5kZXhPZignLicpICsgMSk7XG5cdCAgICAgICAgICAgICAgICBpZiAoZXh0ZW5zaW9ucy5sZW5ndGggPiAwICYmIGV4dGVuc2lvbnMuaW5kZXhPZihleHRlbnNpb24udG9Mb3dlckNhc2UoKSkgPT09IC0xKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbWV0YToge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6ICdJTlZBTElEX0VYVEVOU0lPTicsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHQ6IGV4dGVuc2lvbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQ6IGZhbHNlLFxuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAvLyBDaGVjayBmaWxlIG5hbWVcblx0ICAgICAgICAgICAgICAgIG5hbWUgPSBnZXRGaWxlTmFtZShpbnB1dC52YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICBpZiAoaW5wdXQub3B0aW9ucy52YWxpZGF0ZUZpbGVOYW1lICYmICFpbnB1dC5vcHRpb25zLnZhbGlkYXRlRmlsZU5hbWUobmFtZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBtZXRhOiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogJ0lOVkFMSURfTkFNRScsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZDogZmFsc2UsXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSB9O1xuXHQgICAgICAgIH0sXG5cdCAgICB9O1xuXHR9XG5cblx0Y2pzJGQuZmlsZSA9IGZpbGU7XG5cdHJldHVybiBjanMkZDtcbn1cblxuLyoqXG4gKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcbiAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgbGliJGQuZXhwb3J0cyA9IHJlcXVpcmVJbmRleF9taW4kZCgpO1xufSBlbHNlIHtcbiAgICBsaWIkZC5leHBvcnRzID0gcmVxdWlyZUNqcyRkKCk7XG59XG5cbnZhciBsaWJFeHBvcnRzJGQgPSBsaWIkZC5leHBvcnRzO1xuXG52YXIgbGliJGMgPSB7ZXhwb3J0czoge319O1xuXG52YXIgaW5kZXhfbWluJGMgPSB7fTtcblxuLyoqIFxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqXG4gKiBAbGljZW5zZSBodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvL2xpY2Vuc2VcbiAqIEBwYWNrYWdlIEBmb3JtLXZhbGlkYXRpb24vdmFsaWRhdG9yLWdyZWF0ZXItdGhhblxuICogQHZlcnNpb24gMi40LjBcbiAqL1xuXG52YXIgaGFzUmVxdWlyZWRJbmRleF9taW4kYztcblxuZnVuY3Rpb24gcmVxdWlyZUluZGV4X21pbiRjICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkSW5kZXhfbWluJGMpIHJldHVybiBpbmRleF9taW4kYztcblx0aGFzUmVxdWlyZWRJbmRleF9taW4kYyA9IDE7XG52YXIgZT1saWJFeHBvcnRzJEIsYT1lLnV0aWxzLmZvcm1hdCxzPWUudXRpbHMucmVtb3ZlVW5kZWZpbmVkO2luZGV4X21pbiRjLmdyZWF0ZXJUaGFuPWZ1bmN0aW9uKCl7cmV0dXJuIHt2YWxpZGF0ZTpmdW5jdGlvbihlKXtpZihcIlwiPT09ZS52YWx1ZSlyZXR1cm4ge3ZhbGlkOiEwfTt2YXIgbj1PYmplY3QuYXNzaWduKHt9LHtpbmNsdXNpdmU6ITAsbWVzc2FnZTpcIlwifSxzKGUub3B0aW9ucykpLHI9cGFyc2VGbG9hdChcIlwiLmNvbmNhdChuLm1pbikucmVwbGFjZShcIixcIixcIi5cIikpO3JldHVybiBuLmluY2x1c2l2ZT97bWVzc2FnZTphKGUubDEwbj9uLm1lc3NhZ2V8fGUubDEwbi5ncmVhdGVyVGhhbi5kZWZhdWx0Om4ubWVzc2FnZSxcIlwiLmNvbmNhdChyKSksdmFsaWQ6cGFyc2VGbG9hdChlLnZhbHVlKT49cn06e21lc3NhZ2U6YShlLmwxMG4/bi5tZXNzYWdlfHxlLmwxMG4uZ3JlYXRlclRoYW4ubm90SW5jbHVzaXZlOm4ubWVzc2FnZSxcIlwiLmNvbmNhdChyKSksdmFsaWQ6cGFyc2VGbG9hdChlLnZhbHVlKT5yfX19fTtcblx0cmV0dXJuIGluZGV4X21pbiRjO1xufVxuXG52YXIgY2pzJGMgPSB7fTtcblxudmFyIGhhc1JlcXVpcmVkQ2pzJGM7XG5cbmZ1bmN0aW9uIHJlcXVpcmVDanMkYyAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZENqcyRjKSByZXR1cm4gY2pzJGM7XG5cdGhhc1JlcXVpcmVkQ2pzJGMgPSAxO1xuXG5cdHZhciBjb3JlID0gbGliRXhwb3J0cyRCO1xuXG5cdC8qKlxuXHQgKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcblx0ICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG5cdCAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cblx0ICovXG5cdHZhciBmb3JtYXQgPSBjb3JlLnV0aWxzLmZvcm1hdCwgcmVtb3ZlVW5kZWZpbmVkID0gY29yZS51dGlscy5yZW1vdmVVbmRlZmluZWQ7XG5cdGZ1bmN0aW9uIGdyZWF0ZXJUaGFuKCkge1xuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKGlucHV0KSB7XG5cdCAgICAgICAgICAgIGlmIChpbnB1dC52YWx1ZSA9PT0gJycpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlIH07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCB7IGluY2x1c2l2ZTogdHJ1ZSwgbWVzc2FnZTogJycgfSwgcmVtb3ZlVW5kZWZpbmVkKGlucHV0Lm9wdGlvbnMpKTtcblx0ICAgICAgICAgICAgdmFyIG1pblZhbHVlID0gcGFyc2VGbG9hdChcIlwiLmNvbmNhdChvcHRzLm1pbikucmVwbGFjZSgnLCcsICcuJykpO1xuXHQgICAgICAgICAgICByZXR1cm4gb3B0cy5pbmNsdXNpdmVcblx0ICAgICAgICAgICAgICAgID8ge1xuXHQgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGZvcm1hdChpbnB1dC5sMTBuID8gb3B0cy5tZXNzYWdlIHx8IGlucHV0LmwxMG4uZ3JlYXRlclRoYW4uZGVmYXVsdCA6IG9wdHMubWVzc2FnZSwgXCJcIi5jb25jYXQobWluVmFsdWUpKSxcblx0ICAgICAgICAgICAgICAgICAgICB2YWxpZDogcGFyc2VGbG9hdChpbnB1dC52YWx1ZSkgPj0gbWluVmFsdWUsXG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICA6IHtcblx0ICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBmb3JtYXQoaW5wdXQubDEwbiA/IG9wdHMubWVzc2FnZSB8fCBpbnB1dC5sMTBuLmdyZWF0ZXJUaGFuLm5vdEluY2x1c2l2ZSA6IG9wdHMubWVzc2FnZSwgXCJcIi5jb25jYXQobWluVmFsdWUpKSxcblx0ICAgICAgICAgICAgICAgICAgICB2YWxpZDogcGFyc2VGbG9hdChpbnB1dC52YWx1ZSkgPiBtaW5WYWx1ZSxcblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgfSxcblx0ICAgIH07XG5cdH1cblxuXHRjanMkYy5ncmVhdGVyVGhhbiA9IGdyZWF0ZXJUaGFuO1xuXHRyZXR1cm4gY2pzJGM7XG59XG5cbi8qKlxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgIGxpYiRjLmV4cG9ydHMgPSByZXF1aXJlSW5kZXhfbWluJGMoKTtcbn0gZWxzZSB7XG4gICAgbGliJGMuZXhwb3J0cyA9IHJlcXVpcmVDanMkYygpO1xufVxuXG52YXIgbGliRXhwb3J0cyRjID0gbGliJGMuZXhwb3J0cztcblxudmFyIGxpYiRiID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIGluZGV4X21pbiRiID0ge307XG5cbi8qKiBcbiAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG4gKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKlxuICogQGxpY2Vuc2UgaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pby9saWNlbnNlXG4gKiBAcGFja2FnZSBAZm9ybS12YWxpZGF0aW9uL3ZhbGlkYXRvci1pZGVudGljYWxcbiAqIEB2ZXJzaW9uIDIuNC4wXG4gKi9cblxudmFyIGhhc1JlcXVpcmVkSW5kZXhfbWluJGI7XG5cbmZ1bmN0aW9uIHJlcXVpcmVJbmRleF9taW4kYiAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEluZGV4X21pbiRiKSByZXR1cm4gaW5kZXhfbWluJGI7XG5cdGhhc1JlcXVpcmVkSW5kZXhfbWluJGIgPSAxO1xuaW5kZXhfbWluJGIuaWRlbnRpY2FsPWZ1bmN0aW9uKCl7cmV0dXJuIHt2YWxpZGF0ZTpmdW5jdGlvbih0KXt2YXIgbz1cImZ1bmN0aW9uXCI9PXR5cGVvZiB0Lm9wdGlvbnMuY29tcGFyZT90Lm9wdGlvbnMuY29tcGFyZS5jYWxsKHRoaXMpOnQub3B0aW9ucy5jb21wYXJlO3JldHVybiB7dmFsaWQ6XCJcIj09PW98fHQudmFsdWU9PT1vfX19fTtcblx0cmV0dXJuIGluZGV4X21pbiRiO1xufVxuXG52YXIgY2pzJGIgPSB7fTtcblxudmFyIGhhc1JlcXVpcmVkQ2pzJGI7XG5cbmZ1bmN0aW9uIHJlcXVpcmVDanMkYiAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZENqcyRiKSByZXR1cm4gY2pzJGI7XG5cdGhhc1JlcXVpcmVkQ2pzJGIgPSAxO1xuXG5cdC8qKlxuXHQgKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcblx0ICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG5cdCAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cblx0ICovXG5cdGZ1bmN0aW9uIGlkZW50aWNhbCgpIHtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChpbnB1dCkge1xuXHQgICAgICAgICAgICB2YXIgY29tcGFyZVdpdGggPSAnZnVuY3Rpb24nID09PSB0eXBlb2YgaW5wdXQub3B0aW9ucy5jb21wYXJlXG5cdCAgICAgICAgICAgICAgICA/IGlucHV0Lm9wdGlvbnMuY29tcGFyZS5jYWxsKHRoaXMpXG5cdCAgICAgICAgICAgICAgICA6IGlucHV0Lm9wdGlvbnMuY29tcGFyZTtcblx0ICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgIHZhbGlkOiBjb21wYXJlV2l0aCA9PT0gJycgfHwgaW5wdXQudmFsdWUgPT09IGNvbXBhcmVXaXRoLFxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH0sXG5cdCAgICB9O1xuXHR9XG5cblx0Y2pzJGIuaWRlbnRpY2FsID0gaWRlbnRpY2FsO1xuXHRyZXR1cm4gY2pzJGI7XG59XG5cbi8qKlxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgIGxpYiRiLmV4cG9ydHMgPSByZXF1aXJlSW5kZXhfbWluJGIoKTtcbn0gZWxzZSB7XG4gICAgbGliJGIuZXhwb3J0cyA9IHJlcXVpcmVDanMkYigpO1xufVxuXG52YXIgbGliRXhwb3J0cyRiID0gbGliJGIuZXhwb3J0cztcblxudmFyIGxpYiRhID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIGluZGV4X21pbiRhID0ge307XG5cbi8qKiBcbiAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG4gKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKlxuICogQGxpY2Vuc2UgaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pby9saWNlbnNlXG4gKiBAcGFja2FnZSBAZm9ybS12YWxpZGF0aW9uL3ZhbGlkYXRvci1pbnRlZ2VyXG4gKiBAdmVyc2lvbiAyLjQuMFxuICovXG5cbnZhciBoYXNSZXF1aXJlZEluZGV4X21pbiRhO1xuXG5mdW5jdGlvbiByZXF1aXJlSW5kZXhfbWluJGEgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRJbmRleF9taW4kYSkgcmV0dXJuIGluZGV4X21pbiRhO1xuXHRoYXNSZXF1aXJlZEluZGV4X21pbiRhID0gMTtcbnZhciBhPWxpYkV4cG9ydHMkQi51dGlscy5yZW1vdmVVbmRlZmluZWQ7aW5kZXhfbWluJGEuaW50ZWdlcj1mdW5jdGlvbigpe3JldHVybiB7dmFsaWRhdGU6ZnVuY3Rpb24oZSl7aWYoXCJcIj09PWUudmFsdWUpcmV0dXJuIHt2YWxpZDohMH07dmFyIHI9T2JqZWN0LmFzc2lnbih7fSx7ZGVjaW1hbFNlcGFyYXRvcjpcIi5cIix0aG91c2FuZHNTZXBhcmF0b3I6XCJcIn0sYShlLm9wdGlvbnMpKSx0PVwiLlwiPT09ci5kZWNpbWFsU2VwYXJhdG9yP1wiXFxcXC5cIjpyLmRlY2ltYWxTZXBhcmF0b3IsaT1cIi5cIj09PXIudGhvdXNhbmRzU2VwYXJhdG9yP1wiXFxcXC5cIjpyLnRob3VzYW5kc1NlcGFyYXRvcixvPW5ldyBSZWdFeHAoXCJeLT9bMC05XXsxLDN9KFwiLmNvbmNhdChpLFwiWzAtOV17M30pKihcIikuY29uY2F0KHQsXCJbMC05XSspPyRcIikpLG49bmV3IFJlZ0V4cChpLFwiZ1wiKSxzPVwiXCIuY29uY2F0KGUudmFsdWUpO2lmKCFvLnRlc3QocykpcmV0dXJuIHt2YWxpZDohMX07aSYmKHM9cy5yZXBsYWNlKG4sXCJcIikpLHQmJihzPXMucmVwbGFjZSh0LFwiLlwiKSk7dmFyIGM9cGFyc2VGbG9hdChzKTtyZXR1cm4ge3ZhbGlkOiFpc05hTihjKSYmaXNGaW5pdGUoYykmJk1hdGguZmxvb3IoYyk9PT1jfX19fTtcblx0cmV0dXJuIGluZGV4X21pbiRhO1xufVxuXG52YXIgY2pzJGEgPSB7fTtcblxudmFyIGhhc1JlcXVpcmVkQ2pzJGE7XG5cbmZ1bmN0aW9uIHJlcXVpcmVDanMkYSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZENqcyRhKSByZXR1cm4gY2pzJGE7XG5cdGhhc1JlcXVpcmVkQ2pzJGEgPSAxO1xuXG5cdHZhciBjb3JlID0gbGliRXhwb3J0cyRCO1xuXG5cdC8qKlxuXHQgKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcblx0ICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG5cdCAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cblx0ICovXG5cdHZhciByZW1vdmVVbmRlZmluZWQgPSBjb3JlLnV0aWxzLnJlbW92ZVVuZGVmaW5lZDtcblx0ZnVuY3Rpb24gaW50ZWdlcigpIHtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChpbnB1dCkge1xuXHQgICAgICAgICAgICBpZiAoaW5wdXQudmFsdWUgPT09ICcnKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSB9O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwge1xuXHQgICAgICAgICAgICAgICAgZGVjaW1hbFNlcGFyYXRvcjogJy4nLFxuXHQgICAgICAgICAgICAgICAgdGhvdXNhbmRzU2VwYXJhdG9yOiAnJyxcblx0ICAgICAgICAgICAgfSwgcmVtb3ZlVW5kZWZpbmVkKGlucHV0Lm9wdGlvbnMpKTtcblx0ICAgICAgICAgICAgdmFyIGRlY2ltYWxTZXBhcmF0b3IgPSBvcHRzLmRlY2ltYWxTZXBhcmF0b3IgPT09ICcuJyA/ICdcXFxcLicgOiBvcHRzLmRlY2ltYWxTZXBhcmF0b3I7XG5cdCAgICAgICAgICAgIHZhciB0aG91c2FuZHNTZXBhcmF0b3IgPSBvcHRzLnRob3VzYW5kc1NlcGFyYXRvciA9PT0gJy4nID8gJ1xcXFwuJyA6IG9wdHMudGhvdXNhbmRzU2VwYXJhdG9yO1xuXHQgICAgICAgICAgICB2YXIgdGVzdFJlZ2V4cCA9IG5ldyBSZWdFeHAoXCJeLT9bMC05XXsxLDN9KFwiLmNvbmNhdCh0aG91c2FuZHNTZXBhcmF0b3IsIFwiWzAtOV17M30pKihcIikuY29uY2F0KGRlY2ltYWxTZXBhcmF0b3IsIFwiWzAtOV0rKT8kXCIpKTtcblx0ICAgICAgICAgICAgdmFyIHRob3VzYW5kc1JlcGxhY2VyID0gbmV3IFJlZ0V4cCh0aG91c2FuZHNTZXBhcmF0b3IsICdnJyk7XG5cdCAgICAgICAgICAgIHZhciB2ID0gXCJcIi5jb25jYXQoaW5wdXQudmFsdWUpO1xuXHQgICAgICAgICAgICBpZiAoIXRlc3RSZWdleHAudGVzdCh2KSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgLy8gUmVwbGFjZSB0aG91c2FuZHMgc2VwYXJhdG9yIHdpdGggYmxhbmtcblx0ICAgICAgICAgICAgaWYgKHRob3VzYW5kc1NlcGFyYXRvcikge1xuXHQgICAgICAgICAgICAgICAgdiA9IHYucmVwbGFjZSh0aG91c2FuZHNSZXBsYWNlciwgJycpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vIFJlcGxhY2UgZGVjaW1hbCBzZXBhcmF0b3Igd2l0aCBhIGRvdFxuXHQgICAgICAgICAgICBpZiAoZGVjaW1hbFNlcGFyYXRvcikge1xuXHQgICAgICAgICAgICAgICAgdiA9IHYucmVwbGFjZShkZWNpbWFsU2VwYXJhdG9yLCAnLicpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBuID0gcGFyc2VGbG9hdCh2KTtcblx0ICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6ICFpc05hTihuKSAmJiBpc0Zpbml0ZShuKSAmJiBNYXRoLmZsb29yKG4pID09PSBuIH07XG5cdCAgICAgICAgfSxcblx0ICAgIH07XG5cdH1cblxuXHRjanMkYS5pbnRlZ2VyID0gaW50ZWdlcjtcblx0cmV0dXJuIGNqcyRhO1xufVxuXG4vKipcbiAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG4gKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICBsaWIkYS5leHBvcnRzID0gcmVxdWlyZUluZGV4X21pbiRhKCk7XG59IGVsc2Uge1xuICAgIGxpYiRhLmV4cG9ydHMgPSByZXF1aXJlQ2pzJGEoKTtcbn1cblxudmFyIGxpYkV4cG9ydHMkYSA9IGxpYiRhLmV4cG9ydHM7XG5cbnZhciBsaWIkOSA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBpbmRleF9taW4kOSA9IHt9O1xuXG4vKiogXG4gKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcbiAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuICpcbiAqIEBsaWNlbnNlIGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8vbGljZW5zZVxuICogQHBhY2thZ2UgQGZvcm0tdmFsaWRhdGlvbi92YWxpZGF0b3ItaXBcbiAqIEB2ZXJzaW9uIDIuNC4wXG4gKi9cblxudmFyIGhhc1JlcXVpcmVkSW5kZXhfbWluJDk7XG5cbmZ1bmN0aW9uIHJlcXVpcmVJbmRleF9taW4kOSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEluZGV4X21pbiQ5KSByZXR1cm4gaW5kZXhfbWluJDk7XG5cdGhhc1JlcXVpcmVkSW5kZXhfbWluJDkgPSAxO1xudmFyIGQ9bGliRXhwb3J0cyRCLnV0aWxzLnJlbW92ZVVuZGVmaW5lZDtpbmRleF9taW4kOS5pcD1mdW5jdGlvbigpe3JldHVybiB7dmFsaWRhdGU6ZnVuY3Rpb24oYSl7aWYoXCJcIj09PWEudmFsdWUpcmV0dXJuIHt2YWxpZDohMH07dmFyIGU9T2JqZWN0LmFzc2lnbih7fSx7aXB2NDohMCxpcHY2OiEwfSxkKGEub3B0aW9ucykpLHM9L14oPzooPzoyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPykoXFwvKFswLTldfFsxLTJdWzAtOV18M1swLTJdKSk/JC8saT0vXlxccyooKChbMC05QS1GYS1mXXsxLDR9Oil7N30oWzAtOUEtRmEtZl17MSw0fXw6KSl8KChbMC05QS1GYS1mXXsxLDR9Oil7Nn0oOlswLTlBLUZhLWZdezEsNH18KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoKFswLTlBLUZhLWZdezEsNH06KXs1fSgoKDpbMC05QS1GYS1mXXsxLDR9KXsxLDJ9KXw6KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoKFswLTlBLUZhLWZdezEsNH06KXs0fSgoKDpbMC05QS1GYS1mXXsxLDR9KXsxLDN9KXwoKDpbMC05QS1GYS1mXXsxLDR9KT86KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KChbMC05QS1GYS1mXXsxLDR9Oil7M30oKCg6WzAtOUEtRmEtZl17MSw0fSl7MSw0fSl8KCg6WzAtOUEtRmEtZl17MSw0fSl7MCwyfTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoKFswLTlBLUZhLWZdezEsNH06KXsyfSgoKDpbMC05QS1GYS1mXXsxLDR9KXsxLDV9KXwoKDpbMC05QS1GYS1mXXsxLDR9KXswLDN9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCgoWzAtOUEtRmEtZl17MSw0fTopezF9KCgoOlswLTlBLUZhLWZdezEsNH0pezEsNn0pfCgoOlswLTlBLUZhLWZdezEsNH0pezAsNH06KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KDooKCg6WzAtOUEtRmEtZl17MSw0fSl7MSw3fSl8KCg6WzAtOUEtRmEtZl17MSw0fSl7MCw1fTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKSkoJS4rKT9cXHMqKFxcLyhcXGR8XFxkXFxkfDFbMC0xXVxcZHwxMlswLThdKSk/JC87c3dpdGNoKCEwKXtjYXNlIGUuaXB2NCYmIWUuaXB2NjpyZXR1cm4ge21lc3NhZ2U6YS5sMTBuP2UubWVzc2FnZXx8YS5sMTBuLmlwLmlwdjQ6ZS5tZXNzYWdlLHZhbGlkOnMudGVzdChhLnZhbHVlKX07Y2FzZSFlLmlwdjQmJmUuaXB2NjpyZXR1cm4ge21lc3NhZ2U6YS5sMTBuP2UubWVzc2FnZXx8YS5sMTBuLmlwLmlwdjY6ZS5tZXNzYWdlLHZhbGlkOmkudGVzdChhLnZhbHVlKX07Y2FzZSBlLmlwdjQmJmUuaXB2NjpkZWZhdWx0OnJldHVybiB7bWVzc2FnZTphLmwxMG4/ZS5tZXNzYWdlfHxhLmwxMG4uaXAuZGVmYXVsdDplLm1lc3NhZ2UsdmFsaWQ6cy50ZXN0KGEudmFsdWUpfHxpLnRlc3QoYS52YWx1ZSl9fX19fTtcblx0cmV0dXJuIGluZGV4X21pbiQ5O1xufVxuXG52YXIgY2pzJDkgPSB7fTtcblxudmFyIGhhc1JlcXVpcmVkQ2pzJDk7XG5cbmZ1bmN0aW9uIHJlcXVpcmVDanMkOSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZENqcyQ5KSByZXR1cm4gY2pzJDk7XG5cdGhhc1JlcXVpcmVkQ2pzJDkgPSAxO1xuXG5cdHZhciBjb3JlID0gbGliRXhwb3J0cyRCO1xuXG5cdC8qKlxuXHQgKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcblx0ICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG5cdCAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cblx0ICovXG5cdHZhciByZW1vdmVVbmRlZmluZWQgPSBjb3JlLnV0aWxzLnJlbW92ZVVuZGVmaW5lZDtcblx0ZnVuY3Rpb24gaXAoKSB7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSBpbnB1dCB2YWx1ZSBpcyBhIElQIGFkZHJlc3MuXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChpbnB1dCkge1xuXHQgICAgICAgICAgICBpZiAoaW5wdXQudmFsdWUgPT09ICcnKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSB9O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwge1xuXHQgICAgICAgICAgICAgICAgaXB2NDogdHJ1ZSxcblx0ICAgICAgICAgICAgICAgIGlwdjY6IHRydWUsXG5cdCAgICAgICAgICAgIH0sIHJlbW92ZVVuZGVmaW5lZChpbnB1dC5vcHRpb25zKSk7XG5cdCAgICAgICAgICAgIHZhciBpcHY0UmVnZXggPSAvXig/Oig/OjI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KShcXC8oWzAtOV18WzEtMl1bMC05XXwzWzAtMl0pKT8kLztcblx0ICAgICAgICAgICAgdmFyIGlwdjZSZWdleCA9IC9eXFxzKigoKFswLTlBLUZhLWZdezEsNH06KXs3fShbMC05QS1GYS1mXXsxLDR9fDopKXwoKFswLTlBLUZhLWZdezEsNH06KXs2fSg6WzAtOUEtRmEtZl17MSw0fXwoKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSl8OikpfCgoWzAtOUEtRmEtZl17MSw0fTopezV9KCgoOlswLTlBLUZhLWZdezEsNH0pezEsMn0pfDooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSl8OikpfCgoWzAtOUEtRmEtZl17MSw0fTopezR9KCgoOlswLTlBLUZhLWZdezEsNH0pezEsM30pfCgoOlswLTlBLUZhLWZdezEsNH0pPzooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoKFswLTlBLUZhLWZdezEsNH06KXszfSgoKDpbMC05QS1GYS1mXXsxLDR9KXsxLDR9KXwoKDpbMC05QS1GYS1mXXsxLDR9KXswLDJ9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCgoWzAtOUEtRmEtZl17MSw0fTopezJ9KCgoOlswLTlBLUZhLWZdezEsNH0pezEsNX0pfCgoOlswLTlBLUZhLWZdezEsNH0pezAsM306KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KChbMC05QS1GYS1mXXsxLDR9Oil7MX0oKCg6WzAtOUEtRmEtZl17MSw0fSl7MSw2fSl8KCg6WzAtOUEtRmEtZl17MSw0fSl7MCw0fTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoOigoKDpbMC05QS1GYS1mXXsxLDR9KXsxLDd9KXwoKDpbMC05QS1GYS1mXXsxLDR9KXswLDV9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpKSglLispP1xccyooXFwvKFxcZHxcXGRcXGR8MVswLTFdXFxkfDEyWzAtOF0pKT8kLztcblx0ICAgICAgICAgICAgc3dpdGNoICh0cnVlKSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlIG9wdHMuaXB2NCAmJiAhb3B0cy5pcHY2OlxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGlucHV0LmwxMG4gPyBvcHRzLm1lc3NhZ2UgfHwgaW5wdXQubDEwbi5pcC5pcHY0IDogb3B0cy5tZXNzYWdlLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZDogaXB2NFJlZ2V4LnRlc3QoaW5wdXQudmFsdWUpLFxuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICBjYXNlICFvcHRzLmlwdjQgJiYgb3B0cy5pcHY2OlxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGlucHV0LmwxMG4gPyBvcHRzLm1lc3NhZ2UgfHwgaW5wdXQubDEwbi5pcC5pcHY2IDogb3B0cy5tZXNzYWdlLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZDogaXB2NlJlZ2V4LnRlc3QoaW5wdXQudmFsdWUpLFxuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICBjYXNlIG9wdHMuaXB2NCAmJiBvcHRzLmlwdjY6XG5cdCAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGlucHV0LmwxMG4gPyBvcHRzLm1lc3NhZ2UgfHwgaW5wdXQubDEwbi5pcC5kZWZhdWx0IDogb3B0cy5tZXNzYWdlLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZDogaXB2NFJlZ2V4LnRlc3QoaW5wdXQudmFsdWUpIHx8IGlwdjZSZWdleC50ZXN0KGlucHV0LnZhbHVlKSxcblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgIH07XG5cdH1cblxuXHRjanMkOS5pcCA9IGlwO1xuXHRyZXR1cm4gY2pzJDk7XG59XG5cbi8qKlxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgIGxpYiQ5LmV4cG9ydHMgPSByZXF1aXJlSW5kZXhfbWluJDkoKTtcbn0gZWxzZSB7XG4gICAgbGliJDkuZXhwb3J0cyA9IHJlcXVpcmVDanMkOSgpO1xufVxuXG52YXIgbGliRXhwb3J0cyQ5ID0gbGliJDkuZXhwb3J0cztcblxudmFyIGxpYiQ4ID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIGluZGV4X21pbiQ4ID0ge307XG5cbi8qKiBcbiAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG4gKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKlxuICogQGxpY2Vuc2UgaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pby9saWNlbnNlXG4gKiBAcGFja2FnZSBAZm9ybS12YWxpZGF0aW9uL3ZhbGlkYXRvci1sZXNzLXRoYW5cbiAqIEB2ZXJzaW9uIDIuNC4wXG4gKi9cblxudmFyIGhhc1JlcXVpcmVkSW5kZXhfbWluJDg7XG5cbmZ1bmN0aW9uIHJlcXVpcmVJbmRleF9taW4kOCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEluZGV4X21pbiQ4KSByZXR1cm4gaW5kZXhfbWluJDg7XG5cdGhhc1JlcXVpcmVkSW5kZXhfbWluJDggPSAxO1xudmFyIGU9bGliRXhwb3J0cyRCLGE9ZS51dGlscy5mb3JtYXQscz1lLnV0aWxzLnJlbW92ZVVuZGVmaW5lZDtpbmRleF9taW4kOC5sZXNzVGhhbj1mdW5jdGlvbigpe3JldHVybiB7dmFsaWRhdGU6ZnVuY3Rpb24oZSl7aWYoXCJcIj09PWUudmFsdWUpcmV0dXJuIHt2YWxpZDohMH07dmFyIG49T2JqZWN0LmFzc2lnbih7fSx7aW5jbHVzaXZlOiEwLG1lc3NhZ2U6XCJcIn0scyhlLm9wdGlvbnMpKSxsPXBhcnNlRmxvYXQoXCJcIi5jb25jYXQobi5tYXgpLnJlcGxhY2UoXCIsXCIsXCIuXCIpKTtyZXR1cm4gbi5pbmNsdXNpdmU/e21lc3NhZ2U6YShlLmwxMG4/bi5tZXNzYWdlfHxlLmwxMG4ubGVzc1RoYW4uZGVmYXVsdDpuLm1lc3NhZ2UsXCJcIi5jb25jYXQobCkpLHZhbGlkOnBhcnNlRmxvYXQoZS52YWx1ZSk8PWx9OnttZXNzYWdlOmEoZS5sMTBuP24ubWVzc2FnZXx8ZS5sMTBuLmxlc3NUaGFuLm5vdEluY2x1c2l2ZTpuLm1lc3NhZ2UsXCJcIi5jb25jYXQobCkpLHZhbGlkOnBhcnNlRmxvYXQoZS52YWx1ZSk8bH19fX07XG5cdHJldHVybiBpbmRleF9taW4kODtcbn1cblxudmFyIGNqcyQ4ID0ge307XG5cbnZhciBoYXNSZXF1aXJlZENqcyQ4O1xuXG5mdW5jdGlvbiByZXF1aXJlQ2pzJDggKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRDanMkOCkgcmV0dXJuIGNqcyQ4O1xuXHRoYXNSZXF1aXJlZENqcyQ4ID0gMTtcblxuXHR2YXIgY29yZSA9IGxpYkV4cG9ydHMkQjtcblxuXHQvKipcblx0ICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG5cdCAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuXHQgKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG5cdCAqL1xuXHR2YXIgZm9ybWF0ID0gY29yZS51dGlscy5mb3JtYXQsIHJlbW92ZVVuZGVmaW5lZCA9IGNvcmUudXRpbHMucmVtb3ZlVW5kZWZpbmVkO1xuXHRmdW5jdGlvbiBsZXNzVGhhbigpIHtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChpbnB1dCkge1xuXHQgICAgICAgICAgICBpZiAoaW5wdXQudmFsdWUgPT09ICcnKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSB9O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgeyBpbmNsdXNpdmU6IHRydWUsIG1lc3NhZ2U6ICcnIH0sIHJlbW92ZVVuZGVmaW5lZChpbnB1dC5vcHRpb25zKSk7XG5cdCAgICAgICAgICAgIHZhciBtYXhWYWx1ZSA9IHBhcnNlRmxvYXQoXCJcIi5jb25jYXQob3B0cy5tYXgpLnJlcGxhY2UoJywnLCAnLicpKTtcblx0ICAgICAgICAgICAgcmV0dXJuIG9wdHMuaW5jbHVzaXZlXG5cdCAgICAgICAgICAgICAgICA/IHtcblx0ICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBmb3JtYXQoaW5wdXQubDEwbiA/IG9wdHMubWVzc2FnZSB8fCBpbnB1dC5sMTBuLmxlc3NUaGFuLmRlZmF1bHQgOiBvcHRzLm1lc3NhZ2UsIFwiXCIuY29uY2F0KG1heFZhbHVlKSksXG5cdCAgICAgICAgICAgICAgICAgICAgdmFsaWQ6IHBhcnNlRmxvYXQoaW5wdXQudmFsdWUpIDw9IG1heFZhbHVlLFxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgOiB7XG5cdCAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZm9ybWF0KGlucHV0LmwxMG4gPyBvcHRzLm1lc3NhZ2UgfHwgaW5wdXQubDEwbi5sZXNzVGhhbi5ub3RJbmNsdXNpdmUgOiBvcHRzLm1lc3NhZ2UsIFwiXCIuY29uY2F0KG1heFZhbHVlKSksXG5cdCAgICAgICAgICAgICAgICAgICAgdmFsaWQ6IHBhcnNlRmxvYXQoaW5wdXQudmFsdWUpIDwgbWF4VmFsdWUsXG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgIH0sXG5cdCAgICB9O1xuXHR9XG5cblx0Y2pzJDgubGVzc1RoYW4gPSBsZXNzVGhhbjtcblx0cmV0dXJuIGNqcyQ4O1xufVxuXG4vKipcbiAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG4gKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICBsaWIkOC5leHBvcnRzID0gcmVxdWlyZUluZGV4X21pbiQ4KCk7XG59IGVsc2Uge1xuICAgIGxpYiQ4LmV4cG9ydHMgPSByZXF1aXJlQ2pzJDgoKTtcbn1cblxudmFyIGxpYkV4cG9ydHMkOCA9IGxpYiQ4LmV4cG9ydHM7XG5cbnZhciBsaWIkNyA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBpbmRleF9taW4kNyA9IHt9O1xuXG4vKiogXG4gKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcbiAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuICpcbiAqIEBsaWNlbnNlIGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8vbGljZW5zZVxuICogQHBhY2thZ2UgQGZvcm0tdmFsaWRhdGlvbi92YWxpZGF0b3Itbm90LWVtcHR5XG4gKiBAdmVyc2lvbiAyLjQuMFxuICovXG5cbnZhciBoYXNSZXF1aXJlZEluZGV4X21pbiQ3O1xuXG5mdW5jdGlvbiByZXF1aXJlSW5kZXhfbWluJDcgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRJbmRleF9taW4kNykgcmV0dXJuIGluZGV4X21pbiQ3O1xuXHRoYXNSZXF1aXJlZEluZGV4X21pbiQ3ID0gMTtcbmluZGV4X21pbiQ3Lm5vdEVtcHR5PWZ1bmN0aW9uKCl7cmV0dXJuIHt2YWxpZGF0ZTpmdW5jdGlvbih0KXt2YXIgaT0hIXQub3B0aW9ucyYmISF0Lm9wdGlvbnMudHJpbSxuPXQudmFsdWU7cmV0dXJuIHt2YWxpZDohaSYmXCJcIiE9PW58fGkmJlwiXCIhPT1uJiZcIlwiIT09bi50cmltKCl9fX19O1xuXHRyZXR1cm4gaW5kZXhfbWluJDc7XG59XG5cbnZhciBjanMkNyA9IHt9O1xuXG52YXIgaGFzUmVxdWlyZWRDanMkNztcblxuZnVuY3Rpb24gcmVxdWlyZUNqcyQ3ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkQ2pzJDcpIHJldHVybiBjanMkNztcblx0aGFzUmVxdWlyZWRDanMkNyA9IDE7XG5cblx0LyoqXG5cdCAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuXHQgKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcblx0ICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuXHQgKi9cblx0ZnVuY3Rpb24gbm90RW1wdHkoKSB7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoaW5wdXQpIHtcblx0ICAgICAgICAgICAgdmFyIHRyaW0gPSAhIWlucHV0Lm9wdGlvbnMgJiYgISFpbnB1dC5vcHRpb25zLnRyaW07XG5cdCAgICAgICAgICAgIHZhciB2YWx1ZSA9IGlucHV0LnZhbHVlO1xuXHQgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgdmFsaWQ6ICghdHJpbSAmJiB2YWx1ZSAhPT0gJycpIHx8ICh0cmltICYmIHZhbHVlICE9PSAnJyAmJiB2YWx1ZS50cmltKCkgIT09ICcnKSxcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9LFxuXHQgICAgfTtcblx0fVxuXG5cdGNqcyQ3Lm5vdEVtcHR5ID0gbm90RW1wdHk7XG5cdHJldHVybiBjanMkNztcbn1cblxuLyoqXG4gKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcbiAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgbGliJDcuZXhwb3J0cyA9IHJlcXVpcmVJbmRleF9taW4kNygpO1xufSBlbHNlIHtcbiAgICBsaWIkNy5leHBvcnRzID0gcmVxdWlyZUNqcyQ3KCk7XG59XG5cbnZhciBsaWJFeHBvcnRzJDcgPSBsaWIkNy5leHBvcnRzO1xuXG52YXIgbGliJDYgPSB7ZXhwb3J0czoge319O1xuXG52YXIgaW5kZXhfbWluJDYgPSB7fTtcblxuLyoqIFxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqXG4gKiBAbGljZW5zZSBodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvL2xpY2Vuc2VcbiAqIEBwYWNrYWdlIEBmb3JtLXZhbGlkYXRpb24vdmFsaWRhdG9yLW51bWVyaWNcbiAqIEB2ZXJzaW9uIDIuNC4wXG4gKi9cblxudmFyIGhhc1JlcXVpcmVkSW5kZXhfbWluJDY7XG5cbmZ1bmN0aW9uIHJlcXVpcmVJbmRleF9taW4kNiAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEluZGV4X21pbiQ2KSByZXR1cm4gaW5kZXhfbWluJDY7XG5cdGhhc1JlcXVpcmVkSW5kZXhfbWluJDYgPSAxO1xudmFyIGE9bGliRXhwb3J0cyRCLnV0aWxzLnJlbW92ZVVuZGVmaW5lZDtpbmRleF9taW4kNi5udW1lcmljPWZ1bmN0aW9uKCl7cmV0dXJuIHt2YWxpZGF0ZTpmdW5jdGlvbihyKXtpZihcIlwiPT09ci52YWx1ZSlyZXR1cm4ge3ZhbGlkOiEwfTt2YXIgZT1PYmplY3QuYXNzaWduKHt9LHtkZWNpbWFsU2VwYXJhdG9yOlwiLlwiLHRob3VzYW5kc1NlcGFyYXRvcjpcIlwifSxhKHIub3B0aW9ucykpLHQ9XCJcIi5jb25jYXQoci52YWx1ZSk7dC5zdWJzdHIoMCwxKT09PWUuZGVjaW1hbFNlcGFyYXRvcj90PVwiMFwiLmNvbmNhdChlLmRlY2ltYWxTZXBhcmF0b3IpLmNvbmNhdCh0LnN1YnN0cigxKSk6dC5zdWJzdHIoMCwyKT09PVwiLVwiLmNvbmNhdChlLmRlY2ltYWxTZXBhcmF0b3IpJiYodD1cIi0wXCIuY29uY2F0KGUuZGVjaW1hbFNlcGFyYXRvcikuY29uY2F0KHQuc3Vic3RyKDIpKSk7dmFyIGM9XCIuXCI9PT1lLmRlY2ltYWxTZXBhcmF0b3I/XCJcXFxcLlwiOmUuZGVjaW1hbFNlcGFyYXRvcixvPVwiLlwiPT09ZS50aG91c2FuZHNTZXBhcmF0b3I/XCJcXFxcLlwiOmUudGhvdXNhbmRzU2VwYXJhdG9yLGk9bmV3IFJlZ0V4cChcIl4tP1swLTldezEsM30oXCIuY29uY2F0KG8sXCJbMC05XXszfSkqKFwiKS5jb25jYXQoYyxcIlswLTldKyk/JFwiKSksbj1uZXcgUmVnRXhwKG8sXCJnXCIpO2lmKCFpLnRlc3QodCkpcmV0dXJuIHt2YWxpZDohMX07byYmKHQ9dC5yZXBsYWNlKG4sXCJcIikpLGMmJih0PXQucmVwbGFjZShjLFwiLlwiKSk7dmFyIHM9cGFyc2VGbG9hdCh0KTtyZXR1cm4ge3ZhbGlkOiFpc05hTihzKSYmaXNGaW5pdGUocyl9fX19O1xuXHRyZXR1cm4gaW5kZXhfbWluJDY7XG59XG5cbnZhciBjanMkNiA9IHt9O1xuXG52YXIgaGFzUmVxdWlyZWRDanMkNjtcblxuZnVuY3Rpb24gcmVxdWlyZUNqcyQ2ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkQ2pzJDYpIHJldHVybiBjanMkNjtcblx0aGFzUmVxdWlyZWRDanMkNiA9IDE7XG5cblx0dmFyIGNvcmUgPSBsaWJFeHBvcnRzJEI7XG5cblx0LyoqXG5cdCAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuXHQgKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcblx0ICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuXHQgKi9cblx0dmFyIHJlbW92ZVVuZGVmaW5lZCA9IGNvcmUudXRpbHMucmVtb3ZlVW5kZWZpbmVkO1xuXHRmdW5jdGlvbiBudW1lcmljKCkge1xuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKGlucHV0KSB7XG5cdCAgICAgICAgICAgIGlmIChpbnB1dC52YWx1ZSA9PT0gJycpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlIH07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCB7XG5cdCAgICAgICAgICAgICAgICBkZWNpbWFsU2VwYXJhdG9yOiAnLicsXG5cdCAgICAgICAgICAgICAgICB0aG91c2FuZHNTZXBhcmF0b3I6ICcnLFxuXHQgICAgICAgICAgICB9LCByZW1vdmVVbmRlZmluZWQoaW5wdXQub3B0aW9ucykpO1xuXHQgICAgICAgICAgICB2YXIgdiA9IFwiXCIuY29uY2F0KGlucHV0LnZhbHVlKTtcblx0ICAgICAgICAgICAgLy8gU3VwcG9ydCBwcmVjZWRpbmcgemVybyBudW1iZXJzIHN1Y2ggYXMgLjUsIC0uNVxuXHQgICAgICAgICAgICBpZiAodi5zdWJzdHIoMCwgMSkgPT09IG9wdHMuZGVjaW1hbFNlcGFyYXRvcikge1xuXHQgICAgICAgICAgICAgICAgdiA9IFwiMFwiLmNvbmNhdChvcHRzLmRlY2ltYWxTZXBhcmF0b3IpLmNvbmNhdCh2LnN1YnN0cigxKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAodi5zdWJzdHIoMCwgMikgPT09IFwiLVwiLmNvbmNhdChvcHRzLmRlY2ltYWxTZXBhcmF0b3IpKSB7XG5cdCAgICAgICAgICAgICAgICB2ID0gXCItMFwiLmNvbmNhdChvcHRzLmRlY2ltYWxTZXBhcmF0b3IpLmNvbmNhdCh2LnN1YnN0cigyKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIGRlY2ltYWxTZXBhcmF0b3IgPSBvcHRzLmRlY2ltYWxTZXBhcmF0b3IgPT09ICcuJyA/ICdcXFxcLicgOiBvcHRzLmRlY2ltYWxTZXBhcmF0b3I7XG5cdCAgICAgICAgICAgIHZhciB0aG91c2FuZHNTZXBhcmF0b3IgPSBvcHRzLnRob3VzYW5kc1NlcGFyYXRvciA9PT0gJy4nID8gJ1xcXFwuJyA6IG9wdHMudGhvdXNhbmRzU2VwYXJhdG9yO1xuXHQgICAgICAgICAgICB2YXIgdGVzdFJlZ2V4cCA9IG5ldyBSZWdFeHAoXCJeLT9bMC05XXsxLDN9KFwiLmNvbmNhdCh0aG91c2FuZHNTZXBhcmF0b3IsIFwiWzAtOV17M30pKihcIikuY29uY2F0KGRlY2ltYWxTZXBhcmF0b3IsIFwiWzAtOV0rKT8kXCIpKTtcblx0ICAgICAgICAgICAgdmFyIHRob3VzYW5kc1JlcGxhY2VyID0gbmV3IFJlZ0V4cCh0aG91c2FuZHNTZXBhcmF0b3IsICdnJyk7XG5cdCAgICAgICAgICAgIGlmICghdGVzdFJlZ2V4cC50ZXN0KHYpKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvLyBSZXBsYWNlIHRob3VzYW5kcyBzZXBhcmF0b3Igd2l0aCBibGFua1xuXHQgICAgICAgICAgICBpZiAodGhvdXNhbmRzU2VwYXJhdG9yKSB7XG5cdCAgICAgICAgICAgICAgICB2ID0gdi5yZXBsYWNlKHRob3VzYW5kc1JlcGxhY2VyLCAnJyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgLy8gUmVwbGFjZSBkZWNpbWFsIHNlcGFyYXRvciB3aXRoIGEgZG90XG5cdCAgICAgICAgICAgIGlmIChkZWNpbWFsU2VwYXJhdG9yKSB7XG5cdCAgICAgICAgICAgICAgICB2ID0gdi5yZXBsYWNlKGRlY2ltYWxTZXBhcmF0b3IsICcuJyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIG4gPSBwYXJzZUZsb2F0KHYpO1xuXHQgICAgICAgICAgICByZXR1cm4geyB2YWxpZDogIWlzTmFOKG4pICYmIGlzRmluaXRlKG4pIH07XG5cdCAgICAgICAgfSxcblx0ICAgIH07XG5cdH1cblxuXHRjanMkNi5udW1lcmljID0gbnVtZXJpYztcblx0cmV0dXJuIGNqcyQ2O1xufVxuXG4vKipcbiAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG4gKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICBsaWIkNi5leHBvcnRzID0gcmVxdWlyZUluZGV4X21pbiQ2KCk7XG59IGVsc2Uge1xuICAgIGxpYiQ2LmV4cG9ydHMgPSByZXF1aXJlQ2pzJDYoKTtcbn1cblxudmFyIGxpYkV4cG9ydHMkNiA9IGxpYiQ2LmV4cG9ydHM7XG5cbnZhciBsaWIkNSA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBpbmRleF9taW4kNSA9IHt9O1xuXG4vKiogXG4gKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcbiAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuICpcbiAqIEBsaWNlbnNlIGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8vbGljZW5zZVxuICogQHBhY2thZ2UgQGZvcm0tdmFsaWRhdGlvbi92YWxpZGF0b3ItcHJvbWlzZVxuICogQHZlcnNpb24gMi40LjBcbiAqL1xuXG52YXIgaGFzUmVxdWlyZWRJbmRleF9taW4kNTtcblxuZnVuY3Rpb24gcmVxdWlyZUluZGV4X21pbiQ1ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkSW5kZXhfbWluJDUpIHJldHVybiBpbmRleF9taW4kNTtcblx0aGFzUmVxdWlyZWRJbmRleF9taW4kNSA9IDE7XG52YXIgcj1saWJFeHBvcnRzJEIudXRpbHMuY2FsbDtpbmRleF9taW4kNS5wcm9taXNlPWZ1bmN0aW9uKCl7cmV0dXJuIHt2YWxpZGF0ZTpmdW5jdGlvbihpKXtyZXR1cm4gcihpLm9wdGlvbnMucHJvbWlzZSxbaV0pfX19O1xuXHRyZXR1cm4gaW5kZXhfbWluJDU7XG59XG5cbnZhciBjanMkNSA9IHt9O1xuXG52YXIgaGFzUmVxdWlyZWRDanMkNTtcblxuZnVuY3Rpb24gcmVxdWlyZUNqcyQ1ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkQ2pzJDUpIHJldHVybiBjanMkNTtcblx0aGFzUmVxdWlyZWRDanMkNSA9IDE7XG5cblx0dmFyIGNvcmUgPSBsaWJFeHBvcnRzJEI7XG5cblx0LyoqXG5cdCAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuXHQgKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcblx0ICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuXHQgKi9cblx0dmFyIGNhbGwgPSBjb3JlLnV0aWxzLmNhbGw7XG5cdGZ1bmN0aW9uIHByb21pc2UoKSB7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBkZW1vbnN0cmF0ZXMgaG93IHRvIHVzZSBhIHByb21pc2UgdmFsaWRhdG9yIHRvIHJlcXVpcmVzIGJvdGggd2lkdGggYW5kIGhlaWdodFxuXHQgICAgICAgICAqIG9mIGFuIGltYWdlIHRvIGJlIGxlc3MgdGhhbiAzMDAgcHhcblx0ICAgICAgICAgKiAgYGBgXG5cdCAgICAgICAgICogIGNvbnN0IHAgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdCAgICAgICAgICogICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKVxuXHQgICAgICAgICAqICAgICAgaW1nLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgKiAgICAgICAgICBjb25zdCB3ID0gdGhpcy53aWR0aFxuXHQgICAgICAgICAqICAgICAgICAgIGNvbnN0IGggPSB0aGlzLmhlaWdodFxuXHQgICAgICAgICAqICAgICAgICAgIHJlc29sdmUoe1xuXHQgICAgICAgICAqICAgICAgICAgICAgICB2YWxpZDogdyA8PSAzMDAgJiYgaCA8PSAzMDBcblx0ICAgICAgICAgKiAgICAgICAgICAgICAgbWV0YToge1xuXHQgICAgICAgICAqICAgICAgICAgICAgICAgICAgc291cmNlOiBpbWcuc3JjIC8vIFNvLCB5b3UgY2FuIHJldXNlIGl0IGxhdGVyIGlmIHlvdSB3YW50XG5cdCAgICAgICAgICogICAgICAgICAgICAgIH1cblx0ICAgICAgICAgKiAgICAgICAgICB9KVxuXHQgICAgICAgICAqICAgICAgfSlcblx0ICAgICAgICAgKiAgICAgIGltZy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAqICAgICAgICAgIHJlamVjdCh7XG5cdCAgICAgICAgICogICAgICAgICAgICAgIHZhbGlkOiBmYWxzZSxcblx0ICAgICAgICAgKiAgICAgICAgICAgICAgbWVzc2FnZTogUGxlYXNlIGNob29zZSBhbiBpbWFnZVxuXHQgICAgICAgICAqICAgICAgICAgIH0pXG5cdCAgICAgICAgICogICAgICB9KVxuXHQgICAgICAgICAqICB9KVxuXHQgICAgICAgICAqICBgYGBcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSBpbnB1dFxuXHQgICAgICAgICAqIEByZXR1cm4ge1Byb21pc2U8VmFsaWRhdGVSZXN1bHQ+fVxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoaW5wdXQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGNhbGwoaW5wdXQub3B0aW9ucy5wcm9taXNlLCBbaW5wdXRdKTtcblx0ICAgICAgICB9LFxuXHQgICAgfTtcblx0fVxuXG5cdGNqcyQ1LnByb21pc2UgPSBwcm9taXNlO1xuXHRyZXR1cm4gY2pzJDU7XG59XG5cbi8qKlxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgIGxpYiQ1LmV4cG9ydHMgPSByZXF1aXJlSW5kZXhfbWluJDUoKTtcbn0gZWxzZSB7XG4gICAgbGliJDUuZXhwb3J0cyA9IHJlcXVpcmVDanMkNSgpO1xufVxuXG52YXIgbGliRXhwb3J0cyQ1ID0gbGliJDUuZXhwb3J0cztcblxudmFyIGxpYiQ0ID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIGluZGV4X21pbiQ0ID0ge307XG5cbi8qKiBcbiAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG4gKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKlxuICogQGxpY2Vuc2UgaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pby9saWNlbnNlXG4gKiBAcGFja2FnZSBAZm9ybS12YWxpZGF0aW9uL3ZhbGlkYXRvci1yZWdleHBcbiAqIEB2ZXJzaW9uIDIuNC4wXG4gKi9cblxudmFyIGhhc1JlcXVpcmVkSW5kZXhfbWluJDQ7XG5cbmZ1bmN0aW9uIHJlcXVpcmVJbmRleF9taW4kNCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEluZGV4X21pbiQ0KSByZXR1cm4gaW5kZXhfbWluJDQ7XG5cdGhhc1JlcXVpcmVkSW5kZXhfbWluJDQgPSAxO1xuaW5kZXhfbWluJDQucmVnZXhwPWZ1bmN0aW9uKCl7cmV0dXJuIHt2YWxpZGF0ZTpmdW5jdGlvbihlKXtpZihcIlwiPT09ZS52YWx1ZSlyZXR1cm4ge3ZhbGlkOiEwfTt2YXIgdD1lLm9wdGlvbnMucmVnZXhwO2lmKHQgaW5zdGFuY2VvZiBSZWdFeHApcmV0dXJuIHt2YWxpZDp0LnRlc3QoZS52YWx1ZSl9O3ZhciBuPXQudG9TdHJpbmcoKTtyZXR1cm4ge3ZhbGlkOihlLm9wdGlvbnMuZmxhZ3M/bmV3IFJlZ0V4cChuLGUub3B0aW9ucy5mbGFncyk6bmV3IFJlZ0V4cChuKSkudGVzdChlLnZhbHVlKX19fX07XG5cdHJldHVybiBpbmRleF9taW4kNDtcbn1cblxudmFyIGNqcyQ0ID0ge307XG5cbnZhciBoYXNSZXF1aXJlZENqcyQ0O1xuXG5mdW5jdGlvbiByZXF1aXJlQ2pzJDQgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRDanMkNCkgcmV0dXJuIGNqcyQ0O1xuXHRoYXNSZXF1aXJlZENqcyQ0ID0gMTtcblxuXHQvKipcblx0ICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG5cdCAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuXHQgKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG5cdCAqL1xuXHRmdW5jdGlvbiByZWdleHAoKSB7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENoZWNrIGlmIHRoZSBlbGVtZW50IHZhbHVlIG1hdGNoZXMgZ2l2ZW4gcmVndWxhciBleHByZXNzaW9uXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChpbnB1dCkge1xuXHQgICAgICAgICAgICBpZiAoaW5wdXQudmFsdWUgPT09ICcnKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSB9O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciByZWcgPSBpbnB1dC5vcHRpb25zLnJlZ2V4cDtcblx0ICAgICAgICAgICAgaWYgKHJlZyBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHJlZy50ZXN0KGlucHV0LnZhbHVlKSB9O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSByZWcudG9TdHJpbmcoKTtcblx0ICAgICAgICAgICAgICAgIHZhciBleHAgPSBpbnB1dC5vcHRpb25zLmZsYWdzID8gbmV3IFJlZ0V4cChwYXR0ZXJuLCBpbnB1dC5vcHRpb25zLmZsYWdzKSA6IG5ldyBSZWdFeHAocGF0dGVybik7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZXhwLnRlc3QoaW5wdXQudmFsdWUpIH07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgfTtcblx0fVxuXG5cdGNqcyQ0LnJlZ2V4cCA9IHJlZ2V4cDtcblx0cmV0dXJuIGNqcyQ0O1xufVxuXG4vKipcbiAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG4gKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICBsaWIkNC5leHBvcnRzID0gcmVxdWlyZUluZGV4X21pbiQ0KCk7XG59IGVsc2Uge1xuICAgIGxpYiQ0LmV4cG9ydHMgPSByZXF1aXJlQ2pzJDQoKTtcbn1cblxudmFyIGxpYkV4cG9ydHMkNCA9IGxpYiQ0LmV4cG9ydHM7XG5cbnZhciBsaWIkMyA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBpbmRleF9taW4kMyA9IHt9O1xuXG4vKiogXG4gKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcbiAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuICpcbiAqIEBsaWNlbnNlIGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8vbGljZW5zZVxuICogQHBhY2thZ2UgQGZvcm0tdmFsaWRhdGlvbi92YWxpZGF0b3ItcmVtb3RlXG4gKiBAdmVyc2lvbiAyLjQuMFxuICovXG5cbnZhciBoYXNSZXF1aXJlZEluZGV4X21pbiQzO1xuXG5mdW5jdGlvbiByZXF1aXJlSW5kZXhfbWluJDMgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRJbmRleF9taW4kMykgcmV0dXJuIGluZGV4X21pbiQzO1xuXHRoYXNSZXF1aXJlZEluZGV4X21pbiQzID0gMTtcbnZhciBlPWxpYkV4cG9ydHMkQixhPWUudXRpbHMuZmV0Y2gscj1lLnV0aWxzLnJlbW92ZVVuZGVmaW5lZDtpbmRleF9taW4kMy5yZW1vdGU9ZnVuY3Rpb24oKXt2YXIgZT17Y3Jvc3NEb21haW46ITEsZGF0YTp7fSxoZWFkZXJzOnt9LG1ldGhvZDpcIkdFVFwiLHZhbGlkS2V5OlwidmFsaWRcIn07cmV0dXJuIHt2YWxpZGF0ZTpmdW5jdGlvbih0KXtpZihcIlwiPT09dC52YWx1ZSlyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHt2YWxpZDohMH0pO3ZhciBpPU9iamVjdC5hc3NpZ24oe30sZSxyKHQub3B0aW9ucykpLG89aS5kYXRhO1wiZnVuY3Rpb25cIj09dHlwZW9mIGkuZGF0YSYmKG89aS5kYXRhLmNhbGwodGhpcyx0KSksXCJzdHJpbmdcIj09dHlwZW9mIG8mJihvPUpTT04ucGFyc2UobykpLG9baS5uYW1lfHx0LmZpZWxkXT10LnZhbHVlO3ZhciBzPVwiZnVuY3Rpb25cIj09dHlwZW9mIGkudXJsP2kudXJsLmNhbGwodGhpcyx0KTppLnVybDtyZXR1cm4gYShzLHtjcm9zc0RvbWFpbjppLmNyb3NzRG9tYWluLGhlYWRlcnM6aS5oZWFkZXJzLG1ldGhvZDppLm1ldGhvZCxwYXJhbXM6b30pLnRoZW4oKGZ1bmN0aW9uKGUpe3JldHVybiBQcm9taXNlLnJlc29sdmUoe21lc3NhZ2U6ZS5tZXNzYWdlLG1ldGE6ZSx2YWxpZDpcInRydWVcIj09PVwiXCIuY29uY2F0KGVbaS52YWxpZEtleV0pfSl9KSkuY2F0Y2goKGZ1bmN0aW9uKGUpe3JldHVybiBQcm9taXNlLnJlamVjdCh7dmFsaWQ6ITF9KX0pKX19fTtcblx0cmV0dXJuIGluZGV4X21pbiQzO1xufVxuXG52YXIgY2pzJDMgPSB7fTtcblxudmFyIGhhc1JlcXVpcmVkQ2pzJDM7XG5cbmZ1bmN0aW9uIHJlcXVpcmVDanMkMyAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZENqcyQzKSByZXR1cm4gY2pzJDM7XG5cdGhhc1JlcXVpcmVkQ2pzJDMgPSAxO1xuXG5cdHZhciBjb3JlID0gbGliRXhwb3J0cyRCO1xuXG5cdC8qKlxuXHQgKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcblx0ICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG5cdCAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cblx0ICovXG5cdHZhciBmZXRjaCA9IGNvcmUudXRpbHMuZmV0Y2gsIHJlbW92ZVVuZGVmaW5lZCA9IGNvcmUudXRpbHMucmVtb3ZlVW5kZWZpbmVkO1xuXHRmdW5jdGlvbiByZW1vdGUoKSB7XG5cdCAgICB2YXIgREVGQVVMVF9PUFRJT05TID0ge1xuXHQgICAgICAgIGNyb3NzRG9tYWluOiBmYWxzZSxcblx0ICAgICAgICBkYXRhOiB7fSxcblx0ICAgICAgICBoZWFkZXJzOiB7fSxcblx0ICAgICAgICBtZXRob2Q6ICdHRVQnLFxuXHQgICAgICAgIHZhbGlkS2V5OiAndmFsaWQnLFxuXHQgICAgfTtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChpbnB1dCkge1xuXHQgICAgICAgICAgICBpZiAoaW5wdXQudmFsdWUgPT09ICcnKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcblx0ICAgICAgICAgICAgICAgICAgICB2YWxpZDogdHJ1ZSxcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCByZW1vdmVVbmRlZmluZWQoaW5wdXQub3B0aW9ucykpO1xuXHQgICAgICAgICAgICB2YXIgZGF0YSA9IG9wdHMuZGF0YTtcblx0ICAgICAgICAgICAgLy8gU3VwcG9ydCBkeW5hbWljIGRhdGFcblx0ICAgICAgICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBvcHRzLmRhdGEpIHtcblx0ICAgICAgICAgICAgICAgIGRhdGEgPSBvcHRzLmRhdGEuY2FsbCh0aGlzLCBpbnB1dCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgLy8gUGFyc2Ugc3RyaW5nIGRhdGEgZnJvbSBIVE1MNSBhdHRyaWJ1dGVcblx0ICAgICAgICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgZGF0YSkge1xuXHQgICAgICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZGF0YVtvcHRzLm5hbWUgfHwgaW5wdXQuZmllbGRdID0gaW5wdXQudmFsdWU7XG5cdCAgICAgICAgICAgIC8vIFN1cHBvcnQgZHluYW1pYyB1cmxcblx0ICAgICAgICAgICAgdmFyIHVybCA9ICdmdW5jdGlvbicgPT09IHR5cGVvZiBvcHRzLnVybFxuXHQgICAgICAgICAgICAgICAgPyBvcHRzLnVybC5jYWxsKHRoaXMsIGlucHV0KVxuXHQgICAgICAgICAgICAgICAgOiBvcHRzLnVybDtcblx0ICAgICAgICAgICAgcmV0dXJuIGZldGNoKHVybCwge1xuXHQgICAgICAgICAgICAgICAgY3Jvc3NEb21haW46IG9wdHMuY3Jvc3NEb21haW4sXG5cdCAgICAgICAgICAgICAgICBoZWFkZXJzOiBvcHRzLmhlYWRlcnMsXG5cdCAgICAgICAgICAgICAgICBtZXRob2Q6IG9wdHMubWV0aG9kLFxuXHQgICAgICAgICAgICAgICAgcGFyYW1zOiBkYXRhLFxuXHQgICAgICAgICAgICB9KVxuXHQgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcblx0ICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiByZXNwb25zZVsnbWVzc2FnZSddLFxuXHQgICAgICAgICAgICAgICAgICAgIG1ldGE6IHJlc3BvbnNlLFxuXHQgICAgICAgICAgICAgICAgICAgIHZhbGlkOiBcIlwiLmNvbmNhdChyZXNwb25zZVtvcHRzLnZhbGlkS2V5XSkgPT09ICd0cnVlJyxcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9KVxuXHQgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChfcmVhc29uKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3Qoe1xuXHQgICAgICAgICAgICAgICAgICAgIHZhbGlkOiBmYWxzZSxcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9LFxuXHQgICAgfTtcblx0fVxuXG5cdGNqcyQzLnJlbW90ZSA9IHJlbW90ZTtcblx0cmV0dXJuIGNqcyQzO1xufVxuXG4vKipcbiAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG4gKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICBsaWIkMy5leHBvcnRzID0gcmVxdWlyZUluZGV4X21pbiQzKCk7XG59IGVsc2Uge1xuICAgIGxpYiQzLmV4cG9ydHMgPSByZXF1aXJlQ2pzJDMoKTtcbn1cblxudmFyIGxpYkV4cG9ydHMkMyA9IGxpYiQzLmV4cG9ydHM7XG5cbnZhciBsaWIkMiA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBpbmRleF9taW4kMiA9IHt9O1xuXG4vKiogXG4gKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcbiAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuICpcbiAqIEBsaWNlbnNlIGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8vbGljZW5zZVxuICogQHBhY2thZ2UgQGZvcm0tdmFsaWRhdGlvbi92YWxpZGF0b3Itc3RyaW5nLWNhc2VcbiAqIEB2ZXJzaW9uIDIuNC4wXG4gKi9cblxudmFyIGhhc1JlcXVpcmVkSW5kZXhfbWluJDI7XG5cbmZ1bmN0aW9uIHJlcXVpcmVJbmRleF9taW4kMiAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEluZGV4X21pbiQyKSByZXR1cm4gaW5kZXhfbWluJDI7XG5cdGhhc1JlcXVpcmVkSW5kZXhfbWluJDIgPSAxO1xudmFyIGU9bGliRXhwb3J0cyRCLnV0aWxzLnJlbW92ZVVuZGVmaW5lZDtpbmRleF9taW4kMi5zdHJpbmdDYXNlPWZ1bmN0aW9uKCl7cmV0dXJuIHt2YWxpZGF0ZTpmdW5jdGlvbihhKXtpZihcIlwiPT09YS52YWx1ZSlyZXR1cm4ge3ZhbGlkOiEwfTt2YXIgcj1PYmplY3QuYXNzaWduKHt9LHtjYXNlOlwibG93ZXJcIn0sZShhLm9wdGlvbnMpKSxzPShyLmNhc2V8fFwibG93ZXJcIikudG9Mb3dlckNhc2UoKTtyZXR1cm4ge21lc3NhZ2U6ci5tZXNzYWdlfHwoYS5sMTBuP1widXBwZXJcIj09PXM/YS5sMTBuLnN0cmluZ0Nhc2UudXBwZXI6YS5sMTBuLnN0cmluZ0Nhc2UuZGVmYXVsdDpyLm1lc3NhZ2UpLHZhbGlkOlwidXBwZXJcIj09PXM/YS52YWx1ZT09PWEudmFsdWUudG9VcHBlckNhc2UoKTphLnZhbHVlPT09YS52YWx1ZS50b0xvd2VyQ2FzZSgpfX19fTtcblx0cmV0dXJuIGluZGV4X21pbiQyO1xufVxuXG52YXIgY2pzJDIgPSB7fTtcblxudmFyIGhhc1JlcXVpcmVkQ2pzJDI7XG5cbmZ1bmN0aW9uIHJlcXVpcmVDanMkMiAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZENqcyQyKSByZXR1cm4gY2pzJDI7XG5cdGhhc1JlcXVpcmVkQ2pzJDIgPSAxO1xuXG5cdHZhciBjb3JlID0gbGliRXhwb3J0cyRCO1xuXG5cdC8qKlxuXHQgKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcblx0ICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG5cdCAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cblx0ICovXG5cdHZhciByZW1vdmVVbmRlZmluZWQgPSBjb3JlLnV0aWxzLnJlbW92ZVVuZGVmaW5lZDtcblx0ZnVuY3Rpb24gc3RyaW5nQ2FzZSgpIHtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ2hlY2sgaWYgYSBzdHJpbmcgaXMgYSBsb3dlciBvciB1cHBlciBjYXNlIG9uZVxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoaW5wdXQpIHtcblx0ICAgICAgICAgICAgaWYgKGlucHV0LnZhbHVlID09PSAnJykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUgfTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIHsgY2FzZTogJ2xvd2VyJyB9LCByZW1vdmVVbmRlZmluZWQoaW5wdXQub3B0aW9ucykpO1xuXHQgICAgICAgICAgICB2YXIgY2FzZU9wdCA9IChvcHRzLmNhc2UgfHwgJ2xvd2VyJykudG9Mb3dlckNhc2UoKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG9wdHMubWVzc2FnZSB8fFxuXHQgICAgICAgICAgICAgICAgICAgIChpbnB1dC5sMTBuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgID8gJ3VwcGVyJyA9PT0gY2FzZU9wdFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBpbnB1dC5sMTBuLnN0cmluZ0Nhc2UudXBwZXJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogaW5wdXQubDEwbi5zdHJpbmdDYXNlLmRlZmF1bHRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgOiBvcHRzLm1lc3NhZ2UpLFxuXHQgICAgICAgICAgICAgICAgdmFsaWQ6ICd1cHBlcicgPT09IGNhc2VPcHRcblx0ICAgICAgICAgICAgICAgICAgICA/IGlucHV0LnZhbHVlID09PSBpbnB1dC52YWx1ZS50b1VwcGVyQ2FzZSgpXG5cdCAgICAgICAgICAgICAgICAgICAgOiBpbnB1dC52YWx1ZSA9PT0gaW5wdXQudmFsdWUudG9Mb3dlckNhc2UoKSxcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9LFxuXHQgICAgfTtcblx0fVxuXG5cdGNqcyQyLnN0cmluZ0Nhc2UgPSBzdHJpbmdDYXNlO1xuXHRyZXR1cm4gY2pzJDI7XG59XG5cbi8qKlxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgIGxpYiQyLmV4cG9ydHMgPSByZXF1aXJlSW5kZXhfbWluJDIoKTtcbn0gZWxzZSB7XG4gICAgbGliJDIuZXhwb3J0cyA9IHJlcXVpcmVDanMkMigpO1xufVxuXG52YXIgbGliRXhwb3J0cyQyID0gbGliJDIuZXhwb3J0cztcblxudmFyIGxpYiQxID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIGluZGV4X21pbiQxID0ge307XG5cbi8qKiBcbiAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG4gKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKlxuICogQGxpY2Vuc2UgaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pby9saWNlbnNlXG4gKiBAcGFja2FnZSBAZm9ybS12YWxpZGF0aW9uL3ZhbGlkYXRvci1zdHJpbmctbGVuZ3RoXG4gKiBAdmVyc2lvbiAyLjQuMFxuICovXG5cbnZhciBoYXNSZXF1aXJlZEluZGV4X21pbiQxO1xuXG5mdW5jdGlvbiByZXF1aXJlSW5kZXhfbWluJDEgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRJbmRleF9taW4kMSkgcmV0dXJuIGluZGV4X21pbiQxO1xuXHRoYXNSZXF1aXJlZEluZGV4X21pbiQxID0gMTtcbnZhciBlPWxpYkV4cG9ydHMkQix0PWUudXRpbHMuZm9ybWF0LG49ZS51dGlscy5yZW1vdmVVbmRlZmluZWQ7aW5kZXhfbWluJDEuc3RyaW5nTGVuZ3RoPWZ1bmN0aW9uKCl7cmV0dXJuIHt2YWxpZGF0ZTpmdW5jdGlvbihlKXt2YXIgcz1PYmplY3QuYXNzaWduKHt9LHttZXNzYWdlOlwiXCIsdHJpbTohMSx1dGY4Qnl0ZXM6ITF9LG4oZS5vcHRpb25zKSksYT0hMD09PXMudHJpbXx8XCJ0cnVlXCI9PT1cIlwiLmNvbmNhdChzLnRyaW0pP2UudmFsdWUudHJpbSgpOmUudmFsdWU7aWYoXCJcIj09PWEpcmV0dXJuIHt2YWxpZDohMH07dmFyIHI9cy5taW4/XCJcIi5jb25jYXQocy5taW4pOlwiXCIsaT1zLm1heD9cIlwiLmNvbmNhdChzLm1heCk6XCJcIixnPXMudXRmOEJ5dGVzP2Z1bmN0aW9uKGUpe2Zvcih2YXIgdD1lLmxlbmd0aCxuPWUubGVuZ3RoLTE7bj49MDtuLS0pe3ZhciBzPWUuY2hhckNvZGVBdChuKTtzPjEyNyYmczw9MjA0Nz90Kys6cz4yMDQ3JiZzPD02NTUzNSYmKHQrPTIpLHM+PTU2MzIwJiZzPD01NzM0MyYmbi0tO31yZXR1cm4gdH0oYSk6YS5sZW5ndGgsbT0hMCxjPWUubDEwbj9zLm1lc3NhZ2V8fGUubDEwbi5zdHJpbmdMZW5ndGguZGVmYXVsdDpzLm1lc3NhZ2U7c3dpdGNoKChyJiZnPHBhcnNlSW50KHIsMTApfHxpJiZnPnBhcnNlSW50KGksMTApKSYmKG09ITEpLCEwKXtjYXNlISFyJiYhIWk6Yz10KGUubDEwbj9zLm1lc3NhZ2V8fGUubDEwbi5zdHJpbmdMZW5ndGguYmV0d2VlbjpzLm1lc3NhZ2UsW3IsaV0pO2JyZWFrO2Nhc2UhIXI6Yz10KGUubDEwbj9zLm1lc3NhZ2V8fGUubDEwbi5zdHJpbmdMZW5ndGgubW9yZTpzLm1lc3NhZ2UsXCJcIi5jb25jYXQocGFyc2VJbnQociwxMCkpKTticmVhaztjYXNlISFpOmM9dChlLmwxMG4/cy5tZXNzYWdlfHxlLmwxMG4uc3RyaW5nTGVuZ3RoLmxlc3M6cy5tZXNzYWdlLFwiXCIuY29uY2F0KHBhcnNlSW50KGksMTApKSk7fXJldHVybiB7bWVzc2FnZTpjLHZhbGlkOm19fX19O1xuXHRyZXR1cm4gaW5kZXhfbWluJDE7XG59XG5cbnZhciBjanMkMSA9IHt9O1xuXG52YXIgaGFzUmVxdWlyZWRDanMkMTtcblxuZnVuY3Rpb24gcmVxdWlyZUNqcyQxICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkQ2pzJDEpIHJldHVybiBjanMkMTtcblx0aGFzUmVxdWlyZWRDanMkMSA9IDE7XG5cblx0dmFyIGNvcmUgPSBsaWJFeHBvcnRzJEI7XG5cblx0LyoqXG5cdCAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuXHQgKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcblx0ICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuXHQgKi9cblx0dmFyIGZvcm1hdCA9IGNvcmUudXRpbHMuZm9ybWF0LCByZW1vdmVVbmRlZmluZWQgPSBjb3JlLnV0aWxzLnJlbW92ZVVuZGVmaW5lZDtcblx0Ly8gQ3JlZGl0IHRvIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIzMzI5Mzg2IChAbG92YXNvYSkgZm9yIFVURi04IGJ5dGUgbGVuZ3RoIGNvZGVcblx0dmFyIHV0ZjhMZW5ndGggPSBmdW5jdGlvbiAoc3RyKSB7XG5cdCAgICB2YXIgcyA9IHN0ci5sZW5ndGg7XG5cdCAgICBmb3IgKHZhciBpID0gc3RyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdCAgICAgICAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcblx0ICAgICAgICBpZiAoY29kZSA+IDB4N2YgJiYgY29kZSA8PSAweDdmZikge1xuXHQgICAgICAgICAgICBzKys7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKGNvZGUgPiAweDdmZiAmJiBjb2RlIDw9IDB4ZmZmZikge1xuXHQgICAgICAgICAgICBzICs9IDI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChjb2RlID49IDB4ZGMwMCAmJiBjb2RlIDw9IDB4ZGZmZikge1xuXHQgICAgICAgICAgICBpLS07XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHM7XG5cdH07XG5cdGZ1bmN0aW9uIHN0cmluZ0xlbmd0aCgpIHtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ2hlY2sgaWYgdGhlIGxlbmd0aCBvZiBlbGVtZW50IHZhbHVlIGlzIGxlc3Mgb3IgbW9yZSB0aGFuIGdpdmVuIG51bWJlclxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoaW5wdXQpIHtcblx0ICAgICAgICAgICAgdmFyIG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCB7XG5cdCAgICAgICAgICAgICAgICBtZXNzYWdlOiAnJyxcblx0ICAgICAgICAgICAgICAgIHRyaW06IGZhbHNlLFxuXHQgICAgICAgICAgICAgICAgdXRmOEJ5dGVzOiBmYWxzZSxcblx0ICAgICAgICAgICAgfSwgcmVtb3ZlVW5kZWZpbmVkKGlucHV0Lm9wdGlvbnMpKTtcblx0ICAgICAgICAgICAgdmFyIHYgPSBvcHRzLnRyaW0gPT09IHRydWUgfHwgXCJcIi5jb25jYXQob3B0cy50cmltKSA9PT0gJ3RydWUnID8gaW5wdXQudmFsdWUudHJpbSgpIDogaW5wdXQudmFsdWU7XG5cdCAgICAgICAgICAgIGlmICh2ID09PSAnJykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUgfTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvLyBUT0RPOiBgbWluYCwgYG1heGAgY2FuIGJlIGR5bmFtaWMgb3B0aW9uc1xuXHQgICAgICAgICAgICB2YXIgbWluID0gb3B0cy5taW4gPyBcIlwiLmNvbmNhdChvcHRzLm1pbikgOiAnJztcblx0ICAgICAgICAgICAgdmFyIG1heCA9IG9wdHMubWF4ID8gXCJcIi5jb25jYXQob3B0cy5tYXgpIDogJyc7XG5cdCAgICAgICAgICAgIHZhciBsZW5ndGggPSBvcHRzLnV0ZjhCeXRlcyA/IHV0ZjhMZW5ndGgodikgOiB2Lmxlbmd0aDtcblx0ICAgICAgICAgICAgdmFyIGlzVmFsaWQgPSB0cnVlO1xuXHQgICAgICAgICAgICB2YXIgbXNnID0gaW5wdXQubDEwbiA/IG9wdHMubWVzc2FnZSB8fCBpbnB1dC5sMTBuLnN0cmluZ0xlbmd0aC5kZWZhdWx0IDogb3B0cy5tZXNzYWdlO1xuXHQgICAgICAgICAgICBpZiAoKG1pbiAmJiBsZW5ndGggPCBwYXJzZUludChtaW4sIDEwKSkgfHwgKG1heCAmJiBsZW5ndGggPiBwYXJzZUludChtYXgsIDEwKSkpIHtcblx0ICAgICAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBzd2l0Y2ggKHRydWUpIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgISFtaW4gJiYgISFtYXg6XG5cdCAgICAgICAgICAgICAgICAgICAgbXNnID0gZm9ybWF0KGlucHV0LmwxMG4gPyBvcHRzLm1lc3NhZ2UgfHwgaW5wdXQubDEwbi5zdHJpbmdMZW5ndGguYmV0d2VlbiA6IG9wdHMubWVzc2FnZSwgW1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBtaW4sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG1heCxcblx0ICAgICAgICAgICAgICAgICAgICBdKTtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgISFtaW46XG5cdCAgICAgICAgICAgICAgICAgICAgbXNnID0gZm9ybWF0KGlucHV0LmwxMG4gPyBvcHRzLm1lc3NhZ2UgfHwgaW5wdXQubDEwbi5zdHJpbmdMZW5ndGgubW9yZSA6IG9wdHMubWVzc2FnZSwgXCJcIi5jb25jYXQocGFyc2VJbnQobWluLCAxMCkpKTtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgISFtYXg6XG5cdCAgICAgICAgICAgICAgICAgICAgbXNnID0gZm9ybWF0KGlucHV0LmwxMG4gPyBvcHRzLm1lc3NhZ2UgfHwgaW5wdXQubDEwbi5zdHJpbmdMZW5ndGgubGVzcyA6IG9wdHMubWVzc2FnZSwgXCJcIi5jb25jYXQocGFyc2VJbnQobWF4LCAxMCkpKTtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgbWVzc2FnZTogbXNnLFxuXHQgICAgICAgICAgICAgICAgdmFsaWQ6IGlzVmFsaWQsXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfSxcblx0ICAgIH07XG5cdH1cblxuXHRjanMkMS5zdHJpbmdMZW5ndGggPSBzdHJpbmdMZW5ndGg7XG5cdHJldHVybiBjanMkMTtcbn1cblxuLyoqXG4gKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcbiAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgbGliJDEuZXhwb3J0cyA9IHJlcXVpcmVJbmRleF9taW4kMSgpO1xufSBlbHNlIHtcbiAgICBsaWIkMS5leHBvcnRzID0gcmVxdWlyZUNqcyQxKCk7XG59XG5cbnZhciBsaWJFeHBvcnRzJDEgPSBsaWIkMS5leHBvcnRzO1xuXG52YXIgbGliID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIGluZGV4X21pbiA9IHt9O1xuXG4vKiogXG4gKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcbiAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuICpcbiAqIEBsaWNlbnNlIGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8vbGljZW5zZVxuICogQHBhY2thZ2UgQGZvcm0tdmFsaWRhdGlvbi92YWxpZGF0b3ItdXJpXG4gKiBAdmVyc2lvbiAyLjQuMFxuICovXG5cbnZhciBoYXNSZXF1aXJlZEluZGV4X21pbjtcblxuZnVuY3Rpb24gcmVxdWlyZUluZGV4X21pbiAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEluZGV4X21pbikgcmV0dXJuIGluZGV4X21pbjtcblx0aGFzUmVxdWlyZWRJbmRleF9taW4gPSAxO1xudmFyIG89bGliRXhwb3J0cyRCLnV0aWxzLnJlbW92ZVVuZGVmaW5lZDtpbmRleF9taW4udXJpPWZ1bmN0aW9uKCl7dmFyIGE9e2FsbG93RW1wdHlQcm90b2NvbDohMSxhbGxvd0xvY2FsOiExLHByb3RvY29sOlwiaHR0cCwgaHR0cHMsIGZ0cFwifTtyZXR1cm4ge3ZhbGlkYXRlOmZ1bmN0aW9uKHQpe2lmKFwiXCI9PT10LnZhbHVlKXJldHVybiB7dmFsaWQ6ITB9O3ZhciBsPU9iamVjdC5hc3NpZ24oe30sYSxvKHQub3B0aW9ucykpLGY9ITA9PT1sLmFsbG93TG9jYWx8fFwidHJ1ZVwiPT09XCJcIi5jb25jYXQobC5hbGxvd0xvY2FsKSxyPSEwPT09bC5hbGxvd0VtcHR5UHJvdG9jb2x8fFwidHJ1ZVwiPT09XCJcIi5jb25jYXQobC5hbGxvd0VtcHR5UHJvdG9jb2wpLGU9bC5wcm90b2NvbC5zcGxpdChcIixcIikuam9pbihcInxcIikucmVwbGFjZSgvXFxzL2csXCJcIik7cmV0dXJuIHt2YWxpZDpuZXcgUmVnRXhwKFwiXig/Oig/OlwiK2UrXCIpOi8vKVwiKyhyP1wiP1wiOlwiXCIpK1wiKD86XFxcXFMrKD86OlxcXFxTKik/QCk/KD86XCIrKGY/XCJcIjpcIig/ISg/OjEwfDEyNykoPzpcXFxcLlxcXFxkezEsM30pezN9KSg/ISg/OjE2OVxcXFwuMjU0fDE5MlxcXFwuMTY4KSg/OlxcXFwuXFxcXGR7MSwzfSl7Mn0pKD8hMTcyXFxcXC4oPzoxWzYtOV18MlxcXFxkfDNbMC0xXSkoPzpcXFxcLlxcXFxkezEsM30pezJ9KVwiKStcIig/OlsxLTldXFxcXGQ/fDFcXFxcZFxcXFxkfDJbMDFdXFxcXGR8MjJbMC0zXSkoPzpcXFxcLig/OjE/XFxcXGR7MSwyfXwyWzAtNF1cXFxcZHwyNVswLTVdKSl7Mn0oPzpcXFxcLig/OlsxLTldXFxcXGQ/fDFcXFxcZFxcXFxkfDJbMC00XVxcXFxkfDI1WzAtNF0pKXwoPzooPzpbYS16XFxcXHUwMGExLVxcXFx1ZmZmZjAtOV0tPykqW2EtelxcXFx1MDBhMS1cXFxcdWZmZmYwLTldKykoPzpcXFxcLig/OlthLXpcXFxcdTAwYTEtXFxcXHVmZmZmMC05XS0/KSpbYS16XFxcXHUwMGExLVxcXFx1ZmZmZjAtOV0pKig/OlxcXFwuKD86W2EtelxcXFx1MDBhMS1cXFxcdWZmZmZdezIsfSkpXCIrKGY/XCI/XCI6XCJcIikrXCIpKD86OlxcXFxkezIsNX0pPyg/Oi9bXlxcXFxzXSopPyRcIixcImlcIikudGVzdCh0LnZhbHVlKX19fX07XG5cdHJldHVybiBpbmRleF9taW47XG59XG5cbnZhciBjanMgPSB7fTtcblxudmFyIGhhc1JlcXVpcmVkQ2pzO1xuXG5mdW5jdGlvbiByZXF1aXJlQ2pzICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkQ2pzKSByZXR1cm4gY2pzO1xuXHRoYXNSZXF1aXJlZENqcyA9IDE7XG5cblx0dmFyIGNvcmUgPSBsaWJFeHBvcnRzJEI7XG5cblx0LyoqXG5cdCAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuXHQgKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcblx0ICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuXHQgKi9cblx0dmFyIHJlbW92ZVVuZGVmaW5lZCA9IGNvcmUudXRpbHMucmVtb3ZlVW5kZWZpbmVkO1xuXHRmdW5jdGlvbiB1cmkoKSB7XG5cdCAgICB2YXIgREVGQVVMVF9PUFRJT05TID0ge1xuXHQgICAgICAgIGFsbG93RW1wdHlQcm90b2NvbDogZmFsc2UsXG5cdCAgICAgICAgYWxsb3dMb2NhbDogZmFsc2UsXG5cdCAgICAgICAgcHJvdG9jb2w6ICdodHRwLCBodHRwcywgZnRwJyxcblx0ICAgIH07XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSBpbnB1dCB2YWx1ZSBpcyBhIHZhbGlkIFVSTFxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoaW5wdXQpIHtcblx0ICAgICAgICAgICAgaWYgKGlucHV0LnZhbHVlID09PSAnJykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUgfTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgcmVtb3ZlVW5kZWZpbmVkKGlucHV0Lm9wdGlvbnMpKTtcblx0ICAgICAgICAgICAgLy8gQ3JlZGl0IHRvIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2RwZXJpbmkvNzI5Mjk0XG5cdCAgICAgICAgICAgIC8vXG5cdCAgICAgICAgICAgIC8vIFJlZ3VsYXIgRXhwcmVzc2lvbiBmb3IgVVJMIHZhbGlkYXRpb25cblx0ICAgICAgICAgICAgLy9cblx0ICAgICAgICAgICAgLy8gQXV0aG9yOiBEaWVnbyBQZXJpbmlcblx0ICAgICAgICAgICAgLy8gVXBkYXRlZDogMjAxMC8xMi8wNVxuXHQgICAgICAgICAgICAvL1xuXHQgICAgICAgICAgICAvLyB0aGUgcmVndWxhciBleHByZXNzaW9uIGNvbXBvc2VkICYgY29tbWVudGVkXG5cdCAgICAgICAgICAgIC8vIGNvdWxkIGJlIGVhc2lseSB0d2Vha2VkIGZvciBSRkMgY29tcGxpYW5jZSxcblx0ICAgICAgICAgICAgLy8gaXQgd2FzIGV4cHJlc3NseSBtb2RpZmllZCB0byBmaXQgJiBzYXRpc2Z5XG5cdCAgICAgICAgICAgIC8vIHRoZXNlIHRlc3QgZm9yIGFuIFVSTCBzaG9ydGVuZXI6XG5cdCAgICAgICAgICAgIC8vXG5cdCAgICAgICAgICAgIC8vICAgaHR0cDovL21hdGhpYXNieW5lbnMuYmUvZGVtby91cmwtcmVnZXhcblx0ICAgICAgICAgICAgLy9cblx0ICAgICAgICAgICAgLy8gTm90ZXMgb24gcG9zc2libGUgZGlmZmVyZW5jZXMgZnJvbSBhIHN0YW5kYXJkL2dlbmVyaWMgdmFsaWRhdGlvbjpcblx0ICAgICAgICAgICAgLy9cblx0ICAgICAgICAgICAgLy8gLSB1dGYtOCBjaGFyIGNsYXNzIHRha2UgaW4gY29uc2lkZXJhdGlvbiB0aGUgZnVsbCBVbmljb2RlIHJhbmdlXG5cdCAgICAgICAgICAgIC8vIC0gVExEcyBhcmUgbWFuZGF0b3J5IHVubGVzcyBgYWxsb3dMb2NhbGAgaXMgdHJ1ZVxuXHQgICAgICAgICAgICAvLyAtIHByb3RvY29scyBoYXZlIGJlZW4gcmVzdHJpY3RlZCB0byBmdHAsIGh0dHAgYW5kIGh0dHBzIG9ubHkgYXMgcmVxdWVzdGVkXG5cdCAgICAgICAgICAgIC8vXG5cdCAgICAgICAgICAgIC8vIENoYW5nZXM6XG5cdCAgICAgICAgICAgIC8vXG5cdCAgICAgICAgICAgIC8vIC0gSVAgYWRkcmVzcyBkb3R0ZWQgbm90YXRpb24gdmFsaWRhdGlvbiwgcmFuZ2U6IDEuMC4wLjAgLSAyMjMuMjU1LjI1NS4yNTVcblx0ICAgICAgICAgICAgLy8gICBmaXJzdCBhbmQgbGFzdCBJUCBhZGRyZXNzIG9mIGVhY2ggY2xhc3MgaXMgY29uc2lkZXJlZCBpbnZhbGlkXG5cdCAgICAgICAgICAgIC8vICAgKHNpbmNlIHRoZXkgYXJlIGJyb2FkY2FzdC9uZXR3b3JrIGFkZHJlc3Nlcylcblx0ICAgICAgICAgICAgLy9cblx0ICAgICAgICAgICAgLy8gLSBBZGRlZCBleGNsdXNpb24gb2YgcHJpdmF0ZSwgcmVzZXJ2ZWQgYW5kL29yIGxvY2FsIG5ldHdvcmtzIHJhbmdlc1xuXHQgICAgICAgICAgICAvLyAgIHVubGVzcyBgYWxsb3dMb2NhbGAgaXMgdHJ1ZVxuXHQgICAgICAgICAgICAvL1xuXHQgICAgICAgICAgICAvLyAtIEFkZGVkIHBvc3NpYmlsaXR5IG9mIGNob29zaW5nIGEgY3VzdG9tIHByb3RvY29sXG5cdCAgICAgICAgICAgIC8vXG5cdCAgICAgICAgICAgIC8vIC0gQWRkIG9wdGlvbiB0byB2YWxpZGF0ZSB3aXRob3V0IHByb3RvY29sXG5cdCAgICAgICAgICAgIC8vXG5cdCAgICAgICAgICAgIHZhciBhbGxvd0xvY2FsID0gb3B0cy5hbGxvd0xvY2FsID09PSB0cnVlIHx8IFwiXCIuY29uY2F0KG9wdHMuYWxsb3dMb2NhbCkgPT09ICd0cnVlJztcblx0ICAgICAgICAgICAgdmFyIGFsbG93RW1wdHlQcm90b2NvbCA9IG9wdHMuYWxsb3dFbXB0eVByb3RvY29sID09PSB0cnVlIHx8IFwiXCIuY29uY2F0KG9wdHMuYWxsb3dFbXB0eVByb3RvY29sKSA9PT0gJ3RydWUnO1xuXHQgICAgICAgICAgICB2YXIgcHJvdG9jb2wgPSBvcHRzLnByb3RvY29sLnNwbGl0KCcsJykuam9pbignfCcpLnJlcGxhY2UoL1xccy9nLCAnJyk7XG5cdCAgICAgICAgICAgIHZhciB1cmxFeHAgPSBuZXcgUmVnRXhwKCdeJyArXG5cdCAgICAgICAgICAgICAgICAvLyBwcm90b2NvbCBpZGVudGlmaWVyXG5cdCAgICAgICAgICAgICAgICAnKD86KD86JyArXG5cdCAgICAgICAgICAgICAgICBwcm90b2NvbCArXG5cdCAgICAgICAgICAgICAgICAnKTovLyknICtcblx0ICAgICAgICAgICAgICAgIC8vIGFsbG93IGVtcHR5IHByb3RvY29sXG5cdCAgICAgICAgICAgICAgICAoYWxsb3dFbXB0eVByb3RvY29sID8gJz8nIDogJycpICtcblx0ICAgICAgICAgICAgICAgIC8vIHVzZXI6cGFzcyBhdXRoZW50aWNhdGlvblxuXHQgICAgICAgICAgICAgICAgJyg/OlxcXFxTKyg/OjpcXFxcUyopP0ApPycgK1xuXHQgICAgICAgICAgICAgICAgJyg/OicgK1xuXHQgICAgICAgICAgICAgICAgLy8gSVAgYWRkcmVzcyBleGNsdXNpb25cblx0ICAgICAgICAgICAgICAgIC8vIHByaXZhdGUgJiBsb2NhbCBuZXR3b3Jrc1xuXHQgICAgICAgICAgICAgICAgKGFsbG93TG9jYWxcblx0ICAgICAgICAgICAgICAgICAgICA/ICcnXG5cdCAgICAgICAgICAgICAgICAgICAgOiAnKD8hKD86MTB8MTI3KSg/OlxcXFwuXFxcXGR7MSwzfSl7M30pJyArXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICcoPyEoPzoxNjlcXFxcLjI1NHwxOTJcXFxcLjE2OCkoPzpcXFxcLlxcXFxkezEsM30pezJ9KScgK1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAnKD8hMTcyXFxcXC4oPzoxWzYtOV18MlxcXFxkfDNbMC0xXSkoPzpcXFxcLlxcXFxkezEsM30pezJ9KScpICtcblx0ICAgICAgICAgICAgICAgIC8vIElQIGFkZHJlc3MgZG90dGVkIG5vdGF0aW9uIG9jdGV0c1xuXHQgICAgICAgICAgICAgICAgLy8gZXhjbHVkZXMgbG9vcGJhY2sgbmV0d29yayAwLjAuMC4wXG5cdCAgICAgICAgICAgICAgICAvLyBleGNsdWRlcyByZXNlcnZlZCBzcGFjZSA+PSAyMjQuMC4wLjBcblx0ICAgICAgICAgICAgICAgIC8vIGV4Y2x1ZGVzIG5ldHdvcmsgJiBicm9hZGNhc3QgYWRkcmVzc2VzXG5cdCAgICAgICAgICAgICAgICAvLyAoZmlyc3QgJiBsYXN0IElQIGFkZHJlc3Mgb2YgZWFjaCBjbGFzcylcblx0ICAgICAgICAgICAgICAgICcoPzpbMS05XVxcXFxkP3wxXFxcXGRcXFxcZHwyWzAxXVxcXFxkfDIyWzAtM10pJyArXG5cdCAgICAgICAgICAgICAgICAnKD86XFxcXC4oPzoxP1xcXFxkezEsMn18MlswLTRdXFxcXGR8MjVbMC01XSkpezJ9JyArXG5cdCAgICAgICAgICAgICAgICAnKD86XFxcXC4oPzpbMS05XVxcXFxkP3wxXFxcXGRcXFxcZHwyWzAtNF1cXFxcZHwyNVswLTRdKSknICtcblx0ICAgICAgICAgICAgICAgICd8JyArXG5cdCAgICAgICAgICAgICAgICAvLyBob3N0IG5hbWVcblx0ICAgICAgICAgICAgICAgICcoPzooPzpbYS16XFxcXHUwMGExLVxcXFx1ZmZmZjAtOV0tPykqW2EtelxcXFx1MDBhMS1cXFxcdWZmZmYwLTldKyknICtcblx0ICAgICAgICAgICAgICAgIC8vIGRvbWFpbiBuYW1lXG5cdCAgICAgICAgICAgICAgICAnKD86XFxcXC4oPzpbYS16XFxcXHUwMGExLVxcXFx1ZmZmZjAtOV0tPykqW2EtelxcXFx1MDBhMS1cXFxcdWZmZmYwLTldKSonICtcblx0ICAgICAgICAgICAgICAgIC8vIFRMRCBpZGVudGlmaWVyXG5cdCAgICAgICAgICAgICAgICAnKD86XFxcXC4oPzpbYS16XFxcXHUwMGExLVxcXFx1ZmZmZl17Mix9KSknICtcblx0ICAgICAgICAgICAgICAgIC8vIEFsbG93IGludHJhbmV0IHNpdGVzIChubyBUTEQpIGlmIGBhbGxvd0xvY2FsYCBpcyB0cnVlXG5cdCAgICAgICAgICAgICAgICAoYWxsb3dMb2NhbCA/ICc/JyA6ICcnKSArXG5cdCAgICAgICAgICAgICAgICAnKScgK1xuXHQgICAgICAgICAgICAgICAgLy8gcG9ydCBudW1iZXJcblx0ICAgICAgICAgICAgICAgICcoPzo6XFxcXGR7Miw1fSk/JyArXG5cdCAgICAgICAgICAgICAgICAvLyByZXNvdXJjZSBwYXRoXG5cdCAgICAgICAgICAgICAgICAnKD86L1teXFxcXHNdKik/JCcsICdpJyk7XG5cdCAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiB1cmxFeHAudGVzdChpbnB1dC52YWx1ZSkgfTtcblx0ICAgICAgICB9LFxuXHQgICAgfTtcblx0fVxuXG5cdGNqcy51cmkgPSB1cmk7XG5cdHJldHVybiBjanM7XG59XG5cbi8qKlxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgIGxpYi5leHBvcnRzID0gcmVxdWlyZUluZGV4X21pbigpO1xufSBlbHNlIHtcbiAgICBsaWIuZXhwb3J0cyA9IHJlcXVpcmVDanMoKTtcbn1cblxudmFyIGxpYkV4cG9ydHMgPSBsaWIuZXhwb3J0cztcblxuLyoqXG4gKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcbiAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuICovXG52YXIgcGx1Z2lucyA9IHtcbiAgICBBbGlhczogbGliRXhwb3J0cyRBLkFsaWFzLFxuICAgIEFyaWE6IGxpYkV4cG9ydHMkei5BcmlhLFxuICAgIERlY2xhcmF0aXZlOiBsaWJFeHBvcnRzJHkuRGVjbGFyYXRpdmUsXG4gICAgRGVmYXVsdFN1Ym1pdDogbGliRXhwb3J0cyR4LkRlZmF1bHRTdWJtaXQsXG4gICAgRGVwZW5kZW5jeTogbGliRXhwb3J0cyR3LkRlcGVuZGVuY3ksXG4gICAgRXhjbHVkZWQ6IGxpYkV4cG9ydHMkdi5FeGNsdWRlZCxcbiAgICBGaWVsZFN0YXR1czogbGliRXhwb3J0cyR1LkZpZWxkU3RhdHVzLFxuICAgIEZyYW1ld29yazogbGliRXhwb3J0cyRzLkZyYW1ld29yayxcbiAgICBJY29uOiBsaWJFeHBvcnRzJHIuSWNvbixcbiAgICBNZXNzYWdlOiBsaWJFeHBvcnRzJHQuTWVzc2FnZSxcbiAgICBTZXF1ZW5jZTogbGliRXhwb3J0cyRxLlNlcXVlbmNlLFxuICAgIFN1Ym1pdEJ1dHRvbjogbGliRXhwb3J0cyRwLlN1Ym1pdEJ1dHRvbixcbiAgICBUb29sdGlwOiBsaWJFeHBvcnRzJG8uVG9vbHRpcCxcbiAgICBUcmlnZ2VyOiBsaWJFeHBvcnRzJG4uVHJpZ2dlcixcbn07XG52YXIgdmFsaWRhdG9ycyA9IHtcbiAgICBiZXR3ZWVuOiBsaWJFeHBvcnRzJG0uYmV0d2VlbixcbiAgICBibGFuazogbGliRXhwb3J0cyRsLmJsYW5rLFxuICAgIGNhbGxiYWNrOiBsaWJFeHBvcnRzJGsuY2FsbGJhY2ssXG4gICAgY2hvaWNlOiBsaWJFeHBvcnRzJGouY2hvaWNlLFxuICAgIGNyZWRpdENhcmQ6IGxpYkV4cG9ydHMkaS5jcmVkaXRDYXJkLFxuICAgIGRhdGU6IGxpYkV4cG9ydHMkaC5kYXRlLFxuICAgIGRpZmZlcmVudDogbGliRXhwb3J0cyRnLmRpZmZlcmVudCxcbiAgICBkaWdpdHM6IGxpYkV4cG9ydHMkZi5kaWdpdHMsXG4gICAgZW1haWxBZGRyZXNzOiBsaWJFeHBvcnRzJGUuZW1haWxBZGRyZXNzLFxuICAgIGZpbGU6IGxpYkV4cG9ydHMkZC5maWxlLFxuICAgIGdyZWF0ZXJUaGFuOiBsaWJFeHBvcnRzJGMuZ3JlYXRlclRoYW4sXG4gICAgaWRlbnRpY2FsOiBsaWJFeHBvcnRzJGIuaWRlbnRpY2FsLFxuICAgIGludGVnZXI6IGxpYkV4cG9ydHMkYS5pbnRlZ2VyLFxuICAgIGlwOiBsaWJFeHBvcnRzJDkuaXAsXG4gICAgbGVzc1RoYW46IGxpYkV4cG9ydHMkOC5sZXNzVGhhbixcbiAgICBub3RFbXB0eTogbGliRXhwb3J0cyQ3Lm5vdEVtcHR5LFxuICAgIG51bWVyaWM6IGxpYkV4cG9ydHMkNi5udW1lcmljLFxuICAgIHByb21pc2U6IGxpYkV4cG9ydHMkNS5wcm9taXNlLFxuICAgIHJlZ2V4cDogbGliRXhwb3J0cyQ0LnJlZ2V4cCxcbiAgICByZW1vdGU6IGxpYkV4cG9ydHMkMy5yZW1vdGUsXG4gICAgc3RyaW5nQ2FzZTogbGliRXhwb3J0cyQyLnN0cmluZ0Nhc2UsXG4gICAgc3RyaW5nTGVuZ3RoOiBsaWJFeHBvcnRzJDEuc3RyaW5nTGVuZ3RoLFxuICAgIHVyaTogbGliRXhwb3J0cy51cmksXG59O1xuLy8gUmVnaXN0ZXIgcG9wdWxhciB2YWxpZGF0b3JzXG52YXIgZm9ybVZhbGlkYXRpb25XaXRoUG9wdWxhclZhbGlkYXRvcnMgPSBmdW5jdGlvbiAoZm9ybSwgb3B0aW9ucykge1xuICAgIHZhciBpbnN0YW5jZSA9IGxpYkV4cG9ydHMkQi5mb3JtVmFsaWRhdGlvbihmb3JtLCBvcHRpb25zKTtcbiAgICBPYmplY3Qua2V5cyh2YWxpZGF0b3JzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBpbnN0YW5jZS5yZWdpc3RlclZhbGlkYXRvcihuYW1lLCB2YWxpZGF0b3JzW25hbWVdKTsgfSk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xufTtcblxuZXhwb3J0cy5QbHVnaW4gPSBsaWJFeHBvcnRzJEIuUGx1Z2luO1xuZXhwb3J0cy5hbGdvcml0aG1zID0gbGliRXhwb3J0cyRCLmFsZ29yaXRobXM7XG5leHBvcnRzLmZvcm1WYWxpZGF0aW9uID0gZm9ybVZhbGlkYXRpb25XaXRoUG9wdWxhclZhbGlkYXRvcnM7XG5leHBvcnRzLnBsdWdpbnMgPSBwbHVnaW5zO1xuZXhwb3J0cy51dGlscyA9IGxpYkV4cG9ydHMkQi51dGlscztcbmV4cG9ydHMudmFsaWRhdG9ycyA9IHZhbGlkYXRvcnM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@form-validation/bundle/lib/cjs/popular.js\n");

/***/ }),

/***/ "./node_modules/@form-validation/bundle/lib/popular.js":
/*!*************************************************************!*\
  !*** ./node_modules/@form-validation/bundle/lib/popular.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\n\n\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/popular.js */ \"./node_modules/@form-validation/bundle/lib/cjs/popular.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcm0tdmFsaWRhdGlvbi9idW5kbGUvbGliL3BvcHVsYXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLElBQUkseUhBQTRDO0FBQ2hEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vVnVleHkvLi9ub2RlX21vZHVsZXMvQGZvcm0tdmFsaWRhdGlvbi9idW5kbGUvbGliL3BvcHVsYXIuanM/YzIwYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG4gKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcG9wdWxhci5taW4uanMnKTtcbn0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9wb3B1bGFyLmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@form-validation/bundle/lib/popular.js\n");

/***/ }),

/***/ "./libs/@form-validation/popular.js":
/*!******************************************!*\
  !*** ./libs/@form-validation/popular.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FormValidation: function() { return /* reexport default export from named module */ _form_validation_bundle_popular__WEBPACK_IMPORTED_MODULE_0__; }\n/* harmony export */ });\n/* harmony import */ var _form_validation_bundle_popular__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @form-validation/bundle/popular */ \"./node_modules/@form-validation/bundle/lib/popular.js\");\n\ntry {\n  window.FormValidation = _form_validation_bundle_popular__WEBPACK_IMPORTED_MODULE_0__;\n} catch (e) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWJzL0Bmb3JtLXZhbGlkYXRpb24vcG9wdWxhci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE0RDtBQUU1RCxJQUFJO0VBQ0ZDLE1BQU0sQ0FBQ0QsY0FBYyxHQUFHQSw0REFBYztBQUN4QyxDQUFDLENBQUMsT0FBT0UsQ0FBQyxFQUFFLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9WdWV4eS8uL2xpYnMvQGZvcm0tdmFsaWRhdGlvbi9wb3B1bGFyLmpzPzEwODciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEZvcm1WYWxpZGF0aW9uIGZyb20gJ0Bmb3JtLXZhbGlkYXRpb24vYnVuZGxlL3BvcHVsYXInXG5cbnRyeSB7XG4gIHdpbmRvdy5Gb3JtVmFsaWRhdGlvbiA9IEZvcm1WYWxpZGF0aW9uO1xufSBjYXRjaCAoZSkge31cblxuZXhwb3J0IHsgRm9ybVZhbGlkYXRpb24gfTtcblxuIl0sIm5hbWVzIjpbIkZvcm1WYWxpZGF0aW9uIiwid2luZG93IiwiZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./libs/@form-validation/popular.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./libs/@form-validation/popular.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});