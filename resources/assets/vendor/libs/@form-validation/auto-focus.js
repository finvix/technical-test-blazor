/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(self, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@form-validation/core/lib/cjs/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@form-validation/core/lib/cjs/index.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n/**\n * Implement Luhn validation algorithm\n * Credit to https://gist.github.com/ShirtlessKirk/2134376\n *\n * @see http://en.wikipedia.org/wiki/Luhn\n * @param {string} value\n * @returns {boolean}\n */\nfunction luhn(value) {\n    var length = value.length;\n    var prodArr = [\n        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],\n        [0, 2, 4, 6, 8, 1, 3, 5, 7, 9],\n    ];\n    var mul = 0;\n    var sum = 0;\n    while (length--) {\n        sum += prodArr[mul][parseInt(value.charAt(length), 10)];\n        mul = 1 - mul;\n    }\n    return sum % 10 === 0 && sum > 0;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n/**\n * Implement modulus 11, 10 (ISO 7064) algorithm\n *\n * @param {string} value\n * @returns {boolean}\n */\nfunction mod11And10(value) {\n    var length = value.length;\n    var check = 5;\n    for (var i = 0; i < length; i++) {\n        check = ((((check || 10) * 2) % 11) + parseInt(value.charAt(i), 10)) % 10;\n    }\n    return check === 1;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n/**\n * Implements Mod 37, 36 (ISO 7064) algorithm\n *\n * @param {string} value\n * @param {string} [alphabet]\n * @returns {boolean}\n */\nfunction mod37And36(value, alphabet) {\n    if (alphabet === void 0) { alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; }\n    var length = value.length;\n    var modulus = alphabet.length;\n    var check = Math.floor(modulus / 2);\n    for (var i = 0; i < length; i++) {\n        check = ((((check || modulus) * 2) % (modulus + 1)) + alphabet.indexOf(value.charAt(i))) % modulus;\n    }\n    return check === 1;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\nfunction transform(input) {\n    return input\n        .split('')\n        .map(function (c) {\n        var code = c.charCodeAt(0);\n        // 65, 66, ..., 90 are the char code of A, B, ..., Z\n        return code >= 65 && code <= 90\n            ? // Replace A, B, C, ..., Z with 10, 11, ..., 35\n                code - 55\n            : c;\n    })\n        .join('')\n        .split('')\n        .map(function (c) { return parseInt(c, 10); });\n}\nfunction mod97And10(input) {\n    var digits = transform(input);\n    var temp = 0;\n    var length = digits.length;\n    for (var i = 0; i < length - 1; ++i) {\n        temp = ((temp + digits[i]) * 10) % 97;\n    }\n    temp += digits[length - 1];\n    return temp % 97 === 1;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n/**\n * Implement Verhoeff validation algorithm\n * Credit to Sergey Petushkov, 2014\n *\n * @see https://en.wikipedia.org/wiki/Verhoeff_algorithm\n * @param {string} value\n * @returns {boolean}\n */\nfunction verhoeff(value) {\n    // Multiplication table d\n    var d = [\n        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],\n        [1, 2, 3, 4, 0, 6, 7, 8, 9, 5],\n        [2, 3, 4, 0, 1, 7, 8, 9, 5, 6],\n        [3, 4, 0, 1, 2, 8, 9, 5, 6, 7],\n        [4, 0, 1, 2, 3, 9, 5, 6, 7, 8],\n        [5, 9, 8, 7, 6, 0, 4, 3, 2, 1],\n        [6, 5, 9, 8, 7, 1, 0, 4, 3, 2],\n        [7, 6, 5, 9, 8, 2, 1, 0, 4, 3],\n        [8, 7, 6, 5, 9, 3, 2, 1, 0, 4],\n        [9, 8, 7, 6, 5, 4, 3, 2, 1, 0],\n    ];\n    // Permutation table p\n    var p = [\n        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],\n        [1, 5, 7, 6, 2, 8, 3, 0, 9, 4],\n        [5, 8, 0, 3, 7, 9, 6, 1, 4, 2],\n        [8, 9, 1, 6, 0, 4, 3, 5, 2, 7],\n        [9, 4, 5, 3, 1, 2, 6, 8, 7, 0],\n        [4, 2, 8, 6, 5, 7, 3, 9, 0, 1],\n        [2, 7, 9, 3, 8, 0, 6, 4, 1, 5],\n        [7, 0, 4, 6, 9, 1, 3, 2, 5, 8],\n    ];\n    // Inverse table inv\n    var invertedArray = value.reverse();\n    var c = 0;\n    for (var i = 0; i < invertedArray.length; i++) {\n        c = d[c][p[i % 8][invertedArray[i]]];\n    }\n    return c === 0;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\nvar index$1 = {\n    luhn: luhn,\n    mod11And10: mod11And10,\n    mod37And36: mod37And36,\n    mod97And10: mod97And10,\n    verhoeff: verhoeff,\n};\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n/**\n * @param {HTMLElement} form The form element\n * @param {string} field The field name\n * @param {HTMLElement} element The field element\n * @param {HTMLElement[]} elements The list of elements which have the same name as `field`\n * @return {string}\n */\nfunction getFieldValue(form, field, element, elements) {\n    var type = (element.getAttribute('type') || '').toLowerCase();\n    var tagName = element.tagName.toLowerCase();\n    if (tagName === 'textarea') {\n        return element.value;\n    }\n    if (tagName === 'select') {\n        var select = element;\n        var index = select.selectedIndex;\n        return index >= 0 ? select.options.item(index).value : '';\n    }\n    if (tagName === 'input') {\n        if ('radio' === type || 'checkbox' === type) {\n            var checked = elements.filter(function (ele) { return ele.checked; }).length;\n            return checked === 0 ? '' : checked + '';\n        }\n        else {\n            return element.value;\n        }\n    }\n    return '';\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\nfunction emitter() {\n    return {\n        fns: {},\n        clear: function () {\n            this.fns = {};\n        },\n        emit: function (event) {\n            var args = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                args[_i - 1] = arguments[_i];\n            }\n            (this.fns[event] || []).map(function (handler) { return handler.apply(handler, args); });\n        },\n        off: function (event, func) {\n            if (this.fns[event]) {\n                var index = this.fns[event].indexOf(func);\n                if (index >= 0) {\n                    this.fns[event].splice(index, 1);\n                }\n            }\n        },\n        on: function (event, func) {\n            (this.fns[event] = this.fns[event] || []).push(func);\n        },\n    };\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\nfunction filter() {\n    return {\n        filters: {},\n        add: function (name, func) {\n            (this.filters[name] = this.filters[name] || []).push(func);\n        },\n        clear: function () {\n            this.filters = {};\n        },\n        execute: function (name, defaultValue, args) {\n            if (!this.filters[name] || !this.filters[name].length) {\n                return defaultValue;\n            }\n            var result = defaultValue;\n            var filters = this.filters[name];\n            var count = filters.length;\n            for (var i = 0; i < count; i++) {\n                result = filters[i].apply(result, args);\n            }\n            return result;\n        },\n        remove: function (name, func) {\n            if (this.filters[name]) {\n                this.filters[name] = this.filters[name].filter(function (f) { return f !== func; });\n            }\n        },\n    };\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\nvar Core = /** @class */ (function () {\n    function Core(form, fields) {\n        this.fields = {};\n        this.elements = {};\n        this.ee = emitter();\n        this.filter = filter();\n        this.plugins = {};\n        // Store the result of validation for each field\n        this.results = new Map();\n        this.validators = {};\n        this.form = form;\n        this.fields = fields;\n    }\n    Core.prototype.on = function (event, func) {\n        this.ee.on(event, func);\n        return this;\n    };\n    Core.prototype.off = function (event, func) {\n        this.ee.off(event, func);\n        return this;\n    };\n    Core.prototype.emit = function (event) {\n        var _a;\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        (_a = this.ee).emit.apply(_a, __spreadArray([event], args, false));\n        return this;\n    };\n    Core.prototype.registerPlugin = function (name, plugin) {\n        // Check if whether the plugin is registered\n        if (this.plugins[name]) {\n            throw new Error(\"The plguin \".concat(name, \" is registered\"));\n        }\n        // Install the plugin\n        plugin.setCore(this);\n        plugin.install();\n        this.plugins[name] = plugin;\n        return this;\n    };\n    Core.prototype.deregisterPlugin = function (name) {\n        var plugin = this.plugins[name];\n        if (plugin) {\n            plugin.uninstall();\n        }\n        delete this.plugins[name];\n        return this;\n    };\n    Core.prototype.enablePlugin = function (name) {\n        var plugin = this.plugins[name];\n        if (plugin) {\n            plugin.enable();\n        }\n        return this;\n    };\n    Core.prototype.disablePlugin = function (name) {\n        var plugin = this.plugins[name];\n        if (plugin) {\n            plugin.disable();\n        }\n        return this;\n    };\n    Core.prototype.isPluginEnabled = function (name) {\n        var plugin = this.plugins[name];\n        return plugin ? plugin.isPluginEnabled() : false;\n    };\n    Core.prototype.registerValidator = function (name, func) {\n        if (this.validators[name]) {\n            throw new Error(\"The validator \".concat(name, \" is registered\"));\n        }\n        this.validators[name] = func;\n        return this;\n    };\n    /**\n     * Add a filter\n     *\n     * @param {string} name The name of filter\n     * @param {Function} func The filter function\n     * @return {Core}\n     */\n    Core.prototype.registerFilter = function (name, func) {\n        this.filter.add(name, func);\n        return this;\n    };\n    /**\n     * Remove a filter\n     *\n     * @param {string} name The name of filter\n     * @param {Function} func The filter function\n     * @return {Core}\n     */\n    Core.prototype.deregisterFilter = function (name, func) {\n        this.filter.remove(name, func);\n        return this;\n    };\n    /**\n     * Execute a filter\n     *\n     * @param {string} name The name of filter\n     * @param {T} defaultValue The default value returns by the filter\n     * @param {array} args The filter arguments\n     * @returns {T}\n     */\n    Core.prototype.executeFilter = function (name, defaultValue, args) {\n        return this.filter.execute(name, defaultValue, args);\n    };\n    /**\n     * Add a field\n     *\n     * @param {string} field The field name\n     * @param {FieldOptions} options The field options. The options will be merged with the original validator rules\n     * if the field is already defined\n     * @return {Core}\n     */\n    Core.prototype.addField = function (field, options) {\n        var opts = Object.assign({}, {\n            selector: '',\n            validators: {},\n        }, options);\n        // Merge the options\n        this.fields[field] = this.fields[field]\n            ? {\n                selector: opts.selector || this.fields[field].selector,\n                validators: Object.assign({}, this.fields[field].validators, opts.validators),\n            }\n            : opts;\n        this.elements[field] = this.queryElements(field);\n        this.emit('core.field.added', {\n            elements: this.elements[field],\n            field: field,\n            options: this.fields[field],\n        });\n        return this;\n    };\n    /**\n     * Remove given field by name\n     *\n     * @param {string} field The field name\n     * @return {Core}\n     */\n    Core.prototype.removeField = function (field) {\n        if (!this.fields[field]) {\n            throw new Error(\"The field \".concat(field, \" validators are not defined. Please ensure the field is added first\"));\n        }\n        var elements = this.elements[field];\n        var options = this.fields[field];\n        delete this.elements[field];\n        delete this.fields[field];\n        this.emit('core.field.removed', {\n            elements: elements,\n            field: field,\n            options: options,\n        });\n        return this;\n    };\n    /**\n     * Validate all fields\n     *\n     * @return {Promise<string>}\n     */\n    Core.prototype.validate = function () {\n        var _this = this;\n        this.emit('core.form.validating', {\n            formValidation: this,\n        });\n        return this.filter.execute('validate-pre', Promise.resolve(), []).then(function () {\n            return Promise.all(Object.keys(_this.fields).map(function (field) { return _this.validateField(field); })).then(function (results) {\n                // `results` is an array of `Valid`, `Invalid` and `NotValidated`\n                switch (true) {\n                    case results.indexOf('Invalid') !== -1:\n                        _this.emit('core.form.invalid', {\n                            formValidation: _this,\n                        });\n                        return Promise.resolve('Invalid');\n                    case results.indexOf('NotValidated') !== -1:\n                        _this.emit('core.form.notvalidated', {\n                            formValidation: _this,\n                        });\n                        return Promise.resolve('NotValidated');\n                    default:\n                        _this.emit('core.form.valid', {\n                            formValidation: _this,\n                        });\n                        return Promise.resolve('Valid');\n                }\n            });\n        });\n    };\n    /**\n     * Validate a particular field\n     *\n     * @param {string} field The field name\n     * @return {Promise<string>}\n     */\n    Core.prototype.validateField = function (field) {\n        var _this = this;\n        // Stop validation process if the field is already validated\n        var result = this.results.get(field);\n        if (result === 'Valid' || result === 'Invalid') {\n            return Promise.resolve(result);\n        }\n        this.emit('core.field.validating', field);\n        var elements = this.elements[field];\n        if (elements.length === 0) {\n            this.emit('core.field.valid', field);\n            return Promise.resolve('Valid');\n        }\n        var type = elements[0].getAttribute('type');\n        if ('radio' === type || 'checkbox' === type || elements.length === 1) {\n            return this.validateElement(field, elements[0]);\n        }\n        else {\n            return Promise.all(elements.map(function (ele) { return _this.validateElement(field, ele); })).then(function (results) {\n                // `results` is an array of `Valid`, `Invalid` and `NotValidated`\n                switch (true) {\n                    case results.indexOf('Invalid') !== -1:\n                        _this.emit('core.field.invalid', field);\n                        _this.results.set(field, 'Invalid');\n                        return Promise.resolve('Invalid');\n                    case results.indexOf('NotValidated') !== -1:\n                        _this.emit('core.field.notvalidated', field);\n                        _this.results.delete(field);\n                        return Promise.resolve('NotValidated');\n                    default:\n                        _this.emit('core.field.valid', field);\n                        _this.results.set(field, 'Valid');\n                        return Promise.resolve('Valid');\n                }\n            });\n        }\n    };\n    /**\n     * Validate particular element\n     *\n     * @param {string} field The field name\n     * @param {HTMLElement} ele The field element\n     * @return {Promise<string>}\n     */\n    Core.prototype.validateElement = function (field, ele) {\n        var _this = this;\n        // Reset validation result\n        this.results.delete(field);\n        var elements = this.elements[field];\n        var ignored = this.filter.execute('element-ignored', false, [field, ele, elements]);\n        if (ignored) {\n            this.emit('core.element.ignored', {\n                element: ele,\n                elements: elements,\n                field: field,\n            });\n            return Promise.resolve('Ignored');\n        }\n        var validatorList = this.fields[field].validators;\n        this.emit('core.element.validating', {\n            element: ele,\n            elements: elements,\n            field: field,\n        });\n        var promises = Object.keys(validatorList).map(function (v) {\n            return function () { return _this.executeValidator(field, ele, v, validatorList[v]); };\n        });\n        return this.waterfall(promises)\n            .then(function (results) {\n            // `results` is an array of `Valid` or `Invalid`\n            var isValid = results.indexOf('Invalid') === -1;\n            _this.emit('core.element.validated', {\n                element: ele,\n                elements: elements,\n                field: field,\n                valid: isValid,\n            });\n            var type = ele.getAttribute('type');\n            if ('radio' === type || 'checkbox' === type || elements.length === 1) {\n                _this.emit(isValid ? 'core.field.valid' : 'core.field.invalid', field);\n            }\n            return Promise.resolve(isValid ? 'Valid' : 'Invalid');\n        })\n            .catch(function (reason) {\n            // reason is `NotValidated`\n            _this.emit('core.element.notvalidated', {\n                element: ele,\n                elements: elements,\n                field: field,\n            });\n            return Promise.resolve(reason);\n        });\n    };\n    /**\n     * Perform given validator on field\n     *\n     * @param {string} field The field name\n     * @param {HTMLElement} ele The field element\n     * @param {string} v The validator name\n     * @param {ValidatorOptions} opts The validator options\n     * @return {Promise<string>}\n     */\n    Core.prototype.executeValidator = function (field, ele, v, opts) {\n        var _this = this;\n        var elements = this.elements[field];\n        var name = this.filter.execute('validator-name', v, [v, field]);\n        opts.message = this.filter.execute('validator-message', opts.message, [this.locale, field, name]);\n        // Simply pass the validator if\n        // - it isn't defined yet\n        // - or the associated validator isn't enabled\n        if (!this.validators[name] || opts.enabled === false) {\n            this.emit('core.validator.validated', {\n                element: ele,\n                elements: elements,\n                field: field,\n                result: this.normalizeResult(field, name, { valid: true }),\n                validator: name,\n            });\n            return Promise.resolve('Valid');\n        }\n        var validator = this.validators[name];\n        // Get the field value\n        var value = this.getElementValue(field, ele, name);\n        var willValidate = this.filter.execute('field-should-validate', true, [field, ele, value, v]);\n        if (!willValidate) {\n            this.emit('core.validator.notvalidated', {\n                element: ele,\n                elements: elements,\n                field: field,\n                validator: v,\n            });\n            return Promise.resolve('NotValidated');\n        }\n        this.emit('core.validator.validating', {\n            element: ele,\n            elements: elements,\n            field: field,\n            validator: v,\n        });\n        // Perform validation\n        var result = validator().validate({\n            element: ele,\n            elements: elements,\n            field: field,\n            l10n: this.localization,\n            options: opts,\n            value: value,\n        });\n        // Check whether the result is a `Promise`\n        var isPromise = 'function' === typeof result['then'];\n        if (isPromise) {\n            return result.then(function (r) {\n                var data = _this.normalizeResult(field, v, r);\n                _this.emit('core.validator.validated', {\n                    element: ele,\n                    elements: elements,\n                    field: field,\n                    result: data,\n                    validator: v,\n                });\n                return data.valid ? 'Valid' : 'Invalid';\n            });\n        }\n        else {\n            var data = this.normalizeResult(field, v, result);\n            this.emit('core.validator.validated', {\n                element: ele,\n                elements: elements,\n                field: field,\n                result: data,\n                validator: v,\n            });\n            return Promise.resolve(data.valid ? 'Valid' : 'Invalid');\n        }\n    };\n    Core.prototype.getElementValue = function (field, ele, validator) {\n        var defaultValue = getFieldValue(this.form, field, ele, this.elements[field]);\n        return this.filter.execute('field-value', defaultValue, [defaultValue, field, ele, validator]);\n    };\n    // Some getter methods\n    Core.prototype.getElements = function (field) {\n        return this.elements[field];\n    };\n    Core.prototype.getFields = function () {\n        return this.fields;\n    };\n    Core.prototype.getFormElement = function () {\n        return this.form;\n    };\n    Core.prototype.getLocale = function () {\n        return this.locale;\n    };\n    Core.prototype.getPlugin = function (name) {\n        return this.plugins[name];\n    };\n    /**\n     * Update the field status\n     *\n     * @param {string} field The field name\n     * @param {string} status The new status\n     * @param {string} [validator] The validator name. If it isn't specified, all validators will be updated\n     * @return {Core}\n     */\n    Core.prototype.updateFieldStatus = function (field, status, validator) {\n        var _this = this;\n        var elements = this.elements[field];\n        var type = elements[0].getAttribute('type');\n        var list = 'radio' === type || 'checkbox' === type ? [elements[0]] : elements;\n        list.forEach(function (ele) { return _this.updateElementStatus(field, ele, status, validator); });\n        if (!validator) {\n            switch (status) {\n                case 'NotValidated':\n                    this.emit('core.field.notvalidated', field);\n                    this.results.delete(field);\n                    break;\n                case 'Validating':\n                    this.emit('core.field.validating', field);\n                    this.results.delete(field);\n                    break;\n                case 'Valid':\n                    this.emit('core.field.valid', field);\n                    this.results.set(field, 'Valid');\n                    break;\n                case 'Invalid':\n                    this.emit('core.field.invalid', field);\n                    this.results.set(field, 'Invalid');\n                    break;\n            }\n        }\n        else if (status === 'Invalid') {\n            // We need to mark the field as invalid because it doesn't pass the `validator`\n            this.emit('core.field.invalid', field);\n            this.results.set(field, 'Invalid');\n        }\n        return this;\n    };\n    /**\n     * Update the element status\n     *\n     * @param {string} field The field name\n     * @param {HTMLElement} ele The field element\n     * @param {string} status The new status\n     * @param {string} [validator] The validator name. If it isn't specified, all validators will be updated\n     * @return {Core}\n     */\n    Core.prototype.updateElementStatus = function (field, ele, status, validator) {\n        var _this = this;\n        var elements = this.elements[field];\n        var fieldValidators = this.fields[field].validators;\n        var validatorArr = validator ? [validator] : Object.keys(fieldValidators);\n        switch (status) {\n            case 'NotValidated':\n                validatorArr.forEach(function (v) {\n                    return _this.emit('core.validator.notvalidated', {\n                        element: ele,\n                        elements: elements,\n                        field: field,\n                        validator: v,\n                    });\n                });\n                this.emit('core.element.notvalidated', {\n                    element: ele,\n                    elements: elements,\n                    field: field,\n                });\n                break;\n            case 'Validating':\n                validatorArr.forEach(function (v) {\n                    return _this.emit('core.validator.validating', {\n                        element: ele,\n                        elements: elements,\n                        field: field,\n                        validator: v,\n                    });\n                });\n                this.emit('core.element.validating', {\n                    element: ele,\n                    elements: elements,\n                    field: field,\n                });\n                break;\n            case 'Valid':\n                validatorArr.forEach(function (v) {\n                    return _this.emit('core.validator.validated', {\n                        element: ele,\n                        elements: elements,\n                        field: field,\n                        result: {\n                            message: fieldValidators[v].message,\n                            valid: true,\n                        },\n                        validator: v,\n                    });\n                });\n                this.emit('core.element.validated', {\n                    element: ele,\n                    elements: elements,\n                    field: field,\n                    valid: true,\n                });\n                break;\n            case 'Invalid':\n                validatorArr.forEach(function (v) {\n                    return _this.emit('core.validator.validated', {\n                        element: ele,\n                        elements: elements,\n                        field: field,\n                        result: {\n                            message: fieldValidators[v].message,\n                            valid: false,\n                        },\n                        validator: v,\n                    });\n                });\n                this.emit('core.element.validated', {\n                    element: ele,\n                    elements: elements,\n                    field: field,\n                    valid: false,\n                });\n                break;\n        }\n        return this;\n    };\n    /**\n     * Reset the form. It also clears all the messages, hide the feedback icons, etc.\n     *\n     * @param {boolean} reset If true, the method resets field value to empty\n     * or remove `checked`, `selected` attributes\n     * @return {Core}\n     */\n    Core.prototype.resetForm = function (reset) {\n        var _this = this;\n        Object.keys(this.fields).forEach(function (field) { return _this.resetField(field, reset); });\n        this.emit('core.form.reset', {\n            formValidation: this,\n            reset: reset,\n        });\n        return this;\n    };\n    /**\n     * Reset the field. It also clears all the messages, hide the feedback icons, etc.\n     *\n     * @param {string} field The field name\n     * @param {boolean} reset If true, the method resets field value to empty\n     * or remove `checked`, `selected` attributes\n     * @return {Core}\n     */\n    Core.prototype.resetField = function (field, reset) {\n        // Reset the field element value if needed\n        if (reset) {\n            var elements = this.elements[field];\n            var type_1 = elements[0].getAttribute('type');\n            elements.forEach(function (ele) {\n                if ('radio' === type_1 || 'checkbox' === type_1) {\n                    ele.removeAttribute('selected');\n                    ele.removeAttribute('checked');\n                    ele.checked = false;\n                }\n                else {\n                    ele.setAttribute('value', '');\n                    if (ele instanceof HTMLInputElement || ele instanceof HTMLTextAreaElement) {\n                        ele.value = '';\n                    }\n                }\n            });\n        }\n        // Mark the field as not validated yet\n        this.updateFieldStatus(field, 'NotValidated');\n        this.emit('core.field.reset', {\n            field: field,\n            reset: reset,\n        });\n        return this;\n    };\n    /**\n     * Revalidate a particular field. It's useful when the field value is effected by third parties\n     * (for example, attach another UI library to the field).\n     * Since there isn't an automatic way for FormValidation to know when the field value is modified in those cases,\n     * we need to revalidate the field manually.\n     *\n     * @param {string} field The field name\n     * @return {Promise<string>}\n     */\n    Core.prototype.revalidateField = function (field) {\n        if (!this.fields[field]) {\n            return Promise.resolve('Ignored');\n        }\n        this.updateFieldStatus(field, 'NotValidated');\n        return this.validateField(field);\n    };\n    /**\n     * Disable particular validator for given field\n     *\n     * @param {string} field The field name\n     * @param {string} validator The validator name. If it isn't specified, all validators will be disabled\n     * @return {Core}\n     */\n    Core.prototype.disableValidator = function (field, validator) {\n        if (!this.fields[field]) {\n            return this;\n        }\n        var elements = this.elements[field];\n        this.toggleValidator(false, field, validator);\n        this.emit('core.validator.disabled', {\n            elements: elements,\n            field: field,\n            formValidation: this,\n            validator: validator,\n        });\n        return this;\n    };\n    /**\n     * Enable particular validator for given field\n     *\n     * @param {string} field The field name\n     * @param {string} validator The validator name. If it isn't specified, all validators will be enabled\n     * @return {Core}\n     */\n    Core.prototype.enableValidator = function (field, validator) {\n        if (!this.fields[field]) {\n            return this;\n        }\n        var elements = this.elements[field];\n        this.toggleValidator(true, field, validator);\n        this.emit('core.validator.enabled', {\n            elements: elements,\n            field: field,\n            formValidation: this,\n            validator: validator,\n        });\n        return this;\n    };\n    /**\n     * Update option of particular validator for given field\n     *\n     * @param {string} field The field name\n     * @param {string} validator The validator name\n     * @param {string} name The option's name\n     * @param {unknown} value The option's value\n     * @return {Core}\n     */\n    Core.prototype.updateValidatorOption = function (field, validator, name, value) {\n        if (this.fields[field] && this.fields[field].validators && this.fields[field].validators[validator]) {\n            this.fields[field].validators[validator][name] = value;\n        }\n        return this;\n    };\n    Core.prototype.setFieldOptions = function (field, options) {\n        this.fields[field] = options;\n        return this;\n    };\n    Core.prototype.destroy = function () {\n        var _this = this;\n        // Remove plugins and filters\n        Object.keys(this.plugins).forEach(function (id) { return _this.plugins[id].uninstall(); });\n        this.ee.clear();\n        this.filter.clear();\n        this.results.clear();\n        this.plugins = {};\n        return this;\n    };\n    Core.prototype.setLocale = function (locale, localization) {\n        this.locale = locale;\n        this.localization = localization;\n        return this;\n    };\n    Core.prototype.waterfall = function (promises) {\n        return promises.reduce(function (p, c) {\n            return p.then(function (res) {\n                return c().then(function (result) {\n                    res.push(result);\n                    return res;\n                });\n            });\n        }, Promise.resolve([]));\n    };\n    Core.prototype.queryElements = function (field) {\n        var selector = this.fields[field].selector\n            ? // Check if the selector is an ID selector which starts with `#`\n                '#' === this.fields[field].selector.charAt(0)\n                    ? \"[id=\\\"\".concat(this.fields[field].selector.substring(1), \"\\\"]\")\n                    : this.fields[field].selector\n            : \"[name=\\\"\".concat(field.replace(/\"/g, '\\\\\"'), \"\\\"]\");\n        return [].slice.call(this.form.querySelectorAll(selector));\n    };\n    Core.prototype.normalizeResult = function (field, validator, result) {\n        var opts = this.fields[field].validators[validator];\n        return Object.assign({}, result, {\n            message: result.message ||\n                (opts ? opts.message : '') ||\n                (this.localization && this.localization[validator] && this.localization[validator]['default']\n                    ? this.localization[validator]['default']\n                    : '') ||\n                \"The field \".concat(field, \" is not valid\"),\n        });\n    };\n    Core.prototype.toggleValidator = function (enabled, field, validator) {\n        var _this = this;\n        var validatorArr = this.fields[field].validators;\n        if (validator && validatorArr && validatorArr[validator]) {\n            this.fields[field].validators[validator].enabled = enabled;\n        }\n        else if (!validator) {\n            Object.keys(validatorArr).forEach(function (v) { return (_this.fields[field].validators[v].enabled = enabled); });\n        }\n        return this.updateFieldStatus(field, 'NotValidated', validator);\n    };\n    return Core;\n}());\nfunction formValidation(form, options) {\n    var opts = Object.assign({}, {\n        fields: {},\n        locale: 'en_US',\n        plugins: {},\n        init: function (_) { },\n    }, options);\n    var core = new Core(form, opts.fields);\n    core.setLocale(opts.locale, opts.localization);\n    // Register plugins\n    Object.keys(opts.plugins).forEach(function (name) { return core.registerPlugin(name, opts.plugins[name]); });\n    // It's the single point that users can do a particular task before adding fields\n    // Some initialization tasks must be done at that point\n    opts.init(core);\n    // and add fields\n    Object.keys(opts.fields).forEach(function (field) { return core.addField(field, opts.fields[field]); });\n    return core;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\nvar Plugin = /** @class */ (function () {\n    function Plugin(opts) {\n        this.opts = opts;\n        this.isEnabled = true;\n    }\n    Plugin.prototype.setCore = function (core) {\n        this.core = core;\n        return this;\n    };\n    Plugin.prototype.enable = function () {\n        this.isEnabled = true;\n        this.onEnabled();\n        return this;\n    };\n    Plugin.prototype.disable = function () {\n        this.isEnabled = false;\n        this.onDisabled();\n        return this;\n    };\n    Plugin.prototype.isPluginEnabled = function () {\n        return this.isEnabled;\n    };\n    Plugin.prototype.onEnabled = function () { }; // eslint-disable-line @typescript-eslint/no-empty-function\n    Plugin.prototype.onDisabled = function () { }; // eslint-disable-line @typescript-eslint/no-empty-function\n    Plugin.prototype.install = function () { }; // eslint-disable-line @typescript-eslint/no-empty-function\n    Plugin.prototype.uninstall = function () { }; // eslint-disable-line @typescript-eslint/no-empty-function\n    return Plugin;\n}());\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n/**\n * Execute a callback function\n *\n * @param {Function | string} functionName Can be\n * - name of global function\n * - name of namespace function (such as A.B.C)\n * - a function\n * @param {any[]} args The callback arguments\n * @return {any}\n */\nfunction call(functionName, args) {\n    if ('function' === typeof functionName) {\n        return functionName.apply(this, args);\n    }\n    else if ('string' === typeof functionName) {\n        // Node that it doesn't support node.js based environment because we are trying to access `window`\n        var name_1 = functionName;\n        if ('()' === name_1.substring(name_1.length - 2)) {\n            name_1 = name_1.substring(0, name_1.length - 2);\n        }\n        var ns = name_1.split('.');\n        var func = ns.pop();\n        var context_1 = window;\n        for (var _i = 0, ns_1 = ns; _i < ns_1.length; _i++) {\n            var t = ns_1[_i];\n            context_1 = context_1[t];\n        }\n        return typeof context_1[func] === 'undefined' ? null : context_1[func].apply(this, args);\n    }\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\nvar addClass = function (element, classes) {\n    classes.split(' ').forEach(function (clazz) {\n        if (element.classList) {\n            element.classList.add(clazz);\n        }\n        else if (\" \".concat(element.className, \" \").indexOf(\" \".concat(clazz, \" \"))) {\n            element.className += \" \".concat(clazz);\n        }\n    });\n};\nvar removeClass = function (element, classes) {\n    classes.split(' ').forEach(function (clazz) {\n        element.classList\n            ? element.classList.remove(clazz)\n            : (element.className = element.className.replace(clazz, ''));\n    });\n};\nvar classSet = function (element, classes) {\n    var adding = [];\n    var removing = [];\n    Object.keys(classes).forEach(function (clazz) {\n        if (clazz) {\n            classes[clazz] ? adding.push(clazz) : removing.push(clazz);\n        }\n    });\n    // Always remove before adding class because there might be a class which belong to both sets.\n    // For example, the element will have class `a` after calling\n    //  ```\n    //  classSet(element, {\n    //      'a a1 a2': true,\n    //      'a b1 b2': false\n    //  })\n    //  ```\n    removing.forEach(function (clazz) { return removeClass(element, clazz); });\n    adding.forEach(function (clazz) { return addClass(element, clazz); });\n};\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\nvar matches = function (element, selector) {\n    var nativeMatches = element.matches ||\n        element.webkitMatchesSelector ||\n        element['mozMatchesSelector'] ||\n        element['msMatchesSelector'];\n    if (nativeMatches) {\n        return nativeMatches.call(element, selector);\n    }\n    // In case `matchesselector` isn't supported (such as IE10)\n    // See http://caniuse.com/matchesselector\n    var nodes = [].slice.call(element.parentElement.querySelectorAll(selector));\n    return nodes.indexOf(element) >= 0;\n};\nvar closest = function (element, selector) {\n    var ele = element;\n    while (ele) {\n        if (matches(ele, selector)) {\n            break;\n        }\n        ele = ele.parentElement;\n    }\n    return ele;\n};\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\nvar generateString = function (length) {\n    return Array(length)\n        .fill('')\n        .map(function (v) { return Math.random().toString(36).charAt(2); })\n        .join('');\n};\nvar fetch = function (url, options) {\n    var toQuery = function (obj) {\n        return Object.keys(obj)\n            .map(function (k) { return \"\".concat(encodeURIComponent(k), \"=\").concat(encodeURIComponent(obj[k])); })\n            .join('&');\n    };\n    return new Promise(function (resolve, reject) {\n        var opts = Object.assign({}, {\n            crossDomain: false,\n            headers: {},\n            method: 'GET',\n            params: {},\n        }, options);\n        // Build the params for GET request\n        var params = Object.keys(opts.params)\n            .map(function (k) { return \"\".concat(encodeURIComponent(k), \"=\").concat(encodeURIComponent(opts.params[k])); })\n            .join('&');\n        var hasQuery = url.indexOf('?') > -1;\n        var requestUrl = 'GET' === opts.method ? \"\".concat(url).concat(hasQuery ? '&' : '?').concat(params) : url;\n        if (opts.crossDomain) {\n            // User is making cross domain request\n            var script_1 = document.createElement('script');\n            // In some very fast systems, the different `Date.now()` invocations can return the same value\n            // which leads to the issue where there are multiple remove validators are used, for example.\n            // Appending it with a generated random string can fix the value\n            var callback_1 = \"___FormValidationFetch_\".concat(generateString(12), \"___\");\n            window[callback_1] = function (data) {\n                delete window[callback_1];\n                resolve(data);\n            };\n            script_1.src = \"\".concat(requestUrl).concat(hasQuery ? '&' : '?', \"callback=\").concat(callback_1);\n            script_1.async = true;\n            script_1.addEventListener('load', function () {\n                script_1.parentNode.removeChild(script_1);\n            });\n            script_1.addEventListener('error', function () { return reject; });\n            document.head.appendChild(script_1);\n        }\n        else {\n            var request_1 = new XMLHttpRequest();\n            request_1.open(opts.method, requestUrl);\n            // Set the headers\n            request_1.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n            if ('POST' === opts.method) {\n                request_1.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n            }\n            Object.keys(opts.headers).forEach(function (k) { return request_1.setRequestHeader(k, opts.headers[k]); });\n            request_1.addEventListener('load', function () {\n                // Cannot use arrow function here due to the `this` scope\n                resolve(JSON.parse(this.responseText));\n            });\n            request_1.addEventListener('error', function () { return reject; });\n            // GET request will ignore the passed data here\n            request_1.send(toQuery(opts.params));\n        }\n    });\n};\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n/**\n * Format a string\n * It's used to format the error message\n * format('The field must between %s and %s', [10, 20]) = 'The field must between 10 and 20'\n *\n * @param {string} message\n * @param {string|string[]} parameters\n * @returns {string}\n */\nvar format = function (message, parameters) {\n    var params = Array.isArray(parameters) ? parameters : [parameters];\n    var output = message;\n    params.forEach(function (p) {\n        output = output.replace('%s', p);\n    });\n    return output;\n};\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\nvar hasClass = function (element, clazz) {\n    return element.classList\n        ? element.classList.contains(clazz)\n        : new RegExp(\"(^| )\".concat(clazz, \"( |$)\"), 'gi').test(element.className);\n};\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n/**\n * Validate a date\n *\n * @param {string} year The full year in 4 digits\n * @param {string} month The month number\n * @param {string} day The day number\n * @param {boolean} [notInFuture] If true, the date must not be in the future\n * @returns {boolean}\n */\nvar isValidDate = function (year, month, day, notInFuture) {\n    if (isNaN(year) || isNaN(month) || isNaN(day)) {\n        return false;\n    }\n    if (year < 1000 || year > 9999 || month <= 0 || month > 12) {\n        return false;\n    }\n    var numDays = [\n        31,\n        // Update the number of days in Feb of leap year\n        year % 400 === 0 || (year % 100 !== 0 && year % 4 === 0) ? 29 : 28,\n        31,\n        30,\n        31,\n        30,\n        31,\n        31,\n        30,\n        31,\n        30,\n        31,\n    ];\n    // Check the day\n    if (day <= 0 || day > numDays[month - 1]) {\n        return false;\n    }\n    if (notInFuture === true) {\n        var currentDate = new Date();\n        var currentYear = currentDate.getFullYear();\n        var currentMonth = currentDate.getMonth();\n        var currentDay = currentDate.getDate();\n        return (year < currentYear ||\n            (year === currentYear && month - 1 < currentMonth) ||\n            (year === currentYear && month - 1 === currentMonth && day < currentDay));\n    }\n    return true;\n};\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\nvar removeUndefined = function (obj) {\n    return obj\n        ? Object.entries(obj).reduce(function (a, _a) {\n            var k = _a[0], v = _a[1];\n            return (v === undefined ? a : ((a[k] = v), a));\n        }, {})\n        : {};\n};\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\nvar index = {\n    call: call,\n    classSet: classSet,\n    closest: closest,\n    fetch: fetch,\n    format: format,\n    hasClass: hasClass,\n    isValidDate: isValidDate,\n    removeUndefined: removeUndefined,\n};\n\nexports.Plugin = Plugin;\nexports.algorithms = index$1;\nexports.formValidation = formValidation;\nexports.utils = index;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcm0tdmFsaWRhdGlvbi9jb3JlL2xpYi9janMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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V0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Qsa0JBQWtCO0FBQ2xCLHNCQUFzQjtBQUN0QixhQUFhIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vVnVleHkvLi9ub2RlX21vZHVsZXMvQGZvcm0tdmFsaWRhdGlvbi9jb3JlL2xpYi9janMvaW5kZXguanM/Y2IwNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqL1xuLyoqXG4gKiBJbXBsZW1lbnQgTHVobiB2YWxpZGF0aW9uIGFsZ29yaXRobVxuICogQ3JlZGl0IHRvIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL1NoaXJ0bGVzc0tpcmsvMjEzNDM3NlxuICpcbiAqIEBzZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MdWhuXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBsdWhuKHZhbHVlKSB7XG4gICAgdmFyIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICB2YXIgcHJvZEFyciA9IFtcbiAgICAgICAgWzAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDldLFxuICAgICAgICBbMCwgMiwgNCwgNiwgOCwgMSwgMywgNSwgNywgOV0sXG4gICAgXTtcbiAgICB2YXIgbXVsID0gMDtcbiAgICB2YXIgc3VtID0gMDtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgc3VtICs9IHByb2RBcnJbbXVsXVtwYXJzZUludCh2YWx1ZS5jaGFyQXQobGVuZ3RoKSwgMTApXTtcbiAgICAgICAgbXVsID0gMSAtIG11bDtcbiAgICB9XG4gICAgcmV0dXJuIHN1bSAlIDEwID09PSAwICYmIHN1bSA+IDA7XG59XG5cbi8qKlxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqL1xuLyoqXG4gKiBJbXBsZW1lbnQgbW9kdWx1cyAxMSwgMTAgKElTTyA3MDY0KSBhbGdvcml0aG1cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBtb2QxMUFuZDEwKHZhbHVlKSB7XG4gICAgdmFyIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICB2YXIgY2hlY2sgPSA1O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2hlY2sgPSAoKCgoY2hlY2sgfHwgMTApICogMikgJSAxMSkgKyBwYXJzZUludCh2YWx1ZS5jaGFyQXQoaSksIDEwKSkgJSAxMDtcbiAgICB9XG4gICAgcmV0dXJuIGNoZWNrID09PSAxO1xufVxuXG4vKipcbiAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG4gKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKi9cbi8qKlxuICogSW1wbGVtZW50cyBNb2QgMzcsIDM2IChJU08gNzA2NCkgYWxnb3JpdGhtXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FscGhhYmV0XVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIG1vZDM3QW5kMzYodmFsdWUsIGFscGhhYmV0KSB7XG4gICAgaWYgKGFscGhhYmV0ID09PSB2b2lkIDApIHsgYWxwaGFiZXQgPSAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJzsgfVxuICAgIHZhciBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gICAgdmFyIG1vZHVsdXMgPSBhbHBoYWJldC5sZW5ndGg7XG4gICAgdmFyIGNoZWNrID0gTWF0aC5mbG9vcihtb2R1bHVzIC8gMik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjaGVjayA9ICgoKChjaGVjayB8fCBtb2R1bHVzKSAqIDIpICUgKG1vZHVsdXMgKyAxKSkgKyBhbHBoYWJldC5pbmRleE9mKHZhbHVlLmNoYXJBdChpKSkpICUgbW9kdWx1cztcbiAgICB9XG4gICAgcmV0dXJuIGNoZWNrID09PSAxO1xufVxuXG4vKipcbiAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG4gKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybShpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dFxuICAgICAgICAuc3BsaXQoJycpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIGNvZGUgPSBjLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIC8vIDY1LCA2NiwgLi4uLCA5MCBhcmUgdGhlIGNoYXIgY29kZSBvZiBBLCBCLCAuLi4sIFpcbiAgICAgICAgcmV0dXJuIGNvZGUgPj0gNjUgJiYgY29kZSA8PSA5MFxuICAgICAgICAgICAgPyAvLyBSZXBsYWNlIEEsIEIsIEMsIC4uLiwgWiB3aXRoIDEwLCAxMSwgLi4uLCAzNVxuICAgICAgICAgICAgICAgIGNvZGUgLSA1NVxuICAgICAgICAgICAgOiBjO1xuICAgIH0pXG4gICAgICAgIC5qb2luKCcnKVxuICAgICAgICAuc3BsaXQoJycpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIHBhcnNlSW50KGMsIDEwKTsgfSk7XG59XG5mdW5jdGlvbiBtb2Q5N0FuZDEwKGlucHV0KSB7XG4gICAgdmFyIGRpZ2l0cyA9IHRyYW5zZm9ybShpbnB1dCk7XG4gICAgdmFyIHRlbXAgPSAwO1xuICAgIHZhciBsZW5ndGggPSBkaWdpdHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgIHRlbXAgPSAoKHRlbXAgKyBkaWdpdHNbaV0pICogMTApICUgOTc7XG4gICAgfVxuICAgIHRlbXAgKz0gZGlnaXRzW2xlbmd0aCAtIDFdO1xuICAgIHJldHVybiB0ZW1wICUgOTcgPT09IDE7XG59XG5cbi8qKlxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqL1xuLyoqXG4gKiBJbXBsZW1lbnQgVmVyaG9lZmYgdmFsaWRhdGlvbiBhbGdvcml0aG1cbiAqIENyZWRpdCB0byBTZXJnZXkgUGV0dXNoa292LCAyMDE0XG4gKlxuICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WZXJob2VmZl9hbGdvcml0aG1cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHZlcmhvZWZmKHZhbHVlKSB7XG4gICAgLy8gTXVsdGlwbGljYXRpb24gdGFibGUgZFxuICAgIHZhciBkID0gW1xuICAgICAgICBbMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOV0sXG4gICAgICAgIFsxLCAyLCAzLCA0LCAwLCA2LCA3LCA4LCA5LCA1XSxcbiAgICAgICAgWzIsIDMsIDQsIDAsIDEsIDcsIDgsIDksIDUsIDZdLFxuICAgICAgICBbMywgNCwgMCwgMSwgMiwgOCwgOSwgNSwgNiwgN10sXG4gICAgICAgIFs0LCAwLCAxLCAyLCAzLCA5LCA1LCA2LCA3LCA4XSxcbiAgICAgICAgWzUsIDksIDgsIDcsIDYsIDAsIDQsIDMsIDIsIDFdLFxuICAgICAgICBbNiwgNSwgOSwgOCwgNywgMSwgMCwgNCwgMywgMl0sXG4gICAgICAgIFs3LCA2LCA1LCA5LCA4LCAyLCAxLCAwLCA0LCAzXSxcbiAgICAgICAgWzgsIDcsIDYsIDUsIDksIDMsIDIsIDEsIDAsIDRdLFxuICAgICAgICBbOSwgOCwgNywgNiwgNSwgNCwgMywgMiwgMSwgMF0sXG4gICAgXTtcbiAgICAvLyBQZXJtdXRhdGlvbiB0YWJsZSBwXG4gICAgdmFyIHAgPSBbXG4gICAgICAgIFswLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5XSxcbiAgICAgICAgWzEsIDUsIDcsIDYsIDIsIDgsIDMsIDAsIDksIDRdLFxuICAgICAgICBbNSwgOCwgMCwgMywgNywgOSwgNiwgMSwgNCwgMl0sXG4gICAgICAgIFs4LCA5LCAxLCA2LCAwLCA0LCAzLCA1LCAyLCA3XSxcbiAgICAgICAgWzksIDQsIDUsIDMsIDEsIDIsIDYsIDgsIDcsIDBdLFxuICAgICAgICBbNCwgMiwgOCwgNiwgNSwgNywgMywgOSwgMCwgMV0sXG4gICAgICAgIFsyLCA3LCA5LCAzLCA4LCAwLCA2LCA0LCAxLCA1XSxcbiAgICAgICAgWzcsIDAsIDQsIDYsIDksIDEsIDMsIDIsIDUsIDhdLFxuICAgIF07XG4gICAgLy8gSW52ZXJzZSB0YWJsZSBpbnZcbiAgICB2YXIgaW52ZXJ0ZWRBcnJheSA9IHZhbHVlLnJldmVyc2UoKTtcbiAgICB2YXIgYyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnZlcnRlZEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGMgPSBkW2NdW3BbaSAlIDhdW2ludmVydGVkQXJyYXlbaV1dXTtcbiAgICB9XG4gICAgcmV0dXJuIGMgPT09IDA7XG59XG5cbi8qKlxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqL1xudmFyIGluZGV4JDEgPSB7XG4gICAgbHVobjogbHVobixcbiAgICBtb2QxMUFuZDEwOiBtb2QxMUFuZDEwLFxuICAgIG1vZDM3QW5kMzY6IG1vZDM3QW5kMzYsXG4gICAgbW9kOTdBbmQxMDogbW9kOTdBbmQxMCxcbiAgICB2ZXJob2VmZjogdmVyaG9lZmYsXG59O1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcblxyXG5mdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG59XG5cbi8qKlxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqL1xuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBmb3JtIFRoZSBmb3JtIGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQgbmFtZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgZmllbGQgZWxlbWVudFxuICogQHBhcmFtIHtIVE1MRWxlbWVudFtdfSBlbGVtZW50cyBUaGUgbGlzdCBvZiBlbGVtZW50cyB3aGljaCBoYXZlIHRoZSBzYW1lIG5hbWUgYXMgYGZpZWxkYFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRGaWVsZFZhbHVlKGZvcm0sIGZpZWxkLCBlbGVtZW50LCBlbGVtZW50cykge1xuICAgIHZhciB0eXBlID0gKGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0eXBlJykgfHwgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIHRhZ05hbWUgPSBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAodGFnTmFtZSA9PT0gJ3RleHRhcmVhJykge1xuICAgICAgICByZXR1cm4gZWxlbWVudC52YWx1ZTtcbiAgICB9XG4gICAgaWYgKHRhZ05hbWUgPT09ICdzZWxlY3QnKSB7XG4gICAgICAgIHZhciBzZWxlY3QgPSBlbGVtZW50O1xuICAgICAgICB2YXIgaW5kZXggPSBzZWxlY3Quc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgcmV0dXJuIGluZGV4ID49IDAgPyBzZWxlY3Qub3B0aW9ucy5pdGVtKGluZGV4KS52YWx1ZSA6ICcnO1xuICAgIH1cbiAgICBpZiAodGFnTmFtZSA9PT0gJ2lucHV0Jykge1xuICAgICAgICBpZiAoJ3JhZGlvJyA9PT0gdHlwZSB8fCAnY2hlY2tib3gnID09PSB0eXBlKSB7XG4gICAgICAgICAgICB2YXIgY2hlY2tlZCA9IGVsZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAoZWxlKSB7IHJldHVybiBlbGUuY2hlY2tlZDsgfSkubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrZWQgPT09IDAgPyAnJyA6IGNoZWNrZWQgKyAnJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50LnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcbiAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuICovXG5mdW5jdGlvbiBlbWl0dGVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZuczoge30sXG4gICAgICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmZucyA9IHt9O1xuICAgICAgICB9LFxuICAgICAgICBlbWl0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAodGhpcy5mbnNbZXZlbnRdIHx8IFtdKS5tYXAoZnVuY3Rpb24gKGhhbmRsZXIpIHsgcmV0dXJuIGhhbmRsZXIuYXBwbHkoaGFuZGxlciwgYXJncyk7IH0pO1xuICAgICAgICB9LFxuICAgICAgICBvZmY6IGZ1bmN0aW9uIChldmVudCwgZnVuYykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZm5zW2V2ZW50XSkge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuZm5zW2V2ZW50XS5pbmRleE9mKGZ1bmMpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm5zW2V2ZW50XS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb246IGZ1bmN0aW9uIChldmVudCwgZnVuYykge1xuICAgICAgICAgICAgKHRoaXMuZm5zW2V2ZW50XSA9IHRoaXMuZm5zW2V2ZW50XSB8fCBbXSkucHVzaChmdW5jKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG4vKipcbiAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG4gKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKi9cbmZ1bmN0aW9uIGZpbHRlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBmaWx0ZXJzOiB7fSxcbiAgICAgICAgYWRkOiBmdW5jdGlvbiAobmFtZSwgZnVuYykge1xuICAgICAgICAgICAgKHRoaXMuZmlsdGVyc1tuYW1lXSA9IHRoaXMuZmlsdGVyc1tuYW1lXSB8fCBbXSkucHVzaChmdW5jKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVycyA9IHt9O1xuICAgICAgICB9LFxuICAgICAgICBleGVjdXRlOiBmdW5jdGlvbiAobmFtZSwgZGVmYXVsdFZhbHVlLCBhcmdzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZmlsdGVyc1tuYW1lXSB8fCAhdGhpcy5maWx0ZXJzW25hbWVdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgdmFyIGZpbHRlcnMgPSB0aGlzLmZpbHRlcnNbbmFtZV07XG4gICAgICAgICAgICB2YXIgY291bnQgPSBmaWx0ZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZpbHRlcnNbaV0uYXBwbHkocmVzdWx0LCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKG5hbWUsIGZ1bmMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcnNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbHRlcnNbbmFtZV0gPSB0aGlzLmZpbHRlcnNbbmFtZV0uZmlsdGVyKGZ1bmN0aW9uIChmKSB7IHJldHVybiBmICE9PSBmdW5jOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG4vKipcbiAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG4gKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKi9cbnZhciBDb3JlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvcmUoZm9ybSwgZmllbGRzKSB7XG4gICAgICAgIHRoaXMuZmllbGRzID0ge307XG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSB7fTtcbiAgICAgICAgdGhpcy5lZSA9IGVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5maWx0ZXIgPSBmaWx0ZXIoKTtcbiAgICAgICAgdGhpcy5wbHVnaW5zID0ge307XG4gICAgICAgIC8vIFN0b3JlIHRoZSByZXN1bHQgb2YgdmFsaWRhdGlvbiBmb3IgZWFjaCBmaWVsZFxuICAgICAgICB0aGlzLnJlc3VsdHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMudmFsaWRhdG9ycyA9IHt9O1xuICAgICAgICB0aGlzLmZvcm0gPSBmb3JtO1xuICAgICAgICB0aGlzLmZpZWxkcyA9IGZpZWxkcztcbiAgICB9XG4gICAgQ29yZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnQsIGZ1bmMpIHtcbiAgICAgICAgdGhpcy5lZS5vbihldmVudCwgZnVuYyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQ29yZS5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmdW5jKSB7XG4gICAgICAgIHRoaXMuZWUub2ZmKGV2ZW50LCBmdW5jKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBDb3JlLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5lZSkuZW1pdC5hcHBseShfYSwgX19zcHJlYWRBcnJheShbZXZlbnRdLCBhcmdzLCBmYWxzZSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIENvcmUucHJvdG90eXBlLnJlZ2lzdGVyUGx1Z2luID0gZnVuY3Rpb24gKG5hbWUsIHBsdWdpbikge1xuICAgICAgICAvLyBDaGVjayBpZiB3aGV0aGVyIHRoZSBwbHVnaW4gaXMgcmVnaXN0ZXJlZFxuICAgICAgICBpZiAodGhpcy5wbHVnaW5zW25hbWVdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcGxndWluIFwiLmNvbmNhdChuYW1lLCBcIiBpcyByZWdpc3RlcmVkXCIpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbnN0YWxsIHRoZSBwbHVnaW5cbiAgICAgICAgcGx1Z2luLnNldENvcmUodGhpcyk7XG4gICAgICAgIHBsdWdpbi5pbnN0YWxsKCk7XG4gICAgICAgIHRoaXMucGx1Z2luc1tuYW1lXSA9IHBsdWdpbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBDb3JlLnByb3RvdHlwZS5kZXJlZ2lzdGVyUGx1Z2luID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIHBsdWdpbiA9IHRoaXMucGx1Z2luc1tuYW1lXTtcbiAgICAgICAgaWYgKHBsdWdpbikge1xuICAgICAgICAgICAgcGx1Z2luLnVuaW5zdGFsbCgpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLnBsdWdpbnNbbmFtZV07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQ29yZS5wcm90b3R5cGUuZW5hYmxlUGx1Z2luID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIHBsdWdpbiA9IHRoaXMucGx1Z2luc1tuYW1lXTtcbiAgICAgICAgaWYgKHBsdWdpbikge1xuICAgICAgICAgICAgcGx1Z2luLmVuYWJsZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQ29yZS5wcm90b3R5cGUuZGlzYWJsZVBsdWdpbiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBwbHVnaW4gPSB0aGlzLnBsdWdpbnNbbmFtZV07XG4gICAgICAgIGlmIChwbHVnaW4pIHtcbiAgICAgICAgICAgIHBsdWdpbi5kaXNhYmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBDb3JlLnByb3RvdHlwZS5pc1BsdWdpbkVuYWJsZWQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgcGx1Z2luID0gdGhpcy5wbHVnaW5zW25hbWVdO1xuICAgICAgICByZXR1cm4gcGx1Z2luID8gcGx1Z2luLmlzUGx1Z2luRW5hYmxlZCgpIDogZmFsc2U7XG4gICAgfTtcbiAgICBDb3JlLnByb3RvdHlwZS5yZWdpc3RlclZhbGlkYXRvciA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbGlkYXRvcnNbbmFtZV0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSB2YWxpZGF0b3IgXCIuY29uY2F0KG5hbWUsIFwiIGlzIHJlZ2lzdGVyZWRcIikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsaWRhdG9yc1tuYW1lXSA9IGZ1bmM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIGEgZmlsdGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiBmaWx0ZXJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmaWx0ZXIgZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtDb3JlfVxuICAgICAqL1xuICAgIENvcmUucHJvdG90eXBlLnJlZ2lzdGVyRmlsdGVyID0gZnVuY3Rpb24gKG5hbWUsIGZ1bmMpIHtcbiAgICAgICAgdGhpcy5maWx0ZXIuYWRkKG5hbWUsIGZ1bmMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGZpbHRlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgZmlsdGVyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZmlsdGVyIGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7Q29yZX1cbiAgICAgKi9cbiAgICBDb3JlLnByb3RvdHlwZS5kZXJlZ2lzdGVyRmlsdGVyID0gZnVuY3Rpb24gKG5hbWUsIGZ1bmMpIHtcbiAgICAgICAgdGhpcy5maWx0ZXIucmVtb3ZlKG5hbWUsIGZ1bmMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgYSBmaWx0ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIGZpbHRlclxuICAgICAqIEBwYXJhbSB7VH0gZGVmYXVsdFZhbHVlIFRoZSBkZWZhdWx0IHZhbHVlIHJldHVybnMgYnkgdGhlIGZpbHRlclxuICAgICAqIEBwYXJhbSB7YXJyYXl9IGFyZ3MgVGhlIGZpbHRlciBhcmd1bWVudHNcbiAgICAgKiBAcmV0dXJucyB7VH1cbiAgICAgKi9cbiAgICBDb3JlLnByb3RvdHlwZS5leGVjdXRlRmlsdGVyID0gZnVuY3Rpb24gKG5hbWUsIGRlZmF1bHRWYWx1ZSwgYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIuZXhlY3V0ZShuYW1lLCBkZWZhdWx0VmFsdWUsIGFyZ3MpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIGEgZmllbGRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQgbmFtZVxuICAgICAqIEBwYXJhbSB7RmllbGRPcHRpb25zfSBvcHRpb25zIFRoZSBmaWVsZCBvcHRpb25zLiBUaGUgb3B0aW9ucyB3aWxsIGJlIG1lcmdlZCB3aXRoIHRoZSBvcmlnaW5hbCB2YWxpZGF0b3IgcnVsZXNcbiAgICAgKiBpZiB0aGUgZmllbGQgaXMgYWxyZWFkeSBkZWZpbmVkXG4gICAgICogQHJldHVybiB7Q29yZX1cbiAgICAgKi9cbiAgICBDb3JlLnByb3RvdHlwZS5hZGRGaWVsZCA9IGZ1bmN0aW9uIChmaWVsZCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnJyxcbiAgICAgICAgICAgIHZhbGlkYXRvcnM6IHt9LFxuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgLy8gTWVyZ2UgdGhlIG9wdGlvbnNcbiAgICAgICAgdGhpcy5maWVsZHNbZmllbGRdID0gdGhpcy5maWVsZHNbZmllbGRdXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rvcjogb3B0cy5zZWxlY3RvciB8fCB0aGlzLmZpZWxkc1tmaWVsZF0uc2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgdmFsaWRhdG9yczogT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5maWVsZHNbZmllbGRdLnZhbGlkYXRvcnMsIG9wdHMudmFsaWRhdG9ycyksXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IG9wdHM7XG4gICAgICAgIHRoaXMuZWxlbWVudHNbZmllbGRdID0gdGhpcy5xdWVyeUVsZW1lbnRzKGZpZWxkKTtcbiAgICAgICAgdGhpcy5lbWl0KCdjb3JlLmZpZWxkLmFkZGVkJywge1xuICAgICAgICAgICAgZWxlbWVudHM6IHRoaXMuZWxlbWVudHNbZmllbGRdLFxuICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICAgICAgb3B0aW9uczogdGhpcy5maWVsZHNbZmllbGRdLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgZ2l2ZW4gZmllbGQgYnkgbmFtZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCBuYW1lXG4gICAgICogQHJldHVybiB7Q29yZX1cbiAgICAgKi9cbiAgICBDb3JlLnByb3RvdHlwZS5yZW1vdmVGaWVsZCA9IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICBpZiAoIXRoaXMuZmllbGRzW2ZpZWxkXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGZpZWxkIFwiLmNvbmNhdChmaWVsZCwgXCIgdmFsaWRhdG9ycyBhcmUgbm90IGRlZmluZWQuIFBsZWFzZSBlbnN1cmUgdGhlIGZpZWxkIGlzIGFkZGVkIGZpcnN0XCIpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzW2ZpZWxkXTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmZpZWxkc1tmaWVsZF07XG4gICAgICAgIGRlbGV0ZSB0aGlzLmVsZW1lbnRzW2ZpZWxkXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuZmllbGRzW2ZpZWxkXTtcbiAgICAgICAgdGhpcy5lbWl0KCdjb3JlLmZpZWxkLnJlbW92ZWQnLCB7XG4gICAgICAgICAgICBlbGVtZW50czogZWxlbWVudHMsXG4gICAgICAgICAgICBmaWVsZDogZmllbGQsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSBhbGwgZmllbGRzXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPHN0cmluZz59XG4gICAgICovXG4gICAgQ29yZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZW1pdCgnY29yZS5mb3JtLnZhbGlkYXRpbmcnLCB7XG4gICAgICAgICAgICBmb3JtVmFsaWRhdGlvbjogdGhpcyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlci5leGVjdXRlKCd2YWxpZGF0ZS1wcmUnLCBQcm9taXNlLnJlc29sdmUoKSwgW10pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKE9iamVjdC5rZXlzKF90aGlzLmZpZWxkcykubWFwKGZ1bmN0aW9uIChmaWVsZCkgeyByZXR1cm4gX3RoaXMudmFsaWRhdGVGaWVsZChmaWVsZCk7IH0pKS50aGVuKGZ1bmN0aW9uIChyZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgLy8gYHJlc3VsdHNgIGlzIGFuIGFycmF5IG9mIGBWYWxpZGAsIGBJbnZhbGlkYCBhbmQgYE5vdFZhbGlkYXRlZGBcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSByZXN1bHRzLmluZGV4T2YoJ0ludmFsaWQnKSAhPT0gLTE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KCdjb3JlLmZvcm0uaW52YWxpZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtVmFsaWRhdGlvbjogX3RoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoJ0ludmFsaWQnKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSByZXN1bHRzLmluZGV4T2YoJ05vdFZhbGlkYXRlZCcpICE9PSAtMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ2NvcmUuZm9ybS5ub3R2YWxpZGF0ZWQnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybVZhbGlkYXRpb246IF90aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCdOb3RWYWxpZGF0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ2NvcmUuZm9ybS52YWxpZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtVmFsaWRhdGlvbjogX3RoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoJ1ZhbGlkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGUgYSBwYXJ0aWN1bGFyIGZpZWxkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkIG5hbWVcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPHN0cmluZz59XG4gICAgICovXG4gICAgQ29yZS5wcm90b3R5cGUudmFsaWRhdGVGaWVsZCA9IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBTdG9wIHZhbGlkYXRpb24gcHJvY2VzcyBpZiB0aGUgZmllbGQgaXMgYWxyZWFkeSB2YWxpZGF0ZWRcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucmVzdWx0cy5nZXQoZmllbGQpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSAnVmFsaWQnIHx8IHJlc3VsdCA9PT0gJ0ludmFsaWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KCdjb3JlLmZpZWxkLnZhbGlkYXRpbmcnLCBmaWVsZCk7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHNbZmllbGRdO1xuICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2NvcmUuZmllbGQudmFsaWQnLCBmaWVsZCk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCdWYWxpZCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0eXBlID0gZWxlbWVudHNbMF0uZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG4gICAgICAgIGlmICgncmFkaW8nID09PSB0eXBlIHx8ICdjaGVja2JveCcgPT09IHR5cGUgfHwgZWxlbWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZUVsZW1lbnQoZmllbGQsIGVsZW1lbnRzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChlbGVtZW50cy5tYXAoZnVuY3Rpb24gKGVsZSkgeyByZXR1cm4gX3RoaXMudmFsaWRhdGVFbGVtZW50KGZpZWxkLCBlbGUpOyB9KSkudGhlbihmdW5jdGlvbiAocmVzdWx0cykge1xuICAgICAgICAgICAgICAgIC8vIGByZXN1bHRzYCBpcyBhbiBhcnJheSBvZiBgVmFsaWRgLCBgSW52YWxpZGAgYW5kIGBOb3RWYWxpZGF0ZWRgXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgcmVzdWx0cy5pbmRleE9mKCdJbnZhbGlkJykgIT09IC0xOlxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgnY29yZS5maWVsZC5pbnZhbGlkJywgZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVzdWx0cy5zZXQoZmllbGQsICdJbnZhbGlkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCdJbnZhbGlkJyk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgcmVzdWx0cy5pbmRleE9mKCdOb3RWYWxpZGF0ZWQnKSAhPT0gLTE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KCdjb3JlLmZpZWxkLm5vdHZhbGlkYXRlZCcsIGZpZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlc3VsdHMuZGVsZXRlKGZpZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoJ05vdFZhbGlkYXRlZCcpO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgnY29yZS5maWVsZC52YWxpZCcsIGZpZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlc3VsdHMuc2V0KGZpZWxkLCAnVmFsaWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoJ1ZhbGlkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIHBhcnRpY3VsYXIgZWxlbWVudFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCBuYW1lXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlIFRoZSBmaWVsZCBlbGVtZW50XG4gICAgICogQHJldHVybiB7UHJvbWlzZTxzdHJpbmc+fVxuICAgICAqL1xuICAgIENvcmUucHJvdG90eXBlLnZhbGlkYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChmaWVsZCwgZWxlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIFJlc2V0IHZhbGlkYXRpb24gcmVzdWx0XG4gICAgICAgIHRoaXMucmVzdWx0cy5kZWxldGUoZmllbGQpO1xuICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzW2ZpZWxkXTtcbiAgICAgICAgdmFyIGlnbm9yZWQgPSB0aGlzLmZpbHRlci5leGVjdXRlKCdlbGVtZW50LWlnbm9yZWQnLCBmYWxzZSwgW2ZpZWxkLCBlbGUsIGVsZW1lbnRzXSk7XG4gICAgICAgIGlmIChpZ25vcmVkKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2NvcmUuZWxlbWVudC5pZ25vcmVkJywge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZSxcbiAgICAgICAgICAgICAgICBlbGVtZW50czogZWxlbWVudHMsXG4gICAgICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCdJZ25vcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbGlkYXRvckxpc3QgPSB0aGlzLmZpZWxkc1tmaWVsZF0udmFsaWRhdG9ycztcbiAgICAgICAgdGhpcy5lbWl0KCdjb3JlLmVsZW1lbnQudmFsaWRhdGluZycsIHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IGVsZSxcbiAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcbiAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBwcm9taXNlcyA9IE9iamVjdC5rZXlzKHZhbGlkYXRvckxpc3QpLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmV4ZWN1dGVWYWxpZGF0b3IoZmllbGQsIGVsZSwgdiwgdmFsaWRhdG9yTGlzdFt2XSk7IH07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy53YXRlcmZhbGwocHJvbWlzZXMpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzdWx0cykge1xuICAgICAgICAgICAgLy8gYHJlc3VsdHNgIGlzIGFuIGFycmF5IG9mIGBWYWxpZGAgb3IgYEludmFsaWRgXG4gICAgICAgICAgICB2YXIgaXNWYWxpZCA9IHJlc3VsdHMuaW5kZXhPZignSW52YWxpZCcpID09PSAtMTtcbiAgICAgICAgICAgIF90aGlzLmVtaXQoJ2NvcmUuZWxlbWVudC52YWxpZGF0ZWQnLCB7XG4gICAgICAgICAgICAgICAgZWxlbWVudDogZWxlLFxuICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcbiAgICAgICAgICAgICAgICBmaWVsZDogZmllbGQsXG4gICAgICAgICAgICAgICAgdmFsaWQ6IGlzVmFsaWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciB0eXBlID0gZWxlLmdldEF0dHJpYnV0ZSgndHlwZScpO1xuICAgICAgICAgICAgaWYgKCdyYWRpbycgPT09IHR5cGUgfHwgJ2NoZWNrYm94JyA9PT0gdHlwZSB8fCBlbGVtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KGlzVmFsaWQgPyAnY29yZS5maWVsZC52YWxpZCcgOiAnY29yZS5maWVsZC5pbnZhbGlkJywgZmllbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShpc1ZhbGlkID8gJ1ZhbGlkJyA6ICdJbnZhbGlkJyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgICAgLy8gcmVhc29uIGlzIGBOb3RWYWxpZGF0ZWRgXG4gICAgICAgICAgICBfdGhpcy5lbWl0KCdjb3JlLmVsZW1lbnQubm90dmFsaWRhdGVkJywge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZSxcbiAgICAgICAgICAgICAgICBlbGVtZW50czogZWxlbWVudHMsXG4gICAgICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBnaXZlbiB2YWxpZGF0b3Igb24gZmllbGRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQgbmFtZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZSBUaGUgZmllbGQgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2IFRoZSB2YWxpZGF0b3IgbmFtZVxuICAgICAqIEBwYXJhbSB7VmFsaWRhdG9yT3B0aW9uc30gb3B0cyBUaGUgdmFsaWRhdG9yIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPHN0cmluZz59XG4gICAgICovXG4gICAgQ29yZS5wcm90b3R5cGUuZXhlY3V0ZVZhbGlkYXRvciA9IGZ1bmN0aW9uIChmaWVsZCwgZWxlLCB2LCBvcHRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHNbZmllbGRdO1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMuZmlsdGVyLmV4ZWN1dGUoJ3ZhbGlkYXRvci1uYW1lJywgdiwgW3YsIGZpZWxkXSk7XG4gICAgICAgIG9wdHMubWVzc2FnZSA9IHRoaXMuZmlsdGVyLmV4ZWN1dGUoJ3ZhbGlkYXRvci1tZXNzYWdlJywgb3B0cy5tZXNzYWdlLCBbdGhpcy5sb2NhbGUsIGZpZWxkLCBuYW1lXSk7XG4gICAgICAgIC8vIFNpbXBseSBwYXNzIHRoZSB2YWxpZGF0b3IgaWZcbiAgICAgICAgLy8gLSBpdCBpc24ndCBkZWZpbmVkIHlldFxuICAgICAgICAvLyAtIG9yIHRoZSBhc3NvY2lhdGVkIHZhbGlkYXRvciBpc24ndCBlbmFibGVkXG4gICAgICAgIGlmICghdGhpcy52YWxpZGF0b3JzW25hbWVdIHx8IG9wdHMuZW5hYmxlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY29yZS52YWxpZGF0b3IudmFsaWRhdGVkJywge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZSxcbiAgICAgICAgICAgICAgICBlbGVtZW50czogZWxlbWVudHMsXG4gICAgICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogdGhpcy5ub3JtYWxpemVSZXN1bHQoZmllbGQsIG5hbWUsIHsgdmFsaWQ6IHRydWUgfSksXG4gICAgICAgICAgICAgICAgdmFsaWRhdG9yOiBuYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCdWYWxpZCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWxpZGF0b3IgPSB0aGlzLnZhbGlkYXRvcnNbbmFtZV07XG4gICAgICAgIC8vIEdldCB0aGUgZmllbGQgdmFsdWVcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5nZXRFbGVtZW50VmFsdWUoZmllbGQsIGVsZSwgbmFtZSk7XG4gICAgICAgIHZhciB3aWxsVmFsaWRhdGUgPSB0aGlzLmZpbHRlci5leGVjdXRlKCdmaWVsZC1zaG91bGQtdmFsaWRhdGUnLCB0cnVlLCBbZmllbGQsIGVsZSwgdmFsdWUsIHZdKTtcbiAgICAgICAgaWYgKCF3aWxsVmFsaWRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY29yZS52YWxpZGF0b3Iubm90dmFsaWRhdGVkJywge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZSxcbiAgICAgICAgICAgICAgICBlbGVtZW50czogZWxlbWVudHMsXG4gICAgICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICAgICAgICAgIHZhbGlkYXRvcjogdixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgnTm90VmFsaWRhdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KCdjb3JlLnZhbGlkYXRvci52YWxpZGF0aW5nJywge1xuICAgICAgICAgICAgZWxlbWVudDogZWxlLFxuICAgICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLFxuICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICAgICAgdmFsaWRhdG9yOiB2LFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gUGVyZm9ybSB2YWxpZGF0aW9uXG4gICAgICAgIHZhciByZXN1bHQgPSB2YWxpZGF0b3IoKS52YWxpZGF0ZSh7XG4gICAgICAgICAgICBlbGVtZW50OiBlbGUsXG4gICAgICAgICAgICBlbGVtZW50czogZWxlbWVudHMsXG4gICAgICAgICAgICBmaWVsZDogZmllbGQsXG4gICAgICAgICAgICBsMTBuOiB0aGlzLmxvY2FsaXphdGlvbixcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdHMsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSByZXN1bHQgaXMgYSBgUHJvbWlzZWBcbiAgICAgICAgdmFyIGlzUHJvbWlzZSA9ICdmdW5jdGlvbicgPT09IHR5cGVvZiByZXN1bHRbJ3RoZW4nXTtcbiAgICAgICAgaWYgKGlzUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBfdGhpcy5ub3JtYWxpemVSZXN1bHQoZmllbGQsIHYsIHIpO1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ2NvcmUudmFsaWRhdG9yLnZhbGlkYXRlZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogZWxlLFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50czogZWxlbWVudHMsXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3I6IHYsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEudmFsaWQgPyAnVmFsaWQnIDogJ0ludmFsaWQnO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMubm9ybWFsaXplUmVzdWx0KGZpZWxkLCB2LCByZXN1bHQpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdjb3JlLnZhbGlkYXRvci52YWxpZGF0ZWQnLCB7XG4gICAgICAgICAgICAgICAgZWxlbWVudDogZWxlLFxuICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcbiAgICAgICAgICAgICAgICBmaWVsZDogZmllbGQsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiBkYXRhLFxuICAgICAgICAgICAgICAgIHZhbGlkYXRvcjogdixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkYXRhLnZhbGlkID8gJ1ZhbGlkJyA6ICdJbnZhbGlkJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvcmUucHJvdG90eXBlLmdldEVsZW1lbnRWYWx1ZSA9IGZ1bmN0aW9uIChmaWVsZCwgZWxlLCB2YWxpZGF0b3IpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IGdldEZpZWxkVmFsdWUodGhpcy5mb3JtLCBmaWVsZCwgZWxlLCB0aGlzLmVsZW1lbnRzW2ZpZWxkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlci5leGVjdXRlKCdmaWVsZC12YWx1ZScsIGRlZmF1bHRWYWx1ZSwgW2RlZmF1bHRWYWx1ZSwgZmllbGQsIGVsZSwgdmFsaWRhdG9yXSk7XG4gICAgfTtcbiAgICAvLyBTb21lIGdldHRlciBtZXRob2RzXG4gICAgQ29yZS5wcm90b3R5cGUuZ2V0RWxlbWVudHMgPSBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHNbZmllbGRdO1xuICAgIH07XG4gICAgQ29yZS5wcm90b3R5cGUuZ2V0RmllbGRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWVsZHM7XG4gICAgfTtcbiAgICBDb3JlLnByb3RvdHlwZS5nZXRGb3JtRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybTtcbiAgICB9O1xuICAgIENvcmUucHJvdG90eXBlLmdldExvY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlO1xuICAgIH07XG4gICAgQ29yZS5wcm90b3R5cGUuZ2V0UGx1Z2luID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGx1Z2luc1tuYW1lXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgZmllbGQgc3RhdHVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkIG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RhdHVzIFRoZSBuZXcgc3RhdHVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt2YWxpZGF0b3JdIFRoZSB2YWxpZGF0b3IgbmFtZS4gSWYgaXQgaXNuJ3Qgc3BlY2lmaWVkLCBhbGwgdmFsaWRhdG9ycyB3aWxsIGJlIHVwZGF0ZWRcbiAgICAgKiBAcmV0dXJuIHtDb3JlfVxuICAgICAqL1xuICAgIENvcmUucHJvdG90eXBlLnVwZGF0ZUZpZWxkU3RhdHVzID0gZnVuY3Rpb24gKGZpZWxkLCBzdGF0dXMsIHZhbGlkYXRvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzW2ZpZWxkXTtcbiAgICAgICAgdmFyIHR5cGUgPSBlbGVtZW50c1swXS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcbiAgICAgICAgdmFyIGxpc3QgPSAncmFkaW8nID09PSB0eXBlIHx8ICdjaGVja2JveCcgPT09IHR5cGUgPyBbZWxlbWVudHNbMF1dIDogZWxlbWVudHM7XG4gICAgICAgIGxpc3QuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7IHJldHVybiBfdGhpcy51cGRhdGVFbGVtZW50U3RhdHVzKGZpZWxkLCBlbGUsIHN0YXR1cywgdmFsaWRhdG9yKTsgfSk7XG4gICAgICAgIGlmICghdmFsaWRhdG9yKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHN0YXR1cykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ05vdFZhbGlkYXRlZCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnY29yZS5maWVsZC5ub3R2YWxpZGF0ZWQnLCBmaWVsZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0cy5kZWxldGUoZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdWYWxpZGF0aW5nJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdjb3JlLmZpZWxkLnZhbGlkYXRpbmcnLCBmaWVsZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0cy5kZWxldGUoZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdWYWxpZCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnY29yZS5maWVsZC52YWxpZCcsIGZpZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHRzLnNldChmaWVsZCwgJ1ZhbGlkJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0ludmFsaWQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2NvcmUuZmllbGQuaW52YWxpZCcsIGZpZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHRzLnNldChmaWVsZCwgJ0ludmFsaWQnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdHVzID09PSAnSW52YWxpZCcpIHtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gbWFyayB0aGUgZmllbGQgYXMgaW52YWxpZCBiZWNhdXNlIGl0IGRvZXNuJ3QgcGFzcyB0aGUgYHZhbGlkYXRvcmBcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY29yZS5maWVsZC5pbnZhbGlkJywgZmllbGQpO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRzLnNldChmaWVsZCwgJ0ludmFsaWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgZWxlbWVudCBzdGF0dXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQgbmFtZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZSBUaGUgZmllbGQgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGF0dXMgVGhlIG5ldyBzdGF0dXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3ZhbGlkYXRvcl0gVGhlIHZhbGlkYXRvciBuYW1lLiBJZiBpdCBpc24ndCBzcGVjaWZpZWQsIGFsbCB2YWxpZGF0b3JzIHdpbGwgYmUgdXBkYXRlZFxuICAgICAqIEByZXR1cm4ge0NvcmV9XG4gICAgICovXG4gICAgQ29yZS5wcm90b3R5cGUudXBkYXRlRWxlbWVudFN0YXR1cyA9IGZ1bmN0aW9uIChmaWVsZCwgZWxlLCBzdGF0dXMsIHZhbGlkYXRvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzW2ZpZWxkXTtcbiAgICAgICAgdmFyIGZpZWxkVmFsaWRhdG9ycyA9IHRoaXMuZmllbGRzW2ZpZWxkXS52YWxpZGF0b3JzO1xuICAgICAgICB2YXIgdmFsaWRhdG9yQXJyID0gdmFsaWRhdG9yID8gW3ZhbGlkYXRvcl0gOiBPYmplY3Qua2V5cyhmaWVsZFZhbGlkYXRvcnMpO1xuICAgICAgICBzd2l0Y2ggKHN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSAnTm90VmFsaWRhdGVkJzpcbiAgICAgICAgICAgICAgICB2YWxpZGF0b3JBcnIuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZW1pdCgnY29yZS52YWxpZGF0b3Iubm90dmFsaWRhdGVkJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogZWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yOiB2LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2NvcmUuZWxlbWVudC5ub3R2YWxpZGF0ZWQnLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZSxcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICBmaWVsZDogZmllbGQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdWYWxpZGF0aW5nJzpcbiAgICAgICAgICAgICAgICB2YWxpZGF0b3JBcnIuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZW1pdCgnY29yZS52YWxpZGF0b3IudmFsaWRhdGluZycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvcjogdixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdjb3JlLmVsZW1lbnQudmFsaWRhdGluZycsIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogZWxlLFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50czogZWxlbWVudHMsXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1ZhbGlkJzpcbiAgICAgICAgICAgICAgICB2YWxpZGF0b3JBcnIuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZW1pdCgnY29yZS52YWxpZGF0b3IudmFsaWRhdGVkJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogZWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZmllbGRWYWxpZGF0b3JzW3ZdLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yOiB2LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2NvcmUuZWxlbWVudC52YWxpZGF0ZWQnLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZSxcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICBmaWVsZDogZmllbGQsXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnSW52YWxpZCc6XG4gICAgICAgICAgICAgICAgdmFsaWRhdG9yQXJyLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmVtaXQoJ2NvcmUudmFsaWRhdG9yLnZhbGlkYXRlZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGZpZWxkVmFsaWRhdG9yc1t2XS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3I6IHYsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnY29yZS5lbGVtZW50LnZhbGlkYXRlZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogZWxlLFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50czogZWxlbWVudHMsXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgICAgICAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIGZvcm0uIEl0IGFsc28gY2xlYXJzIGFsbCB0aGUgbWVzc2FnZXMsIGhpZGUgdGhlIGZlZWRiYWNrIGljb25zLCBldGMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlc2V0IElmIHRydWUsIHRoZSBtZXRob2QgcmVzZXRzIGZpZWxkIHZhbHVlIHRvIGVtcHR5XG4gICAgICogb3IgcmVtb3ZlIGBjaGVja2VkYCwgYHNlbGVjdGVkYCBhdHRyaWJ1dGVzXG4gICAgICogQHJldHVybiB7Q29yZX1cbiAgICAgKi9cbiAgICBDb3JlLnByb3RvdHlwZS5yZXNldEZvcm0gPSBmdW5jdGlvbiAocmVzZXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5maWVsZHMpLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiBfdGhpcy5yZXNldEZpZWxkKGZpZWxkLCByZXNldCk7IH0pO1xuICAgICAgICB0aGlzLmVtaXQoJ2NvcmUuZm9ybS5yZXNldCcsIHtcbiAgICAgICAgICAgIGZvcm1WYWxpZGF0aW9uOiB0aGlzLFxuICAgICAgICAgICAgcmVzZXQ6IHJlc2V0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgZmllbGQuIEl0IGFsc28gY2xlYXJzIGFsbCB0aGUgbWVzc2FnZXMsIGhpZGUgdGhlIGZlZWRiYWNrIGljb25zLCBldGMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkIG5hbWVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlc2V0IElmIHRydWUsIHRoZSBtZXRob2QgcmVzZXRzIGZpZWxkIHZhbHVlIHRvIGVtcHR5XG4gICAgICogb3IgcmVtb3ZlIGBjaGVja2VkYCwgYHNlbGVjdGVkYCBhdHRyaWJ1dGVzXG4gICAgICogQHJldHVybiB7Q29yZX1cbiAgICAgKi9cbiAgICBDb3JlLnByb3RvdHlwZS5yZXNldEZpZWxkID0gZnVuY3Rpb24gKGZpZWxkLCByZXNldCkge1xuICAgICAgICAvLyBSZXNldCB0aGUgZmllbGQgZWxlbWVudCB2YWx1ZSBpZiBuZWVkZWRcbiAgICAgICAgaWYgKHJlc2V0KSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzW2ZpZWxkXTtcbiAgICAgICAgICAgIHZhciB0eXBlXzEgPSBlbGVtZW50c1swXS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcbiAgICAgICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgICAgICAgIGlmICgncmFkaW8nID09PSB0eXBlXzEgfHwgJ2NoZWNrYm94JyA9PT0gdHlwZV8xKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZS5yZW1vdmVBdHRyaWJ1dGUoJ3NlbGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGVsZS5yZW1vdmVBdHRyaWJ1dGUoJ2NoZWNrZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgZWxlLmNoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZS5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgJycpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlIGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCB8fCBlbGUgaW5zdGFuY2VvZiBIVE1MVGV4dEFyZWFFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGUudmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1hcmsgdGhlIGZpZWxkIGFzIG5vdCB2YWxpZGF0ZWQgeWV0XG4gICAgICAgIHRoaXMudXBkYXRlRmllbGRTdGF0dXMoZmllbGQsICdOb3RWYWxpZGF0ZWQnKTtcbiAgICAgICAgdGhpcy5lbWl0KCdjb3JlLmZpZWxkLnJlc2V0Jywge1xuICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICAgICAgcmVzZXQ6IHJlc2V0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXZhbGlkYXRlIGEgcGFydGljdWxhciBmaWVsZC4gSXQncyB1c2VmdWwgd2hlbiB0aGUgZmllbGQgdmFsdWUgaXMgZWZmZWN0ZWQgYnkgdGhpcmQgcGFydGllc1xuICAgICAqIChmb3IgZXhhbXBsZSwgYXR0YWNoIGFub3RoZXIgVUkgbGlicmFyeSB0byB0aGUgZmllbGQpLlxuICAgICAqIFNpbmNlIHRoZXJlIGlzbid0IGFuIGF1dG9tYXRpYyB3YXkgZm9yIEZvcm1WYWxpZGF0aW9uIHRvIGtub3cgd2hlbiB0aGUgZmllbGQgdmFsdWUgaXMgbW9kaWZpZWQgaW4gdGhvc2UgY2FzZXMsXG4gICAgICogd2UgbmVlZCB0byByZXZhbGlkYXRlIHRoZSBmaWVsZCBtYW51YWxseS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQgbmFtZVxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8c3RyaW5nPn1cbiAgICAgKi9cbiAgICBDb3JlLnByb3RvdHlwZS5yZXZhbGlkYXRlRmllbGQgPSBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZpZWxkc1tmaWVsZF0pIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoJ0lnbm9yZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZUZpZWxkU3RhdHVzKGZpZWxkLCAnTm90VmFsaWRhdGVkJyk7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlRmllbGQoZmllbGQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGlzYWJsZSBwYXJ0aWN1bGFyIHZhbGlkYXRvciBmb3IgZ2l2ZW4gZmllbGRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQgbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWxpZGF0b3IgVGhlIHZhbGlkYXRvciBuYW1lLiBJZiBpdCBpc24ndCBzcGVjaWZpZWQsIGFsbCB2YWxpZGF0b3JzIHdpbGwgYmUgZGlzYWJsZWRcbiAgICAgKiBAcmV0dXJuIHtDb3JlfVxuICAgICAqL1xuICAgIENvcmUucHJvdG90eXBlLmRpc2FibGVWYWxpZGF0b3IgPSBmdW5jdGlvbiAoZmllbGQsIHZhbGlkYXRvcikge1xuICAgICAgICBpZiAoIXRoaXMuZmllbGRzW2ZpZWxkXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50c1tmaWVsZF07XG4gICAgICAgIHRoaXMudG9nZ2xlVmFsaWRhdG9yKGZhbHNlLCBmaWVsZCwgdmFsaWRhdG9yKTtcbiAgICAgICAgdGhpcy5lbWl0KCdjb3JlLnZhbGlkYXRvci5kaXNhYmxlZCcsIHtcbiAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcbiAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgICAgIGZvcm1WYWxpZGF0aW9uOiB0aGlzLFxuICAgICAgICAgICAgdmFsaWRhdG9yOiB2YWxpZGF0b3IsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEVuYWJsZSBwYXJ0aWN1bGFyIHZhbGlkYXRvciBmb3IgZ2l2ZW4gZmllbGRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQgbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWxpZGF0b3IgVGhlIHZhbGlkYXRvciBuYW1lLiBJZiBpdCBpc24ndCBzcGVjaWZpZWQsIGFsbCB2YWxpZGF0b3JzIHdpbGwgYmUgZW5hYmxlZFxuICAgICAqIEByZXR1cm4ge0NvcmV9XG4gICAgICovXG4gICAgQ29yZS5wcm90b3R5cGUuZW5hYmxlVmFsaWRhdG9yID0gZnVuY3Rpb24gKGZpZWxkLCB2YWxpZGF0b3IpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZpZWxkc1tmaWVsZF0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHNbZmllbGRdO1xuICAgICAgICB0aGlzLnRvZ2dsZVZhbGlkYXRvcih0cnVlLCBmaWVsZCwgdmFsaWRhdG9yKTtcbiAgICAgICAgdGhpcy5lbWl0KCdjb3JlLnZhbGlkYXRvci5lbmFibGVkJywge1xuICAgICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLFxuICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICAgICAgZm9ybVZhbGlkYXRpb246IHRoaXMsXG4gICAgICAgICAgICB2YWxpZGF0b3I6IHZhbGlkYXRvcixcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlIG9wdGlvbiBvZiBwYXJ0aWN1bGFyIHZhbGlkYXRvciBmb3IgZ2l2ZW4gZmllbGRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQgbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWxpZGF0b3IgVGhlIHZhbGlkYXRvciBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG9wdGlvbidzIG5hbWVcbiAgICAgKiBAcGFyYW0ge3Vua25vd259IHZhbHVlIFRoZSBvcHRpb24ncyB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0NvcmV9XG4gICAgICovXG4gICAgQ29yZS5wcm90b3R5cGUudXBkYXRlVmFsaWRhdG9yT3B0aW9uID0gZnVuY3Rpb24gKGZpZWxkLCB2YWxpZGF0b3IsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmZpZWxkc1tmaWVsZF0gJiYgdGhpcy5maWVsZHNbZmllbGRdLnZhbGlkYXRvcnMgJiYgdGhpcy5maWVsZHNbZmllbGRdLnZhbGlkYXRvcnNbdmFsaWRhdG9yXSkge1xuICAgICAgICAgICAgdGhpcy5maWVsZHNbZmllbGRdLnZhbGlkYXRvcnNbdmFsaWRhdG9yXVtuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQ29yZS5wcm90b3R5cGUuc2V0RmllbGRPcHRpb25zID0gZnVuY3Rpb24gKGZpZWxkLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuZmllbGRzW2ZpZWxkXSA9IG9wdGlvbnM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQ29yZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gUmVtb3ZlIHBsdWdpbnMgYW5kIGZpbHRlcnNcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5wbHVnaW5zKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gX3RoaXMucGx1Z2luc1tpZF0udW5pbnN0YWxsKCk7IH0pO1xuICAgICAgICB0aGlzLmVlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuZmlsdGVyLmNsZWFyKCk7XG4gICAgICAgIHRoaXMucmVzdWx0cy5jbGVhcigpO1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBDb3JlLnByb3RvdHlwZS5zZXRMb2NhbGUgPSBmdW5jdGlvbiAobG9jYWxlLCBsb2NhbGl6YXRpb24pIHtcbiAgICAgICAgdGhpcy5sb2NhbGUgPSBsb2NhbGU7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uID0gbG9jYWxpemF0aW9uO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIENvcmUucHJvdG90eXBlLndhdGVyZmFsbCA9IGZ1bmN0aW9uIChwcm9taXNlcykge1xuICAgICAgICByZXR1cm4gcHJvbWlzZXMucmVkdWNlKGZ1bmN0aW9uIChwLCBjKSB7XG4gICAgICAgICAgICByZXR1cm4gcC50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYygpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIFByb21pc2UucmVzb2x2ZShbXSkpO1xuICAgIH07XG4gICAgQ29yZS5wcm90b3R5cGUucXVlcnlFbGVtZW50cyA9IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSB0aGlzLmZpZWxkc1tmaWVsZF0uc2VsZWN0b3JcbiAgICAgICAgICAgID8gLy8gQ2hlY2sgaWYgdGhlIHNlbGVjdG9yIGlzIGFuIElEIHNlbGVjdG9yIHdoaWNoIHN0YXJ0cyB3aXRoIGAjYFxuICAgICAgICAgICAgICAgICcjJyA9PT0gdGhpcy5maWVsZHNbZmllbGRdLnNlbGVjdG9yLmNoYXJBdCgwKVxuICAgICAgICAgICAgICAgICAgICA/IFwiW2lkPVxcXCJcIi5jb25jYXQodGhpcy5maWVsZHNbZmllbGRdLnNlbGVjdG9yLnN1YnN0cmluZygxKSwgXCJcXFwiXVwiKVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuZmllbGRzW2ZpZWxkXS5zZWxlY3RvclxuICAgICAgICAgICAgOiBcIltuYW1lPVxcXCJcIi5jb25jYXQoZmllbGQucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpLCBcIlxcXCJdXCIpO1xuICAgICAgICByZXR1cm4gW10uc2xpY2UuY2FsbCh0aGlzLmZvcm0ucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xuICAgIH07XG4gICAgQ29yZS5wcm90b3R5cGUubm9ybWFsaXplUmVzdWx0ID0gZnVuY3Rpb24gKGZpZWxkLCB2YWxpZGF0b3IsIHJlc3VsdCkge1xuICAgICAgICB2YXIgb3B0cyA9IHRoaXMuZmllbGRzW2ZpZWxkXS52YWxpZGF0b3JzW3ZhbGlkYXRvcl07XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCByZXN1bHQsIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IHJlc3VsdC5tZXNzYWdlIHx8XG4gICAgICAgICAgICAgICAgKG9wdHMgPyBvcHRzLm1lc3NhZ2UgOiAnJykgfHxcbiAgICAgICAgICAgICAgICAodGhpcy5sb2NhbGl6YXRpb24gJiYgdGhpcy5sb2NhbGl6YXRpb25bdmFsaWRhdG9yXSAmJiB0aGlzLmxvY2FsaXphdGlvblt2YWxpZGF0b3JdWydkZWZhdWx0J11cbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmxvY2FsaXphdGlvblt2YWxpZGF0b3JdWydkZWZhdWx0J11cbiAgICAgICAgICAgICAgICAgICAgOiAnJykgfHxcbiAgICAgICAgICAgICAgICBcIlRoZSBmaWVsZCBcIi5jb25jYXQoZmllbGQsIFwiIGlzIG5vdCB2YWxpZFwiKSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb3JlLnByb3RvdHlwZS50b2dnbGVWYWxpZGF0b3IgPSBmdW5jdGlvbiAoZW5hYmxlZCwgZmllbGQsIHZhbGlkYXRvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdmFsaWRhdG9yQXJyID0gdGhpcy5maWVsZHNbZmllbGRdLnZhbGlkYXRvcnM7XG4gICAgICAgIGlmICh2YWxpZGF0b3IgJiYgdmFsaWRhdG9yQXJyICYmIHZhbGlkYXRvckFyclt2YWxpZGF0b3JdKSB7XG4gICAgICAgICAgICB0aGlzLmZpZWxkc1tmaWVsZF0udmFsaWRhdG9yc1t2YWxpZGF0b3JdLmVuYWJsZWQgPSBlbmFibGVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF2YWxpZGF0b3IpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHZhbGlkYXRvckFycikuZm9yRWFjaChmdW5jdGlvbiAodikgeyByZXR1cm4gKF90aGlzLmZpZWxkc1tmaWVsZF0udmFsaWRhdG9yc1t2XS5lbmFibGVkID0gZW5hYmxlZCk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUZpZWxkU3RhdHVzKGZpZWxkLCAnTm90VmFsaWRhdGVkJywgdmFsaWRhdG9yKTtcbiAgICB9O1xuICAgIHJldHVybiBDb3JlO1xufSgpKTtcbmZ1bmN0aW9uIGZvcm1WYWxpZGF0aW9uKGZvcm0sIG9wdGlvbnMpIHtcbiAgICB2YXIgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICAgICAgZmllbGRzOiB7fSxcbiAgICAgICAgbG9jYWxlOiAnZW5fVVMnLFxuICAgICAgICBwbHVnaW5zOiB7fSxcbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKF8pIHsgfSxcbiAgICB9LCBvcHRpb25zKTtcbiAgICB2YXIgY29yZSA9IG5ldyBDb3JlKGZvcm0sIG9wdHMuZmllbGRzKTtcbiAgICBjb3JlLnNldExvY2FsZShvcHRzLmxvY2FsZSwgb3B0cy5sb2NhbGl6YXRpb24pO1xuICAgIC8vIFJlZ2lzdGVyIHBsdWdpbnNcbiAgICBPYmplY3Qua2V5cyhvcHRzLnBsdWdpbnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIGNvcmUucmVnaXN0ZXJQbHVnaW4obmFtZSwgb3B0cy5wbHVnaW5zW25hbWVdKTsgfSk7XG4gICAgLy8gSXQncyB0aGUgc2luZ2xlIHBvaW50IHRoYXQgdXNlcnMgY2FuIGRvIGEgcGFydGljdWxhciB0YXNrIGJlZm9yZSBhZGRpbmcgZmllbGRzXG4gICAgLy8gU29tZSBpbml0aWFsaXphdGlvbiB0YXNrcyBtdXN0IGJlIGRvbmUgYXQgdGhhdCBwb2ludFxuICAgIG9wdHMuaW5pdChjb3JlKTtcbiAgICAvLyBhbmQgYWRkIGZpZWxkc1xuICAgIE9iamVjdC5rZXlzKG9wdHMuZmllbGRzKS5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkgeyByZXR1cm4gY29yZS5hZGRGaWVsZChmaWVsZCwgb3B0cy5maWVsZHNbZmllbGRdKTsgfSk7XG4gICAgcmV0dXJuIGNvcmU7XG59XG5cbi8qKlxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqL1xudmFyIFBsdWdpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQbHVnaW4ob3B0cykge1xuICAgICAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgICAgICB0aGlzLmlzRW5hYmxlZCA9IHRydWU7XG4gICAgfVxuICAgIFBsdWdpbi5wcm90b3R5cGUuc2V0Q29yZSA9IGZ1bmN0aW9uIChjb3JlKSB7XG4gICAgICAgIHRoaXMuY29yZSA9IGNvcmU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgUGx1Z2luLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaXNFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vbkVuYWJsZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBQbHVnaW4ucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaXNFbmFibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMub25EaXNhYmxlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFBsdWdpbi5wcm90b3R5cGUuaXNQbHVnaW5FbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0VuYWJsZWQ7XG4gICAgfTtcbiAgICBQbHVnaW4ucHJvdG90eXBlLm9uRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHsgfTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb25cbiAgICBQbHVnaW4ucHJvdG90eXBlLm9uRGlzYWJsZWQgPSBmdW5jdGlvbiAoKSB7IH07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG4gICAgUGx1Z2luLnByb3RvdHlwZS5pbnN0YWxsID0gZnVuY3Rpb24gKCkgeyB9OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuICAgIFBsdWdpbi5wcm90b3R5cGUudW5pbnN0YWxsID0gZnVuY3Rpb24gKCkgeyB9OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuICAgIHJldHVybiBQbHVnaW47XG59KCkpO1xuXG4vKipcbiAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG4gKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKi9cbi8qKlxuICogRXhlY3V0ZSBhIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbiB8IHN0cmluZ30gZnVuY3Rpb25OYW1lIENhbiBiZVxuICogLSBuYW1lIG9mIGdsb2JhbCBmdW5jdGlvblxuICogLSBuYW1lIG9mIG5hbWVzcGFjZSBmdW5jdGlvbiAoc3VjaCBhcyBBLkIuQylcbiAqIC0gYSBmdW5jdGlvblxuICogQHBhcmFtIHthbnlbXX0gYXJncyBUaGUgY2FsbGJhY2sgYXJndW1lbnRzXG4gKiBAcmV0dXJuIHthbnl9XG4gKi9cbmZ1bmN0aW9uIGNhbGwoZnVuY3Rpb25OYW1lLCBhcmdzKSB7XG4gICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBmdW5jdGlvbk5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uTmFtZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBmdW5jdGlvbk5hbWUpIHtcbiAgICAgICAgLy8gTm9kZSB0aGF0IGl0IGRvZXNuJ3Qgc3VwcG9ydCBub2RlLmpzIGJhc2VkIGVudmlyb25tZW50IGJlY2F1c2Ugd2UgYXJlIHRyeWluZyB0byBhY2Nlc3MgYHdpbmRvd2BcbiAgICAgICAgdmFyIG5hbWVfMSA9IGZ1bmN0aW9uTmFtZTtcbiAgICAgICAgaWYgKCcoKScgPT09IG5hbWVfMS5zdWJzdHJpbmcobmFtZV8xLmxlbmd0aCAtIDIpKSB7XG4gICAgICAgICAgICBuYW1lXzEgPSBuYW1lXzEuc3Vic3RyaW5nKDAsIG5hbWVfMS5sZW5ndGggLSAyKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbnMgPSBuYW1lXzEuc3BsaXQoJy4nKTtcbiAgICAgICAgdmFyIGZ1bmMgPSBucy5wb3AoKTtcbiAgICAgICAgdmFyIGNvbnRleHRfMSA9IHdpbmRvdztcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBuc18xID0gbnM7IF9pIDwgbnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciB0ID0gbnNfMVtfaV07XG4gICAgICAgICAgICBjb250ZXh0XzEgPSBjb250ZXh0XzFbdF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGVvZiBjb250ZXh0XzFbZnVuY10gPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IGNvbnRleHRfMVtmdW5jXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG59XG5cbi8qKlxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqL1xudmFyIGFkZENsYXNzID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNsYXNzZXMpIHtcbiAgICBjbGFzc2VzLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiAoY2xhenopIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG4gICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhenopO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFwiIFwiLmNvbmNhdChlbGVtZW50LmNsYXNzTmFtZSwgXCIgXCIpLmluZGV4T2YoXCIgXCIuY29uY2F0KGNsYXp6LCBcIiBcIikpKSB7XG4gICAgICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSArPSBcIiBcIi5jb25jYXQoY2xhenopO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xudmFyIHJlbW92ZUNsYXNzID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNsYXNzZXMpIHtcbiAgICBjbGFzc2VzLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiAoY2xhenopIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3RcbiAgICAgICAgICAgID8gZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXp6KVxuICAgICAgICAgICAgOiAoZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZS5yZXBsYWNlKGNsYXp6LCAnJykpO1xuICAgIH0pO1xufTtcbnZhciBjbGFzc1NldCA9IGZ1bmN0aW9uIChlbGVtZW50LCBjbGFzc2VzKSB7XG4gICAgdmFyIGFkZGluZyA9IFtdO1xuICAgIHZhciByZW1vdmluZyA9IFtdO1xuICAgIE9iamVjdC5rZXlzKGNsYXNzZXMpLmZvckVhY2goZnVuY3Rpb24gKGNsYXp6KSB7XG4gICAgICAgIGlmIChjbGF6eikge1xuICAgICAgICAgICAgY2xhc3Nlc1tjbGF6el0gPyBhZGRpbmcucHVzaChjbGF6eikgOiByZW1vdmluZy5wdXNoKGNsYXp6KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIEFsd2F5cyByZW1vdmUgYmVmb3JlIGFkZGluZyBjbGFzcyBiZWNhdXNlIHRoZXJlIG1pZ2h0IGJlIGEgY2xhc3Mgd2hpY2ggYmVsb25nIHRvIGJvdGggc2V0cy5cbiAgICAvLyBGb3IgZXhhbXBsZSwgdGhlIGVsZW1lbnQgd2lsbCBoYXZlIGNsYXNzIGBhYCBhZnRlciBjYWxsaW5nXG4gICAgLy8gIGBgYFxuICAgIC8vICBjbGFzc1NldChlbGVtZW50LCB7XG4gICAgLy8gICAgICAnYSBhMSBhMic6IHRydWUsXG4gICAgLy8gICAgICAnYSBiMSBiMic6IGZhbHNlXG4gICAgLy8gIH0pXG4gICAgLy8gIGBgYFxuICAgIHJlbW92aW5nLmZvckVhY2goZnVuY3Rpb24gKGNsYXp6KSB7IHJldHVybiByZW1vdmVDbGFzcyhlbGVtZW50LCBjbGF6eik7IH0pO1xuICAgIGFkZGluZy5mb3JFYWNoKGZ1bmN0aW9uIChjbGF6eikgeyByZXR1cm4gYWRkQ2xhc3MoZWxlbWVudCwgY2xhenopOyB9KTtcbn07XG5cbi8qKlxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqL1xudmFyIG1hdGNoZXMgPSBmdW5jdGlvbiAoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICB2YXIgbmF0aXZlTWF0Y2hlcyA9IGVsZW1lbnQubWF0Y2hlcyB8fFxuICAgICAgICBlbGVtZW50LndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgICBlbGVtZW50Wydtb3pNYXRjaGVzU2VsZWN0b3InXSB8fFxuICAgICAgICBlbGVtZW50Wydtc01hdGNoZXNTZWxlY3RvciddO1xuICAgIGlmIChuYXRpdmVNYXRjaGVzKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVNYXRjaGVzLmNhbGwoZWxlbWVudCwgc2VsZWN0b3IpO1xuICAgIH1cbiAgICAvLyBJbiBjYXNlIGBtYXRjaGVzc2VsZWN0b3JgIGlzbid0IHN1cHBvcnRlZCAoc3VjaCBhcyBJRTEwKVxuICAgIC8vIFNlZSBodHRwOi8vY2FuaXVzZS5jb20vbWF0Y2hlc3NlbGVjdG9yXG4gICAgdmFyIG5vZGVzID0gW10uc2xpY2UuY2FsbChlbGVtZW50LnBhcmVudEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xuICAgIHJldHVybiBub2Rlcy5pbmRleE9mKGVsZW1lbnQpID49IDA7XG59O1xudmFyIGNsb3Nlc3QgPSBmdW5jdGlvbiAoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICB2YXIgZWxlID0gZWxlbWVudDtcbiAgICB3aGlsZSAoZWxlKSB7XG4gICAgICAgIGlmIChtYXRjaGVzKGVsZSwgc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbGUgPSBlbGUucGFyZW50RWxlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIGVsZTtcbn07XG5cbi8qKlxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqL1xudmFyIGdlbmVyYXRlU3RyaW5nID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgIHJldHVybiBBcnJheShsZW5ndGgpXG4gICAgICAgIC5maWxsKCcnKVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5jaGFyQXQoMik7IH0pXG4gICAgICAgIC5qb2luKCcnKTtcbn07XG52YXIgZmV0Y2ggPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG4gICAgdmFyIHRvUXVlcnkgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChrKSB7IHJldHVybiBcIlwiLmNvbmNhdChlbmNvZGVVUklDb21wb25lbnQoayksIFwiPVwiKS5jb25jYXQoZW5jb2RlVVJJQ29tcG9uZW50KG9ialtrXSkpOyB9KVxuICAgICAgICAgICAgLmpvaW4oJyYnKTtcbiAgICB9O1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwge1xuICAgICAgICAgICAgY3Jvc3NEb21haW46IGZhbHNlLFxuICAgICAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgcGFyYW1zOiB7fSxcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgIC8vIEJ1aWxkIHRoZSBwYXJhbXMgZm9yIEdFVCByZXF1ZXN0XG4gICAgICAgIHZhciBwYXJhbXMgPSBPYmplY3Qua2V5cyhvcHRzLnBhcmFtcylcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGspIHsgcmV0dXJuIFwiXCIuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudChrKSwgXCI9XCIpLmNvbmNhdChlbmNvZGVVUklDb21wb25lbnQob3B0cy5wYXJhbXNba10pKTsgfSlcbiAgICAgICAgICAgIC5qb2luKCcmJyk7XG4gICAgICAgIHZhciBoYXNRdWVyeSA9IHVybC5pbmRleE9mKCc/JykgPiAtMTtcbiAgICAgICAgdmFyIHJlcXVlc3RVcmwgPSAnR0VUJyA9PT0gb3B0cy5tZXRob2QgPyBcIlwiLmNvbmNhdCh1cmwpLmNvbmNhdChoYXNRdWVyeSA/ICcmJyA6ICc/JykuY29uY2F0KHBhcmFtcykgOiB1cmw7XG4gICAgICAgIGlmIChvcHRzLmNyb3NzRG9tYWluKSB7XG4gICAgICAgICAgICAvLyBVc2VyIGlzIG1ha2luZyBjcm9zcyBkb21haW4gcmVxdWVzdFxuICAgICAgICAgICAgdmFyIHNjcmlwdF8xID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgICAgICAvLyBJbiBzb21lIHZlcnkgZmFzdCBzeXN0ZW1zLCB0aGUgZGlmZmVyZW50IGBEYXRlLm5vdygpYCBpbnZvY2F0aW9ucyBjYW4gcmV0dXJuIHRoZSBzYW1lIHZhbHVlXG4gICAgICAgICAgICAvLyB3aGljaCBsZWFkcyB0byB0aGUgaXNzdWUgd2hlcmUgdGhlcmUgYXJlIG11bHRpcGxlIHJlbW92ZSB2YWxpZGF0b3JzIGFyZSB1c2VkLCBmb3IgZXhhbXBsZS5cbiAgICAgICAgICAgIC8vIEFwcGVuZGluZyBpdCB3aXRoIGEgZ2VuZXJhdGVkIHJhbmRvbSBzdHJpbmcgY2FuIGZpeCB0aGUgdmFsdWVcbiAgICAgICAgICAgIHZhciBjYWxsYmFja18xID0gXCJfX19Gb3JtVmFsaWRhdGlvbkZldGNoX1wiLmNvbmNhdChnZW5lcmF0ZVN0cmluZygxMiksIFwiX19fXCIpO1xuICAgICAgICAgICAgd2luZG93W2NhbGxiYWNrXzFdID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgd2luZG93W2NhbGxiYWNrXzFdO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc2NyaXB0XzEuc3JjID0gXCJcIi5jb25jYXQocmVxdWVzdFVybCkuY29uY2F0KGhhc1F1ZXJ5ID8gJyYnIDogJz8nLCBcImNhbGxiYWNrPVwiKS5jb25jYXQoY2FsbGJhY2tfMSk7XG4gICAgICAgICAgICBzY3JpcHRfMS5hc3luYyA9IHRydWU7XG4gICAgICAgICAgICBzY3JpcHRfMS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNjcmlwdF8xLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0XzEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzY3JpcHRfMS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlamVjdDsgfSk7XG4gICAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdF8xKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXF1ZXN0XzEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIHJlcXVlc3RfMS5vcGVuKG9wdHMubWV0aG9kLCByZXF1ZXN0VXJsKTtcbiAgICAgICAgICAgIC8vIFNldCB0aGUgaGVhZGVyc1xuICAgICAgICAgICAgcmVxdWVzdF8xLnNldFJlcXVlc3RIZWFkZXIoJ1gtUmVxdWVzdGVkLVdpdGgnLCAnWE1MSHR0cFJlcXVlc3QnKTtcbiAgICAgICAgICAgIGlmICgnUE9TVCcgPT09IG9wdHMubWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdF8xLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG9wdHMuaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbiAoaykgeyByZXR1cm4gcmVxdWVzdF8xLnNldFJlcXVlc3RIZWFkZXIoaywgb3B0cy5oZWFkZXJzW2tdKTsgfSk7XG4gICAgICAgICAgICByZXF1ZXN0XzEuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBDYW5ub3QgdXNlIGFycm93IGZ1bmN0aW9uIGhlcmUgZHVlIHRvIHRoZSBgdGhpc2Agc2NvcGVcbiAgICAgICAgICAgICAgICByZXNvbHZlKEpTT04ucGFyc2UodGhpcy5yZXNwb25zZVRleHQpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVxdWVzdF8xLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVqZWN0OyB9KTtcbiAgICAgICAgICAgIC8vIEdFVCByZXF1ZXN0IHdpbGwgaWdub3JlIHRoZSBwYXNzZWQgZGF0YSBoZXJlXG4gICAgICAgICAgICByZXF1ZXN0XzEuc2VuZCh0b1F1ZXJ5KG9wdHMucGFyYW1zKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbi8qKlxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqL1xuLyoqXG4gKiBGb3JtYXQgYSBzdHJpbmdcbiAqIEl0J3MgdXNlZCB0byBmb3JtYXQgdGhlIGVycm9yIG1lc3NhZ2VcbiAqIGZvcm1hdCgnVGhlIGZpZWxkIG11c3QgYmV0d2VlbiAlcyBhbmQgJXMnLCBbMTAsIDIwXSkgPSAnVGhlIGZpZWxkIG11c3QgYmV0d2VlbiAxMCBhbmQgMjAnXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBwYXJhbWV0ZXJzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG52YXIgZm9ybWF0ID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHBhcmFtZXRlcnMpIHtcbiAgICB2YXIgcGFyYW1zID0gQXJyYXkuaXNBcnJheShwYXJhbWV0ZXJzKSA/IHBhcmFtZXRlcnMgOiBbcGFyYW1ldGVyc107XG4gICAgdmFyIG91dHB1dCA9IG1lc3NhZ2U7XG4gICAgcGFyYW1zLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2UoJyVzJywgcCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKlxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqL1xudmFyIGhhc0NsYXNzID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNsYXp6KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NMaXN0XG4gICAgICAgID8gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoY2xhenopXG4gICAgICAgIDogbmV3IFJlZ0V4cChcIihefCApXCIuY29uY2F0KGNsYXp6LCBcIiggfCQpXCIpLCAnZ2knKS50ZXN0KGVsZW1lbnQuY2xhc3NOYW1lKTtcbn07XG5cbi8qKlxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqL1xuLyoqXG4gKiBWYWxpZGF0ZSBhIGRhdGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30geWVhciBUaGUgZnVsbCB5ZWFyIGluIDQgZGlnaXRzXG4gKiBAcGFyYW0ge3N0cmluZ30gbW9udGggVGhlIG1vbnRoIG51bWJlclxuICogQHBhcmFtIHtzdHJpbmd9IGRheSBUaGUgZGF5IG51bWJlclxuICogQHBhcmFtIHtib29sZWFufSBbbm90SW5GdXR1cmVdIElmIHRydWUsIHRoZSBkYXRlIG11c3Qgbm90IGJlIGluIHRoZSBmdXR1cmVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG52YXIgaXNWYWxpZERhdGUgPSBmdW5jdGlvbiAoeWVhciwgbW9udGgsIGRheSwgbm90SW5GdXR1cmUpIHtcbiAgICBpZiAoaXNOYU4oeWVhcikgfHwgaXNOYU4obW9udGgpIHx8IGlzTmFOKGRheSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoeWVhciA8IDEwMDAgfHwgeWVhciA+IDk5OTkgfHwgbW9udGggPD0gMCB8fCBtb250aCA+IDEyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIG51bURheXMgPSBbXG4gICAgICAgIDMxLFxuICAgICAgICAvLyBVcGRhdGUgdGhlIG51bWJlciBvZiBkYXlzIGluIEZlYiBvZiBsZWFwIHllYXJcbiAgICAgICAgeWVhciAlIDQwMCA9PT0gMCB8fCAoeWVhciAlIDEwMCAhPT0gMCAmJiB5ZWFyICUgNCA9PT0gMCkgPyAyOSA6IDI4LFxuICAgICAgICAzMSxcbiAgICAgICAgMzAsXG4gICAgICAgIDMxLFxuICAgICAgICAzMCxcbiAgICAgICAgMzEsXG4gICAgICAgIDMxLFxuICAgICAgICAzMCxcbiAgICAgICAgMzEsXG4gICAgICAgIDMwLFxuICAgICAgICAzMSxcbiAgICBdO1xuICAgIC8vIENoZWNrIHRoZSBkYXlcbiAgICBpZiAoZGF5IDw9IDAgfHwgZGF5ID4gbnVtRGF5c1ttb250aCAtIDFdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG5vdEluRnV0dXJlID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBjdXJyZW50RGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIHZhciBjdXJyZW50WWVhciA9IGN1cnJlbnREYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgIHZhciBjdXJyZW50TW9udGggPSBjdXJyZW50RGF0ZS5nZXRNb250aCgpO1xuICAgICAgICB2YXIgY3VycmVudERheSA9IGN1cnJlbnREYXRlLmdldERhdGUoKTtcbiAgICAgICAgcmV0dXJuICh5ZWFyIDwgY3VycmVudFllYXIgfHxcbiAgICAgICAgICAgICh5ZWFyID09PSBjdXJyZW50WWVhciAmJiBtb250aCAtIDEgPCBjdXJyZW50TW9udGgpIHx8XG4gICAgICAgICAgICAoeWVhciA9PT0gY3VycmVudFllYXIgJiYgbW9udGggLSAxID09PSBjdXJyZW50TW9udGggJiYgZGF5IDwgY3VycmVudERheSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqL1xudmFyIHJlbW92ZVVuZGVmaW5lZCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gb2JqXG4gICAgICAgID8gT2JqZWN0LmVudHJpZXMob2JqKS5yZWR1Y2UoZnVuY3Rpb24gKGEsIF9hKSB7XG4gICAgICAgICAgICB2YXIgayA9IF9hWzBdLCB2ID0gX2FbMV07XG4gICAgICAgICAgICByZXR1cm4gKHYgPT09IHVuZGVmaW5lZCA/IGEgOiAoKGFba10gPSB2KSwgYSkpO1xuICAgICAgICB9LCB7fSlcbiAgICAgICAgOiB7fTtcbn07XG5cbi8qKlxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqL1xudmFyIGluZGV4ID0ge1xuICAgIGNhbGw6IGNhbGwsXG4gICAgY2xhc3NTZXQ6IGNsYXNzU2V0LFxuICAgIGNsb3Nlc3Q6IGNsb3Nlc3QsXG4gICAgZmV0Y2g6IGZldGNoLFxuICAgIGZvcm1hdDogZm9ybWF0LFxuICAgIGhhc0NsYXNzOiBoYXNDbGFzcyxcbiAgICBpc1ZhbGlkRGF0ZTogaXNWYWxpZERhdGUsXG4gICAgcmVtb3ZlVW5kZWZpbmVkOiByZW1vdmVVbmRlZmluZWQsXG59O1xuXG5leHBvcnRzLlBsdWdpbiA9IFBsdWdpbjtcbmV4cG9ydHMuYWxnb3JpdGhtcyA9IGluZGV4JDE7XG5leHBvcnRzLmZvcm1WYWxpZGF0aW9uID0gZm9ybVZhbGlkYXRpb247XG5leHBvcnRzLnV0aWxzID0gaW5kZXg7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@form-validation/core/lib/cjs/index.js\n");

/***/ }),

/***/ "./node_modules/@form-validation/core/lib/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@form-validation/core/lib/index.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\n\n\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/index.js */ \"./node_modules/@form-validation/core/lib/cjs/index.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcm0tdmFsaWRhdGlvbi9jb3JlL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsSUFBSSxtSEFBMEM7QUFDOUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9WdWV4eS8uL25vZGVfbW9kdWxlcy9AZm9ybS12YWxpZGF0aW9uL2NvcmUvbGliL2luZGV4LmpzPzMyOTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcbiAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL2luZGV4Lm1pbi5qcycpO1xufSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL2luZGV4LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@form-validation/core/lib/index.js\n");

/***/ }),

/***/ "./node_modules/@form-validation/plugin-auto-focus/lib/cjs/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@form-validation/plugin-auto-focus/lib/cjs/index.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n\nvar core = __webpack_require__(/*! @form-validation/core */ \"./node_modules/@form-validation/core/lib/index.js\");\nvar pluginFieldStatus = __webpack_require__(/*! @form-validation/plugin-field-status */ \"./node_modules/@form-validation/plugin-field-status/lib/index.js\");\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\nvar AutoFocus = /** @class */ (function (_super) {\n    __extends(AutoFocus, _super);\n    function AutoFocus(opts) {\n        var _this = _super.call(this, opts) || this;\n        _this.opts = Object.assign({}, {\n            onPrefocus: function () { },\n        }, opts);\n        _this.invalidFormHandler = _this.onFormInvalid.bind(_this);\n        return _this;\n    }\n    AutoFocus.prototype.install = function () {\n        this.core\n            .on('core.form.invalid', this.invalidFormHandler)\n            .registerPlugin(AutoFocus.FIELD_STATUS_PLUGIN, new pluginFieldStatus.FieldStatus());\n    };\n    AutoFocus.prototype.uninstall = function () {\n        this.core.off('core.form.invalid', this.invalidFormHandler).deregisterPlugin(AutoFocus.FIELD_STATUS_PLUGIN);\n    };\n    AutoFocus.prototype.onEnabled = function () {\n        this.core.enablePlugin(AutoFocus.FIELD_STATUS_PLUGIN);\n    };\n    AutoFocus.prototype.onDisabled = function () {\n        this.core.disablePlugin(AutoFocus.FIELD_STATUS_PLUGIN);\n    };\n    AutoFocus.prototype.onFormInvalid = function () {\n        if (!this.isEnabled) {\n            return;\n        }\n        var plugin = this.core.getPlugin(AutoFocus.FIELD_STATUS_PLUGIN);\n        var statuses = plugin.getStatuses();\n        var invalidFields = Object.keys(this.core.getFields()).filter(function (key) { return statuses.get(key) === 'Invalid'; });\n        if (invalidFields.length > 0) {\n            var firstInvalidField = invalidFields[0];\n            var elements = this.core.getElements(firstInvalidField);\n            if (elements.length > 0) {\n                var firstElement = elements[0];\n                var e = {\n                    firstElement: firstElement,\n                    field: firstInvalidField,\n                };\n                this.core.emit('plugins.autofocus.prefocus', e);\n                this.opts.onPrefocus(e);\n                // Focus on the first invalid element\n                firstElement.focus();\n            }\n        }\n    };\n    AutoFocus.FIELD_STATUS_PLUGIN = '___autoFocusFieldStatus';\n    return AutoFocus;\n}(core.Plugin));\n\nexports.AutoFocus = AutoFocus;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcm0tdmFsaWRhdGlvbi9wbHVnaW4tYXV0by1mb2N1cy9saWIvY2pzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFdBQVcsbUJBQU8sQ0FBQyxnRkFBdUI7QUFDMUMsd0JBQXdCLG1CQUFPLENBQUMsOEdBQXNDOztBQUV0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ25GLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyx1Q0FBdUM7QUFDdkMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYseUNBQXlDO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vVnVleHkvLi9ub2RlX21vZHVsZXMvQGZvcm0tdmFsaWRhdGlvbi9wbHVnaW4tYXV0by1mb2N1cy9saWIvY2pzL2luZGV4LmpzP2RkNzEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJ0Bmb3JtLXZhbGlkYXRpb24vY29yZScpO1xudmFyIHBsdWdpbkZpZWxkU3RhdHVzID0gcmVxdWlyZSgnQGZvcm0tdmFsaWRhdGlvbi9wbHVnaW4tZmllbGQtc3RhdHVzJyk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxuXG4vKipcbiAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG4gKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKi9cbnZhciBBdXRvRm9jdXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEF1dG9Gb2N1cywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBdXRvRm9jdXMob3B0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5vcHRzID0gT2JqZWN0LmFzc2lnbih7fSwge1xuICAgICAgICAgICAgb25QcmVmb2N1czogZnVuY3Rpb24gKCkgeyB9LFxuICAgICAgICB9LCBvcHRzKTtcbiAgICAgICAgX3RoaXMuaW52YWxpZEZvcm1IYW5kbGVyID0gX3RoaXMub25Gb3JtSW52YWxpZC5iaW5kKF90aGlzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBdXRvRm9jdXMucHJvdG90eXBlLmluc3RhbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29yZVxuICAgICAgICAgICAgLm9uKCdjb3JlLmZvcm0uaW52YWxpZCcsIHRoaXMuaW52YWxpZEZvcm1IYW5kbGVyKVxuICAgICAgICAgICAgLnJlZ2lzdGVyUGx1Z2luKEF1dG9Gb2N1cy5GSUVMRF9TVEFUVVNfUExVR0lOLCBuZXcgcGx1Z2luRmllbGRTdGF0dXMuRmllbGRTdGF0dXMoKSk7XG4gICAgfTtcbiAgICBBdXRvRm9jdXMucHJvdG90eXBlLnVuaW5zdGFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb3JlLm9mZignY29yZS5mb3JtLmludmFsaWQnLCB0aGlzLmludmFsaWRGb3JtSGFuZGxlcikuZGVyZWdpc3RlclBsdWdpbihBdXRvRm9jdXMuRklFTERfU1RBVFVTX1BMVUdJTik7XG4gICAgfTtcbiAgICBBdXRvRm9jdXMucHJvdG90eXBlLm9uRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb3JlLmVuYWJsZVBsdWdpbihBdXRvRm9jdXMuRklFTERfU1RBVFVTX1BMVUdJTik7XG4gICAgfTtcbiAgICBBdXRvRm9jdXMucHJvdG90eXBlLm9uRGlzYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29yZS5kaXNhYmxlUGx1Z2luKEF1dG9Gb2N1cy5GSUVMRF9TVEFUVVNfUExVR0lOKTtcbiAgICB9O1xuICAgIEF1dG9Gb2N1cy5wcm90b3R5cGUub25Gb3JtSW52YWxpZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwbHVnaW4gPSB0aGlzLmNvcmUuZ2V0UGx1Z2luKEF1dG9Gb2N1cy5GSUVMRF9TVEFUVVNfUExVR0lOKTtcbiAgICAgICAgdmFyIHN0YXR1c2VzID0gcGx1Z2luLmdldFN0YXR1c2VzKCk7XG4gICAgICAgIHZhciBpbnZhbGlkRmllbGRzID0gT2JqZWN0LmtleXModGhpcy5jb3JlLmdldEZpZWxkcygpKS5maWx0ZXIoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gc3RhdHVzZXMuZ2V0KGtleSkgPT09ICdJbnZhbGlkJzsgfSk7XG4gICAgICAgIGlmIChpbnZhbGlkRmllbGRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBmaXJzdEludmFsaWRGaWVsZCA9IGludmFsaWRGaWVsZHNbMF07XG4gICAgICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmNvcmUuZ2V0RWxlbWVudHMoZmlyc3RJbnZhbGlkRmllbGQpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3RFbGVtZW50ID0gZWxlbWVudHNbMF07XG4gICAgICAgICAgICAgICAgdmFyIGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0RWxlbWVudDogZmlyc3RFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICBmaWVsZDogZmlyc3RJbnZhbGlkRmllbGQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvcmUuZW1pdCgncGx1Z2lucy5hdXRvZm9jdXMucHJlZm9jdXMnLCBlKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdHMub25QcmVmb2N1cyhlKTtcbiAgICAgICAgICAgICAgICAvLyBGb2N1cyBvbiB0aGUgZmlyc3QgaW52YWxpZCBlbGVtZW50XG4gICAgICAgICAgICAgICAgZmlyc3RFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEF1dG9Gb2N1cy5GSUVMRF9TVEFUVVNfUExVR0lOID0gJ19fX2F1dG9Gb2N1c0ZpZWxkU3RhdHVzJztcbiAgICByZXR1cm4gQXV0b0ZvY3VzO1xufShjb3JlLlBsdWdpbikpO1xuXG5leHBvcnRzLkF1dG9Gb2N1cyA9IEF1dG9Gb2N1cztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@form-validation/plugin-auto-focus/lib/cjs/index.js\n");

/***/ }),

/***/ "./node_modules/@form-validation/plugin-auto-focus/lib/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@form-validation/plugin-auto-focus/lib/index.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\n\n\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/index.js */ \"./node_modules/@form-validation/plugin-auto-focus/lib/cjs/index.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcm0tdmFsaWRhdGlvbi9wbHVnaW4tYXV0by1mb2N1cy9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLElBQUksZ0lBQTBDO0FBQzlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vVnVleHkvLi9ub2RlX21vZHVsZXMvQGZvcm0tdmFsaWRhdGlvbi9wbHVnaW4tYXV0by1mb2N1cy9saWIvaW5kZXguanM/ZGIzNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG4gKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvaW5kZXgubWluLmpzJyk7XG59IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvaW5kZXguanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@form-validation/plugin-auto-focus/lib/index.js\n");

/***/ }),

/***/ "./node_modules/@form-validation/plugin-field-status/lib/cjs/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@form-validation/plugin-field-status/lib/cjs/index.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n\nvar core = __webpack_require__(/*! @form-validation/core */ \"./node_modules/@form-validation/core/lib/index.js\");\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\nvar FieldStatus = /** @class */ (function (_super) {\n    __extends(FieldStatus, _super);\n    function FieldStatus(opts) {\n        var _this = _super.call(this, opts) || this;\n        _this.statuses = new Map();\n        _this.opts = Object.assign({}, {\n            onStatusChanged: function () { },\n        }, opts);\n        _this.elementValidatingHandler = _this.onElementValidating.bind(_this);\n        _this.elementValidatedHandler = _this.onElementValidated.bind(_this);\n        _this.elementNotValidatedHandler = _this.onElementNotValidated.bind(_this);\n        _this.elementIgnoredHandler = _this.onElementIgnored.bind(_this);\n        _this.fieldAddedHandler = _this.onFieldAdded.bind(_this);\n        _this.fieldRemovedHandler = _this.onFieldRemoved.bind(_this);\n        return _this;\n    }\n    FieldStatus.prototype.install = function () {\n        this.core\n            .on('core.element.validating', this.elementValidatingHandler)\n            .on('core.element.validated', this.elementValidatedHandler)\n            .on('core.element.notvalidated', this.elementNotValidatedHandler)\n            .on('core.element.ignored', this.elementIgnoredHandler)\n            .on('core.field.added', this.fieldAddedHandler)\n            .on('core.field.removed', this.fieldRemovedHandler);\n    };\n    FieldStatus.prototype.uninstall = function () {\n        this.statuses.clear();\n        this.core\n            .off('core.element.validating', this.elementValidatingHandler)\n            .off('core.element.validated', this.elementValidatedHandler)\n            .off('core.element.notvalidated', this.elementNotValidatedHandler)\n            .off('core.element.ignored', this.elementIgnoredHandler)\n            .off('core.field.added', this.fieldAddedHandler)\n            .off('core.field.removed', this.fieldRemovedHandler);\n    };\n    FieldStatus.prototype.areFieldsValid = function () {\n        return Array.from(this.statuses.values()).every(function (value) {\n            return value === 'Valid' || value === 'NotValidated' || value === 'Ignored';\n        });\n    };\n    FieldStatus.prototype.getStatuses = function () {\n        return this.isEnabled ? this.statuses : new Map();\n    };\n    FieldStatus.prototype.onFieldAdded = function (e) {\n        this.statuses.set(e.field, 'NotValidated');\n    };\n    FieldStatus.prototype.onFieldRemoved = function (e) {\n        if (this.statuses.has(e.field)) {\n            this.statuses.delete(e.field);\n        }\n        this.handleStatusChanged(this.areFieldsValid());\n    };\n    FieldStatus.prototype.onElementValidating = function (e) {\n        this.statuses.set(e.field, 'Validating');\n        this.handleStatusChanged(false);\n    };\n    FieldStatus.prototype.onElementValidated = function (e) {\n        this.statuses.set(e.field, e.valid ? 'Valid' : 'Invalid');\n        if (e.valid) {\n            this.handleStatusChanged(this.areFieldsValid());\n        }\n        else {\n            this.handleStatusChanged(false);\n        }\n    };\n    FieldStatus.prototype.onElementNotValidated = function (e) {\n        this.statuses.set(e.field, 'NotValidated');\n        this.handleStatusChanged(false);\n    };\n    FieldStatus.prototype.onElementIgnored = function (e) {\n        this.statuses.set(e.field, 'Ignored');\n        this.handleStatusChanged(this.areFieldsValid());\n    };\n    FieldStatus.prototype.handleStatusChanged = function (areFieldsValid) {\n        if (this.isEnabled) {\n            this.opts.onStatusChanged(areFieldsValid);\n        }\n    };\n    return FieldStatus;\n}(core.Plugin));\n\nexports.FieldStatus = FieldStatus;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcm0tdmFsaWRhdGlvbi9wbHVnaW4tZmllbGQtc3RhdHVzL2xpYi9janMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsV0FBVyxtQkFBTyxDQUFDLGdGQUF1Qjs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUNuRiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyw0Q0FBNEM7QUFDNUMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsbUJBQW1CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vVnVleHkvLi9ub2RlX21vZHVsZXMvQGZvcm0tdmFsaWRhdGlvbi9wbHVnaW4tZmllbGQtc3RhdHVzL2xpYi9janMvaW5kZXguanM/ZDFkMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBjb3JlID0gcmVxdWlyZSgnQGZvcm0tdmFsaWRhdGlvbi9jb3JlJyk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxuXG4vKipcbiAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG4gKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKi9cbnZhciBGaWVsZFN0YXR1cyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRmllbGRTdGF0dXMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRmllbGRTdGF0dXMob3B0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdGF0dXNlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgX3RoaXMub3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICAgICAgICAgIG9uU3RhdHVzQ2hhbmdlZDogZnVuY3Rpb24gKCkgeyB9LFxuICAgICAgICB9LCBvcHRzKTtcbiAgICAgICAgX3RoaXMuZWxlbWVudFZhbGlkYXRpbmdIYW5kbGVyID0gX3RoaXMub25FbGVtZW50VmFsaWRhdGluZy5iaW5kKF90aGlzKTtcbiAgICAgICAgX3RoaXMuZWxlbWVudFZhbGlkYXRlZEhhbmRsZXIgPSBfdGhpcy5vbkVsZW1lbnRWYWxpZGF0ZWQuYmluZChfdGhpcyk7XG4gICAgICAgIF90aGlzLmVsZW1lbnROb3RWYWxpZGF0ZWRIYW5kbGVyID0gX3RoaXMub25FbGVtZW50Tm90VmFsaWRhdGVkLmJpbmQoX3RoaXMpO1xuICAgICAgICBfdGhpcy5lbGVtZW50SWdub3JlZEhhbmRsZXIgPSBfdGhpcy5vbkVsZW1lbnRJZ25vcmVkLmJpbmQoX3RoaXMpO1xuICAgICAgICBfdGhpcy5maWVsZEFkZGVkSGFuZGxlciA9IF90aGlzLm9uRmllbGRBZGRlZC5iaW5kKF90aGlzKTtcbiAgICAgICAgX3RoaXMuZmllbGRSZW1vdmVkSGFuZGxlciA9IF90aGlzLm9uRmllbGRSZW1vdmVkLmJpbmQoX3RoaXMpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEZpZWxkU3RhdHVzLnByb3RvdHlwZS5pbnN0YWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvcmVcbiAgICAgICAgICAgIC5vbignY29yZS5lbGVtZW50LnZhbGlkYXRpbmcnLCB0aGlzLmVsZW1lbnRWYWxpZGF0aW5nSGFuZGxlcilcbiAgICAgICAgICAgIC5vbignY29yZS5lbGVtZW50LnZhbGlkYXRlZCcsIHRoaXMuZWxlbWVudFZhbGlkYXRlZEhhbmRsZXIpXG4gICAgICAgICAgICAub24oJ2NvcmUuZWxlbWVudC5ub3R2YWxpZGF0ZWQnLCB0aGlzLmVsZW1lbnROb3RWYWxpZGF0ZWRIYW5kbGVyKVxuICAgICAgICAgICAgLm9uKCdjb3JlLmVsZW1lbnQuaWdub3JlZCcsIHRoaXMuZWxlbWVudElnbm9yZWRIYW5kbGVyKVxuICAgICAgICAgICAgLm9uKCdjb3JlLmZpZWxkLmFkZGVkJywgdGhpcy5maWVsZEFkZGVkSGFuZGxlcilcbiAgICAgICAgICAgIC5vbignY29yZS5maWVsZC5yZW1vdmVkJywgdGhpcy5maWVsZFJlbW92ZWRIYW5kbGVyKTtcbiAgICB9O1xuICAgIEZpZWxkU3RhdHVzLnByb3RvdHlwZS51bmluc3RhbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3RhdHVzZXMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5jb3JlXG4gICAgICAgICAgICAub2ZmKCdjb3JlLmVsZW1lbnQudmFsaWRhdGluZycsIHRoaXMuZWxlbWVudFZhbGlkYXRpbmdIYW5kbGVyKVxuICAgICAgICAgICAgLm9mZignY29yZS5lbGVtZW50LnZhbGlkYXRlZCcsIHRoaXMuZWxlbWVudFZhbGlkYXRlZEhhbmRsZXIpXG4gICAgICAgICAgICAub2ZmKCdjb3JlLmVsZW1lbnQubm90dmFsaWRhdGVkJywgdGhpcy5lbGVtZW50Tm90VmFsaWRhdGVkSGFuZGxlcilcbiAgICAgICAgICAgIC5vZmYoJ2NvcmUuZWxlbWVudC5pZ25vcmVkJywgdGhpcy5lbGVtZW50SWdub3JlZEhhbmRsZXIpXG4gICAgICAgICAgICAub2ZmKCdjb3JlLmZpZWxkLmFkZGVkJywgdGhpcy5maWVsZEFkZGVkSGFuZGxlcilcbiAgICAgICAgICAgIC5vZmYoJ2NvcmUuZmllbGQucmVtb3ZlZCcsIHRoaXMuZmllbGRSZW1vdmVkSGFuZGxlcik7XG4gICAgfTtcbiAgICBGaWVsZFN0YXR1cy5wcm90b3R5cGUuYXJlRmllbGRzVmFsaWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuc3RhdHVzZXMudmFsdWVzKCkpLmV2ZXJ5KGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09PSAnVmFsaWQnIHx8IHZhbHVlID09PSAnTm90VmFsaWRhdGVkJyB8fCB2YWx1ZSA9PT0gJ0lnbm9yZWQnO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEZpZWxkU3RhdHVzLnByb3RvdHlwZS5nZXRTdGF0dXNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNFbmFibGVkID8gdGhpcy5zdGF0dXNlcyA6IG5ldyBNYXAoKTtcbiAgICB9O1xuICAgIEZpZWxkU3RhdHVzLnByb3RvdHlwZS5vbkZpZWxkQWRkZWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLnN0YXR1c2VzLnNldChlLmZpZWxkLCAnTm90VmFsaWRhdGVkJyk7XG4gICAgfTtcbiAgICBGaWVsZFN0YXR1cy5wcm90b3R5cGUub25GaWVsZFJlbW92ZWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXNlcy5oYXMoZS5maWVsZCkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzZXMuZGVsZXRlKGUuZmllbGQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGFuZGxlU3RhdHVzQ2hhbmdlZCh0aGlzLmFyZUZpZWxkc1ZhbGlkKCkpO1xuICAgIH07XG4gICAgRmllbGRTdGF0dXMucHJvdG90eXBlLm9uRWxlbWVudFZhbGlkYXRpbmcgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLnN0YXR1c2VzLnNldChlLmZpZWxkLCAnVmFsaWRhdGluZycpO1xuICAgICAgICB0aGlzLmhhbmRsZVN0YXR1c0NoYW5nZWQoZmFsc2UpO1xuICAgIH07XG4gICAgRmllbGRTdGF0dXMucHJvdG90eXBlLm9uRWxlbWVudFZhbGlkYXRlZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMuc3RhdHVzZXMuc2V0KGUuZmllbGQsIGUudmFsaWQgPyAnVmFsaWQnIDogJ0ludmFsaWQnKTtcbiAgICAgICAgaWYgKGUudmFsaWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU3RhdHVzQ2hhbmdlZCh0aGlzLmFyZUZpZWxkc1ZhbGlkKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVTdGF0dXNDaGFuZ2VkKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRmllbGRTdGF0dXMucHJvdG90eXBlLm9uRWxlbWVudE5vdFZhbGlkYXRlZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMuc3RhdHVzZXMuc2V0KGUuZmllbGQsICdOb3RWYWxpZGF0ZWQnKTtcbiAgICAgICAgdGhpcy5oYW5kbGVTdGF0dXNDaGFuZ2VkKGZhbHNlKTtcbiAgICB9O1xuICAgIEZpZWxkU3RhdHVzLnByb3RvdHlwZS5vbkVsZW1lbnRJZ25vcmVkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5zdGF0dXNlcy5zZXQoZS5maWVsZCwgJ0lnbm9yZWQnKTtcbiAgICAgICAgdGhpcy5oYW5kbGVTdGF0dXNDaGFuZ2VkKHRoaXMuYXJlRmllbGRzVmFsaWQoKSk7XG4gICAgfTtcbiAgICBGaWVsZFN0YXR1cy5wcm90b3R5cGUuaGFuZGxlU3RhdHVzQ2hhbmdlZCA9IGZ1bmN0aW9uIChhcmVGaWVsZHNWYWxpZCkge1xuICAgICAgICBpZiAodGhpcy5pc0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMub3B0cy5vblN0YXR1c0NoYW5nZWQoYXJlRmllbGRzVmFsaWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRmllbGRTdGF0dXM7XG59KGNvcmUuUGx1Z2luKSk7XG5cbmV4cG9ydHMuRmllbGRTdGF0dXMgPSBGaWVsZFN0YXR1cztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@form-validation/plugin-field-status/lib/cjs/index.js\n");

/***/ }),

/***/ "./node_modules/@form-validation/plugin-field-status/lib/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/@form-validation/plugin-field-status/lib/index.js ***!
  \************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\n\n\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/index.js */ \"./node_modules/@form-validation/plugin-field-status/lib/cjs/index.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcm0tdmFsaWRhdGlvbi9wbHVnaW4tZmllbGQtc3RhdHVzL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsSUFBSSxrSUFBMEM7QUFDOUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9WdWV4eS8uL25vZGVfbW9kdWxlcy9AZm9ybS12YWxpZGF0aW9uL3BsdWdpbi1maWVsZC1zdGF0dXMvbGliL2luZGV4LmpzPzMzYWMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcbiAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL2luZGV4Lm1pbi5qcycpO1xufSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL2luZGV4LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@form-validation/plugin-field-status/lib/index.js\n");

/***/ }),

/***/ "./libs/@form-validation/auto-focus.js":
/*!*********************************************!*\
  !*** ./libs/@form-validation/auto-focus.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AutoFocus: function() { return /* reexport safe */ _form_validation_plugin_auto_focus__WEBPACK_IMPORTED_MODULE_0__.AutoFocus; }\n/* harmony export */ });\n/* harmony import */ var _form_validation_plugin_auto_focus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @form-validation/plugin-auto-focus */ \"./node_modules/@form-validation/plugin-auto-focus/lib/index.js\");\n\ntry {\n  FormValidation.plugins.AutoFocus = _form_validation_plugin_auto_focus__WEBPACK_IMPORTED_MODULE_0__.AutoFocus;\n} catch (e) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWJzL0Bmb3JtLXZhbGlkYXRpb24vYXV0by1mb2N1cy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUErRDtBQUUvRCxJQUFJO0VBQ0ZDLGNBQWMsQ0FBQ0MsT0FBTyxDQUFDRixTQUFTLEdBQUdBLHlFQUFTO0FBQzlDLENBQUMsQ0FBQyxPQUFPRyxDQUFDLEVBQUUsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL1Z1ZXh5Ly4vbGlicy9AZm9ybS12YWxpZGF0aW9uL2F1dG8tZm9jdXMuanM/MDA4MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBdXRvRm9jdXMgfSBmcm9tICdAZm9ybS12YWxpZGF0aW9uL3BsdWdpbi1hdXRvLWZvY3VzJztcblxudHJ5IHtcbiAgRm9ybVZhbGlkYXRpb24ucGx1Z2lucy5BdXRvRm9jdXMgPSBBdXRvRm9jdXM7XG59IGNhdGNoIChlKSB7fVxuXG5leHBvcnQgeyBBdXRvRm9jdXMgfTtcbiJdLCJuYW1lcyI6WyJBdXRvRm9jdXMiLCJGb3JtVmFsaWRhdGlvbiIsInBsdWdpbnMiLCJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./libs/@form-validation/auto-focus.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./libs/@form-validation/auto-focus.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});