/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(self, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./libs/shepherd/shepherd.js":
/*!***********************************!*\
  !*** ./libs/shepherd/shepherd.js ***!
  \***********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Shepherd: function() { return /* reexport default from dynamic */ shepherd_js_dist_js_shepherd__WEBPACK_IMPORTED_MODULE_0___default.a; }\n/* harmony export */ });\n/* harmony import */ var shepherd_js_dist_js_shepherd__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! shepherd.js/dist/js/shepherd */ \"./node_modules/shepherd.js/dist/js/shepherd.js\");\n/* harmony import */ var shepherd_js_dist_js_shepherd__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(shepherd_js_dist_js_shepherd__WEBPACK_IMPORTED_MODULE_0__);\n\ntry {\n  window.Shepherd = (shepherd_js_dist_js_shepherd__WEBPACK_IMPORTED_MODULE_0___default());\n} catch (e) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWJzL3NoZXBoZXJkL3NoZXBoZXJkLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFvRDtBQUVwRCxJQUFJO0VBQ0ZDLE1BQU0sQ0FBQ0QsUUFBUSxHQUFHQSxxRUFBUTtBQUM1QixDQUFDLENBQUMsT0FBT0UsQ0FBQyxFQUFFLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9WdWV4eS8uL2xpYnMvc2hlcGhlcmQvc2hlcGhlcmQuanM/N2E4MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgU2hlcGhlcmQgZnJvbSAnc2hlcGhlcmQuanMvZGlzdC9qcy9zaGVwaGVyZCc7XG5cbnRyeSB7XG4gIHdpbmRvdy5TaGVwaGVyZCA9IFNoZXBoZXJkO1xufSBjYXRjaCAoZSkge31cblxuZXhwb3J0IHsgU2hlcGhlcmQgfTtcbiJdLCJuYW1lcyI6WyJTaGVwaGVyZCIsIndpbmRvdyIsImUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./libs/shepherd/shepherd.js\n");

/***/ }),

/***/ "./node_modules/shepherd.js/dist/js/shepherd.js":
/*!******************************************************!*\
  !*** ./node_modules/shepherd.js/dist/js/shepherd.js ***!
  \******************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator.return && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n/*! shepherd.js 11.2.0 */\n\n(function (global, factory) {\n  ( false ? 0 : _typeof(exports)) === 'object' && \"object\" !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (0);\n})(this, function () {\n  'use strict';\n\n  var isMergeableObject = function isMergeableObject(value) {\n    return isNonNullObject(value) && !isSpecial(value);\n  };\n  function isNonNullObject(value) {\n    return !!value && _typeof(value) === 'object';\n  }\n  function isSpecial(value) {\n    var stringValue = Object.prototype.toString.call(value);\n    return stringValue === '[object RegExp]' || stringValue === '[object Date]' || isReactElement(value);\n  }\n\n  // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\n  var canUseSymbol = typeof Symbol === 'function' && Symbol.for;\n  var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n  function isReactElement(value) {\n    return value.$$typeof === REACT_ELEMENT_TYPE;\n  }\n  function emptyTarget(val) {\n    return Array.isArray(val) ? [] : {};\n  }\n  function cloneUnlessOtherwiseSpecified(value, options) {\n    return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;\n  }\n  function defaultArrayMerge(target, source, options) {\n    return target.concat(source).map(function (element) {\n      return cloneUnlessOtherwiseSpecified(element, options);\n    });\n  }\n  function getMergeFunction(key, options) {\n    if (!options.customMerge) {\n      return deepmerge;\n    }\n    var customMerge = options.customMerge(key);\n    return typeof customMerge === 'function' ? customMerge : deepmerge;\n  }\n  function getEnumerableOwnPropertySymbols(target) {\n    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function (symbol) {\n      return Object.propertyIsEnumerable.call(target, symbol);\n    }) : [];\n  }\n  function getKeys(target) {\n    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));\n  }\n  function propertyIsOnObject(object, property) {\n    try {\n      return property in object;\n    } catch (_) {\n      return false;\n    }\n  }\n\n  // Protects from prototype poisoning and unexpected merging up the prototype chain.\n  function propertyIsUnsafe(target, key) {\n    return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n    && !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n    && Object.propertyIsEnumerable.call(target, key)); // and also unsafe if they're nonenumerable.\n  }\n  function mergeObject(target, source, options) {\n    var destination = {};\n    if (options.isMergeableObject(target)) {\n      getKeys(target).forEach(function (key) {\n        destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n      });\n    }\n    getKeys(source).forEach(function (key) {\n      if (propertyIsUnsafe(target, key)) {\n        return;\n      }\n      if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n        destination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n      } else {\n        destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n      }\n    });\n    return destination;\n  }\n  function deepmerge(target, source, options) {\n    options = options || {};\n    options.arrayMerge = options.arrayMerge || defaultArrayMerge;\n    options.isMergeableObject = options.isMergeableObject || isMergeableObject;\n    // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n    // implementations can use it. The caller may not replace it.\n    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n    var sourceIsArray = Array.isArray(source);\n    var targetIsArray = Array.isArray(target);\n    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n    if (!sourceAndTargetTypesMatch) {\n      return cloneUnlessOtherwiseSpecified(source, options);\n    } else if (sourceIsArray) {\n      return options.arrayMerge(target, source, options);\n    } else {\n      return mergeObject(target, source, options);\n    }\n  }\n  deepmerge.all = function deepmergeAll(array, options) {\n    if (!Array.isArray(array)) {\n      throw new Error('first argument should be an array');\n    }\n    return array.reduce(function (prev, next) {\n      return deepmerge(prev, next, options);\n    }, {});\n  };\n  var deepmerge_1 = deepmerge;\n  var cjs = deepmerge_1;\n\n  /**\n   * Checks if `value` is classified as an `Element`.\n   * @param {*} value The param to check if it is an Element\n   */\n  function isElement$1(value) {\n    return value instanceof Element;\n  }\n\n  /**\n   * Checks if `value` is classified as an `HTMLElement`.\n   * @param {*} value The param to check if it is an HTMLElement\n   */\n  function isHTMLElement$1(value) {\n    return value instanceof HTMLElement;\n  }\n\n  /**\n   * Checks if `value` is classified as a `Function` object.\n   * @param {*} value The param to check if it is a function\n   */\n  function isFunction(value) {\n    return typeof value === 'function';\n  }\n\n  /**\n   * Checks if `value` is classified as a `String` object.\n   * @param {*} value The param to check if it is a string\n   */\n  function isString(value) {\n    return typeof value === 'string';\n  }\n\n  /**\n   * Checks if `value` is undefined.\n   * @param {*} value The param to check if it is undefined\n   */\n  function isUndefined(value) {\n    return value === undefined;\n  }\n  var Evented = /*#__PURE__*/function () {\n    function Evented() {\n      _classCallCheck(this, Evented);\n    }\n    _createClass(Evented, [{\n      key: \"on\",\n      value: function on(event, handler, ctx) {\n        var once = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n        if (isUndefined(this.bindings)) {\n          this.bindings = {};\n        }\n        if (isUndefined(this.bindings[event])) {\n          this.bindings[event] = [];\n        }\n        this.bindings[event].push({\n          handler: handler,\n          ctx: ctx,\n          once: once\n        });\n        return this;\n      }\n    }, {\n      key: \"once\",\n      value: function once(event, handler, ctx) {\n        return this.on(event, handler, ctx, true);\n      }\n    }, {\n      key: \"off\",\n      value: function off(event, handler) {\n        var _this = this;\n        if (isUndefined(this.bindings) || isUndefined(this.bindings[event])) {\n          return this;\n        }\n        if (isUndefined(handler)) {\n          delete this.bindings[event];\n        } else {\n          this.bindings[event].forEach(function (binding, index) {\n            if (binding.handler === handler) {\n              _this.bindings[event].splice(index, 1);\n            }\n          });\n        }\n        return this;\n      }\n    }, {\n      key: \"trigger\",\n      value: function trigger(event) {\n        var _this2 = this;\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n        if (!isUndefined(this.bindings) && this.bindings[event]) {\n          this.bindings[event].forEach(function (binding, index) {\n            var ctx = binding.ctx,\n              handler = binding.handler,\n              once = binding.once;\n            var context = ctx || _this2;\n            handler.apply(context, args);\n            if (once) {\n              _this2.bindings[event].splice(index, 1);\n            }\n          });\n        }\n        return this;\n      }\n    }]);\n    return Evented;\n  }();\n  /**\n   * Binds all the methods on a JS Class to the `this` context of the class.\n   * Adapted from https://github.com/sindresorhus/auto-bind\n   * @param {object} self The `this` context of the class\n   * @return {object} The `this` context of the class\n   */\n  function autoBind(self) {\n    var keys = Object.getOwnPropertyNames(self.constructor.prototype);\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var val = self[key];\n      if (key !== 'constructor' && typeof val === 'function') {\n        self[key] = val.bind(self);\n      }\n    }\n    return self;\n  }\n\n  /**\n   * Sets up the handler to determine if we should advance the tour\n   * @param {string} selector\n   * @param {Step} step The step instance\n   * @return {Function}\n   * @private\n   */\n  function _setupAdvanceOnHandler(selector, step) {\n    return function (event) {\n      if (step.isOpen()) {\n        var targetIsEl = step.el && event.currentTarget === step.el;\n        var targetIsSelector = !isUndefined(selector) && event.currentTarget.matches(selector);\n        if (targetIsSelector || targetIsEl) {\n          step.tour.next();\n        }\n      }\n    };\n  }\n\n  /**\n   * Bind the event handler for advanceOn\n   * @param {Step} step The step instance\n   */\n  function bindAdvance(step) {\n    // An empty selector matches the step element\n    var _ref2 = step.options.advanceOn || {},\n      event = _ref2.event,\n      selector = _ref2.selector;\n    if (event) {\n      var handler = _setupAdvanceOnHandler(selector, step);\n\n      // TODO: this should also bind/unbind on show/hide\n      var el;\n      try {\n        el = document.querySelector(selector);\n      } catch (e) {\n        // TODO\n      }\n      if (!isUndefined(selector) && !el) {\n        return console.error(\"No element was found for the selector supplied to advanceOn: \".concat(selector));\n      } else if (el) {\n        el.addEventListener(event, handler);\n        step.on('destroy', function () {\n          return el.removeEventListener(event, handler);\n        });\n      } else {\n        document.body.addEventListener(event, handler, true);\n        step.on('destroy', function () {\n          return document.body.removeEventListener(event, handler, true);\n        });\n      }\n    } else {\n      return console.error('advanceOn was defined, but no event name was passed.');\n    }\n  }\n\n  /**\n   * Ensure class prefix ends in `-`\n   * @param {string} prefix The prefix to prepend to the class names generated by nano-css\n   * @return {string} The prefix ending in `-`\n   */\n  function normalizePrefix(prefix) {\n    if (!isString(prefix) || prefix === '') {\n      return '';\n    }\n    return prefix.charAt(prefix.length - 1) !== '-' ? \"\".concat(prefix, \"-\") : prefix;\n  }\n\n  /**\n   * Resolves attachTo options, converting element option value to a qualified HTMLElement.\n   * @param {Step} step The step instance\n   * @returns {{}|{element, on}}\n   * `element` is a qualified HTML Element\n   * `on` is a string position value\n   */\n  function parseAttachTo(step) {\n    var options = step.options.attachTo || {};\n    var returnOpts = Object.assign({}, options);\n    if (isFunction(returnOpts.element)) {\n      // Bind the callback to step so that it has access to the object, to enable running additional logic\n      returnOpts.element = returnOpts.element.call(step);\n    }\n    if (isString(returnOpts.element)) {\n      // Can't override the element in user opts reference because we can't\n      // guarantee that the element will exist in the future.\n      try {\n        returnOpts.element = document.querySelector(returnOpts.element);\n      } catch (e) {\n        // TODO\n      }\n      if (!returnOpts.element) {\n        console.error(\"The element for this Shepherd step was not found \".concat(options.element));\n      }\n    }\n    return returnOpts;\n  }\n\n  /**\n   * Checks if the step should be centered or not. Does not trigger attachTo.element evaluation, making it a pure\n   * alternative for the deprecated step.isCentered() method.\n   * @param resolvedAttachToOptions\n   * @returns {boolean}\n   */\n  function shouldCenterStep(resolvedAttachToOptions) {\n    if (resolvedAttachToOptions === undefined || resolvedAttachToOptions === null) {\n      return true;\n    }\n    return !resolvedAttachToOptions.element || !resolvedAttachToOptions.on;\n  }\n\n  /**\n   * Create a unique id for steps, tours, modals, etc\n   * @return {string}\n   */\n  function uuid() {\n    var d = Date.now();\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n      var r = (d + Math.random() * 16) % 16 | 0;\n      d = Math.floor(d / 16);\n      return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n    });\n  }\n  function _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n      return target;\n    };\n    return _extends.apply(this, arguments);\n  }\n  function _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for (i = 0; i < sourceKeys.length; i++) {\n      key = sourceKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      target[key] = source[key];\n    }\n    return target;\n  }\n  var min = Math.min;\n  var max = Math.max;\n  var round = Math.round;\n  var floor = Math.floor;\n  var createCoords = function createCoords(v) {\n    return {\n      x: v,\n      y: v\n    };\n  };\n  var oppositeSideMap = {\n    left: 'right',\n    right: 'left',\n    bottom: 'top',\n    top: 'bottom'\n  };\n  var oppositeAlignmentMap = {\n    start: 'end',\n    end: 'start'\n  };\n  function clamp(start, value, end) {\n    return max(start, min(value, end));\n  }\n  function evaluate(value, param) {\n    return typeof value === 'function' ? value(param) : value;\n  }\n  function getSide(placement) {\n    return placement.split('-')[0];\n  }\n  function getAlignment(placement) {\n    return placement.split('-')[1];\n  }\n  function getOppositeAxis(axis) {\n    return axis === 'x' ? 'y' : 'x';\n  }\n  function getAxisLength(axis) {\n    return axis === 'y' ? 'height' : 'width';\n  }\n  function getSideAxis(placement) {\n    return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';\n  }\n  function getAlignmentAxis(placement) {\n    return getOppositeAxis(getSideAxis(placement));\n  }\n  function getAlignmentSides(placement, rects, rtl) {\n    if (rtl === void 0) {\n      rtl = false;\n    }\n    var alignment = getAlignment(placement);\n    var alignmentAxis = getAlignmentAxis(placement);\n    var length = getAxisLength(alignmentAxis);\n    var mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n    if (rects.reference[length] > rects.floating[length]) {\n      mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n    }\n    return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n  }\n  function getExpandedPlacements(placement) {\n    var oppositePlacement = getOppositePlacement(placement);\n    return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n  }\n  function getOppositeAlignmentPlacement(placement) {\n    return placement.replace(/start|end/g, function (alignment) {\n      return oppositeAlignmentMap[alignment];\n    });\n  }\n  function getSideList(side, isStart, rtl) {\n    var lr = ['left', 'right'];\n    var rl = ['right', 'left'];\n    var tb = ['top', 'bottom'];\n    var bt = ['bottom', 'top'];\n    switch (side) {\n      case 'top':\n      case 'bottom':\n        if (rtl) return isStart ? rl : lr;\n        return isStart ? lr : rl;\n      case 'left':\n      case 'right':\n        return isStart ? tb : bt;\n      default:\n        return [];\n    }\n  }\n  function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n    var alignment = getAlignment(placement);\n    var list = getSideList(getSide(placement), direction === 'start', rtl);\n    if (alignment) {\n      list = list.map(function (side) {\n        return side + \"-\" + alignment;\n      });\n      if (flipAlignment) {\n        list = list.concat(list.map(getOppositeAlignmentPlacement));\n      }\n    }\n    return list;\n  }\n  function getOppositePlacement(placement) {\n    return placement.replace(/left|right|bottom|top/g, function (side) {\n      return oppositeSideMap[side];\n    });\n  }\n  function expandPaddingObject(padding) {\n    return _extends({\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    }, padding);\n  }\n  function getPaddingObject(padding) {\n    return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n      top: padding,\n      right: padding,\n      bottom: padding,\n      left: padding\n    };\n  }\n  function rectToClientRect(rect) {\n    return _extends({}, rect, {\n      top: rect.y,\n      left: rect.x,\n      right: rect.x + rect.width,\n      bottom: rect.y + rect.height\n    });\n  }\n  var _excluded2 = [\"mainAxis\", \"crossAxis\", \"fallbackPlacements\", \"fallbackStrategy\", \"fallbackAxisSideDirection\", \"flipAlignment\"],\n    _excluded4 = [\"mainAxis\", \"crossAxis\", \"limiter\"];\n  function computeCoordsFromPlacement(_ref, placement, rtl) {\n    var reference = _ref.reference,\n      floating = _ref.floating;\n    var sideAxis = getSideAxis(placement);\n    var alignmentAxis = getAlignmentAxis(placement);\n    var alignLength = getAxisLength(alignmentAxis);\n    var side = getSide(placement);\n    var isVertical = sideAxis === 'y';\n    var commonX = reference.x + reference.width / 2 - floating.width / 2;\n    var commonY = reference.y + reference.height / 2 - floating.height / 2;\n    var commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n    var coords;\n    switch (side) {\n      case 'top':\n        coords = {\n          x: commonX,\n          y: reference.y - floating.height\n        };\n        break;\n      case 'bottom':\n        coords = {\n          x: commonX,\n          y: reference.y + reference.height\n        };\n        break;\n      case 'right':\n        coords = {\n          x: reference.x + reference.width,\n          y: commonY\n        };\n        break;\n      case 'left':\n        coords = {\n          x: reference.x - floating.width,\n          y: commonY\n        };\n        break;\n      default:\n        coords = {\n          x: reference.x,\n          y: reference.y\n        };\n    }\n    switch (getAlignment(placement)) {\n      case 'start':\n        coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n        break;\n      case 'end':\n        coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n        break;\n    }\n    return coords;\n  }\n\n  /**\n   * Computes the `x` and `y` coordinates that will place the floating element\n   * next to a reference element when it is given a certain positioning strategy.\n   *\n   * This export does not have any `platform` interface logic. You will need to\n   * write one for the platform you are using Floating UI with.\n   */\n  var computePosition$1 = /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(reference, floating, config) {\n      var _config$placement, placement, _config$strategy, strategy, _config$middleware, middleware, platform, validMiddleware, rtl, rects, _computeCoordsFromPla, x, y, statefulPlacement, middlewareData, resetCount, i, _validMiddleware$i, name, fn, _yield$fn, nextX, nextY, data, reset, _computeCoordsFromPla2;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            _config$placement = config.placement, placement = _config$placement === void 0 ? 'bottom' : _config$placement, _config$strategy = config.strategy, strategy = _config$strategy === void 0 ? 'absolute' : _config$strategy, _config$middleware = config.middleware, middleware = _config$middleware === void 0 ? [] : _config$middleware, platform = config.platform;\n            validMiddleware = middleware.filter(Boolean);\n            _context.next = 4;\n            return platform.isRTL == null ? void 0 : platform.isRTL(floating);\n          case 4:\n            rtl = _context.sent;\n            _context.next = 7;\n            return platform.getElementRects({\n              reference: reference,\n              floating: floating,\n              strategy: strategy\n            });\n          case 7:\n            rects = _context.sent;\n            _computeCoordsFromPla = computeCoordsFromPlacement(rects, placement, rtl), x = _computeCoordsFromPla.x, y = _computeCoordsFromPla.y;\n            statefulPlacement = placement;\n            middlewareData = {};\n            resetCount = 0;\n            i = 0;\n          case 13:\n            if (!(i < validMiddleware.length)) {\n              _context.next = 46;\n              break;\n            }\n            _validMiddleware$i = validMiddleware[i], name = _validMiddleware$i.name, fn = _validMiddleware$i.fn;\n            _context.next = 17;\n            return fn({\n              x: x,\n              y: y,\n              initialPlacement: placement,\n              placement: statefulPlacement,\n              strategy: strategy,\n              middlewareData: middlewareData,\n              rects: rects,\n              platform: platform,\n              elements: {\n                reference: reference,\n                floating: floating\n              }\n            });\n          case 17:\n            _yield$fn = _context.sent;\n            nextX = _yield$fn.x;\n            nextY = _yield$fn.y;\n            data = _yield$fn.data;\n            reset = _yield$fn.reset;\n            x = nextX != null ? nextX : x;\n            y = nextY != null ? nextY : y;\n            middlewareData = _extends({}, middlewareData, _defineProperty({}, name, _extends({}, middlewareData[name], data)));\n            if (!(reset && resetCount <= 50)) {\n              _context.next = 43;\n              break;\n            }\n            resetCount++;\n            if (!(_typeof(reset) === 'object')) {\n              _context.next = 41;\n              break;\n            }\n            if (reset.placement) {\n              statefulPlacement = reset.placement;\n            }\n            if (!reset.rects) {\n              _context.next = 38;\n              break;\n            }\n            if (!(reset.rects === true)) {\n              _context.next = 36;\n              break;\n            }\n            _context.next = 33;\n            return platform.getElementRects({\n              reference: reference,\n              floating: floating,\n              strategy: strategy\n            });\n          case 33:\n            _context.t0 = _context.sent;\n            _context.next = 37;\n            break;\n          case 36:\n            _context.t0 = reset.rects;\n          case 37:\n            rects = _context.t0;\n          case 38:\n            _computeCoordsFromPla2 = computeCoordsFromPlacement(rects, statefulPlacement, rtl);\n            x = _computeCoordsFromPla2.x;\n            y = _computeCoordsFromPla2.y;\n          case 41:\n            i = -1;\n            return _context.abrupt(\"continue\", 43);\n          case 43:\n            i++;\n            _context.next = 13;\n            break;\n          case 46:\n            return _context.abrupt(\"return\", {\n              x: x,\n              y: y,\n              placement: statefulPlacement,\n              strategy: strategy,\n              middlewareData: middlewareData\n            });\n          case 47:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }));\n    return function computePosition$1(_x, _x2, _x3) {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n\n  /**\n   * Resolves with an object of overflow side offsets that determine how much the\n   * element is overflowing a given clipping boundary on each side.\n   * - positive = overflowing the boundary by that number of pixels\n   * - negative = how many pixels left before it will overflow\n   * - 0 = lies flush with the boundary\n   * @see https://floating-ui.com/docs/detectOverflow\n   */\n  function detectOverflow(_x4, _x5) {\n    return _detectOverflow.apply(this, arguments);\n  }\n  /**\n   * Provides data to position an inner element of the floating element so that it\n   * appears centered to the reference element.\n   * @see https://floating-ui.com/docs/arrow\n   */\n  function _detectOverflow() {\n    _detectOverflow = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(state, options) {\n      var _await$platform$isEle, x, y, platform, rects, elements, strategy, _evaluate3, _evaluate3$boundary, boundary, _evaluate3$rootBounda, rootBoundary, _evaluate3$elementCon, elementContext, _evaluate3$altBoundar, altBoundary, _evaluate3$padding, padding, paddingObject, altContext, element, clippingClientRect, rect, offsetParent, offsetScale, elementClientRect;\n      return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n        while (1) switch (_context7.prev = _context7.next) {\n          case 0:\n            if (options === void 0) {\n              options = {};\n            }\n            x = state.x, y = state.y, platform = state.platform, rects = state.rects, elements = state.elements, strategy = state.strategy;\n            _evaluate3 = evaluate(options, state), _evaluate3$boundary = _evaluate3.boundary, boundary = _evaluate3$boundary === void 0 ? 'clippingAncestors' : _evaluate3$boundary, _evaluate3$rootBounda = _evaluate3.rootBoundary, rootBoundary = _evaluate3$rootBounda === void 0 ? 'viewport' : _evaluate3$rootBounda, _evaluate3$elementCon = _evaluate3.elementContext, elementContext = _evaluate3$elementCon === void 0 ? 'floating' : _evaluate3$elementCon, _evaluate3$altBoundar = _evaluate3.altBoundary, altBoundary = _evaluate3$altBoundar === void 0 ? false : _evaluate3$altBoundar, _evaluate3$padding = _evaluate3.padding, padding = _evaluate3$padding === void 0 ? 0 : _evaluate3$padding;\n            paddingObject = getPaddingObject(padding);\n            altContext = elementContext === 'floating' ? 'reference' : 'floating';\n            element = elements[altBoundary ? altContext : elementContext];\n            _context7.t0 = rectToClientRect;\n            _context7.t1 = platform;\n            _context7.next = 10;\n            return platform.isElement == null ? void 0 : platform.isElement(element);\n          case 10:\n            _context7.t2 = _await$platform$isEle = _context7.sent;\n            if (!(_context7.t2 != null)) {\n              _context7.next = 15;\n              break;\n            }\n            _context7.t3 = _await$platform$isEle;\n            _context7.next = 16;\n            break;\n          case 15:\n            _context7.t3 = true;\n          case 16:\n            if (!_context7.t3) {\n              _context7.next = 20;\n              break;\n            }\n            _context7.t4 = element;\n            _context7.next = 26;\n            break;\n          case 20:\n            _context7.t5 = element.contextElement;\n            if (_context7.t5) {\n              _context7.next = 25;\n              break;\n            }\n            _context7.next = 24;\n            return platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating);\n          case 24:\n            _context7.t5 = _context7.sent;\n          case 25:\n            _context7.t4 = _context7.t5;\n          case 26:\n            _context7.t6 = _context7.t4;\n            _context7.t7 = boundary;\n            _context7.t8 = rootBoundary;\n            _context7.t9 = strategy;\n            _context7.t10 = {\n              element: _context7.t6,\n              boundary: _context7.t7,\n              rootBoundary: _context7.t8,\n              strategy: _context7.t9\n            };\n            _context7.next = 33;\n            return _context7.t1.getClippingRect.call(_context7.t1, _context7.t10);\n          case 33:\n            _context7.t11 = _context7.sent;\n            clippingClientRect = (0, _context7.t0)(_context7.t11);\n            rect = elementContext === 'floating' ? _extends({}, rects.floating, {\n              x: x,\n              y: y\n            }) : rects.reference;\n            _context7.next = 38;\n            return platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating);\n          case 38:\n            offsetParent = _context7.sent;\n            _context7.next = 41;\n            return platform.isElement == null ? void 0 : platform.isElement(offsetParent);\n          case 41:\n            if (!_context7.sent) {\n              _context7.next = 50;\n              break;\n            }\n            _context7.next = 44;\n            return platform.getScale == null ? void 0 : platform.getScale(offsetParent);\n          case 44:\n            _context7.t13 = _context7.sent;\n            if (_context7.t13) {\n              _context7.next = 47;\n              break;\n            }\n            _context7.t13 = {\n              x: 1,\n              y: 1\n            };\n          case 47:\n            _context7.t12 = _context7.t13;\n            _context7.next = 51;\n            break;\n          case 50:\n            _context7.t12 = {\n              x: 1,\n              y: 1\n            };\n          case 51:\n            offsetScale = _context7.t12;\n            _context7.t14 = rectToClientRect;\n            if (!platform.convertOffsetParentRelativeRectToViewportRelativeRect) {\n              _context7.next = 59;\n              break;\n            }\n            _context7.next = 56;\n            return platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n              rect: rect,\n              offsetParent: offsetParent,\n              strategy: strategy\n            });\n          case 56:\n            _context7.t15 = _context7.sent;\n            _context7.next = 60;\n            break;\n          case 59:\n            _context7.t15 = rect;\n          case 60:\n            _context7.t16 = _context7.t15;\n            elementClientRect = (0, _context7.t14)(_context7.t16);\n            return _context7.abrupt(\"return\", {\n              top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n              bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n              left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n              right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n            });\n          case 63:\n          case \"end\":\n            return _context7.stop();\n        }\n      }, _callee7);\n    }));\n    return _detectOverflow.apply(this, arguments);\n  }\n  var arrow = function arrow(options) {\n    return {\n      name: 'arrow',\n      options: options,\n      fn: function fn(state) {\n        return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n          var x, y, placement, rects, platform, elements, _ref4, element, _ref4$padding, padding, paddingObject, coords, axis, length, arrowDimensions, isYAxis, minProp, maxProp, clientProp, endDiff, startDiff, arrowOffsetParent, clientSize, centerToReference, largestPossiblePadding, minPadding, maxPadding, min$1, max, center, offset, shouldAddOffset, alignmentOffset;\n          return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n            while (1) switch (_context2.prev = _context2.next) {\n              case 0:\n                x = state.x, y = state.y, placement = state.placement, rects = state.rects, platform = state.platform, elements = state.elements; // Since `element` is required, we don't Partial<> the type.\n                _ref4 = evaluate(options, state) || {}, element = _ref4.element, _ref4$padding = _ref4.padding, padding = _ref4$padding === void 0 ? 0 : _ref4$padding;\n                if (!(element == null)) {\n                  _context2.next = 4;\n                  break;\n                }\n                return _context2.abrupt(\"return\", {});\n              case 4:\n                paddingObject = getPaddingObject(padding);\n                coords = {\n                  x: x,\n                  y: y\n                };\n                axis = getAlignmentAxis(placement);\n                length = getAxisLength(axis);\n                _context2.next = 10;\n                return platform.getDimensions(element);\n              case 10:\n                arrowDimensions = _context2.sent;\n                isYAxis = axis === 'y';\n                minProp = isYAxis ? 'top' : 'left';\n                maxProp = isYAxis ? 'bottom' : 'right';\n                clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n                endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n                startDiff = coords[axis] - rects.reference[axis];\n                _context2.next = 19;\n                return platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element);\n              case 19:\n                arrowOffsetParent = _context2.sent;\n                clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0; // DOM platform can return `window` as the `offsetParent`.\n                _context2.t0 = !clientSize;\n                if (_context2.t0) {\n                  _context2.next = 26;\n                  break;\n                }\n                _context2.next = 25;\n                return platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent);\n              case 25:\n                _context2.t0 = !_context2.sent;\n              case 26:\n                if (!_context2.t0) {\n                  _context2.next = 28;\n                  break;\n                }\n                clientSize = elements.floating[clientProp] || rects.floating[length];\n              case 28:\n                centerToReference = endDiff / 2 - startDiff / 2; // If the padding is large enough that it causes the arrow to no longer be\n                // centered, modify the padding so that it is centered.\n                largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n                minPadding = min(paddingObject[minProp], largestPossiblePadding);\n                maxPadding = min(paddingObject[maxProp], largestPossiblePadding); // Make sure the arrow doesn't overflow the floating element if the center\n                // point is outside the floating element's bounds.\n                min$1 = minPadding;\n                max = clientSize - arrowDimensions[length] - maxPadding;\n                center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n                offset = clamp(min$1, center, max); // If the reference is small enough that the arrow's padding causes it to\n                // to point to nothing for an aligned placement, adjust the offset of the\n                // floating element itself. This stops `shift()` from taking action, but can\n                // be worked around by calling it again after the `arrow()` if desired.\n                shouldAddOffset = getAlignment(placement) != null && center != offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n                alignmentOffset = shouldAddOffset ? center < min$1 ? min$1 - center : max - center : 0;\n                return _context2.abrupt(\"return\", _defineProperty(_defineProperty({}, axis, coords[axis] - alignmentOffset), \"data\", _defineProperty(_defineProperty({}, axis, offset), \"centerOffset\", center - offset + alignmentOffset)));\n              case 39:\n              case \"end\":\n                return _context2.stop();\n            }\n          }, _callee2);\n        }))();\n      }\n    };\n  };\n\n  /**\n   * Optimizes the visibility of the floating element by flipping the `placement`\n   * in order to keep it in view when the preferred placement(s) will overflow the\n   * clipping boundary. Alternative to `autoPlacement`.\n   * @see https://floating-ui.com/docs/flip\n   */\n  var flip = function flip(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    return {\n      name: 'flip',\n      options: options,\n      fn: function fn(state) {\n        return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n          var _middlewareData$flip, placement, middlewareData, rects, initialPlacement, platform, elements, _evaluate2, _evaluate2$mainAxis, checkMainAxis, _evaluate2$crossAxis, checkCrossAxis, specifiedFallbackPlacements, _evaluate2$fallbackSt, fallbackStrategy, _evaluate2$fallbackAx, fallbackAxisSideDirection, _evaluate2$flipAlignm, flipAlignment, detectOverflowOptions, side, isBasePlacement, rtl, fallbackPlacements, placements, overflow, overflows, overflowsData, sides, _middlewareData$flip2, _overflowsData$filter, nextIndex, nextPlacement, resetPlacement, _overflowsData$map$so, _placement;\n          return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n            while (1) switch (_context3.prev = _context3.next) {\n              case 0:\n                placement = state.placement, middlewareData = state.middlewareData, rects = state.rects, initialPlacement = state.initialPlacement, platform = state.platform, elements = state.elements;\n                _evaluate2 = evaluate(options, state), _evaluate2$mainAxis = _evaluate2.mainAxis, checkMainAxis = _evaluate2$mainAxis === void 0 ? true : _evaluate2$mainAxis, _evaluate2$crossAxis = _evaluate2.crossAxis, checkCrossAxis = _evaluate2$crossAxis === void 0 ? true : _evaluate2$crossAxis, specifiedFallbackPlacements = _evaluate2.fallbackPlacements, _evaluate2$fallbackSt = _evaluate2.fallbackStrategy, fallbackStrategy = _evaluate2$fallbackSt === void 0 ? 'bestFit' : _evaluate2$fallbackSt, _evaluate2$fallbackAx = _evaluate2.fallbackAxisSideDirection, fallbackAxisSideDirection = _evaluate2$fallbackAx === void 0 ? 'none' : _evaluate2$fallbackAx, _evaluate2$flipAlignm = _evaluate2.flipAlignment, flipAlignment = _evaluate2$flipAlignm === void 0 ? true : _evaluate2$flipAlignm, detectOverflowOptions = _objectWithoutPropertiesLoose(_evaluate2, _excluded2);\n                side = getSide(placement);\n                isBasePlacement = getSide(initialPlacement) === initialPlacement;\n                _context3.next = 6;\n                return platform.isRTL == null ? void 0 : platform.isRTL(elements.floating);\n              case 6:\n                rtl = _context3.sent;\n                fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n                if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {\n                  fallbackPlacements.push.apply(fallbackPlacements, _toConsumableArray(getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl)));\n                }\n                placements = [initialPlacement].concat(_toConsumableArray(fallbackPlacements));\n                _context3.next = 12;\n                return detectOverflow(state, detectOverflowOptions);\n              case 12:\n                overflow = _context3.sent;\n                overflows = [];\n                overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n                if (checkMainAxis) {\n                  overflows.push(overflow[side]);\n                }\n                if (checkCrossAxis) {\n                  sides = getAlignmentSides(placement, rects, rtl);\n                  overflows.push(overflow[sides[0]], overflow[sides[1]]);\n                }\n                overflowsData = [].concat(_toConsumableArray(overflowsData), [{\n                  placement: placement,\n                  overflows: overflows\n                }]);\n\n                // One or more sides is overflowing.\n                if (overflows.every(function (side) {\n                  return side <= 0;\n                })) {\n                  _context3.next = 35;\n                  break;\n                }\n                nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n                nextPlacement = placements[nextIndex];\n                if (!nextPlacement) {\n                  _context3.next = 23;\n                  break;\n                }\n                return _context3.abrupt(\"return\", {\n                  data: {\n                    index: nextIndex,\n                    overflows: overflowsData\n                  },\n                  reset: {\n                    placement: nextPlacement\n                  }\n                });\n              case 23:\n                // First, find the candidates that fit on the mainAxis side of overflow,\n                // then find the placement that fits the best on the main crossAxis side.\n                resetPlacement = (_overflowsData$filter = overflowsData.filter(function (d) {\n                  return d.overflows[0] <= 0;\n                }).sort(function (a, b) {\n                  return a.overflows[1] - b.overflows[1];\n                })[0]) == null ? void 0 : _overflowsData$filter.placement; // Otherwise fallback.\n                if (resetPlacement) {\n                  _context3.next = 33;\n                  break;\n                }\n                _context3.t0 = fallbackStrategy;\n                _context3.next = _context3.t0 === 'bestFit' ? 28 : _context3.t0 === 'initialPlacement' ? 31 : 33;\n                break;\n              case 28:\n                _placement = (_overflowsData$map$so = overflowsData.map(function (d) {\n                  return [d.placement, d.overflows.filter(function (overflow) {\n                    return overflow > 0;\n                  }).reduce(function (acc, overflow) {\n                    return acc + overflow;\n                  }, 0)];\n                }).sort(function (a, b) {\n                  return a[1] - b[1];\n                })[0]) == null ? void 0 : _overflowsData$map$so[0];\n                if (_placement) {\n                  resetPlacement = _placement;\n                }\n                return _context3.abrupt(\"break\", 33);\n              case 31:\n                resetPlacement = initialPlacement;\n                return _context3.abrupt(\"break\", 33);\n              case 33:\n                if (!(placement !== resetPlacement)) {\n                  _context3.next = 35;\n                  break;\n                }\n                return _context3.abrupt(\"return\", {\n                  reset: {\n                    placement: resetPlacement\n                  }\n                });\n              case 35:\n                return _context3.abrupt(\"return\", {});\n              case 36:\n              case \"end\":\n                return _context3.stop();\n            }\n          }, _callee3);\n        }))();\n      }\n    };\n  };\n\n  /**\n   * Optimizes the visibility of the floating element by shifting it in order to\n   * keep it in view when it will overflow the clipping boundary.\n   * @see https://floating-ui.com/docs/shift\n   */\n  var shift = function shift(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    return {\n      name: 'shift',\n      options: options,\n      fn: function fn(state) {\n        return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n          var x, y, placement, _evaluate4, _evaluate4$mainAxis, checkMainAxis, _evaluate4$crossAxis, checkCrossAxis, _evaluate4$limiter, limiter, detectOverflowOptions, coords, overflow, crossAxis, mainAxis, mainAxisCoord, crossAxisCoord, minSide, maxSide, _min, _max, _minSide, _maxSide, _min2, _max2, limitedCoords;\n          return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n            while (1) switch (_context4.prev = _context4.next) {\n              case 0:\n                x = state.x, y = state.y, placement = state.placement;\n                _evaluate4 = evaluate(options, state), _evaluate4$mainAxis = _evaluate4.mainAxis, checkMainAxis = _evaluate4$mainAxis === void 0 ? true : _evaluate4$mainAxis, _evaluate4$crossAxis = _evaluate4.crossAxis, checkCrossAxis = _evaluate4$crossAxis === void 0 ? false : _evaluate4$crossAxis, _evaluate4$limiter = _evaluate4.limiter, limiter = _evaluate4$limiter === void 0 ? {\n                  fn: function fn(_ref) {\n                    var x = _ref.x,\n                      y = _ref.y;\n                    return {\n                      x: x,\n                      y: y\n                    };\n                  }\n                } : _evaluate4$limiter, detectOverflowOptions = _objectWithoutPropertiesLoose(_evaluate4, _excluded4);\n                coords = {\n                  x: x,\n                  y: y\n                };\n                _context4.next = 5;\n                return detectOverflow(state, detectOverflowOptions);\n              case 5:\n                overflow = _context4.sent;\n                crossAxis = getSideAxis(getSide(placement));\n                mainAxis = getOppositeAxis(crossAxis);\n                mainAxisCoord = coords[mainAxis];\n                crossAxisCoord = coords[crossAxis];\n                if (checkMainAxis) {\n                  minSide = mainAxis === 'y' ? 'top' : 'left';\n                  maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n                  _min = mainAxisCoord + overflow[minSide];\n                  _max = mainAxisCoord - overflow[maxSide];\n                  mainAxisCoord = clamp(_min, mainAxisCoord, _max);\n                }\n                if (checkCrossAxis) {\n                  _minSide = crossAxis === 'y' ? 'top' : 'left';\n                  _maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n                  _min2 = crossAxisCoord + overflow[_minSide];\n                  _max2 = crossAxisCoord - overflow[_maxSide];\n                  crossAxisCoord = clamp(_min2, crossAxisCoord, _max2);\n                }\n                limitedCoords = limiter.fn(_extends({}, state, _defineProperty(_defineProperty({}, mainAxis, mainAxisCoord), crossAxis, crossAxisCoord)));\n                return _context4.abrupt(\"return\", _extends({}, limitedCoords, {\n                  data: {\n                    x: limitedCoords.x - x,\n                    y: limitedCoords.y - y\n                  }\n                }));\n              case 14:\n              case \"end\":\n                return _context4.stop();\n            }\n          }, _callee4);\n        }))();\n      }\n    };\n  };\n  /**\n   * Built-in `limiter` that will stop `shift()` at a certain point.\n   */\n  var limitShift = function limitShift(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    return {\n      options: options,\n      fn: function fn(state) {\n        var x = state.x,\n          y = state.y,\n          placement = state.placement,\n          rects = state.rects,\n          middlewareData = state.middlewareData;\n        var _evaluate = evaluate(options, state),\n          _evaluate$offset = _evaluate.offset,\n          offset = _evaluate$offset === void 0 ? 0 : _evaluate$offset,\n          _evaluate$mainAxis = _evaluate.mainAxis,\n          checkMainAxis = _evaluate$mainAxis === void 0 ? true : _evaluate$mainAxis,\n          _evaluate$crossAxis = _evaluate.crossAxis,\n          checkCrossAxis = _evaluate$crossAxis === void 0 ? true : _evaluate$crossAxis;\n        var coords = {\n          x: x,\n          y: y\n        };\n        var crossAxis = getSideAxis(placement);\n        var mainAxis = getOppositeAxis(crossAxis);\n        var mainAxisCoord = coords[mainAxis];\n        var crossAxisCoord = coords[crossAxis];\n        var rawOffset = evaluate(offset, state);\n        var computedOffset = typeof rawOffset === 'number' ? {\n          mainAxis: rawOffset,\n          crossAxis: 0\n        } : _extends({\n          mainAxis: 0,\n          crossAxis: 0\n        }, rawOffset);\n        if (checkMainAxis) {\n          var len = mainAxis === 'y' ? 'height' : 'width';\n          var limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n          var limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n          if (mainAxisCoord < limitMin) {\n            mainAxisCoord = limitMin;\n          } else if (mainAxisCoord > limitMax) {\n            mainAxisCoord = limitMax;\n          }\n        }\n        if (checkCrossAxis) {\n          var _middlewareData$offse, _middlewareData$offse2;\n          var _len2 = mainAxis === 'y' ? 'width' : 'height';\n          var isOriginSide = ['top', 'left'].includes(getSide(placement));\n          var _limitMin = rects.reference[crossAxis] - rects.floating[_len2] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n          var _limitMax = rects.reference[crossAxis] + rects.reference[_len2] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n          if (crossAxisCoord < _limitMin) {\n            crossAxisCoord = _limitMin;\n          } else if (crossAxisCoord > _limitMax) {\n            crossAxisCoord = _limitMax;\n          }\n        }\n        return _defineProperty(_defineProperty({}, mainAxis, mainAxisCoord), crossAxis, crossAxisCoord);\n      }\n    };\n  };\n  function getNodeName(node) {\n    if (isNode(node)) {\n      return (node.nodeName || '').toLowerCase();\n    }\n    // Mocked nodes in testing environments may not be instances of Node. By\n    // returning `#document` an infinite loop won't occur.\n    // https://github.com/floating-ui/floating-ui/issues/2317\n    return '#document';\n  }\n  function getWindow(node) {\n    var _node$ownerDocument;\n    return (node == null ? void 0 : (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n  }\n  function getDocumentElement(node) {\n    var _ref;\n    return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n  }\n  function isNode(value) {\n    return value instanceof Node || value instanceof getWindow(value).Node;\n  }\n  function isElement(value) {\n    return value instanceof Element || value instanceof getWindow(value).Element;\n  }\n  function isHTMLElement(value) {\n    return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n  }\n  function isShadowRoot(value) {\n    // Browsers without `ShadowRoot` support.\n    if (typeof ShadowRoot === 'undefined') {\n      return false;\n    }\n    return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n  }\n  function isOverflowElement(element) {\n    var _getComputedStyle = getComputedStyle(element),\n      overflow = _getComputedStyle.overflow,\n      overflowX = _getComputedStyle.overflowX,\n      overflowY = _getComputedStyle.overflowY,\n      display = _getComputedStyle.display;\n    return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n  }\n  function isTableElement(element) {\n    return ['table', 'td', 'th'].includes(getNodeName(element));\n  }\n  function isContainingBlock(element) {\n    var webkit = isWebKit();\n    var css = getComputedStyle(element);\n\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n    return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(function (value) {\n      return (css.willChange || '').includes(value);\n    }) || ['paint', 'layout', 'strict', 'content'].some(function (value) {\n      return (css.contain || '').includes(value);\n    });\n  }\n  function getContainingBlock(element) {\n    var currentNode = getParentNode(element);\n    while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n      if (isContainingBlock(currentNode)) {\n        return currentNode;\n      } else {\n        currentNode = getParentNode(currentNode);\n      }\n    }\n    return null;\n  }\n  function isWebKit() {\n    if (typeof CSS === 'undefined' || !CSS.supports) return false;\n    return CSS.supports('-webkit-backdrop-filter', 'none');\n  }\n  function isLastTraversableNode(node) {\n    return ['html', 'body', '#document'].includes(getNodeName(node));\n  }\n  function getComputedStyle(element) {\n    return getWindow(element).getComputedStyle(element);\n  }\n  function getNodeScroll(element) {\n    if (isElement(element)) {\n      return {\n        scrollLeft: element.scrollLeft,\n        scrollTop: element.scrollTop\n      };\n    }\n    return {\n      scrollLeft: element.pageXOffset,\n      scrollTop: element.pageYOffset\n    };\n  }\n  function getParentNode(node) {\n    if (getNodeName(node) === 'html') {\n      return node;\n    }\n    var result =\n    // Step into the shadow DOM of the parent of a slotted node.\n    node.assignedSlot ||\n    // DOM Element detected.\n    node.parentNode ||\n    // ShadowRoot detected.\n    isShadowRoot(node) && node.host ||\n    // Fallback.\n    getDocumentElement(node);\n    return isShadowRoot(result) ? result.host : result;\n  }\n  function getNearestOverflowAncestor(node) {\n    var parentNode = getParentNode(node);\n    if (isLastTraversableNode(parentNode)) {\n      return node.ownerDocument ? node.ownerDocument.body : node.body;\n    }\n    if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n      return parentNode;\n    }\n    return getNearestOverflowAncestor(parentNode);\n  }\n  function getOverflowAncestors(node, list) {\n    var _node$ownerDocument2;\n    if (list === void 0) {\n      list = [];\n    }\n    var scrollableAncestor = getNearestOverflowAncestor(node);\n    var isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n    var win = getWindow(scrollableAncestor);\n    if (isBody) {\n      return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);\n    }\n    return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor));\n  }\n  function getCssDimensions(element) {\n    var css = getComputedStyle(element);\n    // In testing environments, the `width` and `height` properties are empty\n    // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n    var width = parseFloat(css.width) || 0;\n    var height = parseFloat(css.height) || 0;\n    var hasOffset = isHTMLElement(element);\n    var offsetWidth = hasOffset ? element.offsetWidth : width;\n    var offsetHeight = hasOffset ? element.offsetHeight : height;\n    var shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n    if (shouldFallback) {\n      width = offsetWidth;\n      height = offsetHeight;\n    }\n    return {\n      width: width,\n      height: height,\n      $: shouldFallback\n    };\n  }\n  function unwrapElement(element) {\n    return !isElement(element) ? element.contextElement : element;\n  }\n  function getScale(element) {\n    var domElement = unwrapElement(element);\n    if (!isHTMLElement(domElement)) {\n      return createCoords(1);\n    }\n    var rect = domElement.getBoundingClientRect();\n    var _getCssDimensions = getCssDimensions(domElement),\n      width = _getCssDimensions.width,\n      height = _getCssDimensions.height,\n      $ = _getCssDimensions.$;\n    var x = ($ ? round(rect.width) : rect.width) / width;\n    var y = ($ ? round(rect.height) : rect.height) / height;\n\n    // 0, NaN, or Infinity should always fallback to 1.\n\n    if (!x || !Number.isFinite(x)) {\n      x = 1;\n    }\n    if (!y || !Number.isFinite(y)) {\n      y = 1;\n    }\n    return {\n      x: x,\n      y: y\n    };\n  }\n  var noOffsets = /*#__PURE__*/createCoords(0);\n  function getVisualOffsets(element) {\n    var win = getWindow(element);\n    if (!isWebKit() || !win.visualViewport) {\n      return noOffsets;\n    }\n    return {\n      x: win.visualViewport.offsetLeft,\n      y: win.visualViewport.offsetTop\n    };\n  }\n  function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n    if (isFixed === void 0) {\n      isFixed = false;\n    }\n    if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n      return false;\n    }\n    return isFixed;\n  }\n  function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n    if (includeScale === void 0) {\n      includeScale = false;\n    }\n    if (isFixedStrategy === void 0) {\n      isFixedStrategy = false;\n    }\n    var clientRect = element.getBoundingClientRect();\n    var domElement = unwrapElement(element);\n    var scale = createCoords(1);\n    if (includeScale) {\n      if (offsetParent) {\n        if (isElement(offsetParent)) {\n          scale = getScale(offsetParent);\n        }\n      } else {\n        scale = getScale(element);\n      }\n    }\n    var visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n    var x = (clientRect.left + visualOffsets.x) / scale.x;\n    var y = (clientRect.top + visualOffsets.y) / scale.y;\n    var width = clientRect.width / scale.x;\n    var height = clientRect.height / scale.y;\n    if (domElement) {\n      var win = getWindow(domElement);\n      var offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n      var currentIFrame = win.frameElement;\n      while (currentIFrame && offsetParent && offsetWin !== win) {\n        var iframeScale = getScale(currentIFrame);\n        var iframeRect = currentIFrame.getBoundingClientRect();\n        var css = getComputedStyle(currentIFrame);\n        var left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n        var top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n        x *= iframeScale.x;\n        y *= iframeScale.y;\n        width *= iframeScale.x;\n        height *= iframeScale.y;\n        x += left;\n        y += top;\n        currentIFrame = getWindow(currentIFrame).frameElement;\n      }\n    }\n    return rectToClientRect({\n      width: width,\n      height: height,\n      x: x,\n      y: y\n    });\n  }\n  function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n    var rect = _ref.rect,\n      offsetParent = _ref.offsetParent,\n      strategy = _ref.strategy;\n    var isOffsetParentAnElement = isHTMLElement(offsetParent);\n    var documentElement = getDocumentElement(offsetParent);\n    if (offsetParent === documentElement) {\n      return rect;\n    }\n    var scroll = {\n      scrollLeft: 0,\n      scrollTop: 0\n    };\n    var scale = createCoords(1);\n    var offsets = createCoords(0);\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n      if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n        scroll = getNodeScroll(offsetParent);\n      }\n      if (isHTMLElement(offsetParent)) {\n        var offsetRect = getBoundingClientRect(offsetParent);\n        scale = getScale(offsetParent);\n        offsets.x = offsetRect.x + offsetParent.clientLeft;\n        offsets.y = offsetRect.y + offsetParent.clientTop;\n      }\n    }\n    return {\n      width: rect.width * scale.x,\n      height: rect.height * scale.y,\n      x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n      y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n    };\n  }\n  function getClientRects(element) {\n    return Array.from(element.getClientRects());\n  }\n  function getWindowScrollBarX(element) {\n    // If <html> has a CSS width greater than the viewport, then this will be\n    // incorrect for RTL.\n    return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n  }\n\n  // Gets the entire size of the scrollable document area, even extending outside\n  // of the `<html>` and `<body>` rect bounds if horizontally scrollable.\n  function getDocumentRect(element) {\n    var html = getDocumentElement(element);\n    var scroll = getNodeScroll(element);\n    var body = element.ownerDocument.body;\n    var width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n    var height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n    var x = -scroll.scrollLeft + getWindowScrollBarX(element);\n    var y = -scroll.scrollTop;\n    if (getComputedStyle(body).direction === 'rtl') {\n      x += max(html.clientWidth, body.clientWidth) - width;\n    }\n    return {\n      width: width,\n      height: height,\n      x: x,\n      y: y\n    };\n  }\n  function getViewportRect(element, strategy) {\n    var win = getWindow(element);\n    var html = getDocumentElement(element);\n    var visualViewport = win.visualViewport;\n    var width = html.clientWidth;\n    var height = html.clientHeight;\n    var x = 0;\n    var y = 0;\n    if (visualViewport) {\n      width = visualViewport.width;\n      height = visualViewport.height;\n      var visualViewportBased = isWebKit();\n      if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n        x = visualViewport.offsetLeft;\n        y = visualViewport.offsetTop;\n      }\n    }\n    return {\n      width: width,\n      height: height,\n      x: x,\n      y: y\n    };\n  }\n\n  // Returns the inner client rect, subtracting scrollbars if present.\n  function getInnerBoundingClientRect(element, strategy) {\n    var clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n    var top = clientRect.top + element.clientTop;\n    var left = clientRect.left + element.clientLeft;\n    var scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n    var width = element.clientWidth * scale.x;\n    var height = element.clientHeight * scale.y;\n    var x = left * scale.x;\n    var y = top * scale.y;\n    return {\n      width: width,\n      height: height,\n      x: x,\n      y: y\n    };\n  }\n  function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n    var rect;\n    if (clippingAncestor === 'viewport') {\n      rect = getViewportRect(element, strategy);\n    } else if (clippingAncestor === 'document') {\n      rect = getDocumentRect(getDocumentElement(element));\n    } else if (isElement(clippingAncestor)) {\n      rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n    } else {\n      var visualOffsets = getVisualOffsets(element);\n      rect = _extends({}, clippingAncestor, {\n        x: clippingAncestor.x - visualOffsets.x,\n        y: clippingAncestor.y - visualOffsets.y\n      });\n    }\n    return rectToClientRect(rect);\n  }\n  function hasFixedPositionAncestor(element, stopNode) {\n    var parentNode = getParentNode(element);\n    if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n      return false;\n    }\n    return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n  }\n\n  // A \"clipping ancestor\" is an `overflow` element with the characteristic of\n  // clipping (or hiding) child elements. This returns all clipping ancestors\n  // of the given element up the tree.\n  function getClippingElementAncestors(element, cache) {\n    var cachedResult = cache.get(element);\n    if (cachedResult) {\n      return cachedResult;\n    }\n    var result = getOverflowAncestors(element).filter(function (el) {\n      return isElement(el) && getNodeName(el) !== 'body';\n    });\n    var currentContainingBlockComputedStyle = null;\n    var elementIsFixed = getComputedStyle(element).position === 'fixed';\n    var currentNode = elementIsFixed ? getParentNode(element) : element;\n\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n    while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n      var computedStyle = getComputedStyle(currentNode);\n      var currentNodeIsContaining = isContainingBlock(currentNode);\n      if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n        currentContainingBlockComputedStyle = null;\n      }\n      var shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n      if (shouldDropCurrentNode) {\n        // Drop non-containing blocks.\n        result = result.filter(function (ancestor) {\n          return ancestor !== currentNode;\n        });\n      } else {\n        // Record last containing block for next iteration.\n        currentContainingBlockComputedStyle = computedStyle;\n      }\n      currentNode = getParentNode(currentNode);\n    }\n    cache.set(element, result);\n    return result;\n  }\n\n  // Gets the maximum area that the element is visible in due to any number of\n  // clipping ancestors.\n  function getClippingRect(_ref) {\n    var element = _ref.element,\n      boundary = _ref.boundary,\n      rootBoundary = _ref.rootBoundary,\n      strategy = _ref.strategy;\n    var elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n    var clippingAncestors = [].concat(_toConsumableArray(elementClippingAncestors), [rootBoundary]);\n    var firstClippingAncestor = clippingAncestors[0];\n    var clippingRect = clippingAncestors.reduce(function (accRect, clippingAncestor) {\n      var rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n      accRect.top = max(rect.top, accRect.top);\n      accRect.right = min(rect.right, accRect.right);\n      accRect.bottom = min(rect.bottom, accRect.bottom);\n      accRect.left = max(rect.left, accRect.left);\n      return accRect;\n    }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n    return {\n      width: clippingRect.right - clippingRect.left,\n      height: clippingRect.bottom - clippingRect.top,\n      x: clippingRect.left,\n      y: clippingRect.top\n    };\n  }\n  function getDimensions(element) {\n    return getCssDimensions(element);\n  }\n  function getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n    var isOffsetParentAnElement = isHTMLElement(offsetParent);\n    var documentElement = getDocumentElement(offsetParent);\n    var isFixed = strategy === 'fixed';\n    var rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n    var scroll = {\n      scrollLeft: 0,\n      scrollTop: 0\n    };\n    var offsets = createCoords(0);\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n      if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n        scroll = getNodeScroll(offsetParent);\n      }\n      if (isOffsetParentAnElement) {\n        var offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n        offsets.x = offsetRect.x + offsetParent.clientLeft;\n        offsets.y = offsetRect.y + offsetParent.clientTop;\n      } else if (documentElement) {\n        offsets.x = getWindowScrollBarX(documentElement);\n      }\n    }\n    return {\n      x: rect.left + scroll.scrollLeft - offsets.x,\n      y: rect.top + scroll.scrollTop - offsets.y,\n      width: rect.width,\n      height: rect.height\n    };\n  }\n  function getTrueOffsetParent(element, polyfill) {\n    if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n      return null;\n    }\n    if (polyfill) {\n      return polyfill(element);\n    }\n    return element.offsetParent;\n  }\n\n  // Gets the closest ancestor positioned element. Handles some edge cases,\n  // such as table ancestors and cross browser bugs.\n  function getOffsetParent(element, polyfill) {\n    var window = getWindow(element);\n    if (!isHTMLElement(element)) {\n      return window;\n    }\n    var offsetParent = getTrueOffsetParent(element, polyfill);\n    while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n      offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n    }\n    if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n      return window;\n    }\n    return offsetParent || getContainingBlock(element) || window;\n  }\n  var getElementRects = /*#__PURE__*/function () {\n    var _getElementRects = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(_ref) {\n      var reference, floating, strategy, getOffsetParentFn, getDimensionsFn;\n      return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n        while (1) switch (_context5.prev = _context5.next) {\n          case 0:\n            reference = _ref.reference, floating = _ref.floating, strategy = _ref.strategy;\n            getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n            getDimensionsFn = this.getDimensions;\n            _context5.t0 = getRectRelativeToOffsetParent;\n            _context5.t1 = reference;\n            _context5.next = 7;\n            return getOffsetParentFn(floating);\n          case 7:\n            _context5.t2 = _context5.sent;\n            _context5.t3 = strategy;\n            _context5.t4 = (0, _context5.t0)(_context5.t1, _context5.t2, _context5.t3);\n            _context5.t5 = _extends;\n            _context5.t6 = {\n              x: 0,\n              y: 0\n            };\n            _context5.next = 14;\n            return getDimensionsFn(floating);\n          case 14:\n            _context5.t7 = _context5.sent;\n            _context5.t8 = (0, _context5.t5)(_context5.t6, _context5.t7);\n            return _context5.abrupt(\"return\", {\n              reference: _context5.t4,\n              floating: _context5.t8\n            });\n          case 17:\n          case \"end\":\n            return _context5.stop();\n        }\n      }, _callee5, this);\n    }));\n    function getElementRects(_x6) {\n      return _getElementRects.apply(this, arguments);\n    }\n    return getElementRects;\n  }();\n  function isRTL(element) {\n    return getComputedStyle(element).direction === 'rtl';\n  }\n  var platform = {\n    convertOffsetParentRelativeRectToViewportRelativeRect: convertOffsetParentRelativeRectToViewportRelativeRect,\n    getDocumentElement: getDocumentElement,\n    getClippingRect: getClippingRect,\n    getOffsetParent: getOffsetParent,\n    getElementRects: getElementRects,\n    getClientRects: getClientRects,\n    getDimensions: getDimensions,\n    getScale: getScale,\n    isElement: isElement,\n    isRTL: isRTL\n  };\n\n  // https://samthor.au/2021/observing-dom/\n  function observeMove(element, onMove) {\n    var io = null;\n    var timeoutId;\n    var root = getDocumentElement(element);\n    function cleanup() {\n      clearTimeout(timeoutId);\n      io && io.disconnect();\n      io = null;\n    }\n    function refresh(skip, threshold) {\n      if (skip === void 0) {\n        skip = false;\n      }\n      if (threshold === void 0) {\n        threshold = 1;\n      }\n      cleanup();\n      var _element$getBoundingC = element.getBoundingClientRect(),\n        left = _element$getBoundingC.left,\n        top = _element$getBoundingC.top,\n        width = _element$getBoundingC.width,\n        height = _element$getBoundingC.height;\n      if (!skip) {\n        onMove();\n      }\n      if (!width || !height) {\n        return;\n      }\n      var insetTop = floor(top);\n      var insetRight = floor(root.clientWidth - (left + width));\n      var insetBottom = floor(root.clientHeight - (top + height));\n      var insetLeft = floor(left);\n      var rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n      var options = {\n        rootMargin: rootMargin,\n        threshold: max(0, min(1, threshold)) || 1\n      };\n      var isFirstUpdate = true;\n      function handleObserve(entries) {\n        var ratio = entries[0].intersectionRatio;\n        if (ratio !== threshold) {\n          if (!isFirstUpdate) {\n            return refresh();\n          }\n          if (!ratio) {\n            timeoutId = setTimeout(function () {\n              refresh(false, 1e-7);\n            }, 100);\n          } else {\n            refresh(false, ratio);\n          }\n        }\n        isFirstUpdate = false;\n      }\n\n      // Older browsers don't support a `document` as the root and will throw an\n      // error.\n      try {\n        io = new IntersectionObserver(handleObserve, _extends({}, options, {\n          // Handle <iframe>s\n          root: root.ownerDocument\n        }));\n      } catch (e) {\n        io = new IntersectionObserver(handleObserve, options);\n      }\n      io.observe(element);\n    }\n    refresh(true);\n    return cleanup;\n  }\n\n  /**\n   * Automatically updates the position of the floating element when necessary.\n   * Should only be called when the floating element is mounted on the DOM or\n   * visible on the screen.\n   * @returns cleanup function that should be invoked when the floating element is\n   * removed from the DOM or hidden from the screen.\n   * @see https://floating-ui.com/docs/autoUpdate\n   */\n  function autoUpdate(reference, floating, update, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    var _options = options,\n      _options$ancestorScro = _options.ancestorScroll,\n      ancestorScroll = _options$ancestorScro === void 0 ? true : _options$ancestorScro,\n      _options$ancestorResi = _options.ancestorResize,\n      ancestorResize = _options$ancestorResi === void 0 ? true : _options$ancestorResi,\n      _options$elementResiz = _options.elementResize,\n      elementResize = _options$elementResiz === void 0 ? typeof ResizeObserver === 'function' : _options$elementResiz,\n      _options$layoutShift = _options.layoutShift,\n      layoutShift = _options$layoutShift === void 0 ? typeof IntersectionObserver === 'function' : _options$layoutShift,\n      _options$animationFra = _options.animationFrame,\n      animationFrame = _options$animationFra === void 0 ? false : _options$animationFra;\n    var referenceEl = unwrapElement(reference);\n    var ancestors = ancestorScroll || ancestorResize ? [].concat(_toConsumableArray(referenceEl ? getOverflowAncestors(referenceEl) : []), _toConsumableArray(getOverflowAncestors(floating))) : [];\n    ancestors.forEach(function (ancestor) {\n      ancestorScroll && ancestor.addEventListener('scroll', update, {\n        passive: true\n      });\n      ancestorResize && ancestor.addEventListener('resize', update);\n    });\n    var cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n    var reobserveFrame = -1;\n    var resizeObserver = null;\n    if (elementResize) {\n      resizeObserver = new ResizeObserver(function (_ref) {\n        var _ref7 = _slicedToArray(_ref, 1),\n          firstEntry = _ref7[0];\n        if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n          // Prevent update loops when using the `size` middleware.\n          // https://github.com/floating-ui/floating-ui/issues/1740\n          resizeObserver.unobserve(floating);\n          cancelAnimationFrame(reobserveFrame);\n          reobserveFrame = requestAnimationFrame(function () {\n            resizeObserver && resizeObserver.observe(floating);\n          });\n        }\n        update();\n      });\n      if (referenceEl && !animationFrame) {\n        resizeObserver.observe(referenceEl);\n      }\n      resizeObserver.observe(floating);\n    }\n    var frameId;\n    var prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n    if (animationFrame) {\n      frameLoop();\n    }\n    function frameLoop() {\n      var nextRefRect = getBoundingClientRect(reference);\n      if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n        update();\n      }\n      prevRefRect = nextRefRect;\n      frameId = requestAnimationFrame(frameLoop);\n    }\n    update();\n    return function () {\n      ancestors.forEach(function (ancestor) {\n        ancestorScroll && ancestor.removeEventListener('scroll', update);\n        ancestorResize && ancestor.removeEventListener('resize', update);\n      });\n      cleanupIo && cleanupIo();\n      resizeObserver && resizeObserver.disconnect();\n      resizeObserver = null;\n      if (animationFrame) {\n        cancelAnimationFrame(frameId);\n      }\n    };\n  }\n\n  /**\n   * Computes the `x` and `y` coordinates that will place the floating element\n   * next to a reference element when it is given a certain CSS positioning\n   * strategy.\n   */\n  var computePosition = function computePosition(reference, floating, options) {\n    // This caches the expensive `getClippingElementAncestors` function so that\n    // multiple lifecycle resets re-use the same result. It only lives for a\n    // single call. If other functions become expensive, we can add them as well.\n    var cache = new Map();\n    var mergedOptions = _extends({\n      platform: platform\n    }, options);\n    var platformWithCache = _extends({}, mergedOptions.platform, {\n      _c: cache\n    });\n    return computePosition$1(reference, floating, _extends({}, mergedOptions, {\n      platform: platformWithCache\n    }));\n  };\n\n  /**\n   * Floating UI Options\n   *\n   * @typedef {object} FloatingUIOptions\n   */\n\n  /**\n   * Determines options for the tooltip and initializes event listeners.\n   *\n   * @param {Step} step The step instance\n   *\n   * @return {FloatingUIOptions}\n   */\n  function setupTooltip(step) {\n    if (step.cleanup) {\n      step.cleanup();\n    }\n    var attachToOptions = step._getResolvedAttachToOptions();\n    var target = attachToOptions.element;\n    var floatingUIOptions = getFloatingUIOptions(attachToOptions, step);\n    var shouldCenter = shouldCenterStep(attachToOptions);\n    if (shouldCenter) {\n      target = document.body;\n      var content = step.shepherdElementComponent.getElement();\n      content.classList.add('shepherd-centered');\n    }\n    step.cleanup = autoUpdate(target, step.el, function () {\n      // The element might have already been removed by the end of the tour.\n      if (!step.el) {\n        step.cleanup();\n        return;\n      }\n      setPosition(target, step, floatingUIOptions, shouldCenter);\n    });\n    step.target = attachToOptions.element;\n    return floatingUIOptions;\n  }\n\n  /**\n   * Merge tooltip options handling nested keys.\n   *\n   * @param tourOptions - The default tour options.\n   * @param options - Step specific options.\n   *\n   * @return {floatingUIOptions: FloatingUIOptions}\n   */\n  function mergeTooltipConfig(tourOptions, options) {\n    return {\n      floatingUIOptions: cjs(tourOptions.floatingUIOptions || {}, options.floatingUIOptions || {})\n    };\n  }\n\n  /**\n   * Cleanup function called when the step is closed/destroyed.\n   *\n   * @param {Step} step\n   */\n  function destroyTooltip(step) {\n    if (step.cleanup) {\n      step.cleanup();\n    }\n    step.cleanup = null;\n  }\n\n  /**\n   *\n   * @return {Promise<*>}\n   */\n  function setPosition(target, step, floatingUIOptions, shouldCenter) {\n    return computePosition(target, step.el, floatingUIOptions).then(floatingUIposition(step, shouldCenter))\n    // Wait before forcing focus.\n    .then(function (step) {\n      return new Promise(function (resolve) {\n        setTimeout(function () {\n          return resolve(step);\n        }, 300);\n      });\n    })\n    // Replaces focusAfterRender modifier.\n    .then(function (step) {\n      if (step && step.el) {\n        step.el.focus({\n          preventScroll: true\n        });\n      }\n    });\n  }\n\n  /**\n   *\n   * @param step\n   * @param shouldCenter\n   * @return {function({x: *, y: *, placement: *, middlewareData: *}): Promise<unknown>}\n   */\n  function floatingUIposition(step, shouldCenter) {\n    return function (_ref8) {\n      var x = _ref8.x,\n        y = _ref8.y,\n        placement = _ref8.placement,\n        middlewareData = _ref8.middlewareData;\n      if (!step.el) {\n        return step;\n      }\n      if (shouldCenter) {\n        Object.assign(step.el.style, {\n          position: 'fixed',\n          left: '50%',\n          top: '50%',\n          transform: 'translate(-50%, -50%)'\n        });\n      } else {\n        Object.assign(step.el.style, {\n          position: 'absolute',\n          left: \"\".concat(x, \"px\"),\n          top: \"\".concat(y, \"px\")\n        });\n      }\n      step.el.dataset.popperPlacement = placement;\n      placeArrow(step.el, middlewareData);\n      return step;\n    };\n  }\n\n  /**\n   *\n   * @param el\n   * @param middlewareData\n   */\n  function placeArrow(el, middlewareData) {\n    var arrowEl = el.querySelector('.shepherd-arrow');\n    if (arrowEl && middlewareData.arrow) {\n      var _middlewareData$arrow = middlewareData.arrow,\n        arrowX = _middlewareData$arrow.x,\n        arrowY = _middlewareData$arrow.y;\n      Object.assign(arrowEl.style, {\n        left: arrowX != null ? \"\".concat(arrowX, \"px\") : '',\n        top: arrowY != null ? \"\".concat(arrowY, \"px\") : ''\n      });\n    }\n  }\n\n  /**\n   * Gets the `Floating UI` options from a set of base `attachTo` options\n   * @param attachToOptions\n   * @param {Step} step The step instance\n   * @return {Object}\n   * @private\n   */\n  function getFloatingUIOptions(attachToOptions, step) {\n    var options = {\n      strategy: 'absolute',\n      middleware: []\n    };\n    var arrowEl = addArrow(step);\n    var shouldCenter = shouldCenterStep(attachToOptions);\n    if (!shouldCenter) {\n      options.middleware.push(flip(),\n      // Replicate PopperJS default behavior.\n      shift({\n        limiter: limitShift(),\n        crossAxis: true\n      }));\n      if (arrowEl) {\n        options.middleware.push(arrow({\n          element: arrowEl\n        }));\n      }\n      options.placement = attachToOptions.on;\n    }\n    return cjs(step.options.floatingUIOptions || {}, options);\n  }\n\n  /**\n   * @param {Step} step\n   * @return {HTMLElement|false|null}\n   */\n  function addArrow(step) {\n    if (step.options.arrow && step.el) {\n      return step.el.querySelector('.shepherd-arrow');\n    }\n    return false;\n  }\n  function noop() {}\n  function assign(tar, src) {\n    // @ts-ignore\n    for (var k in src) tar[k] = src[k];\n    return tar;\n  }\n  function run(fn) {\n    return fn();\n  }\n  function blank_object() {\n    return Object.create(null);\n  }\n  function run_all(fns) {\n    fns.forEach(run);\n  }\n  function is_function(thing) {\n    return typeof thing === 'function';\n  }\n  function safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || a && _typeof(a) === 'object' || typeof a === 'function';\n  }\n  function is_empty(obj) {\n    return Object.keys(obj).length === 0;\n  }\n  function append(target, node) {\n    target.appendChild(node);\n  }\n  function insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n  }\n  function detach(node) {\n    if (node.parentNode) {\n      node.parentNode.removeChild(node);\n    }\n  }\n  function destroy_each(iterations, detaching) {\n    for (var i = 0; i < iterations.length; i += 1) {\n      if (iterations[i]) iterations[i].d(detaching);\n    }\n  }\n  function element(name) {\n    return document.createElement(name);\n  }\n  function svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n  }\n  function text(data) {\n    return document.createTextNode(data);\n  }\n  function space() {\n    return text(' ');\n  }\n  function empty() {\n    return text('');\n  }\n  function listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return function () {\n      return node.removeEventListener(event, handler, options);\n    };\n  }\n  function attr(node, attribute, value) {\n    if (value == null) node.removeAttribute(attribute);else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);\n  }\n  /**\n   * List of attributes that should always be set through the attr method,\n   * because updating them through the property setter doesn't work reliably.\n   * In the example of `width`/`height`, the problem is that the setter only\n   * accepts numeric values, but the attribute can also be set to a string like `50%`.\n   * If this list becomes too big, rethink this approach.\n   */\n  var always_set_through_set_attribute = ['width', 'height'];\n  function set_attributes(node, attributes) {\n    // @ts-ignore\n    var descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (var key in attributes) {\n      if (attributes[key] == null) {\n        node.removeAttribute(key);\n      } else if (key === 'style') {\n        node.style.cssText = attributes[key];\n      } else if (key === '__value') {\n        node.value = node[key] = attributes[key];\n      } else if (descriptors[key] && descriptors[key].set && always_set_through_set_attribute.indexOf(key) === -1) {\n        node[key] = attributes[key];\n      } else {\n        attr(node, key, attributes[key]);\n      }\n    }\n  }\n  function children(element) {\n    return Array.from(element.childNodes);\n  }\n  function toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n  }\n  var current_component;\n  function set_current_component(component) {\n    current_component = component;\n  }\n  function get_current_component() {\n    if (!current_component) throw new Error('Function called outside component initialization');\n    return current_component;\n  }\n  /**\n   * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.\n   * It must be called during the component's initialisation (but doesn't need to live *inside* the component;\n   * it can be called from an external module).\n   *\n   * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).\n   *\n   * https://svelte.dev/docs#run-time-svelte-onmount\n   */\n  function onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n  }\n  /**\n   * Schedules a callback to run immediately after the component has been updated.\n   *\n   * The first time the callback runs will be after the initial `onMount`\n   */\n  function afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n  }\n  var dirty_components = [];\n  var binding_callbacks = [];\n  var render_callbacks = [];\n  var flush_callbacks = [];\n  var resolved_promise = /* @__PURE__ */Promise.resolve();\n  var update_scheduled = false;\n  function schedule_update() {\n    if (!update_scheduled) {\n      update_scheduled = true;\n      resolved_promise.then(flush);\n    }\n  }\n  function add_render_callback(fn) {\n    render_callbacks.push(fn);\n  }\n  // flush() calls callbacks in this order:\n  // 1. All beforeUpdate callbacks, in order: parents before children\n  // 2. All bind:this callbacks, in reverse order: children before parents.\n  // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n  //    for afterUpdates called during the initial onMount, which are called in\n  //    reverse order: children before parents.\n  // Since callbacks might update component values, which could trigger another\n  // call to flush(), the following steps guard against this:\n  // 1. During beforeUpdate, any updated components will be added to the\n  //    dirty_components array and will cause a reentrant call to flush(). Because\n  //    the flush index is kept outside the function, the reentrant call will pick\n  //    up where the earlier call left off and go through all dirty components. The\n  //    current_component value is saved and restored so that the reentrant call will\n  //    not interfere with the \"parent\" flush() call.\n  // 2. bind:this callbacks cannot trigger new flush() calls.\n  // 3. During afterUpdate, any updated components will NOT have their afterUpdate\n  //    callback called a second time; the seen_callbacks set, outside the flush()\n  //    function, guarantees this behavior.\n  var seen_callbacks = new Set();\n  var flushidx = 0; // Do *not* move this inside the flush() function\n  function flush() {\n    // Do not reenter flush while dirty components are updated, as this can\n    // result in an infinite loop. Instead, let the inner flush handle it.\n    // Reentrancy is ok afterwards for bindings etc.\n    if (flushidx !== 0) {\n      return;\n    }\n    var saved_component = current_component;\n    do {\n      // first, call beforeUpdate functions\n      // and update components\n      try {\n        while (flushidx < dirty_components.length) {\n          var component = dirty_components[flushidx];\n          flushidx++;\n          set_current_component(component);\n          update(component.$$);\n        }\n      } catch (e) {\n        // reset dirty state to not end up in a deadlocked state and then rethrow\n        dirty_components.length = 0;\n        flushidx = 0;\n        throw e;\n      }\n      set_current_component(null);\n      dirty_components.length = 0;\n      flushidx = 0;\n      while (binding_callbacks.length) binding_callbacks.pop()();\n      // then, once components are updated, call\n      // afterUpdate functions. This may cause\n      // subsequent updates...\n      for (var i = 0; i < render_callbacks.length; i += 1) {\n        var callback = render_callbacks[i];\n        if (!seen_callbacks.has(callback)) {\n          // ...so guard against infinite loops\n          seen_callbacks.add(callback);\n          callback();\n        }\n      }\n      render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n      flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    seen_callbacks.clear();\n    set_current_component(saved_component);\n  }\n  function update($$) {\n    if ($$.fragment !== null) {\n      $$.update();\n      run_all($$.before_update);\n      var dirty = $$.dirty;\n      $$.dirty = [-1];\n      $$.fragment && $$.fragment.p($$.ctx, dirty);\n      $$.after_update.forEach(add_render_callback);\n    }\n  }\n  /**\n   * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.\n   */\n  function flush_render_callbacks(fns) {\n    var filtered = [];\n    var targets = [];\n    render_callbacks.forEach(function (c) {\n      return fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c);\n    });\n    targets.forEach(function (c) {\n      return c();\n    });\n    render_callbacks = filtered;\n  }\n  var outroing = new Set();\n  var outros;\n  function group_outros() {\n    outros = {\n      r: 0,\n      c: [],\n      p: outros // parent group\n    };\n  }\n  function check_outros() {\n    if (!outros.r) {\n      run_all(outros.c);\n    }\n    outros = outros.p;\n  }\n  function transition_in(block, local) {\n    if (block && block.i) {\n      outroing.delete(block);\n      block.i(local);\n    }\n  }\n  function transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n      if (outroing.has(block)) return;\n      outroing.add(block);\n      outros.c.push(function () {\n        outroing.delete(block);\n        if (callback) {\n          if (detach) block.d(1);\n          callback();\n        }\n      });\n      block.o(local);\n    } else if (callback) {\n      callback();\n    }\n  }\n  function get_spread_update(levels, updates) {\n    var update = {};\n    var to_null_out = {};\n    var accounted_for = {\n      $$scope: 1\n    };\n    var i = levels.length;\n    while (i--) {\n      var o = levels[i];\n      var n = updates[i];\n      if (n) {\n        for (var key in o) {\n          if (!(key in n)) to_null_out[key] = 1;\n        }\n        for (var _key2 in n) {\n          if (!accounted_for[_key2]) {\n            update[_key2] = n[_key2];\n            accounted_for[_key2] = 1;\n          }\n        }\n        levels[i] = n;\n      } else {\n        for (var _key3 in o) {\n          accounted_for[_key3] = 1;\n        }\n      }\n    }\n    for (var _key4 in to_null_out) {\n      if (!(_key4 in update)) update[_key4] = undefined;\n    }\n    return update;\n  }\n  function create_component(block) {\n    block && block.c();\n  }\n  function mount_component(component, target, anchor, customElement) {\n    var _component$$$ = component.$$,\n      fragment = _component$$$.fragment,\n      after_update = _component$$$.after_update;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n      // onMount happens before the initial afterUpdate\n      add_render_callback(function () {\n        var new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n        // if the component was destroyed immediately\n        // it will update the `$$.on_destroy` reference to `null`.\n        // the destructured on_destroy may still reference to the old array\n        if (component.$$.on_destroy) {\n          var _component$$$$on_dest;\n          (_component$$$$on_dest = component.$$.on_destroy).push.apply(_component$$$$on_dest, _toConsumableArray(new_on_destroy));\n        } else {\n          // Edge case - component was destroyed immediately,\n          // most likely as a result of a binding initialising\n          run_all(new_on_destroy);\n        }\n        component.$$.on_mount = [];\n      });\n    }\n    after_update.forEach(add_render_callback);\n  }\n  function destroy_component(component, detaching) {\n    var $$ = component.$$;\n    if ($$.fragment !== null) {\n      flush_render_callbacks($$.after_update);\n      run_all($$.on_destroy);\n      $$.fragment && $$.fragment.d(detaching);\n      // TODO null out other refs, including component.$$ (but need to\n      // preserve final state?)\n      $$.on_destroy = $$.fragment = null;\n      $$.ctx = [];\n    }\n  }\n  function make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n      dirty_components.push(component);\n      schedule_update();\n      component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n  }\n  function init(component, options, instance, create_fragment, not_equal, props, append_styles) {\n    var dirty = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : [-1];\n    var parent_component = current_component;\n    set_current_component(component);\n    var $$ = component.$$ = {\n      fragment: null,\n      ctx: [],\n      // state\n      props: props,\n      update: noop,\n      not_equal: not_equal,\n      bound: blank_object(),\n      // lifecycle\n      on_mount: [],\n      on_destroy: [],\n      on_disconnect: [],\n      before_update: [],\n      after_update: [],\n      context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n      // everything else\n      callbacks: blank_object(),\n      dirty: dirty,\n      skip_bound: false,\n      root: options.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    var ready = false;\n    $$.ctx = instance ? instance(component, options.props || {}, function (i, ret) {\n      var value = (arguments.length <= 2 ? 0 : arguments.length - 2) ? arguments.length <= 2 ? undefined : arguments[2] : ret;\n      if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n        if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);\n        if (ready) make_dirty(component, i);\n      }\n      return ret;\n    }) : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n      if (options.hydrate) {\n        var nodes = children(options.target);\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        $$.fragment && $$.fragment.l(nodes);\n        nodes.forEach(detach);\n      } else {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        $$.fragment && $$.fragment.c();\n      }\n      if (options.intro) transition_in(component.$$.fragment);\n      mount_component(component, options.target, options.anchor, options.customElement);\n      flush();\n    }\n    set_current_component(parent_component);\n  }\n  /**\n   * Base class for Svelte components. Used when dev=false.\n   */\n  var SvelteComponent = /*#__PURE__*/function () {\n    function SvelteComponent() {\n      _classCallCheck(this, SvelteComponent);\n    }\n    _createClass(SvelteComponent, [{\n      key: \"$destroy\",\n      value: function $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n      }\n    }, {\n      key: \"$on\",\n      value: function $on(type, callback) {\n        if (!is_function(callback)) {\n          return noop;\n        }\n        var callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n        callbacks.push(callback);\n        return function () {\n          var index = callbacks.indexOf(callback);\n          if (index !== -1) callbacks.splice(index, 1);\n        };\n      }\n    }, {\n      key: \"$set\",\n      value: function $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n          this.$$.skip_bound = true;\n          this.$$set($$props);\n          this.$$.skip_bound = false;\n        }\n      }\n    }]);\n    return SvelteComponent;\n  }();\n  /* src/js/components/shepherd-button.svelte generated by Svelte v3.59.2 */\n  function create_fragment$8(ctx) {\n    var button;\n    var button_aria_label_value;\n    var button_class_value;\n    var mounted;\n    var dispose;\n    return {\n      c: function c() {\n        button = element(\"button\");\n        attr(button, \"aria-label\", button_aria_label_value = /*label*/ctx[3] ? /*label*/ctx[3] : null);\n        attr(button, \"class\", button_class_value = \"\".concat( /*classes*/ctx[1] || '', \" shepherd-button \").concat( /*secondary*/ctx[4] ? 'shepherd-button-secondary' : ''));\n        button.disabled = /*disabled*/ctx[2];\n        attr(button, \"tabindex\", \"0\");\n      },\n      m: function m(target, anchor) {\n        insert(target, button, anchor);\n        button.innerHTML = /*text*/ctx[5];\n        if (!mounted) {\n          dispose = listen(button, \"click\", function () {\n            if (is_function( /*action*/ctx[0])) /*action*/ctx[0].apply(this, arguments);\n          });\n          mounted = true;\n        }\n      },\n      p: function p(new_ctx, _ref9) {\n        var _ref10 = _slicedToArray(_ref9, 1),\n          dirty = _ref10[0];\n        ctx = new_ctx;\n        if (dirty & /*text*/32) button.innerHTML = /*text*/ctx[5];\n        if (dirty & /*label*/8 && button_aria_label_value !== (button_aria_label_value = /*label*/ctx[3] ? /*label*/ctx[3] : null)) {\n          attr(button, \"aria-label\", button_aria_label_value);\n        }\n        if (dirty & /*classes, secondary*/18 && button_class_value !== (button_class_value = \"\".concat( /*classes*/ctx[1] || '', \" shepherd-button \").concat( /*secondary*/ctx[4] ? 'shepherd-button-secondary' : ''))) {\n          attr(button, \"class\", button_class_value);\n        }\n        if (dirty & /*disabled*/4) {\n          button.disabled = /*disabled*/ctx[2];\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(button);\n        mounted = false;\n        dispose();\n      }\n    };\n  }\n  function instance$8($$self, $$props, $$invalidate) {\n    var config = $$props.config,\n      step = $$props.step;\n    var action, classes, disabled, label, secondary, text;\n    function getConfigOption(option) {\n      if (isFunction(option)) {\n        return option = option.call(step);\n      }\n      return option;\n    }\n    $$self.$$set = function ($$props) {\n      if ('config' in $$props) $$invalidate(6, config = $$props.config);\n      if ('step' in $$props) $$invalidate(7, step = $$props.step);\n    };\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty & /*config, step*/192) {\n        {\n          $$invalidate(0, action = config.action ? config.action.bind(step.tour) : null);\n          $$invalidate(1, classes = config.classes);\n          $$invalidate(2, disabled = config.disabled ? getConfigOption(config.disabled) : false);\n          $$invalidate(3, label = config.label ? getConfigOption(config.label) : null);\n          $$invalidate(4, secondary = config.secondary);\n          $$invalidate(5, text = config.text ? getConfigOption(config.text) : null);\n        }\n      }\n    };\n    return [action, classes, disabled, label, secondary, text, config, step];\n  }\n  var Shepherd_button = /*#__PURE__*/function (_SvelteComponent) {\n    _inherits(Shepherd_button, _SvelteComponent);\n    function Shepherd_button(options) {\n      var _this3;\n      _classCallCheck(this, Shepherd_button);\n      _this3 = _callSuper(this, Shepherd_button);\n      init(_assertThisInitialized(_this3), options, instance$8, create_fragment$8, safe_not_equal, {\n        config: 6,\n        step: 7\n      });\n      return _this3;\n    }\n    return _createClass(Shepherd_button);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-footer.svelte generated by Svelte v3.59.2 */\n  function get_each_context(ctx, list, i) {\n    var child_ctx = ctx.slice();\n    child_ctx[2] = list[i];\n    return child_ctx;\n  }\n\n  // (24:4) {#if buttons}\n  function create_if_block$3(ctx) {\n    var each_1_anchor;\n    var current;\n    var each_value = /*buttons*/ctx[1];\n    var each_blocks = [];\n    for (var i = 0; i < each_value.length; i += 1) {\n      each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));\n    }\n    var out = function out(i) {\n      return transition_out(each_blocks[i], 1, 1, function () {\n        each_blocks[i] = null;\n      });\n    };\n    return {\n      c: function c() {\n        for (var _i = 0; _i < each_blocks.length; _i += 1) {\n          each_blocks[_i].c();\n        }\n        each_1_anchor = empty();\n      },\n      m: function m(target, anchor) {\n        for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {\n          if (each_blocks[_i2]) {\n            each_blocks[_i2].m(target, anchor);\n          }\n        }\n        insert(target, each_1_anchor, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        if (dirty & /*buttons, step*/3) {\n          each_value = /*buttons*/ctx[1];\n          var _i3;\n          for (_i3 = 0; _i3 < each_value.length; _i3 += 1) {\n            var child_ctx = get_each_context(ctx, each_value, _i3);\n            if (each_blocks[_i3]) {\n              each_blocks[_i3].p(child_ctx, dirty);\n              transition_in(each_blocks[_i3], 1);\n            } else {\n              each_blocks[_i3] = create_each_block(child_ctx);\n              each_blocks[_i3].c();\n              transition_in(each_blocks[_i3], 1);\n              each_blocks[_i3].m(each_1_anchor.parentNode, each_1_anchor);\n            }\n          }\n          group_outros();\n          for (_i3 = each_value.length; _i3 < each_blocks.length; _i3 += 1) {\n            out(_i3);\n          }\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n        for (var _i4 = 0; _i4 < each_value.length; _i4 += 1) {\n          transition_in(each_blocks[_i4]);\n        }\n        current = true;\n      },\n      o: function o(local) {\n        each_blocks = each_blocks.filter(Boolean);\n        for (var _i5 = 0; _i5 < each_blocks.length; _i5 += 1) {\n          transition_out(each_blocks[_i5]);\n        }\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_each(each_blocks, detaching);\n        if (detaching) detach(each_1_anchor);\n      }\n    };\n  }\n\n  // (25:8) {#each buttons as config}\n  function create_each_block(ctx) {\n    var shepherdbutton;\n    var current;\n    shepherdbutton = new Shepherd_button({\n      props: {\n        config: /*config*/ctx[2],\n        step: /*step*/ctx[0]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdbutton.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdbutton, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdbutton_changes = {};\n        if (dirty & /*buttons*/2) shepherdbutton_changes.config = /*config*/ctx[2];\n        if (dirty & /*step*/1) shepherdbutton_changes.step = /*step*/ctx[0];\n        shepherdbutton.$set(shepherdbutton_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdbutton.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdbutton.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdbutton, detaching);\n      }\n    };\n  }\n  function create_fragment$7(ctx) {\n    var footer;\n    var current;\n    var if_block = /*buttons*/ctx[1] && create_if_block$3(ctx);\n    return {\n      c: function c() {\n        footer = element(\"footer\");\n        if (if_block) if_block.c();\n        attr(footer, \"class\", \"shepherd-footer\");\n      },\n      m: function m(target, anchor) {\n        insert(target, footer, anchor);\n        if (if_block) if_block.m(footer, null);\n        current = true;\n      },\n      p: function p(ctx, _ref11) {\n        var _ref12 = _slicedToArray(_ref11, 1),\n          dirty = _ref12[0];\n        if ( /*buttons*/ctx[1]) {\n          if (if_block) {\n            if_block.p(ctx, dirty);\n            if (dirty & /*buttons*/2) {\n              transition_in(if_block, 1);\n            }\n          } else {\n            if_block = create_if_block$3(ctx);\n            if_block.c();\n            transition_in(if_block, 1);\n            if_block.m(footer, null);\n          }\n        } else if (if_block) {\n          group_outros();\n          transition_out(if_block, 1, 1, function () {\n            if_block = null;\n          });\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(if_block);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(if_block);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(footer);\n        if (if_block) if_block.d();\n      }\n    };\n  }\n  function instance$7($$self, $$props, $$invalidate) {\n    var buttons;\n    var step = $$props.step;\n    $$self.$$set = function ($$props) {\n      if ('step' in $$props) $$invalidate(0, step = $$props.step);\n    };\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty & /*step*/1) {\n        $$invalidate(1, buttons = step.options.buttons);\n      }\n    };\n    return [step, buttons];\n  }\n  var Shepherd_footer = /*#__PURE__*/function (_SvelteComponent2) {\n    _inherits(Shepherd_footer, _SvelteComponent2);\n    function Shepherd_footer(options) {\n      var _this4;\n      _classCallCheck(this, Shepherd_footer);\n      _this4 = _callSuper(this, Shepherd_footer);\n      init(_assertThisInitialized(_this4), options, instance$7, create_fragment$7, safe_not_equal, {\n        step: 0\n      });\n      return _this4;\n    }\n    return _createClass(Shepherd_footer);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-cancel-icon.svelte generated by Svelte v3.59.2 */\n  function create_fragment$6(ctx) {\n    var button;\n    var span;\n    var button_aria_label_value;\n    var mounted;\n    var dispose;\n    return {\n      c: function c() {\n        button = element(\"button\");\n        span = element(\"span\");\n        span.textContent = \"\";\n        attr(span, \"aria-hidden\", \"true\");\n        attr(button, \"aria-label\", button_aria_label_value = /*cancelIcon*/ctx[0].label ? /*cancelIcon*/ctx[0].label : 'Close Tour');\n        attr(button, \"class\", \"shepherd-cancel-icon\");\n        attr(button, \"type\", \"button\");\n      },\n      m: function m(target, anchor) {\n        insert(target, button, anchor);\n        append(button, span);\n        if (!mounted) {\n          dispose = listen(button, \"click\", /*handleCancelClick*/ctx[1]);\n          mounted = true;\n        }\n      },\n      p: function p(ctx, _ref13) {\n        var _ref14 = _slicedToArray(_ref13, 1),\n          dirty = _ref14[0];\n        if (dirty & /*cancelIcon*/1 && button_aria_label_value !== (button_aria_label_value = /*cancelIcon*/ctx[0].label ? /*cancelIcon*/ctx[0].label : 'Close Tour')) {\n          attr(button, \"aria-label\", button_aria_label_value);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(button);\n        mounted = false;\n        dispose();\n      }\n    };\n  }\n  function instance$6($$self, $$props, $$invalidate) {\n    var cancelIcon = $$props.cancelIcon,\n      step = $$props.step;\n\n    /**\n    * Add a click listener to the cancel link that cancels the tour\n    */\n    var handleCancelClick = function handleCancelClick(e) {\n      e.preventDefault();\n      step.cancel();\n    };\n    $$self.$$set = function ($$props) {\n      if ('cancelIcon' in $$props) $$invalidate(0, cancelIcon = $$props.cancelIcon);\n      if ('step' in $$props) $$invalidate(2, step = $$props.step);\n    };\n    return [cancelIcon, handleCancelClick, step];\n  }\n  var Shepherd_cancel_icon = /*#__PURE__*/function (_SvelteComponent3) {\n    _inherits(Shepherd_cancel_icon, _SvelteComponent3);\n    function Shepherd_cancel_icon(options) {\n      var _this5;\n      _classCallCheck(this, Shepherd_cancel_icon);\n      _this5 = _callSuper(this, Shepherd_cancel_icon);\n      init(_assertThisInitialized(_this5), options, instance$6, create_fragment$6, safe_not_equal, {\n        cancelIcon: 0,\n        step: 2\n      });\n      return _this5;\n    }\n    return _createClass(Shepherd_cancel_icon);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-title.svelte generated by Svelte v3.59.2 */\n  function create_fragment$5(ctx) {\n    var h3;\n    return {\n      c: function c() {\n        h3 = element(\"h3\");\n        attr(h3, \"id\", /*labelId*/ctx[1]);\n        attr(h3, \"class\", \"shepherd-title\");\n      },\n      m: function m(target, anchor) {\n        insert(target, h3, anchor);\n        /*h3_binding*/\n        ctx[3](h3);\n      },\n      p: function p(ctx, _ref15) {\n        var _ref16 = _slicedToArray(_ref15, 1),\n          dirty = _ref16[0];\n        if (dirty & /*labelId*/2) {\n          attr(h3, \"id\", /*labelId*/ctx[1]);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(h3);\n        /*h3_binding*/\n        ctx[3](null);\n      }\n    };\n  }\n  function instance$5($$self, $$props, $$invalidate) {\n    var labelId = $$props.labelId,\n      element = $$props.element,\n      title = $$props.title;\n    afterUpdate(function () {\n      if (isFunction(title)) {\n        $$invalidate(2, title = title());\n      }\n      $$invalidate(0, element.innerHTML = title, element);\n    });\n    function h3_binding($$value) {\n      binding_callbacks[$$value ? 'unshift' : 'push'](function () {\n        element = $$value;\n        $$invalidate(0, element);\n      });\n    }\n    $$self.$$set = function ($$props) {\n      if ('labelId' in $$props) $$invalidate(1, labelId = $$props.labelId);\n      if ('element' in $$props) $$invalidate(0, element = $$props.element);\n      if ('title' in $$props) $$invalidate(2, title = $$props.title);\n    };\n    return [element, labelId, title, h3_binding];\n  }\n  var Shepherd_title = /*#__PURE__*/function (_SvelteComponent4) {\n    _inherits(Shepherd_title, _SvelteComponent4);\n    function Shepherd_title(options) {\n      var _this6;\n      _classCallCheck(this, Shepherd_title);\n      _this6 = _callSuper(this, Shepherd_title);\n      init(_assertThisInitialized(_this6), options, instance$5, create_fragment$5, safe_not_equal, {\n        labelId: 1,\n        element: 0,\n        title: 2\n      });\n      return _this6;\n    }\n    return _createClass(Shepherd_title);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-header.svelte generated by Svelte v3.59.2 */\n  function create_if_block_1$1(ctx) {\n    var shepherdtitle;\n    var current;\n    shepherdtitle = new Shepherd_title({\n      props: {\n        labelId: /*labelId*/ctx[0],\n        title: /*title*/ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdtitle.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdtitle, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdtitle_changes = {};\n        if (dirty & /*labelId*/1) shepherdtitle_changes.labelId = /*labelId*/ctx[0];\n        if (dirty & /*title*/4) shepherdtitle_changes.title = /*title*/ctx[2];\n        shepherdtitle.$set(shepherdtitle_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdtitle.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdtitle.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdtitle, detaching);\n      }\n    };\n  }\n\n  // (39:4) {#if cancelIcon && cancelIcon.enabled}\n  function create_if_block$2(ctx) {\n    var shepherdcancelicon;\n    var current;\n    shepherdcancelicon = new Shepherd_cancel_icon({\n      props: {\n        cancelIcon: /*cancelIcon*/ctx[3],\n        step: /*step*/ctx[1]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdcancelicon.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdcancelicon, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdcancelicon_changes = {};\n        if (dirty & /*cancelIcon*/8) shepherdcancelicon_changes.cancelIcon = /*cancelIcon*/ctx[3];\n        if (dirty & /*step*/2) shepherdcancelicon_changes.step = /*step*/ctx[1];\n        shepherdcancelicon.$set(shepherdcancelicon_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdcancelicon.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdcancelicon.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdcancelicon, detaching);\n      }\n    };\n  }\n  function create_fragment$4(ctx) {\n    var header;\n    var t;\n    var current;\n    var if_block0 = /*title*/ctx[2] && create_if_block_1$1(ctx);\n    var if_block1 = /*cancelIcon*/ctx[3] && /*cancelIcon*/ctx[3].enabled && create_if_block$2(ctx);\n    return {\n      c: function c() {\n        header = element(\"header\");\n        if (if_block0) if_block0.c();\n        t = space();\n        if (if_block1) if_block1.c();\n        attr(header, \"class\", \"shepherd-header\");\n      },\n      m: function m(target, anchor) {\n        insert(target, header, anchor);\n        if (if_block0) if_block0.m(header, null);\n        append(header, t);\n        if (if_block1) if_block1.m(header, null);\n        current = true;\n      },\n      p: function p(ctx, _ref17) {\n        var _ref18 = _slicedToArray(_ref17, 1),\n          dirty = _ref18[0];\n        if ( /*title*/ctx[2]) {\n          if (if_block0) {\n            if_block0.p(ctx, dirty);\n            if (dirty & /*title*/4) {\n              transition_in(if_block0, 1);\n            }\n          } else {\n            if_block0 = create_if_block_1$1(ctx);\n            if_block0.c();\n            transition_in(if_block0, 1);\n            if_block0.m(header, t);\n          }\n        } else if (if_block0) {\n          group_outros();\n          transition_out(if_block0, 1, 1, function () {\n            if_block0 = null;\n          });\n          check_outros();\n        }\n        if ( /*cancelIcon*/ctx[3] && /*cancelIcon*/ctx[3].enabled) {\n          if (if_block1) {\n            if_block1.p(ctx, dirty);\n            if (dirty & /*cancelIcon*/8) {\n              transition_in(if_block1, 1);\n            }\n          } else {\n            if_block1 = create_if_block$2(ctx);\n            if_block1.c();\n            transition_in(if_block1, 1);\n            if_block1.m(header, null);\n          }\n        } else if (if_block1) {\n          group_outros();\n          transition_out(if_block1, 1, 1, function () {\n            if_block1 = null;\n          });\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(if_block0);\n        transition_in(if_block1);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(if_block0);\n        transition_out(if_block1);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(header);\n        if (if_block0) if_block0.d();\n        if (if_block1) if_block1.d();\n      }\n    };\n  }\n  function instance$4($$self, $$props, $$invalidate) {\n    var labelId = $$props.labelId,\n      step = $$props.step;\n    var title, cancelIcon;\n    $$self.$$set = function ($$props) {\n      if ('labelId' in $$props) $$invalidate(0, labelId = $$props.labelId);\n      if ('step' in $$props) $$invalidate(1, step = $$props.step);\n    };\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty & /*step*/2) {\n        {\n          $$invalidate(2, title = step.options.title);\n          $$invalidate(3, cancelIcon = step.options.cancelIcon);\n        }\n      }\n    };\n    return [labelId, step, title, cancelIcon];\n  }\n  var Shepherd_header = /*#__PURE__*/function (_SvelteComponent5) {\n    _inherits(Shepherd_header, _SvelteComponent5);\n    function Shepherd_header(options) {\n      var _this7;\n      _classCallCheck(this, Shepherd_header);\n      _this7 = _callSuper(this, Shepherd_header);\n      init(_assertThisInitialized(_this7), options, instance$4, create_fragment$4, safe_not_equal, {\n        labelId: 0,\n        step: 1\n      });\n      return _this7;\n    }\n    return _createClass(Shepherd_header);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-text.svelte generated by Svelte v3.59.2 */\n  function create_fragment$3(ctx) {\n    var div;\n    return {\n      c: function c() {\n        div = element(\"div\");\n        attr(div, \"class\", \"shepherd-text\");\n        attr(div, \"id\", /*descriptionId*/ctx[1]);\n      },\n      m: function m(target, anchor) {\n        insert(target, div, anchor);\n        /*div_binding*/\n        ctx[3](div);\n      },\n      p: function p(ctx, _ref19) {\n        var _ref20 = _slicedToArray(_ref19, 1),\n          dirty = _ref20[0];\n        if (dirty & /*descriptionId*/2) {\n          attr(div, \"id\", /*descriptionId*/ctx[1]);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(div);\n        /*div_binding*/\n        ctx[3](null);\n      }\n    };\n  }\n  function instance$3($$self, $$props, $$invalidate) {\n    var descriptionId = $$props.descriptionId,\n      element = $$props.element,\n      step = $$props.step;\n    afterUpdate(function () {\n      var text = step.options.text;\n      if (isFunction(text)) {\n        text = text.call(step);\n      }\n      if (isHTMLElement$1(text)) {\n        element.appendChild(text);\n      } else {\n        $$invalidate(0, element.innerHTML = text, element);\n      }\n    });\n    function div_binding($$value) {\n      binding_callbacks[$$value ? 'unshift' : 'push'](function () {\n        element = $$value;\n        $$invalidate(0, element);\n      });\n    }\n    $$self.$$set = function ($$props) {\n      if ('descriptionId' in $$props) $$invalidate(1, descriptionId = $$props.descriptionId);\n      if ('element' in $$props) $$invalidate(0, element = $$props.element);\n      if ('step' in $$props) $$invalidate(2, step = $$props.step);\n    };\n    return [element, descriptionId, step, div_binding];\n  }\n  var Shepherd_text = /*#__PURE__*/function (_SvelteComponent6) {\n    _inherits(Shepherd_text, _SvelteComponent6);\n    function Shepherd_text(options) {\n      var _this8;\n      _classCallCheck(this, Shepherd_text);\n      _this8 = _callSuper(this, Shepherd_text);\n      init(_assertThisInitialized(_this8), options, instance$3, create_fragment$3, safe_not_equal, {\n        descriptionId: 1,\n        element: 0,\n        step: 2\n      });\n      return _this8;\n    }\n    return _createClass(Shepherd_text);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-content.svelte generated by Svelte v3.59.2 */\n  function create_if_block_2(ctx) {\n    var shepherdheader;\n    var current;\n    shepherdheader = new Shepherd_header({\n      props: {\n        labelId: /*labelId*/ctx[1],\n        step: /*step*/ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdheader.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdheader, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdheader_changes = {};\n        if (dirty & /*labelId*/2) shepherdheader_changes.labelId = /*labelId*/ctx[1];\n        if (dirty & /*step*/4) shepherdheader_changes.step = /*step*/ctx[2];\n        shepherdheader.$set(shepherdheader_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdheader.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdheader.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdheader, detaching);\n      }\n    };\n  }\n\n  // (28:2) {#if !isUndefined(step.options.text)}\n  function create_if_block_1(ctx) {\n    var shepherdtext;\n    var current;\n    shepherdtext = new Shepherd_text({\n      props: {\n        descriptionId: /*descriptionId*/ctx[0],\n        step: /*step*/ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdtext.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdtext, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdtext_changes = {};\n        if (dirty & /*descriptionId*/1) shepherdtext_changes.descriptionId = /*descriptionId*/ctx[0];\n        if (dirty & /*step*/4) shepherdtext_changes.step = /*step*/ctx[2];\n        shepherdtext.$set(shepherdtext_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdtext.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdtext.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdtext, detaching);\n      }\n    };\n  }\n\n  // (35:2) {#if Array.isArray(step.options.buttons) && step.options.buttons.length}\n  function create_if_block$1(ctx) {\n    var shepherdfooter;\n    var current;\n    shepherdfooter = new Shepherd_footer({\n      props: {\n        step: /*step*/ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdfooter.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdfooter, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdfooter_changes = {};\n        if (dirty & /*step*/4) shepherdfooter_changes.step = /*step*/ctx[2];\n        shepherdfooter.$set(shepherdfooter_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdfooter.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdfooter.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdfooter, detaching);\n      }\n    };\n  }\n  function create_fragment$2(ctx) {\n    var div;\n    var show_if_2 = !isUndefined( /*step*/ctx[2].options.title) || /*step*/ctx[2].options.cancelIcon && /*step*/ctx[2].options.cancelIcon.enabled;\n    var t0;\n    var show_if_1 = !isUndefined( /*step*/ctx[2].options.text);\n    var t1;\n    var show_if = Array.isArray( /*step*/ctx[2].options.buttons) && /*step*/ctx[2].options.buttons.length;\n    var current;\n    var if_block0 = show_if_2 && create_if_block_2(ctx);\n    var if_block1 = show_if_1 && create_if_block_1(ctx);\n    var if_block2 = show_if && create_if_block$1(ctx);\n    return {\n      c: function c() {\n        div = element(\"div\");\n        if (if_block0) if_block0.c();\n        t0 = space();\n        if (if_block1) if_block1.c();\n        t1 = space();\n        if (if_block2) if_block2.c();\n        attr(div, \"class\", \"shepherd-content\");\n      },\n      m: function m(target, anchor) {\n        insert(target, div, anchor);\n        if (if_block0) if_block0.m(div, null);\n        append(div, t0);\n        if (if_block1) if_block1.m(div, null);\n        append(div, t1);\n        if (if_block2) if_block2.m(div, null);\n        current = true;\n      },\n      p: function p(ctx, _ref21) {\n        var _ref22 = _slicedToArray(_ref21, 1),\n          dirty = _ref22[0];\n        if (dirty & /*step*/4) show_if_2 = !isUndefined( /*step*/ctx[2].options.title) || /*step*/ctx[2].options.cancelIcon && /*step*/ctx[2].options.cancelIcon.enabled;\n        if (show_if_2) {\n          if (if_block0) {\n            if_block0.p(ctx, dirty);\n            if (dirty & /*step*/4) {\n              transition_in(if_block0, 1);\n            }\n          } else {\n            if_block0 = create_if_block_2(ctx);\n            if_block0.c();\n            transition_in(if_block0, 1);\n            if_block0.m(div, t0);\n          }\n        } else if (if_block0) {\n          group_outros();\n          transition_out(if_block0, 1, 1, function () {\n            if_block0 = null;\n          });\n          check_outros();\n        }\n        if (dirty & /*step*/4) show_if_1 = !isUndefined( /*step*/ctx[2].options.text);\n        if (show_if_1) {\n          if (if_block1) {\n            if_block1.p(ctx, dirty);\n            if (dirty & /*step*/4) {\n              transition_in(if_block1, 1);\n            }\n          } else {\n            if_block1 = create_if_block_1(ctx);\n            if_block1.c();\n            transition_in(if_block1, 1);\n            if_block1.m(div, t1);\n          }\n        } else if (if_block1) {\n          group_outros();\n          transition_out(if_block1, 1, 1, function () {\n            if_block1 = null;\n          });\n          check_outros();\n        }\n        if (dirty & /*step*/4) show_if = Array.isArray( /*step*/ctx[2].options.buttons) && /*step*/ctx[2].options.buttons.length;\n        if (show_if) {\n          if (if_block2) {\n            if_block2.p(ctx, dirty);\n            if (dirty & /*step*/4) {\n              transition_in(if_block2, 1);\n            }\n          } else {\n            if_block2 = create_if_block$1(ctx);\n            if_block2.c();\n            transition_in(if_block2, 1);\n            if_block2.m(div, null);\n          }\n        } else if (if_block2) {\n          group_outros();\n          transition_out(if_block2, 1, 1, function () {\n            if_block2 = null;\n          });\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(if_block0);\n        transition_in(if_block1);\n        transition_in(if_block2);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(if_block0);\n        transition_out(if_block1);\n        transition_out(if_block2);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(div);\n        if (if_block0) if_block0.d();\n        if (if_block1) if_block1.d();\n        if (if_block2) if_block2.d();\n      }\n    };\n  }\n  function instance$2($$self, $$props, $$invalidate) {\n    var descriptionId = $$props.descriptionId,\n      labelId = $$props.labelId,\n      step = $$props.step;\n    $$self.$$set = function ($$props) {\n      if ('descriptionId' in $$props) $$invalidate(0, descriptionId = $$props.descriptionId);\n      if ('labelId' in $$props) $$invalidate(1, labelId = $$props.labelId);\n      if ('step' in $$props) $$invalidate(2, step = $$props.step);\n    };\n    return [descriptionId, labelId, step];\n  }\n  var Shepherd_content = /*#__PURE__*/function (_SvelteComponent7) {\n    _inherits(Shepherd_content, _SvelteComponent7);\n    function Shepherd_content(options) {\n      var _this9;\n      _classCallCheck(this, Shepherd_content);\n      _this9 = _callSuper(this, Shepherd_content);\n      init(_assertThisInitialized(_this9), options, instance$2, create_fragment$2, safe_not_equal, {\n        descriptionId: 0,\n        labelId: 1,\n        step: 2\n      });\n      return _this9;\n    }\n    return _createClass(Shepherd_content);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-element.svelte generated by Svelte v3.59.2 */\n  function create_if_block(ctx) {\n    var div;\n    return {\n      c: function c() {\n        div = element(\"div\");\n        attr(div, \"class\", \"shepherd-arrow\");\n        attr(div, \"data-popper-arrow\", \"\");\n      },\n      m: function m(target, anchor) {\n        insert(target, div, anchor);\n      },\n      d: function d(detaching) {\n        if (detaching) detach(div);\n      }\n    };\n  }\n  function create_fragment$1(ctx) {\n    var div;\n    var t;\n    var shepherdcontent;\n    var div_aria_describedby_value;\n    var div_aria_labelledby_value;\n    var current;\n    var mounted;\n    var dispose;\n    var if_block = /*step*/ctx[4].options.arrow && /*step*/ctx[4].options.attachTo && /*step*/ctx[4].options.attachTo.element && /*step*/ctx[4].options.attachTo.on && create_if_block();\n    shepherdcontent = new Shepherd_content({\n      props: {\n        descriptionId: /*descriptionId*/ctx[2],\n        labelId: /*labelId*/ctx[3],\n        step: /*step*/ctx[4]\n      }\n    });\n    var div_levels = [{\n      \"aria-describedby\": div_aria_describedby_value = !isUndefined( /*step*/ctx[4].options.text) ? /*descriptionId*/ctx[2] : null\n    }, {\n      \"aria-labelledby\": div_aria_labelledby_value = /*step*/ctx[4].options.title ? /*labelId*/ctx[3] : null\n    }, /*dataStepId*/ctx[1], {\n      role: \"dialog\"\n    }, {\n      tabindex: \"0\"\n    }];\n    var div_data = {};\n    for (var i = 0; i < div_levels.length; i += 1) {\n      div_data = assign(div_data, div_levels[i]);\n    }\n    return {\n      c: function c() {\n        div = element(\"div\");\n        if (if_block) if_block.c();\n        t = space();\n        create_component(shepherdcontent.$$.fragment);\n        set_attributes(div, div_data);\n        toggle_class(div, \"shepherd-has-cancel-icon\", /*hasCancelIcon*/ctx[5]);\n        toggle_class(div, \"shepherd-has-title\", /*hasTitle*/ctx[6]);\n        toggle_class(div, \"shepherd-element\", true);\n      },\n      m: function m(target, anchor) {\n        insert(target, div, anchor);\n        if (if_block) if_block.m(div, null);\n        append(div, t);\n        mount_component(shepherdcontent, div, null);\n        /*div_binding*/\n        ctx[13](div);\n        current = true;\n        if (!mounted) {\n          dispose = listen(div, \"keydown\", /*handleKeyDown*/ctx[7]);\n          mounted = true;\n        }\n      },\n      p: function p(ctx, _ref23) {\n        var _ref24 = _slicedToArray(_ref23, 1),\n          dirty = _ref24[0];\n        if ( /*step*/ctx[4].options.arrow && /*step*/ctx[4].options.attachTo && /*step*/ctx[4].options.attachTo.element && /*step*/ctx[4].options.attachTo.on) {\n          if (if_block) ;else {\n            if_block = create_if_block();\n            if_block.c();\n            if_block.m(div, t);\n          }\n        } else if (if_block) {\n          if_block.d(1);\n          if_block = null;\n        }\n        var shepherdcontent_changes = {};\n        if (dirty & /*descriptionId*/4) shepherdcontent_changes.descriptionId = /*descriptionId*/ctx[2];\n        if (dirty & /*labelId*/8) shepherdcontent_changes.labelId = /*labelId*/ctx[3];\n        if (dirty & /*step*/16) shepherdcontent_changes.step = /*step*/ctx[4];\n        shepherdcontent.$set(shepherdcontent_changes);\n        set_attributes(div, div_data = get_spread_update(div_levels, [(!current || dirty & /*step, descriptionId*/20 && div_aria_describedby_value !== (div_aria_describedby_value = !isUndefined( /*step*/ctx[4].options.text) ? /*descriptionId*/ctx[2] : null)) && {\n          \"aria-describedby\": div_aria_describedby_value\n        }, (!current || dirty & /*step, labelId*/24 && div_aria_labelledby_value !== (div_aria_labelledby_value = /*step*/ctx[4].options.title ? /*labelId*/ctx[3] : null)) && {\n          \"aria-labelledby\": div_aria_labelledby_value\n        }, dirty & /*dataStepId*/2 && /*dataStepId*/ctx[1], {\n          role: \"dialog\"\n        }, {\n          tabindex: \"0\"\n        }]));\n        toggle_class(div, \"shepherd-has-cancel-icon\", /*hasCancelIcon*/ctx[5]);\n        toggle_class(div, \"shepherd-has-title\", /*hasTitle*/ctx[6]);\n        toggle_class(div, \"shepherd-element\", true);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdcontent.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdcontent.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(div);\n        if (if_block) if_block.d();\n        destroy_component(shepherdcontent);\n        /*div_binding*/\n        ctx[13](null);\n        mounted = false;\n        dispose();\n      }\n    };\n  }\n  var KEY_TAB = 9;\n  var KEY_ESC = 27;\n  var LEFT_ARROW = 37;\n  var RIGHT_ARROW = 39;\n  function getClassesArray(classes) {\n    return classes.split(' ').filter(function (className) {\n      return !!className.length;\n    });\n  }\n  function instance$1($$self, $$props, $$invalidate) {\n    var classPrefix = $$props.classPrefix,\n      element = $$props.element,\n      descriptionId = $$props.descriptionId,\n      firstFocusableElement = $$props.firstFocusableElement,\n      focusableElements = $$props.focusableElements,\n      labelId = $$props.labelId,\n      lastFocusableElement = $$props.lastFocusableElement,\n      step = $$props.step,\n      dataStepId = $$props.dataStepId;\n    var hasCancelIcon, hasTitle, classes;\n    var getElement = function getElement() {\n      return element;\n    };\n    onMount(function () {\n      // Get all elements that are focusable\n      $$invalidate(1, dataStepId = _defineProperty({}, \"data-\".concat(classPrefix, \"shepherd-step-id\"), step.id));\n      $$invalidate(9, focusableElements = element.querySelectorAll('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), [tabindex=\"0\"]'));\n      $$invalidate(8, firstFocusableElement = focusableElements[0]);\n      $$invalidate(10, lastFocusableElement = focusableElements[focusableElements.length - 1]);\n    });\n    afterUpdate(function () {\n      if (classes !== step.options.classes) {\n        updateDynamicClasses();\n      }\n    });\n    function updateDynamicClasses() {\n      removeClasses(classes);\n      classes = step.options.classes;\n      addClasses(classes);\n    }\n    function removeClasses(classes) {\n      if (isString(classes)) {\n        var oldClasses = getClassesArray(classes);\n        if (oldClasses.length) {\n          var _element$classList;\n          (_element$classList = element.classList).remove.apply(_element$classList, _toConsumableArray(oldClasses));\n        }\n      }\n    }\n    function addClasses(classes) {\n      if (isString(classes)) {\n        var newClasses = getClassesArray(classes);\n        if (newClasses.length) {\n          var _element$classList2;\n          (_element$classList2 = element.classList).add.apply(_element$classList2, _toConsumableArray(newClasses));\n        }\n      }\n    }\n\n    /**\n    * Setup keydown events to allow closing the modal with ESC\n    *\n    * Borrowed from this great post! https://bitsofco.de/accessible-modal-dialog/\n    *\n    * @private\n    */\n    var handleKeyDown = function handleKeyDown(e) {\n      var _step = step,\n        tour = _step.tour;\n      switch (e.keyCode) {\n        case KEY_TAB:\n          if (focusableElements.length === 0) {\n            e.preventDefault();\n            break;\n          }\n          // Backward tab\n          if (e.shiftKey) {\n            if (document.activeElement === firstFocusableElement || document.activeElement.classList.contains('shepherd-element')) {\n              e.preventDefault();\n              lastFocusableElement.focus();\n            }\n          } else {\n            if (document.activeElement === lastFocusableElement) {\n              e.preventDefault();\n              firstFocusableElement.focus();\n            }\n          }\n          break;\n        case KEY_ESC:\n          if (tour.options.exitOnEsc) {\n            e.stopPropagation();\n            step.cancel();\n          }\n          break;\n        case LEFT_ARROW:\n          if (tour.options.keyboardNavigation) {\n            e.stopPropagation();\n            tour.back();\n          }\n          break;\n        case RIGHT_ARROW:\n          if (tour.options.keyboardNavigation) {\n            e.stopPropagation();\n            tour.next();\n          }\n          break;\n      }\n    };\n    function div_binding($$value) {\n      binding_callbacks[$$value ? 'unshift' : 'push'](function () {\n        element = $$value;\n        $$invalidate(0, element);\n      });\n    }\n    $$self.$$set = function ($$props) {\n      if ('classPrefix' in $$props) $$invalidate(11, classPrefix = $$props.classPrefix);\n      if ('element' in $$props) $$invalidate(0, element = $$props.element);\n      if ('descriptionId' in $$props) $$invalidate(2, descriptionId = $$props.descriptionId);\n      if ('firstFocusableElement' in $$props) $$invalidate(8, firstFocusableElement = $$props.firstFocusableElement);\n      if ('focusableElements' in $$props) $$invalidate(9, focusableElements = $$props.focusableElements);\n      if ('labelId' in $$props) $$invalidate(3, labelId = $$props.labelId);\n      if ('lastFocusableElement' in $$props) $$invalidate(10, lastFocusableElement = $$props.lastFocusableElement);\n      if ('step' in $$props) $$invalidate(4, step = $$props.step);\n      if ('dataStepId' in $$props) $$invalidate(1, dataStepId = $$props.dataStepId);\n    };\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty & /*step*/16) {\n        {\n          $$invalidate(5, hasCancelIcon = step.options && step.options.cancelIcon && step.options.cancelIcon.enabled);\n          $$invalidate(6, hasTitle = step.options && step.options.title);\n        }\n      }\n    };\n    return [element, dataStepId, descriptionId, labelId, step, hasCancelIcon, hasTitle, handleKeyDown, firstFocusableElement, focusableElements, lastFocusableElement, classPrefix, getElement, div_binding];\n  }\n  var Shepherd_element = /*#__PURE__*/function (_SvelteComponent8) {\n    _inherits(Shepherd_element, _SvelteComponent8);\n    function Shepherd_element(options) {\n      var _this10;\n      _classCallCheck(this, Shepherd_element);\n      _this10 = _callSuper(this, Shepherd_element);\n      init(_assertThisInitialized(_this10), options, instance$1, create_fragment$1, safe_not_equal, {\n        classPrefix: 11,\n        element: 0,\n        descriptionId: 2,\n        firstFocusableElement: 8,\n        focusableElements: 9,\n        labelId: 3,\n        lastFocusableElement: 10,\n        step: 4,\n        dataStepId: 1,\n        getElement: 12\n      });\n      return _this10;\n    }\n    _createClass(Shepherd_element, [{\n      key: \"getElement\",\n      get: function get() {\n        return this.$$.ctx[12];\n      }\n    }]);\n    return Shepherd_element;\n  }(SvelteComponent);\n  /**\n   * A class representing steps to be added to a tour.\n   * @extends {Evented}\n   */\n  var Step = /*#__PURE__*/function (_Evented) {\n    _inherits(Step, _Evented);\n    /**\n     * Create a step\n     * @param {Tour} tour The tour for the step\n     * @param {object} options The options for the step\n     * @param {boolean} options.arrow Whether to display the arrow for the tooltip or not. Defaults to `true`.\n     * @param {object} options.attachTo The element the step should be attached to on the page.\n     * An object with properties `element` and `on`.\n     *\n     * ```js\n     * const step = new Step(tour, {\n     *   attachTo: { element: '.some .selector-path', on: 'left' },\n     *   ...moreOptions\n     * });\n     * ```\n     *\n     * If you dont specify an `attachTo` the element will appear in the middle of the screen. The same will happen if your `attachTo.element` callback returns `null`, `undefined`, or a selector that does not exist in the DOM.\n     * If you omit the `on` portion of `attachTo`, the element will still be highlighted, but the tooltip will appear\n     * in the middle of the screen, without an arrow pointing to the target.\n     * If the element to highlight does not yet exist while instantiating tour steps, you may use lazy evaluation by supplying a function to `attachTo.element`. The function will be called in the `before-show` phase.\n     * @param {string|HTMLElement|function} options.attachTo.element An element selector string, DOM element, or a function (returning a selector, a DOM element, `null` or `undefined`).\n     * @param {string} options.attachTo.on The optional direction to place the FloatingUI tooltip relative to the element.\n     *   - Possible string values: 'top', 'top-start', 'top-end', 'bottom', 'bottom-start', 'bottom-end', 'right', 'right-start', 'right-end', 'left', 'left-start', 'left-end'\n     * @param {Object} options.advanceOn An action on the page which should advance shepherd to the next step.\n     * It should be an object with a string `selector` and an `event` name\n     * ```js\n     * const step = new Step(tour, {\n     *   advanceOn: { selector: '.some .selector-path', event: 'click' },\n     *   ...moreOptions\n     * });\n     * ```\n     * `event` doesnt have to be an event inside the tour, it can be any event fired on any element on the page.\n     * You can also always manually advance the Tour by calling `myTour.next()`.\n     * @param {function} options.beforeShowPromise A function that returns a promise.\n     * When the promise resolves, the rest of the `show` code for the step will execute.\n     * @param {Object[]} options.buttons An array of buttons to add to the step. These will be rendered in a\n     * footer below the main body text.\n     * @param {function} options.buttons.button.action A function executed when the button is clicked on.\n     * It is automatically bound to the `tour` the step is associated with, so things like `this.next` will\n     * work inside the action.\n     * You can use action to skip steps or navigate to specific steps, with something like:\n     * ```js\n     * action() {\n     *   return this.show('some_step_name');\n     * }\n     * ```\n     * @param {string} options.buttons.button.classes Extra classes to apply to the `<a>`\n     * @param {boolean} options.buttons.button.disabled Should the button be disabled?\n     * @param {string} options.buttons.button.label The aria-label text of the button\n     * @param {boolean} options.buttons.button.secondary If true, a shepherd-button-secondary class is applied to the button\n     * @param {string} options.buttons.button.text The HTML text of the button\n     * @param {boolean} options.canClickTarget A boolean, that when set to false, will set `pointer-events: none` on the target\n     * @param {object} options.cancelIcon Options for the cancel icon\n     * @param {boolean} options.cancelIcon.enabled Should a cancel  be shown in the header of the step?\n     * @param {string} options.cancelIcon.label The label to add for `aria-label`\n     * @param {string} options.classes A string of extra classes to add to the step's content element.\n     * @param {string} options.highlightClass An extra class to apply to the `attachTo` element when it is\n     * highlighted (that is, when its step is active). You can then target that selector in your CSS.\n     * @param {string} options.id The string to use as the `id` for the step.\n     * @param {number} options.modalOverlayOpeningPadding An amount of padding to add around the modal overlay opening\n     * @param {number | { topLeft: number, bottomLeft: number, bottomRight: number, topRight: number }} options.modalOverlayOpeningRadius An amount of border radius to add around the modal overlay opening\n     * @param {object} options.floatingUIOptions Extra options to pass to FloatingUI\n     * @param {boolean|Object} options.scrollTo Should the element be scrolled to when this step is shown? If true, uses the default `scrollIntoView`,\n     * if an object, passes that object as the params to `scrollIntoView` i.e. `{behavior: 'smooth', block: 'center'}`\n     * @param {function} options.scrollToHandler A function that lets you override the default scrollTo behavior and\n     * define a custom action to do the scrolling, and possibly other logic.\n     * @param {function} options.showOn A function that, when it returns `true`, will show the step.\n     * If it returns false, the step will be skipped.\n     * @param {string} options.text The text in the body of the step. It can be one of three types:\n     * ```\n     * - HTML string\n     * - `HTMLElement` object\n     * - `Function` to be executed when the step is built. It must return one the two options above.\n     * ```\n     * @param {string} options.title The step's title. It becomes an `h3` at the top of the step. It can be one of two types:\n     * ```\n     * - HTML string\n     * - `Function` to be executed when the step is built. It must return HTML string.\n     * ```\n     * @param {object} options.when You can define `show`, `hide`, etc events inside `when`. For example:\n     * ```js\n     * when: {\n     *   show: function() {\n     *     window.scrollTo(0, 0);\n     *   }\n     * }\n     * ```\n     * @return {Step} The newly created Step instance\n     */\n    function Step(tour) {\n      var _this11;\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      _classCallCheck(this, Step);\n      _this11 = _callSuper(this, Step, [tour, options]);\n      _this11.tour = tour;\n      _this11.classPrefix = _this11.tour.options ? normalizePrefix(_this11.tour.options.classPrefix) : '';\n      _this11.styles = tour.styles;\n\n      /**\n       * Resolved attachTo options. Due to lazy evaluation, we only resolve the options during `before-show` phase.\n       * Do not use this directly, use the _getResolvedAttachToOptions method instead.\n       * @type {null|{}|{element, to}}\n       * @private\n       */\n      _this11._resolvedAttachTo = null;\n      autoBind(_assertThisInitialized(_this11));\n      _this11._setOptions(options);\n      return _possibleConstructorReturn(_this11, _assertThisInitialized(_this11));\n    }\n\n    /**\n     * Cancel the tour\n     * Triggers the `cancel` event\n     */\n    _createClass(Step, [{\n      key: \"cancel\",\n      value: function cancel() {\n        this.tour.cancel();\n        this.trigger('cancel');\n      }\n\n      /**\n       * Complete the tour\n       * Triggers the `complete` event\n       */\n    }, {\n      key: \"complete\",\n      value: function complete() {\n        this.tour.complete();\n        this.trigger('complete');\n      }\n\n      /**\n       * Remove the step, delete the step's element, and destroy the FloatingUI instance for the step.\n       * Triggers `destroy` event\n       */\n    }, {\n      key: \"destroy\",\n      value: function destroy() {\n        destroyTooltip(this);\n        if (isHTMLElement$1(this.el)) {\n          this.el.remove();\n          this.el = null;\n        }\n        this._updateStepTargetOnHide();\n        this.trigger('destroy');\n      }\n\n      /**\n       * Returns the tour for the step\n       * @return {Tour} The tour instance\n       */\n    }, {\n      key: \"getTour\",\n      value: function getTour() {\n        return this.tour;\n      }\n\n      /**\n       * Hide the step\n       */\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        this.tour.modal.hide();\n        this.trigger('before-hide');\n        if (this.el) {\n          this.el.hidden = true;\n        }\n        this._updateStepTargetOnHide();\n        this.trigger('hide');\n      }\n\n      /**\n       * Resolves attachTo options.\n       * @returns {{}|{element, on}}\n       * @private\n       */\n    }, {\n      key: \"_resolveAttachToOptions\",\n      value: function _resolveAttachToOptions() {\n        this._resolvedAttachTo = parseAttachTo(this);\n        return this._resolvedAttachTo;\n      }\n\n      /**\n       * A selector for resolved attachTo options.\n       * @returns {{}|{element, on}}\n       * @private\n       */\n    }, {\n      key: \"_getResolvedAttachToOptions\",\n      value: function _getResolvedAttachToOptions() {\n        if (this._resolvedAttachTo === null) {\n          return this._resolveAttachToOptions();\n        }\n        return this._resolvedAttachTo;\n      }\n\n      /**\n       * Check if the step is open and visible\n       * @return {boolean} True if the step is open and visible\n       */\n    }, {\n      key: \"isOpen\",\n      value: function isOpen() {\n        return Boolean(this.el && !this.el.hidden);\n      }\n\n      /**\n       * Wraps `_show` and ensures `beforeShowPromise` resolves before calling show\n       * @return {*|Promise}\n       */\n    }, {\n      key: \"show\",\n      value: function show() {\n        var _this12 = this;\n        if (isFunction(this.options.beforeShowPromise)) {\n          return Promise.resolve(this.options.beforeShowPromise()).then(function () {\n            return _this12._show();\n          });\n        }\n        return Promise.resolve(this._show());\n      }\n\n      /**\n       * Updates the options of the step.\n       *\n       * @param {Object} options The options for the step\n       */\n    }, {\n      key: \"updateStepOptions\",\n      value: function updateStepOptions(options) {\n        Object.assign(this.options, options);\n        if (this.shepherdElementComponent) {\n          this.shepherdElementComponent.$set({\n            step: this\n          });\n        }\n      }\n\n      /**\n       * Returns the element for the step\n       * @return {HTMLElement|null|undefined} The element instance. undefined if it has never been shown, null if it has been destroyed\n       */\n    }, {\n      key: \"getElement\",\n      value: function getElement() {\n        return this.el;\n      }\n\n      /**\n       * Returns the target for the step\n       * @return {HTMLElement|null|undefined} The element instance. undefined if it has never been shown, null if query string has not been found\n       */\n    }, {\n      key: \"getTarget\",\n      value: function getTarget() {\n        return this.target;\n      }\n\n      /**\n       * Creates Shepherd element for step based on options\n       *\n       * @return {Element} The DOM element for the step tooltip\n       * @private\n       */\n    }, {\n      key: \"_createTooltipContent\",\n      value: function _createTooltipContent() {\n        var descriptionId = \"\".concat(this.id, \"-description\");\n        var labelId = \"\".concat(this.id, \"-label\");\n        this.shepherdElementComponent = new Shepherd_element({\n          target: this.tour.options.stepsContainer || document.body,\n          props: {\n            classPrefix: this.classPrefix,\n            descriptionId: descriptionId,\n            labelId: labelId,\n            step: this,\n            styles: this.styles\n          }\n        });\n        return this.shepherdElementComponent.getElement();\n      }\n\n      /**\n       * If a custom scrollToHandler is defined, call that, otherwise do the generic\n       * scrollIntoView call.\n       *\n       * @param {boolean|Object} scrollToOptions If true, uses the default `scrollIntoView`,\n       * if an object, passes that object as the params to `scrollIntoView` i.e. `{ behavior: 'smooth', block: 'center' }`\n       * @private\n       */\n    }, {\n      key: \"_scrollTo\",\n      value: function _scrollTo(scrollToOptions) {\n        var _this$_getResolvedAtt = this._getResolvedAttachToOptions(),\n          element = _this$_getResolvedAtt.element;\n        if (isFunction(this.options.scrollToHandler)) {\n          this.options.scrollToHandler(element);\n        } else if (isElement$1(element) && typeof element.scrollIntoView === 'function') {\n          element.scrollIntoView(scrollToOptions);\n        }\n      }\n\n      /**\n       * _getClassOptions gets all possible classes for the step\n       * @param {Object} stepOptions The step specific options\n       * @returns {String} unique string from array of classes\n       * @private\n       */\n    }, {\n      key: \"_getClassOptions\",\n      value: function _getClassOptions(stepOptions) {\n        var defaultStepOptions = this.tour && this.tour.options && this.tour.options.defaultStepOptions;\n        var stepClasses = stepOptions.classes ? stepOptions.classes : '';\n        var defaultStepOptionsClasses = defaultStepOptions && defaultStepOptions.classes ? defaultStepOptions.classes : '';\n        var allClasses = [].concat(_toConsumableArray(stepClasses.split(' ')), _toConsumableArray(defaultStepOptionsClasses.split(' ')));\n        var uniqClasses = new Set(allClasses);\n        return Array.from(uniqClasses).join(' ').trim();\n      }\n\n      /**\n       * Sets the options for the step, maps `when` to events, sets up buttons\n       * @param {Object} options The options for the step\n       * @private\n       */\n    }, {\n      key: \"_setOptions\",\n      value: function _setOptions() {\n        var _this13 = this;\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var tourOptions = this.tour && this.tour.options && this.tour.options.defaultStepOptions;\n        tourOptions = cjs({}, tourOptions || {});\n        this.options = Object.assign({\n          arrow: true\n        }, tourOptions, options, mergeTooltipConfig(tourOptions, options));\n        var when = this.options.when;\n        this.options.classes = this._getClassOptions(options);\n        this.destroy();\n        this.id = this.options.id || \"step-\".concat(uuid());\n        if (when) {\n          Object.keys(when).forEach(function (event) {\n            _this13.on(event, when[event], _this13);\n          });\n        }\n      }\n\n      /**\n       * Create the element and set up the FloatingUI instance\n       * @private\n       */\n    }, {\n      key: \"_setupElements\",\n      value: function _setupElements() {\n        if (!isUndefined(this.el)) {\n          this.destroy();\n        }\n        this.el = this._createTooltipContent();\n        if (this.options.advanceOn) {\n          bindAdvance(this);\n        }\n\n        // The tooltip implementation details are handled outside of the Step\n        // object.\n        setupTooltip(this);\n      }\n\n      /**\n       * Triggers `before-show`, generates the tooltip DOM content,\n       * sets up a FloatingUI instance for the tooltip, then triggers `show`.\n       * @private\n       */\n    }, {\n      key: \"_show\",\n      value: function _show() {\n        var _this14 = this;\n        this.trigger('before-show');\n\n        // Force resolve to make sure the options are updated on subsequent shows.\n        this._resolveAttachToOptions();\n        this._setupElements();\n        if (!this.tour.modal) {\n          this.tour._setupModal();\n        }\n        this.tour.modal.setupForStep(this);\n        this._styleTargetElementForStep(this);\n        this.el.hidden = false;\n\n        // start scrolling to target before showing the step\n        if (this.options.scrollTo) {\n          setTimeout(function () {\n            _this14._scrollTo(_this14.options.scrollTo);\n          });\n        }\n        this.el.hidden = false;\n        var content = this.shepherdElementComponent.getElement();\n        var target = this.target || document.body;\n        target.classList.add(\"\".concat(this.classPrefix, \"shepherd-enabled\"));\n        target.classList.add(\"\".concat(this.classPrefix, \"shepherd-target\"));\n        content.classList.add('shepherd-enabled');\n        this.trigger('show');\n      }\n\n      /**\n       * Modulates the styles of the passed step's target element, based on the step's options and\n       * the tour's `modal` option, to visually emphasize the element\n       *\n       * @param step The step object that attaches to the element\n       * @private\n       */\n    }, {\n      key: \"_styleTargetElementForStep\",\n      value: function _styleTargetElementForStep(step) {\n        var targetElement = step.target;\n        if (!targetElement) {\n          return;\n        }\n        if (step.options.highlightClass) {\n          targetElement.classList.add(step.options.highlightClass);\n        }\n        targetElement.classList.remove('shepherd-target-click-disabled');\n        if (step.options.canClickTarget === false) {\n          targetElement.classList.add('shepherd-target-click-disabled');\n        }\n      }\n\n      /**\n       * When a step is hidden, remove the highlightClass and 'shepherd-enabled'\n       * and 'shepherd-target' classes\n       * @private\n       */\n    }, {\n      key: \"_updateStepTargetOnHide\",\n      value: function _updateStepTargetOnHide() {\n        var target = this.target || document.body;\n        if (this.options.highlightClass) {\n          target.classList.remove(this.options.highlightClass);\n        }\n        target.classList.remove('shepherd-target-click-disabled', \"\".concat(this.classPrefix, \"shepherd-enabled\"), \"\".concat(this.classPrefix, \"shepherd-target\"));\n      }\n    }]);\n    return Step;\n  }(Evented);\n  /**\n   * Cleanup the steps and set pointerEvents back to 'auto'\n   * @param tour The tour object\n   */\n  function cleanupSteps(tour) {\n    if (tour) {\n      var steps = tour.steps;\n      steps.forEach(function (step) {\n        if (step.options && step.options.canClickTarget === false && step.options.attachTo) {\n          if (step.target instanceof HTMLElement) {\n            step.target.classList.remove('shepherd-target-click-disabled');\n          }\n        }\n      });\n    }\n  }\n\n  /**\n   * Generates the svg path data for a rounded rectangle overlay\n   * @param {Object} dimension - Dimensions of rectangle.\n   * @param {number} width - Width.\n   * @param {number} height - Height.\n   * @param {number} [x=0] - Offset from top left corner in x axis. default 0.\n   * @param {number} [y=0] - Offset from top left corner in y axis. default 0.\n   * @param {number | { topLeft: number, topRight: number, bottomRight: number, bottomLeft: number }} [r=0] - Corner Radius. Keep this smaller than half of width or height.\n   * @returns {string} - Rounded rectangle overlay path data.\n   */\n  function makeOverlayPath(_ref25) {\n    var width = _ref25.width,\n      height = _ref25.height,\n      _ref25$x = _ref25.x,\n      x = _ref25$x === void 0 ? 0 : _ref25$x,\n      _ref25$y = _ref25.y,\n      y = _ref25$y === void 0 ? 0 : _ref25$y,\n      _ref25$r = _ref25.r,\n      r = _ref25$r === void 0 ? 0 : _ref25$r;\n    var _window = window,\n      w = _window.innerWidth,\n      h = _window.innerHeight;\n    var _ref26 = typeof r === 'number' ? {\n        topLeft: r,\n        topRight: r,\n        bottomRight: r,\n        bottomLeft: r\n      } : r,\n      _ref26$topLeft = _ref26.topLeft,\n      topLeft = _ref26$topLeft === void 0 ? 0 : _ref26$topLeft,\n      _ref26$topRight = _ref26.topRight,\n      topRight = _ref26$topRight === void 0 ? 0 : _ref26$topRight,\n      _ref26$bottomRight = _ref26.bottomRight,\n      bottomRight = _ref26$bottomRight === void 0 ? 0 : _ref26$bottomRight,\n      _ref26$bottomLeft = _ref26.bottomLeft,\n      bottomLeft = _ref26$bottomLeft === void 0 ? 0 : _ref26$bottomLeft;\n    return \"M\".concat(w, \",\").concat(h, \"H0V0H\").concat(w, \"V\").concat(h, \"ZM\").concat(x + topLeft, \",\").concat(y, \"a\").concat(topLeft, \",\").concat(topLeft, \",0,0,0-\").concat(topLeft, \",\").concat(topLeft, \"V\").concat(height + y - bottomLeft, \"a\").concat(bottomLeft, \",\").concat(bottomLeft, \",0,0,0,\").concat(bottomLeft, \",\").concat(bottomLeft, \"H\").concat(width + x - bottomRight, \"a\").concat(bottomRight, \",\").concat(bottomRight, \",0,0,0,\").concat(bottomRight, \"-\").concat(bottomRight, \"V\").concat(y + topRight, \"a\").concat(topRight, \",\").concat(topRight, \",0,0,0-\").concat(topRight, \"-\").concat(topRight, \"Z\");\n  }\n\n  /* src/js/components/shepherd-modal.svelte generated by Svelte v3.59.2 */\n  function create_fragment(ctx) {\n    var svg;\n    var path;\n    var svg_class_value;\n    var mounted;\n    var dispose;\n    return {\n      c: function c() {\n        svg = svg_element(\"svg\");\n        path = svg_element(\"path\");\n        attr(path, \"d\", /*pathDefinition*/ctx[2]);\n        attr(svg, \"class\", svg_class_value = \"\".concat( /*modalIsVisible*/ctx[1] ? 'shepherd-modal-is-visible' : '', \" shepherd-modal-overlay-container\"));\n      },\n      m: function m(target, anchor) {\n        insert(target, svg, anchor);\n        append(svg, path);\n        /*svg_binding*/\n        ctx[11](svg);\n        if (!mounted) {\n          dispose = listen(svg, \"touchmove\", /*_preventModalOverlayTouch*/ctx[3]);\n          mounted = true;\n        }\n      },\n      p: function p(ctx, _ref27) {\n        var _ref28 = _slicedToArray(_ref27, 1),\n          dirty = _ref28[0];\n        if (dirty & /*pathDefinition*/4) {\n          attr(path, \"d\", /*pathDefinition*/ctx[2]);\n        }\n        if (dirty & /*modalIsVisible*/2 && svg_class_value !== (svg_class_value = \"\".concat( /*modalIsVisible*/ctx[1] ? 'shepherd-modal-is-visible' : '', \" shepherd-modal-overlay-container\"))) {\n          attr(svg, \"class\", svg_class_value);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(svg);\n        /*svg_binding*/\n        ctx[11](null);\n        mounted = false;\n        dispose();\n      }\n    };\n  }\n  function _getScrollParent(element) {\n    if (!element) {\n      return null;\n    }\n    var isHtmlElement = element instanceof HTMLElement;\n    var overflowY = isHtmlElement && window.getComputedStyle(element).overflowY;\n    var isScrollable = overflowY !== 'hidden' && overflowY !== 'visible';\n    if (isScrollable && element.scrollHeight >= element.clientHeight) {\n      return element;\n    }\n    return _getScrollParent(element.parentElement);\n  }\n\n  /**\n   * Get the visible height of the target element relative to its scrollParent.\n   * If there is no scroll parent, the height of the element is returned.\n   *\n   * @param {HTMLElement} element The target element\n   * @param {HTMLElement} [scrollParent] The scrollable parent element\n   * @returns {{y: number, height: number}}\n   * @private\n   */\n  function _getVisibleHeight(element, scrollParent) {\n    var elementRect = element.getBoundingClientRect();\n    var top = elementRect.y || elementRect.top;\n    var bottom = elementRect.bottom || top + elementRect.height;\n    if (scrollParent) {\n      var scrollRect = scrollParent.getBoundingClientRect();\n      var scrollTop = scrollRect.y || scrollRect.top;\n      var scrollBottom = scrollRect.bottom || scrollTop + scrollRect.height;\n      top = Math.max(top, scrollTop);\n      bottom = Math.min(bottom, scrollBottom);\n    }\n    var height = Math.max(bottom - top, 0); // Default to 0 if height is negative\n    return {\n      y: top,\n      height: height\n    };\n  }\n  function instance($$self, $$props, $$invalidate) {\n    var element = $$props.element,\n      openingProperties = $$props.openingProperties;\n    uuid();\n    var modalIsVisible = false;\n    var rafId = undefined;\n    var pathDefinition;\n    closeModalOpening();\n    var getElement = function getElement() {\n      return element;\n    };\n    function closeModalOpening() {\n      $$invalidate(4, openingProperties = {\n        width: 0,\n        height: 0,\n        x: 0,\n        y: 0,\n        r: 0\n      });\n    }\n    function hide() {\n      $$invalidate(1, modalIsVisible = false);\n\n      // Ensure we cleanup all event listeners when we hide the modal\n      _cleanupStepEventListeners();\n    }\n    function positionModal() {\n      var modalOverlayOpeningPadding = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var modalOverlayOpeningRadius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var scrollParent = arguments.length > 2 ? arguments[2] : undefined;\n      var targetElement = arguments.length > 3 ? arguments[3] : undefined;\n      if (targetElement) {\n        var _getVisibleHeight2 = _getVisibleHeight(targetElement, scrollParent),\n          y = _getVisibleHeight2.y,\n          height = _getVisibleHeight2.height;\n        var _targetElement$getBou = targetElement.getBoundingClientRect(),\n          x = _targetElement$getBou.x,\n          width = _targetElement$getBou.width,\n          left = _targetElement$getBou.left;\n\n        // getBoundingClientRect is not consistent. Some browsers use x and y, while others use left and top\n        $$invalidate(4, openingProperties = {\n          width: width + modalOverlayOpeningPadding * 2,\n          height: height + modalOverlayOpeningPadding * 2,\n          x: (x || left) - modalOverlayOpeningPadding,\n          y: y - modalOverlayOpeningPadding,\n          r: modalOverlayOpeningRadius\n        });\n      } else {\n        closeModalOpening();\n      }\n    }\n    function setupForStep(step) {\n      // Ensure we move listeners from the previous step, before we setup new ones\n      _cleanupStepEventListeners();\n      if (step.tour.options.useModalOverlay) {\n        _styleForStep(step);\n        show();\n      } else {\n        hide();\n      }\n    }\n    function show() {\n      $$invalidate(1, modalIsVisible = true);\n    }\n    var _preventModalBodyTouch = function _preventModalBodyTouch(e) {\n      e.preventDefault();\n    };\n    var _preventModalOverlayTouch = function _preventModalOverlayTouch(e) {\n      e.stopPropagation();\n    };\n\n    /**\n    * Add touchmove event listener\n    * @private\n    */\n    function _addStepEventListeners() {\n      // Prevents window from moving on touch.\n      window.addEventListener('touchmove', _preventModalBodyTouch, {\n        passive: false\n      });\n    }\n\n    /**\n    * Cancel the requestAnimationFrame loop and remove touchmove event listeners\n    * @private\n    */\n    function _cleanupStepEventListeners() {\n      if (rafId) {\n        cancelAnimationFrame(rafId);\n        rafId = undefined;\n      }\n      window.removeEventListener('touchmove', _preventModalBodyTouch, {\n        passive: false\n      });\n    }\n\n    /**\n    * Style the modal for the step\n    * @param {Step} step The step to style the opening for\n    * @private\n    */\n    function _styleForStep(step) {\n      var _step$options = step.options,\n        modalOverlayOpeningPadding = _step$options.modalOverlayOpeningPadding,\n        modalOverlayOpeningRadius = _step$options.modalOverlayOpeningRadius;\n      var scrollParent = _getScrollParent(step.target);\n\n      // Setup recursive function to call requestAnimationFrame to update the modal opening position\n      var rafLoop = function rafLoop() {\n        rafId = undefined;\n        positionModal(modalOverlayOpeningPadding, modalOverlayOpeningRadius, scrollParent, step.target);\n        rafId = requestAnimationFrame(rafLoop);\n      };\n      rafLoop();\n      _addStepEventListeners();\n    }\n    function svg_binding($$value) {\n      binding_callbacks[$$value ? 'unshift' : 'push'](function () {\n        element = $$value;\n        $$invalidate(0, element);\n      });\n    }\n    $$self.$$set = function ($$props) {\n      if ('element' in $$props) $$invalidate(0, element = $$props.element);\n      if ('openingProperties' in $$props) $$invalidate(4, openingProperties = $$props.openingProperties);\n    };\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty & /*openingProperties*/16) {\n        $$invalidate(2, pathDefinition = makeOverlayPath(openingProperties));\n      }\n    };\n    return [element, modalIsVisible, pathDefinition, _preventModalOverlayTouch, openingProperties, getElement, closeModalOpening, hide, positionModal, setupForStep, show, svg_binding];\n  }\n  var Shepherd_modal = /*#__PURE__*/function (_SvelteComponent9) {\n    _inherits(Shepherd_modal, _SvelteComponent9);\n    function Shepherd_modal(options) {\n      var _this15;\n      _classCallCheck(this, Shepherd_modal);\n      _this15 = _callSuper(this, Shepherd_modal);\n      init(_assertThisInitialized(_this15), options, instance, create_fragment, safe_not_equal, {\n        element: 0,\n        openingProperties: 4,\n        getElement: 5,\n        closeModalOpening: 6,\n        hide: 7,\n        positionModal: 8,\n        setupForStep: 9,\n        show: 10\n      });\n      return _this15;\n    }\n    _createClass(Shepherd_modal, [{\n      key: \"getElement\",\n      get: function get() {\n        return this.$$.ctx[5];\n      }\n    }, {\n      key: \"closeModalOpening\",\n      get: function get() {\n        return this.$$.ctx[6];\n      }\n    }, {\n      key: \"hide\",\n      get: function get() {\n        return this.$$.ctx[7];\n      }\n    }, {\n      key: \"positionModal\",\n      get: function get() {\n        return this.$$.ctx[8];\n      }\n    }, {\n      key: \"setupForStep\",\n      get: function get() {\n        return this.$$.ctx[9];\n      }\n    }, {\n      key: \"show\",\n      get: function get() {\n        return this.$$.ctx[10];\n      }\n    }]);\n    return Shepherd_modal;\n  }(SvelteComponent);\n  var Shepherd = new Evented();\n\n  /**\n   * Class representing the site tour\n   * @extends {Evented}\n   */\n  var Tour = /*#__PURE__*/function (_Evented2) {\n    _inherits(Tour, _Evented2);\n    /**\n     * @param {Object} options The options for the tour\n     * @param {boolean | function(): boolean | Promise<boolean> | function(): Promise<boolean>} options.confirmCancel If true, will issue a `window.confirm` before cancelling.\n     * If it is a function(support Async Function), it will be called and wait for the return value, and will only be cancelled if the value returned is true\n     * @param {string} options.confirmCancelMessage The message to display in the `window.confirm` dialog\n     * @param {string} options.classPrefix The prefix to add to the `shepherd-enabled` and `shepherd-target` class names as well as the `data-shepherd-step-id`.\n     * @param {Object} options.defaultStepOptions Default options for Steps ({@link Step#constructor}), created through `addStep`\n     * @param {boolean} options.exitOnEsc Exiting the tour with the escape key will be enabled unless this is explicitly\n     * set to false.\n     * @param {boolean} options.keyboardNavigation Navigating the tour via left and right arrow keys will be enabled\n     * unless this is explicitly set to false.\n     * @param {HTMLElement} options.stepsContainer An optional container element for the steps.\n     * If not set, the steps will be appended to `document.body`.\n     * @param {HTMLElement} options.modalContainer An optional container element for the modal.\n     * If not set, the modal will be appended to `document.body`.\n     * @param {object[] | Step[]} options.steps An array of step options objects or Step instances to initialize the tour with\n     * @param {string} options.tourName An optional \"name\" for the tour. This will be appended to the the tour's\n     * dynamically generated `id` property.\n     * @param {boolean} options.useModalOverlay Whether or not steps should be placed above a darkened\n     * modal overlay. If true, the overlay will create an opening around the target element so that it\n     * can remain interactive\n     * @returns {Tour}\n     */\n    function Tour() {\n      var _this16;\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      _classCallCheck(this, Tour);\n      _this16 = _callSuper(this, Tour, [options]);\n      autoBind(_assertThisInitialized(_this16));\n      var defaultTourOptions = {\n        exitOnEsc: true,\n        keyboardNavigation: true\n      };\n      _this16.options = Object.assign({}, defaultTourOptions, options);\n      _this16.classPrefix = normalizePrefix(_this16.options.classPrefix);\n      _this16.steps = [];\n      _this16.addSteps(_this16.options.steps);\n\n      // Pass these events onto the global Shepherd object\n      var events = ['active', 'cancel', 'complete', 'inactive', 'show', 'start'];\n      events.map(function (event) {\n        (function (e) {\n          _this16.on(e, function (opts) {\n            opts = opts || {};\n            opts.tour = _assertThisInitialized(_this16);\n            Shepherd.trigger(e, opts);\n          });\n        })(event);\n      });\n      _this16._setTourID();\n      return _possibleConstructorReturn(_this16, _assertThisInitialized(_this16));\n    }\n\n    /**\n     * Adds a new step to the tour\n     * @param {Object|Step} options An object containing step options or a Step instance\n     * @param {number} index The optional index to insert the step at. If undefined, the step\n     * is added to the end of the array.\n     * @return {Step} The newly added step\n     */\n    _createClass(Tour, [{\n      key: \"addStep\",\n      value: function addStep(options, index) {\n        var step = options;\n        if (!(step instanceof Step)) {\n          step = new Step(this, step);\n        } else {\n          step.tour = this;\n        }\n        if (!isUndefined(index)) {\n          this.steps.splice(index, 0, step);\n        } else {\n          this.steps.push(step);\n        }\n        return step;\n      }\n\n      /**\n       * Add multiple steps to the tour\n       * @param {Array<object> | Array<Step>} steps The steps to add to the tour\n       */\n    }, {\n      key: \"addSteps\",\n      value: function addSteps(steps) {\n        var _this17 = this;\n        if (Array.isArray(steps)) {\n          steps.forEach(function (step) {\n            _this17.addStep(step);\n          });\n        }\n        return this;\n      }\n\n      /**\n       * Go to the previous step in the tour\n       */\n    }, {\n      key: \"back\",\n      value: function back() {\n        var index = this.steps.indexOf(this.currentStep);\n        this.show(index - 1, false);\n      }\n\n      /**\n       * Calls _done() triggering the 'cancel' event\n       * If `confirmCancel` is true, will show a window.confirm before cancelling\n       * If `confirmCancel` is a function, will call it and wait for the return value,\n       * and only cancel when the value returned is true\n       */\n    }, {\n      key: \"cancel\",\n      value: (function () {\n        var _cancel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n          var confirmCancelIsFunction, cancelMessage, stopTour;\n          return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n            while (1) switch (_context6.prev = _context6.next) {\n              case 0:\n                if (!this.options.confirmCancel) {\n                  _context6.next = 14;\n                  break;\n                }\n                confirmCancelIsFunction = typeof this.options.confirmCancel === 'function';\n                cancelMessage = this.options.confirmCancelMessage || 'Are you sure you want to stop the tour?';\n                if (!confirmCancelIsFunction) {\n                  _context6.next = 9;\n                  break;\n                }\n                _context6.next = 6;\n                return this.options.confirmCancel();\n              case 6:\n                _context6.t0 = _context6.sent;\n                _context6.next = 10;\n                break;\n              case 9:\n                _context6.t0 = window.confirm(cancelMessage);\n              case 10:\n                stopTour = _context6.t0;\n                if (stopTour) {\n                  this._done('cancel');\n                }\n                _context6.next = 15;\n                break;\n              case 14:\n                this._done('cancel');\n              case 15:\n              case \"end\":\n                return _context6.stop();\n            }\n          }, _callee6, this);\n        }));\n        function cancel() {\n          return _cancel.apply(this, arguments);\n        }\n        return cancel;\n      }()\n      /**\n       * Calls _done() triggering the `complete` event\n       */\n      )\n    }, {\n      key: \"complete\",\n      value: function complete() {\n        this._done('complete');\n      }\n\n      /**\n       * Gets the step from a given id\n       * @param {Number|String} id The id of the step to retrieve\n       * @return {Step} The step corresponding to the `id`\n       */\n    }, {\n      key: \"getById\",\n      value: function getById(id) {\n        return this.steps.find(function (step) {\n          return step.id === id;\n        });\n      }\n\n      /**\n       * Gets the current step\n       * @returns {Step|null}\n       */\n    }, {\n      key: \"getCurrentStep\",\n      value: function getCurrentStep() {\n        return this.currentStep;\n      }\n\n      /**\n       * Hide the current step\n       */\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        var currentStep = this.getCurrentStep();\n        if (currentStep) {\n          return currentStep.hide();\n        }\n      }\n\n      /**\n       * Check if the tour is active\n       * @return {boolean}\n       */\n    }, {\n      key: \"isActive\",\n      value: function isActive() {\n        return Shepherd.activeTour === this;\n      }\n\n      /**\n       * Go to the next step in the tour\n       * If we are at the end, call `complete`\n       */\n    }, {\n      key: \"next\",\n      value: function next() {\n        var index = this.steps.indexOf(this.currentStep);\n        if (index === this.steps.length - 1) {\n          this.complete();\n        } else {\n          this.show(index + 1, true);\n        }\n      }\n\n      /**\n       * Removes the step from the tour\n       * @param {String} name The id for the step to remove\n       */\n    }, {\n      key: \"removeStep\",\n      value: function removeStep(name) {\n        var _this18 = this;\n        var current = this.getCurrentStep();\n\n        // Find the step, destroy it and remove it from this.steps\n        this.steps.some(function (step, i) {\n          if (step.id === name) {\n            if (step.isOpen()) {\n              step.hide();\n            }\n            step.destroy();\n            _this18.steps.splice(i, 1);\n            return true;\n          }\n        });\n        if (current && current.id === name) {\n          this.currentStep = undefined;\n\n          // If we have steps left, show the first one, otherwise just cancel the tour\n          this.steps.length ? this.show(0) : this.cancel();\n        }\n      }\n\n      /**\n       * Show a specific step in the tour\n       * @param {Number|String} key The key to look up the step by\n       * @param {Boolean} forward True if we are going forward, false if backward\n       */\n    }, {\n      key: \"show\",\n      value: function show() {\n        var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        var forward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var step = isString(key) ? this.getById(key) : this.steps[key];\n        if (step) {\n          this._updateStateBeforeShow();\n          var shouldSkipStep = isFunction(step.options.showOn) && !step.options.showOn();\n\n          // If `showOn` returns false, we want to skip the step, otherwise, show the step like normal\n          if (shouldSkipStep) {\n            this._skipStep(step, forward);\n          } else {\n            this.trigger('show', {\n              step: step,\n              previous: this.currentStep\n            });\n            this.currentStep = step;\n            step.show();\n          }\n        }\n      }\n\n      /**\n       * Start the tour\n       */\n    }, {\n      key: \"start\",\n      value: function start() {\n        this.trigger('start');\n\n        // Save the focused element before the tour opens\n        this.focusedElBeforeOpen = document.activeElement;\n        this.currentStep = null;\n        this._setupModal();\n        this._setupActiveTour();\n        this.next();\n      }\n\n      /**\n       * Called whenever the tour is cancelled or completed, basically anytime we exit the tour\n       * @param {String} event The event name to trigger\n       * @private\n       */\n    }, {\n      key: \"_done\",\n      value: function _done(event) {\n        var index = this.steps.indexOf(this.currentStep);\n        if (Array.isArray(this.steps)) {\n          this.steps.forEach(function (step) {\n            return step.destroy();\n          });\n        }\n        cleanupSteps(this);\n        this.trigger(event, {\n          index: index\n        });\n        Shepherd.activeTour = null;\n        this.trigger('inactive', {\n          tour: this\n        });\n        if (this.modal) {\n          this.modal.hide();\n        }\n        if (event === 'cancel' || event === 'complete') {\n          if (this.modal) {\n            var modalContainer = document.querySelector('.shepherd-modal-overlay-container');\n            if (modalContainer) {\n              modalContainer.remove();\n            }\n          }\n        }\n\n        // Focus the element that was focused before the tour started\n        if (isHTMLElement$1(this.focusedElBeforeOpen)) {\n          this.focusedElBeforeOpen.focus();\n        }\n      }\n\n      /**\n       * Make this tour \"active\"\n       * @private\n       */\n    }, {\n      key: \"_setupActiveTour\",\n      value: function _setupActiveTour() {\n        this.trigger('active', {\n          tour: this\n        });\n        Shepherd.activeTour = this;\n      }\n\n      /**\n       * _setupModal create the modal container and instance\n       * @private\n       */\n    }, {\n      key: \"_setupModal\",\n      value: function _setupModal() {\n        this.modal = new Shepherd_modal({\n          target: this.options.modalContainer || document.body,\n          props: {\n            classPrefix: this.classPrefix,\n            styles: this.styles\n          }\n        });\n      }\n\n      /**\n       * Called when `showOn` evaluates to false, to skip the step or complete the tour if it's the last step\n       * @param {Step} step The step to skip\n       * @param {Boolean} forward True if we are going forward, false if backward\n       * @private\n       */\n    }, {\n      key: \"_skipStep\",\n      value: function _skipStep(step, forward) {\n        var index = this.steps.indexOf(step);\n        if (index === this.steps.length - 1) {\n          this.complete();\n        } else {\n          var nextIndex = forward ? index + 1 : index - 1;\n          this.show(nextIndex, forward);\n        }\n      }\n\n      /**\n       * Before showing, hide the current step and if the tour is not\n       * already active, call `this._setupActiveTour`.\n       * @private\n       */\n    }, {\n      key: \"_updateStateBeforeShow\",\n      value: function _updateStateBeforeShow() {\n        if (this.currentStep) {\n          this.currentStep.hide();\n        }\n        if (!this.isActive()) {\n          this._setupActiveTour();\n        }\n      }\n\n      /**\n       * Sets this.id to `${tourName}--${uuid}`\n       * @private\n       */\n    }, {\n      key: \"_setTourID\",\n      value: function _setTourID() {\n        var tourName = this.options.tourName || 'tour';\n        this.id = \"\".concat(tourName, \"--\").concat(uuid());\n      }\n    }]);\n    return Tour;\n  }(Evented);\n  var isServerSide = typeof window === 'undefined';\n  var NoOp = /*#__PURE__*/_createClass(function NoOp() {\n    _classCallCheck(this, NoOp);\n  });\n  if (isServerSide) {\n    Object.assign(Shepherd, {\n      Tour: NoOp,\n      Step: NoOp\n    });\n  } else {\n    Object.assign(Shepherd, {\n      Tour: Tour,\n      Step: Step\n    });\n  }\n  return Shepherd;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2hlcGhlcmQuanMvZGlzdC9qcy9zaGVwaGVyZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQUVBLElBQUlBLGlCQUFpQixHQUFHLFNBQVNBLGlCQUFpQkEsQ0FBQ0MsS0FBSyxFQUFFO0lBQ3pELE9BQU9DLGVBQWUsQ0FBQ0QsS0FBSyxDQUFDLElBQ3pCLENBQUNFLFNBQVMsQ0FBQ0YsS0FBSyxDQUFDO0VBQ3RCLENBQUM7RUFFRCxTQUFTQyxlQUFlQSxDQUFDRCxLQUFLLEVBQUU7SUFDL0IsT0FBTyxDQUFDLENBQUNBLEtBQUssSUFBSUcsT0FBQSxDQUFPSCxLQUFLLE1BQUssUUFBUTtFQUM1QztFQUVBLFNBQVNFLFNBQVNBLENBQUNGLEtBQUssRUFBRTtJQUN6QixJQUFJSSxXQUFXLEdBQUdDLE1BQU0sQ0FBQ0MsU0FBUyxDQUFDQyxRQUFRLENBQUNDLElBQUksQ0FBQ1IsS0FBSyxDQUFDO0lBRXZELE9BQU9JLFdBQVcsS0FBSyxpQkFBaUIsSUFDcENBLFdBQVcsS0FBSyxlQUFlLElBQy9CSyxjQUFjLENBQUNULEtBQUssQ0FBQztFQUMxQjs7RUFFQTtFQUNBLElBQUlVLFlBQVksR0FBRyxPQUFPQyxNQUFNLEtBQUssVUFBVSxJQUFJQSxNQUFNLENBQUNDLEdBQUc7RUFDN0QsSUFBSUMsa0JBQWtCLEdBQUdILFlBQVksR0FBR0MsTUFBTSxDQUFDQyxHQUFHLENBQUMsZUFBZSxDQUFDLEdBQUcsTUFBTTtFQUU1RSxTQUFTSCxjQUFjQSxDQUFDVCxLQUFLLEVBQUU7SUFDOUIsT0FBT0EsS0FBSyxDQUFDYyxRQUFRLEtBQUtELGtCQUFrQjtFQUM3QztFQUVBLFNBQVNFLFdBQVdBLENBQUNDLEdBQUcsRUFBRTtJQUN6QixPQUFPQyxLQUFLLENBQUNDLE9BQU8sQ0FBQ0YsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUU7RUFDcEM7RUFFQSxTQUFTRyw2QkFBNkJBLENBQUNuQixL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QixJQUFBO0VBQUEsRUFwWHdCaDJCLE9BQU87RUNoQmpDLElBQU13NEIsWUFBWSxHQUFHLE9BQU9yakIsTUFBTSxLQUFLLFdBQVc7RUFBQSxJQUU1Q3NqQixJQUFJLGdCQUFBdjRCLFlBQUEsQ0FDUixTQUFBdTRCLEtBQUEsRUFBYztJQUFBeDRCLGVBQUEsT0FBQXc0QixJQUFBO0VBQUM7RUFHakIsSUFBSUQsWUFBWSxFQUFFO0lBQ2hCeDhCLE1BQU0sQ0FBQ3lILE1BQU0sQ0FBQ3N5QixRQUFRLEVBQUU7TUFBRUMsSUFBSSxFQUFFeUMsSUFBSTtNQUFFaEosSUFBSSxFQUFFZ0o7SUFBSyxDQUFDLENBQUM7RUFDckQsQ0FBQyxNQUFNO0lBQ0x6OEIsTUFBTSxDQUFDeUgsTUFBTSxDQUFDc3lCLFFBQVEsRUFBRTtNQUFFQyxJQUFJLEVBQUpBLElBQUk7TUFBRXZHLElBQUEsRUFBQUE7SUFBSyxDQUFDLENBQUM7RUFDekMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9ub2RlX21vZHVsZXMvZGVlcG1lcmdlL2Rpc3QvY2pzLmpzPzVhZDEiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vc3JjL2pzL3V0aWxzL3R5cGUtY2hlY2suanM/MWZkMyIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9zcmMvanMvZXZlbnRlZC5qcz85NzNkIiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL3NyYy9qcy91dGlscy9hdXRvLWJpbmQuanM/N2IxNiIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9zcmMvanMvdXRpbHMvYmluZC5qcz9hNTE1Iiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL3NyYy9qcy91dGlscy9nZW5lcmFsLmpzP2I0MmQiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0BmbG9hdGluZy11aS91dGlscy9kaXN0L2Zsb2F0aW5nLXVpLnV0aWxzLmVzbS5qcz85MzU3Iiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL25vZGVfbW9kdWxlcy9AZmxvYXRpbmctdWkvY29yZS9kaXN0L2Zsb2F0aW5nLXVpLmNvcmUuZXNtLmpzPzBjY2UiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0BmbG9hdGluZy11aS91dGlscy9kb20vZGlzdC9mbG9hdGluZy11aS51dGlscy5kb20uZXNtLmpzP2RmY2IiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0BmbG9hdGluZy11aS9kb20vZGlzdC9mbG9hdGluZy11aS5kb20uZXNtLmpzPzEzNDMiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vc3JjL2pzL3V0aWxzL2Zsb2F0aW5nLXVpLmpzP2VjZGMiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9pbnRlcm5hbC9pbmRleC5tanM/MDRmNyIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9zcmMvanMvY29tcG9uZW50cy9zaGVwaGVyZC1idXR0b24uc3ZlbHRlPzc4YzUiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vc3JjL2pzL2NvbXBvbmVudHMvc2hlcGhlcmQtZm9vdGVyLnN2ZWx0ZT9hZjQ3Iiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL3NyYy9qcy9jb21wb25lbnRzL3NoZXBoZXJkLWNhbmNlbC1pY29uLnN2ZWx0ZT83OWMxIiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL3NyYy9qcy9jb21wb25lbnRzL3NoZXBoZXJkLXRpdGxlLnN2ZWx0ZT9jYWMyIiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL3NyYy9qcy9jb21wb25lbnRzL3NoZXBoZXJkLWhlYWRlci5zdmVsdGU/MmYyNyIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9zcmMvanMvY29tcG9uZW50cy9zaGVwaGVyZC10ZXh0LnN2ZWx0ZT9hY2VmIiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL3NyYy9qcy9jb21wb25lbnRzL3NoZXBoZXJkLWNvbnRlbnQuc3ZlbHRlP2YwN2UiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vc3JjL2pzL2NvbXBvbmVudHMvc2hlcGhlcmQtZWxlbWVudC5zdmVsdGU/YjU4NiIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9zcmMvanMvc3RlcC5qcz9hZDhkIiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL3NyYy9qcy91dGlscy9jbGVhbnVwLmpzPzZkY2EiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vc3JjL2pzL3V0aWxzL292ZXJsYXktcGF0aC5qcz9jZDUzIiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL3NyYy9qcy9jb21wb25lbnRzL3NoZXBoZXJkLW1vZGFsLnN2ZWx0ZT9mNTRiIiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL3NyYy9qcy90b3VyLmpzPzM5NTEiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vc3JjL2pzL3NoZXBoZXJkLmpzPzUxNDQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNNZXJnZWFibGVPYmplY3QgPSBmdW5jdGlvbiBpc01lcmdlYWJsZU9iamVjdCh2YWx1ZSkge1xuXHRyZXR1cm4gaXNOb25OdWxsT2JqZWN0KHZhbHVlKVxuXHRcdCYmICFpc1NwZWNpYWwodmFsdWUpXG59O1xuXG5mdW5jdGlvbiBpc05vbk51bGxPYmplY3QodmFsdWUpIHtcblx0cmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0J1xufVxuXG5mdW5jdGlvbiBpc1NwZWNpYWwodmFsdWUpIHtcblx0dmFyIHN0cmluZ1ZhbHVlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcblxuXHRyZXR1cm4gc3RyaW5nVmFsdWUgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXG5cdFx0fHwgc3RyaW5nVmFsdWUgPT09ICdbb2JqZWN0IERhdGVdJ1xuXHRcdHx8IGlzUmVhY3RFbGVtZW50KHZhbHVlKVxufVxuXG4vLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvYjVhYzk2M2ZiNzkxZDEyOThlN2YzOTYyMzYzODNiYzk1NWY5MTZjMS9zcmMvaXNvbW9ycGhpYy9jbGFzc2ljL2VsZW1lbnQvUmVhY3RFbGVtZW50LmpzI0wyMS1MMjVcbnZhciBjYW5Vc2VTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gY2FuVXNlU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIDogMHhlYWM3O1xuXG5mdW5jdGlvbiBpc1JlYWN0RWxlbWVudCh2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxufVxuXG5mdW5jdGlvbiBlbXB0eVRhcmdldCh2YWwpIHtcblx0cmV0dXJuIEFycmF5LmlzQXJyYXkodmFsKSA/IFtdIDoge31cbn1cblxuZnVuY3Rpb24gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQodmFsdWUsIG9wdGlvbnMpIHtcblx0cmV0dXJuIChvcHRpb25zLmNsb25lICE9PSBmYWxzZSAmJiBvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0KHZhbHVlKSlcblx0XHQ/IGRlZXBtZXJnZShlbXB0eVRhcmdldCh2YWx1ZSksIHZhbHVlLCBvcHRpb25zKVxuXHRcdDogdmFsdWVcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEFycmF5TWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0cmV0dXJuIHRhcmdldC5jb25jYXQoc291cmNlKS5tYXAoZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdHJldHVybiBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChlbGVtZW50LCBvcHRpb25zKVxuXHR9KVxufVxuXG5mdW5jdGlvbiBnZXRNZXJnZUZ1bmN0aW9uKGtleSwgb3B0aW9ucykge1xuXHRpZiAoIW9wdGlvbnMuY3VzdG9tTWVyZ2UpIHtcblx0XHRyZXR1cm4gZGVlcG1lcmdlXG5cdH1cblx0dmFyIGN1c3RvbU1lcmdlID0gb3B0aW9ucy5jdXN0b21NZXJnZShrZXkpO1xuXHRyZXR1cm4gdHlwZW9mIGN1c3RvbU1lcmdlID09PSAnZnVuY3Rpb24nID8gY3VzdG9tTWVyZ2UgOiBkZWVwbWVyZ2Vcbn1cblxuZnVuY3Rpb24gZ2V0RW51bWVyYWJsZU93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpIHtcblx0cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHNcblx0XHQ/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KS5maWx0ZXIoZnVuY3Rpb24oc3ltYm9sKSB7XG5cdFx0XHRyZXR1cm4gT2JqZWN0LnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodGFyZ2V0LCBzeW1ib2wpXG5cdFx0fSlcblx0XHQ6IFtdXG59XG5cbmZ1bmN0aW9uIGdldEtleXModGFyZ2V0KSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyh0YXJnZXQpLmNvbmNhdChnZXRFbnVtZXJhYmxlT3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpXG59XG5cbmZ1bmN0aW9uIHByb3BlcnR5SXNPbk9iamVjdChvYmplY3QsIHByb3BlcnR5KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHByb3BlcnR5IGluIG9iamVjdFxuXHR9IGNhdGNoKF8pIHtcblx0XHRyZXR1cm4gZmFsc2Vcblx0fVxufVxuXG4vLyBQcm90ZWN0cyBmcm9tIHByb3RvdHlwZSBwb2lzb25pbmcgYW5kIHVuZXhwZWN0ZWQgbWVyZ2luZyB1cCB0aGUgcHJvdG90eXBlIGNoYWluLlxuZnVuY3Rpb24gcHJvcGVydHlJc1Vuc2FmZSh0YXJnZXQsIGtleSkge1xuXHRyZXR1cm4gcHJvcGVydHlJc09uT2JqZWN0KHRhcmdldCwga2V5KSAvLyBQcm9wZXJ0aWVzIGFyZSBzYWZlIHRvIG1lcmdlIGlmIHRoZXkgZG9uJ3QgZXhpc3QgaW4gdGhlIHRhcmdldCB5ZXQsXG5cdFx0JiYgIShPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIGtleSkgLy8gdW5zYWZlIGlmIHRoZXkgZXhpc3QgdXAgdGhlIHByb3RvdHlwZSBjaGFpbixcblx0XHRcdCYmIE9iamVjdC5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHRhcmdldCwga2V5KSkgLy8gYW5kIGFsc28gdW5zYWZlIGlmIHRoZXkncmUgbm9uZW51bWVyYWJsZS5cbn1cblxuZnVuY3Rpb24gbWVyZ2VPYmplY3QodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0dmFyIGRlc3RpbmF0aW9uID0ge307XG5cdGlmIChvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0KHRhcmdldCkpIHtcblx0XHRnZXRLZXlzKHRhcmdldCkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHRcdGRlc3RpbmF0aW9uW2tleV0gPSBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCh0YXJnZXRba2V5XSwgb3B0aW9ucyk7XG5cdFx0fSk7XG5cdH1cblx0Z2V0S2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0aWYgKHByb3BlcnR5SXNVbnNhZmUodGFyZ2V0LCBrZXkpKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cblx0XHRpZiAocHJvcGVydHlJc09uT2JqZWN0KHRhcmdldCwga2V5KSAmJiBvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0KHNvdXJjZVtrZXldKSkge1xuXHRcdFx0ZGVzdGluYXRpb25ba2V5XSA9IGdldE1lcmdlRnVuY3Rpb24oa2V5LCBvcHRpb25zKSh0YXJnZXRba2V5XSwgc291cmNlW2tleV0sIG9wdGlvbnMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZXN0aW5hdGlvbltrZXldID0gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoc291cmNlW2tleV0sIG9wdGlvbnMpO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBkZXN0aW5hdGlvblxufVxuXG5mdW5jdGlvbiBkZWVwbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdG9wdGlvbnMuYXJyYXlNZXJnZSA9IG9wdGlvbnMuYXJyYXlNZXJnZSB8fCBkZWZhdWx0QXJyYXlNZXJnZTtcblx0b3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdCA9IG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QgfHwgaXNNZXJnZWFibGVPYmplY3Q7XG5cdC8vIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkIGlzIGFkZGVkIHRvIGBvcHRpb25zYCBzbyB0aGF0IGN1c3RvbSBhcnJheU1lcmdlKClcblx0Ly8gaW1wbGVtZW50YXRpb25zIGNhbiB1c2UgaXQuIFRoZSBjYWxsZXIgbWF5IG5vdCByZXBsYWNlIGl0LlxuXHRvcHRpb25zLmNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkID0gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQ7XG5cblx0dmFyIHNvdXJjZUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHNvdXJjZSk7XG5cdHZhciB0YXJnZXRJc0FycmF5ID0gQXJyYXkuaXNBcnJheSh0YXJnZXQpO1xuXHR2YXIgc291cmNlQW5kVGFyZ2V0VHlwZXNNYXRjaCA9IHNvdXJjZUlzQXJyYXkgPT09IHRhcmdldElzQXJyYXk7XG5cblx0aWYgKCFzb3VyY2VBbmRUYXJnZXRUeXBlc01hdGNoKSB7XG5cdFx0cmV0dXJuIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHNvdXJjZSwgb3B0aW9ucylcblx0fSBlbHNlIGlmIChzb3VyY2VJc0FycmF5KSB7XG5cdFx0cmV0dXJuIG9wdGlvbnMuYXJyYXlNZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucylcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gbWVyZ2VPYmplY3QodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpXG5cdH1cbn1cblxuZGVlcG1lcmdlLmFsbCA9IGZ1bmN0aW9uIGRlZXBtZXJnZUFsbChhcnJheSwgb3B0aW9ucykge1xuXHRpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmd1bWVudCBzaG91bGQgYmUgYW4gYXJyYXknKVxuXHR9XG5cblx0cmV0dXJuIGFycmF5LnJlZHVjZShmdW5jdGlvbihwcmV2LCBuZXh0KSB7XG5cdFx0cmV0dXJuIGRlZXBtZXJnZShwcmV2LCBuZXh0LCBvcHRpb25zKVxuXHR9LCB7fSlcbn07XG5cbnZhciBkZWVwbWVyZ2VfMSA9IGRlZXBtZXJnZTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWVwbWVyZ2VfMTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgRWxlbWVudGAuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwYXJhbSB0byBjaGVjayBpZiBpdCBpcyBhbiBFbGVtZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRWxlbWVudDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBIVE1MRWxlbWVudGAuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwYXJhbSB0byBjaGVjayBpZiBpdCBpcyBhbiBIVE1MRWxlbWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNIVE1MRWxlbWVudCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwYXJhbSB0byBjaGVjayBpZiBpdCBpcyBhIGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTdHJpbmdgIG9iamVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBhcmFtIHRvIGNoZWNrIGlmIGl0IGlzIGEgc3RyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB1bmRlZmluZWQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwYXJhbSB0byBjaGVjayBpZiBpdCBpcyB1bmRlZmluZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuIiwiaW1wb3J0IHsgaXNVbmRlZmluZWQgfSBmcm9tICcuL3V0aWxzL3R5cGUtY2hlY2snO1xuXG5leHBvcnQgY2xhc3MgRXZlbnRlZCB7XG4gIG9uKGV2ZW50LCBoYW5kbGVyLCBjdHgsIG9uY2UgPSBmYWxzZSkge1xuICAgIGlmIChpc1VuZGVmaW5lZCh0aGlzLmJpbmRpbmdzKSkge1xuICAgICAgdGhpcy5iaW5kaW5ncyA9IHt9O1xuICAgIH1cbiAgICBpZiAoaXNVbmRlZmluZWQodGhpcy5iaW5kaW5nc1tldmVudF0pKSB7XG4gICAgICB0aGlzLmJpbmRpbmdzW2V2ZW50XSA9IFtdO1xuICAgIH1cbiAgICB0aGlzLmJpbmRpbmdzW2V2ZW50XS5wdXNoKHsgaGFuZGxlciwgY3R4LCBvbmNlIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBvbmNlKGV2ZW50LCBoYW5kbGVyLCBjdHgpIHtcbiAgICByZXR1cm4gdGhpcy5vbihldmVudCwgaGFuZGxlciwgY3R4LCB0cnVlKTtcbiAgfVxuXG4gIG9mZihldmVudCwgaGFuZGxlcikge1xuICAgIGlmIChpc1VuZGVmaW5lZCh0aGlzLmJpbmRpbmdzKSB8fCBpc1VuZGVmaW5lZCh0aGlzLmJpbmRpbmdzW2V2ZW50XSkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSkge1xuICAgICAgZGVsZXRlIHRoaXMuYmluZGluZ3NbZXZlbnRdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJpbmRpbmdzW2V2ZW50XS5mb3JFYWNoKChiaW5kaW5nLCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAoYmluZGluZy5oYW5kbGVyID09PSBoYW5kbGVyKSB7XG4gICAgICAgICAgdGhpcy5iaW5kaW5nc1tldmVudF0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0cmlnZ2VyKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLmJpbmRpbmdzKSAmJiB0aGlzLmJpbmRpbmdzW2V2ZW50XSkge1xuICAgICAgdGhpcy5iaW5kaW5nc1tldmVudF0uZm9yRWFjaCgoYmluZGluZywgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgeyBjdHgsIGhhbmRsZXIsIG9uY2UgfSA9IGJpbmRpbmc7XG5cbiAgICAgICAgY29uc3QgY29udGV4dCA9IGN0eCB8fCB0aGlzO1xuXG4gICAgICAgIGhhbmRsZXIuYXBwbHkoY29udGV4dCwgYXJncyk7XG5cbiAgICAgICAgaWYgKG9uY2UpIHtcbiAgICAgICAgICB0aGlzLmJpbmRpbmdzW2V2ZW50XS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuIiwiLyoqXG4gKiBCaW5kcyBhbGwgdGhlIG1ldGhvZHMgb24gYSBKUyBDbGFzcyB0byB0aGUgYHRoaXNgIGNvbnRleHQgb2YgdGhlIGNsYXNzLlxuICogQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvYXV0by1iaW5kXG4gKiBAcGFyYW0ge29iamVjdH0gc2VsZiBUaGUgYHRoaXNgIGNvbnRleHQgb2YgdGhlIGNsYXNzXG4gKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBgdGhpc2AgY29udGV4dCBvZiB0aGUgY2xhc3NcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXV0b0JpbmQoc2VsZikge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc2VsZi5jb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgIGNvbnN0IHZhbCA9IHNlbGZba2V5XTtcbiAgICBpZiAoa2V5ICE9PSAnY29uc3RydWN0b3InICYmIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHNlbGZba2V5XSA9IHZhbC5iaW5kKHNlbGYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuIiwiaW1wb3J0IHsgaXNVbmRlZmluZWQgfSBmcm9tICcuL3R5cGUtY2hlY2snO1xuXG4vKipcbiAqIFNldHMgdXAgdGhlIGhhbmRsZXIgdG8gZGV0ZXJtaW5lIGlmIHdlIHNob3VsZCBhZHZhbmNlIHRoZSB0b3VyXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcbiAqIEBwYXJhbSB7U3RlcH0gc3RlcCBUaGUgc3RlcCBpbnN0YW5jZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfc2V0dXBBZHZhbmNlT25IYW5kbGVyKHNlbGVjdG9yLCBzdGVwKSB7XG4gIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICBpZiAoc3RlcC5pc09wZW4oKSkge1xuICAgICAgY29uc3QgdGFyZ2V0SXNFbCA9IHN0ZXAuZWwgJiYgZXZlbnQuY3VycmVudFRhcmdldCA9PT0gc3RlcC5lbDtcbiAgICAgIGNvbnN0IHRhcmdldElzU2VsZWN0b3IgPVxuICAgICAgICAhaXNVbmRlZmluZWQoc2VsZWN0b3IpICYmIGV2ZW50LmN1cnJlbnRUYXJnZXQubWF0Y2hlcyhzZWxlY3Rvcik7XG5cbiAgICAgIGlmICh0YXJnZXRJc1NlbGVjdG9yIHx8IHRhcmdldElzRWwpIHtcbiAgICAgICAgc3RlcC50b3VyLm5leHQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQmluZCB0aGUgZXZlbnQgaGFuZGxlciBmb3IgYWR2YW5jZU9uXG4gKiBAcGFyYW0ge1N0ZXB9IHN0ZXAgVGhlIHN0ZXAgaW5zdGFuY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRBZHZhbmNlKHN0ZXApIHtcbiAgLy8gQW4gZW1wdHkgc2VsZWN0b3IgbWF0Y2hlcyB0aGUgc3RlcCBlbGVtZW50XG4gIGNvbnN0IHsgZXZlbnQsIHNlbGVjdG9yIH0gPSBzdGVwLm9wdGlvbnMuYWR2YW5jZU9uIHx8IHt9O1xuICBpZiAoZXZlbnQpIHtcbiAgICBjb25zdCBoYW5kbGVyID0gX3NldHVwQWR2YW5jZU9uSGFuZGxlcihzZWxlY3Rvciwgc3RlcCk7XG5cbiAgICAvLyBUT0RPOiB0aGlzIHNob3VsZCBhbHNvIGJpbmQvdW5iaW5kIG9uIHNob3cvaGlkZVxuICAgIGxldCBlbDtcbiAgICB0cnkge1xuICAgICAgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBUT0RPXG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoc2VsZWN0b3IpICYmICFlbCkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIGBObyBlbGVtZW50IHdhcyBmb3VuZCBmb3IgdGhlIHNlbGVjdG9yIHN1cHBsaWVkIHRvIGFkdmFuY2VPbjogJHtzZWxlY3Rvcn1gXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoZWwpIHtcbiAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIpO1xuICAgICAgc3RlcC5vbignZGVzdHJveScsICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgdHJ1ZSk7XG4gICAgICBzdGVwLm9uKCdkZXN0cm95JywgKCkgPT4ge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCB0cnVlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29uc29sZS5lcnJvcihcbiAgICAgICdhZHZhbmNlT24gd2FzIGRlZmluZWQsIGJ1dCBubyBldmVudCBuYW1lIHdhcyBwYXNzZWQuJ1xuICAgICk7XG4gIH1cbn1cbiIsImltcG9ydCB7IGlzRnVuY3Rpb24sIGlzU3RyaW5nIH0gZnJvbSAnLi90eXBlLWNoZWNrJztcblxuLyoqXG4gKiBFbnN1cmUgY2xhc3MgcHJlZml4IGVuZHMgaW4gYC1gXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IFRoZSBwcmVmaXggdG8gcHJlcGVuZCB0byB0aGUgY2xhc3MgbmFtZXMgZ2VuZXJhdGVkIGJ5IG5hbm8tY3NzXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBwcmVmaXggZW5kaW5nIGluIGAtYFxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplUHJlZml4KHByZWZpeCkge1xuICBpZiAoIWlzU3RyaW5nKHByZWZpeCkgfHwgcHJlZml4ID09PSAnJykge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHJldHVybiBwcmVmaXguY2hhckF0KHByZWZpeC5sZW5ndGggLSAxKSAhPT0gJy0nID8gYCR7cHJlZml4fS1gIDogcHJlZml4O1xufVxuXG4vKipcbiAqIFJlc29sdmVzIGF0dGFjaFRvIG9wdGlvbnMsIGNvbnZlcnRpbmcgZWxlbWVudCBvcHRpb24gdmFsdWUgdG8gYSBxdWFsaWZpZWQgSFRNTEVsZW1lbnQuXG4gKiBAcGFyYW0ge1N0ZXB9IHN0ZXAgVGhlIHN0ZXAgaW5zdGFuY2VcbiAqIEByZXR1cm5zIHt7fXx7ZWxlbWVudCwgb259fVxuICogYGVsZW1lbnRgIGlzIGEgcXVhbGlmaWVkIEhUTUwgRWxlbWVudFxuICogYG9uYCBpcyBhIHN0cmluZyBwb3NpdGlvbiB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VBdHRhY2hUbyhzdGVwKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBzdGVwLm9wdGlvbnMuYXR0YWNoVG8gfHwge307XG4gIGNvbnN0IHJldHVybk9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcblxuICBpZiAoaXNGdW5jdGlvbihyZXR1cm5PcHRzLmVsZW1lbnQpKSB7XG4gICAgLy8gQmluZCB0aGUgY2FsbGJhY2sgdG8gc3RlcCBzbyB0aGF0IGl0IGhhcyBhY2Nlc3MgdG8gdGhlIG9iamVjdCwgdG8gZW5hYmxlIHJ1bm5pbmcgYWRkaXRpb25hbCBsb2dpY1xuICAgIHJldHVybk9wdHMuZWxlbWVudCA9IHJldHVybk9wdHMuZWxlbWVudC5jYWxsKHN0ZXApO1xuICB9XG5cbiAgaWYgKGlzU3RyaW5nKHJldHVybk9wdHMuZWxlbWVudCkpIHtcbiAgICAvLyBDYW4ndCBvdmVycmlkZSB0aGUgZWxlbWVudCBpbiB1c2VyIG9wdHMgcmVmZXJlbmNlIGJlY2F1c2Ugd2UgY2FuJ3RcbiAgICAvLyBndWFyYW50ZWUgdGhhdCB0aGUgZWxlbWVudCB3aWxsIGV4aXN0IGluIHRoZSBmdXR1cmUuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybk9wdHMuZWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocmV0dXJuT3B0cy5lbGVtZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBUT0RPXG4gICAgfVxuICAgIGlmICghcmV0dXJuT3B0cy5lbGVtZW50KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBgVGhlIGVsZW1lbnQgZm9yIHRoaXMgU2hlcGhlcmQgc3RlcCB3YXMgbm90IGZvdW5kICR7b3B0aW9ucy5lbGVtZW50fWBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldHVybk9wdHM7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBzdGVwIHNob3VsZCBiZSBjZW50ZXJlZCBvciBub3QuIERvZXMgbm90IHRyaWdnZXIgYXR0YWNoVG8uZWxlbWVudCBldmFsdWF0aW9uLCBtYWtpbmcgaXQgYSBwdXJlXG4gKiBhbHRlcm5hdGl2ZSBmb3IgdGhlIGRlcHJlY2F0ZWQgc3RlcC5pc0NlbnRlcmVkKCkgbWV0aG9kLlxuICogQHBhcmFtIHJlc29sdmVkQXR0YWNoVG9PcHRpb25zXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNob3VsZENlbnRlclN0ZXAocmVzb2x2ZWRBdHRhY2hUb09wdGlvbnMpIHtcbiAgaWYgKFxuICAgIHJlc29sdmVkQXR0YWNoVG9PcHRpb25zID09PSB1bmRlZmluZWQgfHxcbiAgICByZXNvbHZlZEF0dGFjaFRvT3B0aW9ucyA9PT0gbnVsbFxuICApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiAhcmVzb2x2ZWRBdHRhY2hUb09wdGlvbnMuZWxlbWVudCB8fCAhcmVzb2x2ZWRBdHRhY2hUb09wdGlvbnMub247XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgdW5pcXVlIGlkIGZvciBzdGVwcywgdG91cnMsIG1vZGFscywgZXRjXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dWlkKCkge1xuICBsZXQgZCA9IERhdGUubm93KCk7XG4gIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIChjKSA9PiB7XG4gICAgY29uc3QgciA9IChkICsgTWF0aC5yYW5kb20oKSAqIDE2KSAlIDE2IHwgMDtcbiAgICBkID0gTWF0aC5mbG9vcihkIC8gMTYpO1xuICAgIHJldHVybiAoYyA9PSAneCcgPyByIDogKHIgJiAweDMpIHwgMHg4KS50b1N0cmluZygxNik7XG4gIH0pO1xufVxuIiwiY29uc3Qgc2lkZXMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xuY29uc3QgYWxpZ25tZW50cyA9IFsnc3RhcnQnLCAnZW5kJ107XG5jb25zdCBwbGFjZW1lbnRzID0gLyojX19QVVJFX18qL3NpZGVzLnJlZHVjZSgoYWNjLCBzaWRlKSA9PiBhY2MuY29uY2F0KHNpZGUsIHNpZGUgKyBcIi1cIiArIGFsaWdubWVudHNbMF0sIHNpZGUgKyBcIi1cIiArIGFsaWdubWVudHNbMV0pLCBbXSk7XG5jb25zdCBtaW4gPSBNYXRoLm1pbjtcbmNvbnN0IG1heCA9IE1hdGgubWF4O1xuY29uc3Qgcm91bmQgPSBNYXRoLnJvdW5kO1xuY29uc3QgZmxvb3IgPSBNYXRoLmZsb29yO1xuY29uc3QgY3JlYXRlQ29vcmRzID0gdiA9PiAoe1xuICB4OiB2LFxuICB5OiB2XG59KTtcbmNvbnN0IG9wcG9zaXRlU2lkZU1hcCA9IHtcbiAgbGVmdDogJ3JpZ2h0JyxcbiAgcmlnaHQ6ICdsZWZ0JyxcbiAgYm90dG9tOiAndG9wJyxcbiAgdG9wOiAnYm90dG9tJ1xufTtcbmNvbnN0IG9wcG9zaXRlQWxpZ25tZW50TWFwID0ge1xuICBzdGFydDogJ2VuZCcsXG4gIGVuZDogJ3N0YXJ0J1xufTtcbmZ1bmN0aW9uIGNsYW1wKHN0YXJ0LCB2YWx1ZSwgZW5kKSB7XG4gIHJldHVybiBtYXgoc3RhcnQsIG1pbih2YWx1ZSwgZW5kKSk7XG59XG5mdW5jdGlvbiBldmFsdWF0ZSh2YWx1ZSwgcGFyYW0pIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlKHBhcmFtKSA6IHZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0U2lkZShwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xufVxuZnVuY3Rpb24gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZUF4aXMoYXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xufVxuZnVuY3Rpb24gZ2V0QXhpc0xlbmd0aChheGlzKSB7XG4gIHJldHVybiBheGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG59XG5mdW5jdGlvbiBnZXRTaWRlQXhpcyhwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIFsndG9wJywgJ2JvdHRvbSddLmluY2x1ZGVzKGdldFNpZGUocGxhY2VtZW50KSkgPyAneScgOiAneCc7XG59XG5mdW5jdGlvbiBnZXRBbGlnbm1lbnRBeGlzKHBsYWNlbWVudCkge1xuICByZXR1cm4gZ2V0T3Bwb3NpdGVBeGlzKGdldFNpZGVBeGlzKHBsYWNlbWVudCkpO1xufVxuZnVuY3Rpb24gZ2V0QWxpZ25tZW50U2lkZXMocGxhY2VtZW50LCByZWN0cywgcnRsKSB7XG4gIGlmIChydGwgPT09IHZvaWQgMCkge1xuICAgIHJ0bCA9IGZhbHNlO1xuICB9XG4gIGNvbnN0IGFsaWdubWVudCA9IGdldEFsaWdubWVudChwbGFjZW1lbnQpO1xuICBjb25zdCBhbGlnbm1lbnRBeGlzID0gZ2V0QWxpZ25tZW50QXhpcyhwbGFjZW1lbnQpO1xuICBjb25zdCBsZW5ndGggPSBnZXRBeGlzTGVuZ3RoKGFsaWdubWVudEF4aXMpO1xuICBsZXQgbWFpbkFsaWdubWVudFNpZGUgPSBhbGlnbm1lbnRBeGlzID09PSAneCcgPyBhbGlnbm1lbnQgPT09IChydGwgPyAnZW5kJyA6ICdzdGFydCcpID8gJ3JpZ2h0JyA6ICdsZWZ0JyA6IGFsaWdubWVudCA9PT0gJ3N0YXJ0JyA/ICdib3R0b20nIDogJ3RvcCc7XG4gIGlmIChyZWN0cy5yZWZlcmVuY2VbbGVuZ3RoXSA+IHJlY3RzLmZsb2F0aW5nW2xlbmd0aF0pIHtcbiAgICBtYWluQWxpZ25tZW50U2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5BbGlnbm1lbnRTaWRlKTtcbiAgfVxuICByZXR1cm4gW21haW5BbGlnbm1lbnRTaWRlLCBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluQWxpZ25tZW50U2lkZSldO1xufVxuZnVuY3Rpb24gZ2V0RXhwYW5kZWRQbGFjZW1lbnRzKHBsYWNlbWVudCkge1xuICBjb25zdCBvcHBvc2l0ZVBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHJldHVybiBbZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQocGxhY2VtZW50KSwgb3Bwb3NpdGVQbGFjZW1lbnQsIGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KG9wcG9zaXRlUGxhY2VtZW50KV07XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9zdGFydHxlbmQvZywgYWxpZ25tZW50ID0+IG9wcG9zaXRlQWxpZ25tZW50TWFwW2FsaWdubWVudF0pO1xufVxuZnVuY3Rpb24gZ2V0U2lkZUxpc3Qoc2lkZSwgaXNTdGFydCwgcnRsKSB7XG4gIGNvbnN0IGxyID0gWydsZWZ0JywgJ3JpZ2h0J107XG4gIGNvbnN0IHJsID0gWydyaWdodCcsICdsZWZ0J107XG4gIGNvbnN0IHRiID0gWyd0b3AnLCAnYm90dG9tJ107XG4gIGNvbnN0IGJ0ID0gWydib3R0b20nLCAndG9wJ107XG4gIHN3aXRjaCAoc2lkZSkge1xuICAgIGNhc2UgJ3RvcCc6XG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIGlmIChydGwpIHJldHVybiBpc1N0YXJ0ID8gcmwgOiBscjtcbiAgICAgIHJldHVybiBpc1N0YXJ0ID8gbHIgOiBybDtcbiAgICBjYXNlICdsZWZ0JzpcbiAgICBjYXNlICdyaWdodCc6XG4gICAgICByZXR1cm4gaXNTdGFydCA/IHRiIDogYnQ7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBbXTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVBeGlzUGxhY2VtZW50cyhwbGFjZW1lbnQsIGZsaXBBbGlnbm1lbnQsIGRpcmVjdGlvbiwgcnRsKSB7XG4gIGNvbnN0IGFsaWdubWVudCA9IGdldEFsaWdubWVudChwbGFjZW1lbnQpO1xuICBsZXQgbGlzdCA9IGdldFNpZGVMaXN0KGdldFNpZGUocGxhY2VtZW50KSwgZGlyZWN0aW9uID09PSAnc3RhcnQnLCBydGwpO1xuICBpZiAoYWxpZ25tZW50KSB7XG4gICAgbGlzdCA9IGxpc3QubWFwKHNpZGUgPT4gc2lkZSArIFwiLVwiICsgYWxpZ25tZW50KTtcbiAgICBpZiAoZmxpcEFsaWdubWVudCkge1xuICAgICAgbGlzdCA9IGxpc3QuY29uY2F0KGxpc3QubWFwKGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBsaXN0O1xufVxuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIHNpZGUgPT4gb3Bwb3NpdGVTaWRlTWFwW3NpZGVdKTtcbn1cbmZ1bmN0aW9uIGV4cGFuZFBhZGRpbmdPYmplY3QocGFkZGluZykge1xuICByZXR1cm4ge1xuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMCxcbiAgICAuLi5wYWRkaW5nXG4gIH07XG59XG5mdW5jdGlvbiBnZXRQYWRkaW5nT2JqZWN0KHBhZGRpbmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IGV4cGFuZFBhZGRpbmdPYmplY3QocGFkZGluZykgOiB7XG4gICAgdG9wOiBwYWRkaW5nLFxuICAgIHJpZ2h0OiBwYWRkaW5nLFxuICAgIGJvdHRvbTogcGFkZGluZyxcbiAgICBsZWZ0OiBwYWRkaW5nXG4gIH07XG59XG5mdW5jdGlvbiByZWN0VG9DbGllbnRSZWN0KHJlY3QpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5yZWN0LFxuICAgIHRvcDogcmVjdC55LFxuICAgIGxlZnQ6IHJlY3QueCxcbiAgICByaWdodDogcmVjdC54ICsgcmVjdC53aWR0aCxcbiAgICBib3R0b206IHJlY3QueSArIHJlY3QuaGVpZ2h0XG4gIH07XG59XG5cbmV4cG9ydCB7IGFsaWdubWVudHMsIGNsYW1wLCBjcmVhdGVDb29yZHMsIGV2YWx1YXRlLCBleHBhbmRQYWRkaW5nT2JqZWN0LCBmbG9vciwgZ2V0QWxpZ25tZW50LCBnZXRBbGlnbm1lbnRBeGlzLCBnZXRBbGlnbm1lbnRTaWRlcywgZ2V0QXhpc0xlbmd0aCwgZ2V0RXhwYW5kZWRQbGFjZW1lbnRzLCBnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudCwgZ2V0T3Bwb3NpdGVBeGlzLCBnZXRPcHBvc2l0ZUF4aXNQbGFjZW1lbnRzLCBnZXRPcHBvc2l0ZVBsYWNlbWVudCwgZ2V0UGFkZGluZ09iamVjdCwgZ2V0U2lkZSwgZ2V0U2lkZUF4aXMsIG1heCwgbWluLCBwbGFjZW1lbnRzLCByZWN0VG9DbGllbnRSZWN0LCByb3VuZCwgc2lkZXMgfTtcbiIsImltcG9ydCB7IGdldFNpZGVBeGlzLCBnZXRBbGlnbm1lbnRBeGlzLCBnZXRBeGlzTGVuZ3RoLCBnZXRTaWRlLCBnZXRBbGlnbm1lbnQsIGV2YWx1YXRlLCBnZXRQYWRkaW5nT2JqZWN0LCByZWN0VG9DbGllbnRSZWN0LCBtaW4sIGNsYW1wLCBwbGFjZW1lbnRzLCBnZXRBbGlnbm1lbnRTaWRlcywgZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQsIGdldE9wcG9zaXRlUGxhY2VtZW50LCBnZXRFeHBhbmRlZFBsYWNlbWVudHMsIGdldE9wcG9zaXRlQXhpc1BsYWNlbWVudHMsIHNpZGVzLCBtYXgsIGdldE9wcG9zaXRlQXhpcyB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscyc7XG5leHBvcnQgeyByZWN0VG9DbGllbnRSZWN0IH0gZnJvbSAnQGZsb2F0aW5nLXVpL3V0aWxzJztcblxuZnVuY3Rpb24gY29tcHV0ZUNvb3Jkc0Zyb21QbGFjZW1lbnQoX3JlZiwgcGxhY2VtZW50LCBydGwpIHtcbiAgbGV0IHtcbiAgICByZWZlcmVuY2UsXG4gICAgZmxvYXRpbmdcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IHNpZGVBeGlzID0gZ2V0U2lkZUF4aXMocGxhY2VtZW50KTtcbiAgY29uc3QgYWxpZ25tZW50QXhpcyA9IGdldEFsaWdubWVudEF4aXMocGxhY2VtZW50KTtcbiAgY29uc3QgYWxpZ25MZW5ndGggPSBnZXRBeGlzTGVuZ3RoKGFsaWdubWVudEF4aXMpO1xuICBjb25zdCBzaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpO1xuICBjb25zdCBpc1ZlcnRpY2FsID0gc2lkZUF4aXMgPT09ICd5JztcbiAgY29uc3QgY29tbW9uWCA9IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoIC8gMiAtIGZsb2F0aW5nLndpZHRoIC8gMjtcbiAgY29uc3QgY29tbW9uWSA9IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodCAvIDIgLSBmbG9hdGluZy5oZWlnaHQgLyAyO1xuICBjb25zdCBjb21tb25BbGlnbiA9IHJlZmVyZW5jZVthbGlnbkxlbmd0aF0gLyAyIC0gZmxvYXRpbmdbYWxpZ25MZW5ndGhdIC8gMjtcbiAgbGV0IGNvb3JkcztcbiAgc3dpdGNoIChzaWRlKSB7XG4gICAgY2FzZSAndG9wJzpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgLSBmbG9hdGluZy5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdib3R0b20nOlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdyaWdodCc6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbGVmdCc6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54IC0gZmxvYXRpbmcud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vbllcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnlcbiAgICAgIH07XG4gIH1cbiAgc3dpdGNoIChnZXRBbGlnbm1lbnQocGxhY2VtZW50KSkge1xuICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgIGNvb3Jkc1thbGlnbm1lbnRBeGlzXSAtPSBjb21tb25BbGlnbiAqIChydGwgJiYgaXNWZXJ0aWNhbCA/IC0xIDogMSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdlbmQnOlxuICAgICAgY29vcmRzW2FsaWdubWVudEF4aXNdICs9IGNvbW1vbkFsaWduICogKHJ0bCAmJiBpc1ZlcnRpY2FsID8gLTEgOiAxKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBjb29yZHM7XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzIHRoYXQgd2lsbCBwbGFjZSB0aGUgZmxvYXRpbmcgZWxlbWVudFxuICogbmV4dCB0byBhIHJlZmVyZW5jZSBlbGVtZW50IHdoZW4gaXQgaXMgZ2l2ZW4gYSBjZXJ0YWluIHBvc2l0aW9uaW5nIHN0cmF0ZWd5LlxuICpcbiAqIFRoaXMgZXhwb3J0IGRvZXMgbm90IGhhdmUgYW55IGBwbGF0Zm9ybWAgaW50ZXJmYWNlIGxvZ2ljLiBZb3Ugd2lsbCBuZWVkIHRvXG4gKiB3cml0ZSBvbmUgZm9yIHRoZSBwbGF0Zm9ybSB5b3UgYXJlIHVzaW5nIEZsb2F0aW5nIFVJIHdpdGguXG4gKi9cbmNvbnN0IGNvbXB1dGVQb3NpdGlvbiA9IGFzeW5jIChyZWZlcmVuY2UsIGZsb2F0aW5nLCBjb25maWcpID0+IHtcbiAgY29uc3Qge1xuICAgIHBsYWNlbWVudCA9ICdib3R0b20nLFxuICAgIHN0cmF0ZWd5ID0gJ2Fic29sdXRlJyxcbiAgICBtaWRkbGV3YXJlID0gW10sXG4gICAgcGxhdGZvcm1cbiAgfSA9IGNvbmZpZztcbiAgY29uc3QgdmFsaWRNaWRkbGV3YXJlID0gbWlkZGxld2FyZS5maWx0ZXIoQm9vbGVhbik7XG4gIGNvbnN0IHJ0bCA9IGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZmxvYXRpbmcpKTtcbiAgbGV0IHJlY3RzID0gYXdhaXQgcGxhdGZvcm0uZ2V0RWxlbWVudFJlY3RzKHtcbiAgICByZWZlcmVuY2UsXG4gICAgZmxvYXRpbmcsXG4gICAgc3RyYXRlZ3lcbiAgfSk7XG4gIGxldCB7XG4gICAgeCxcbiAgICB5XG4gIH0gPSBjb21wdXRlQ29vcmRzRnJvbVBsYWNlbWVudChyZWN0cywgcGxhY2VtZW50LCBydGwpO1xuICBsZXQgc3RhdGVmdWxQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gIGxldCBtaWRkbGV3YXJlRGF0YSA9IHt9O1xuICBsZXQgcmVzZXRDb3VudCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsaWRNaWRkbGV3YXJlLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIGZuXG4gICAgfSA9IHZhbGlkTWlkZGxld2FyZVtpXTtcbiAgICBjb25zdCB7XG4gICAgICB4OiBuZXh0WCxcbiAgICAgIHk6IG5leHRZLFxuICAgICAgZGF0YSxcbiAgICAgIHJlc2V0XG4gICAgfSA9IGF3YWl0IGZuKHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgaW5pdGlhbFBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgcGxhY2VtZW50OiBzdGF0ZWZ1bFBsYWNlbWVudCxcbiAgICAgIHN0cmF0ZWd5LFxuICAgICAgbWlkZGxld2FyZURhdGEsXG4gICAgICByZWN0cyxcbiAgICAgIHBsYXRmb3JtLFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgcmVmZXJlbmNlLFxuICAgICAgICBmbG9hdGluZ1xuICAgICAgfVxuICAgIH0pO1xuICAgIHggPSBuZXh0WCAhPSBudWxsID8gbmV4dFggOiB4O1xuICAgIHkgPSBuZXh0WSAhPSBudWxsID8gbmV4dFkgOiB5O1xuICAgIG1pZGRsZXdhcmVEYXRhID0ge1xuICAgICAgLi4ubWlkZGxld2FyZURhdGEsXG4gICAgICBbbmFtZV06IHtcbiAgICAgICAgLi4ubWlkZGxld2FyZURhdGFbbmFtZV0sXG4gICAgICAgIC4uLmRhdGFcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChyZXNldCAmJiByZXNldENvdW50IDw9IDUwKSB7XG4gICAgICByZXNldENvdW50Kys7XG4gICAgICBpZiAodHlwZW9mIHJlc2V0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAocmVzZXQucGxhY2VtZW50KSB7XG4gICAgICAgICAgc3RhdGVmdWxQbGFjZW1lbnQgPSByZXNldC5wbGFjZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc2V0LnJlY3RzKSB7XG4gICAgICAgICAgcmVjdHMgPSByZXNldC5yZWN0cyA9PT0gdHJ1ZSA/IGF3YWl0IHBsYXRmb3JtLmdldEVsZW1lbnRSZWN0cyh7XG4gICAgICAgICAgICByZWZlcmVuY2UsXG4gICAgICAgICAgICBmbG9hdGluZyxcbiAgICAgICAgICAgIHN0cmF0ZWd5XG4gICAgICAgICAgfSkgOiByZXNldC5yZWN0cztcbiAgICAgICAgfVxuICAgICAgICAoe1xuICAgICAgICAgIHgsXG4gICAgICAgICAgeVxuICAgICAgICB9ID0gY29tcHV0ZUNvb3Jkc0Zyb21QbGFjZW1lbnQocmVjdHMsIHN0YXRlZnVsUGxhY2VtZW50LCBydGwpKTtcbiAgICAgIH1cbiAgICAgIGkgPSAtMTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHgsXG4gICAgeSxcbiAgICBwbGFjZW1lbnQ6IHN0YXRlZnVsUGxhY2VtZW50LFxuICAgIHN0cmF0ZWd5LFxuICAgIG1pZGRsZXdhcmVEYXRhXG4gIH07XG59O1xuXG4vKipcbiAqIFJlc29sdmVzIHdpdGggYW4gb2JqZWN0IG9mIG92ZXJmbG93IHNpZGUgb2Zmc2V0cyB0aGF0IGRldGVybWluZSBob3cgbXVjaCB0aGVcbiAqIGVsZW1lbnQgaXMgb3ZlcmZsb3dpbmcgYSBnaXZlbiBjbGlwcGluZyBib3VuZGFyeSBvbiBlYWNoIHNpZGUuXG4gKiAtIHBvc2l0aXZlID0gb3ZlcmZsb3dpbmcgdGhlIGJvdW5kYXJ5IGJ5IHRoYXQgbnVtYmVyIG9mIHBpeGVsc1xuICogLSBuZWdhdGl2ZSA9IGhvdyBtYW55IHBpeGVscyBsZWZ0IGJlZm9yZSBpdCB3aWxsIG92ZXJmbG93XG4gKiAtIDAgPSBsaWVzIGZsdXNoIHdpdGggdGhlIGJvdW5kYXJ5XG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvZGV0ZWN0T3ZlcmZsb3dcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIG9wdGlvbnMpIHtcbiAgdmFyIF9hd2FpdCRwbGF0Zm9ybSRpc0VsZTtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgeCxcbiAgICB5LFxuICAgIHBsYXRmb3JtLFxuICAgIHJlY3RzLFxuICAgIGVsZW1lbnRzLFxuICAgIHN0cmF0ZWd5XG4gIH0gPSBzdGF0ZTtcbiAgY29uc3Qge1xuICAgIGJvdW5kYXJ5ID0gJ2NsaXBwaW5nQW5jZXN0b3JzJyxcbiAgICByb290Qm91bmRhcnkgPSAndmlld3BvcnQnLFxuICAgIGVsZW1lbnRDb250ZXh0ID0gJ2Zsb2F0aW5nJyxcbiAgICBhbHRCb3VuZGFyeSA9IGZhbHNlLFxuICAgIHBhZGRpbmcgPSAwXG4gIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gIGNvbnN0IHBhZGRpbmdPYmplY3QgPSBnZXRQYWRkaW5nT2JqZWN0KHBhZGRpbmcpO1xuICBjb25zdCBhbHRDb250ZXh0ID0gZWxlbWVudENvbnRleHQgPT09ICdmbG9hdGluZycgPyAncmVmZXJlbmNlJyA6ICdmbG9hdGluZyc7XG4gIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1thbHRCb3VuZGFyeSA/IGFsdENvbnRleHQgOiBlbGVtZW50Q29udGV4dF07XG4gIGNvbnN0IGNsaXBwaW5nQ2xpZW50UmVjdCA9IHJlY3RUb0NsaWVudFJlY3QoYXdhaXQgcGxhdGZvcm0uZ2V0Q2xpcHBpbmdSZWN0KHtcbiAgICBlbGVtZW50OiAoKF9hd2FpdCRwbGF0Zm9ybSRpc0VsZSA9IGF3YWl0IChwbGF0Zm9ybS5pc0VsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzRWxlbWVudChlbGVtZW50KSkpICE9IG51bGwgPyBfYXdhaXQkcGxhdGZvcm0kaXNFbGUgOiB0cnVlKSA/IGVsZW1lbnQgOiBlbGVtZW50LmNvbnRleHRFbGVtZW50IHx8IChhd2FpdCAocGxhdGZvcm0uZ2V0RG9jdW1lbnRFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudHMuZmxvYXRpbmcpKSksXG4gICAgYm91bmRhcnksXG4gICAgcm9vdEJvdW5kYXJ5LFxuICAgIHN0cmF0ZWd5XG4gIH0pKTtcbiAgY29uc3QgcmVjdCA9IGVsZW1lbnRDb250ZXh0ID09PSAnZmxvYXRpbmcnID8ge1xuICAgIC4uLnJlY3RzLmZsb2F0aW5nLFxuICAgIHgsXG4gICAgeVxuICB9IDogcmVjdHMucmVmZXJlbmNlO1xuICBjb25zdCBvZmZzZXRQYXJlbnQgPSBhd2FpdCAocGxhdGZvcm0uZ2V0T2Zmc2V0UGFyZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXRPZmZzZXRQYXJlbnQoZWxlbWVudHMuZmxvYXRpbmcpKTtcbiAgY29uc3Qgb2Zmc2V0U2NhbGUgPSAoYXdhaXQgKHBsYXRmb3JtLmlzRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNFbGVtZW50KG9mZnNldFBhcmVudCkpKSA/IChhd2FpdCAocGxhdGZvcm0uZ2V0U2NhbGUgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmdldFNjYWxlKG9mZnNldFBhcmVudCkpKSB8fCB7XG4gICAgeDogMSxcbiAgICB5OiAxXG4gIH0gOiB7XG4gICAgeDogMSxcbiAgICB5OiAxXG4gIH07XG4gIGNvbnN0IGVsZW1lbnRDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdChwbGF0Zm9ybS5jb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCA/IGF3YWl0IHBsYXRmb3JtLmNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0KHtcbiAgICByZWN0LFxuICAgIG9mZnNldFBhcmVudCxcbiAgICBzdHJhdGVneVxuICB9KSA6IHJlY3QpO1xuICByZXR1cm4ge1xuICAgIHRvcDogKGNsaXBwaW5nQ2xpZW50UmVjdC50b3AgLSBlbGVtZW50Q2xpZW50UmVjdC50b3AgKyBwYWRkaW5nT2JqZWN0LnRvcCkgLyBvZmZzZXRTY2FsZS55LFxuICAgIGJvdHRvbTogKGVsZW1lbnRDbGllbnRSZWN0LmJvdHRvbSAtIGNsaXBwaW5nQ2xpZW50UmVjdC5ib3R0b20gKyBwYWRkaW5nT2JqZWN0LmJvdHRvbSkgLyBvZmZzZXRTY2FsZS55LFxuICAgIGxlZnQ6IChjbGlwcGluZ0NsaWVudFJlY3QubGVmdCAtIGVsZW1lbnRDbGllbnRSZWN0LmxlZnQgKyBwYWRkaW5nT2JqZWN0LmxlZnQpIC8gb2Zmc2V0U2NhbGUueCxcbiAgICByaWdodDogKGVsZW1lbnRDbGllbnRSZWN0LnJpZ2h0IC0gY2xpcHBpbmdDbGllbnRSZWN0LnJpZ2h0ICsgcGFkZGluZ09iamVjdC5yaWdodCkgLyBvZmZzZXRTY2FsZS54XG4gIH07XG59XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBwb3NpdGlvbiBhbiBpbm5lciBlbGVtZW50IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IHNvIHRoYXQgaXRcbiAqIGFwcGVhcnMgY2VudGVyZWQgdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2Fycm93XG4gKi9cbmNvbnN0IGFycm93ID0gb3B0aW9ucyA9PiAoe1xuICBuYW1lOiAnYXJyb3cnLFxuICBvcHRpb25zLFxuICBhc3luYyBmbihzdGF0ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgcGxhY2VtZW50LFxuICAgICAgcmVjdHMsXG4gICAgICBwbGF0Zm9ybSxcbiAgICAgIGVsZW1lbnRzXG4gICAgfSA9IHN0YXRlO1xuICAgIC8vIFNpbmNlIGBlbGVtZW50YCBpcyByZXF1aXJlZCwgd2UgZG9uJ3QgUGFydGlhbDw+IHRoZSB0eXBlLlxuICAgIGNvbnN0IHtcbiAgICAgIGVsZW1lbnQsXG4gICAgICBwYWRkaW5nID0gMFxuICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSkgfHwge307XG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBjb25zdCBwYWRkaW5nT2JqZWN0ID0gZ2V0UGFkZGluZ09iamVjdChwYWRkaW5nKTtcbiAgICBjb25zdCBjb29yZHMgPSB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH07XG4gICAgY29uc3QgYXhpcyA9IGdldEFsaWdubWVudEF4aXMocGxhY2VtZW50KTtcbiAgICBjb25zdCBsZW5ndGggPSBnZXRBeGlzTGVuZ3RoKGF4aXMpO1xuICAgIGNvbnN0IGFycm93RGltZW5zaW9ucyA9IGF3YWl0IHBsYXRmb3JtLmdldERpbWVuc2lvbnMoZWxlbWVudCk7XG4gICAgY29uc3QgaXNZQXhpcyA9IGF4aXMgPT09ICd5JztcbiAgICBjb25zdCBtaW5Qcm9wID0gaXNZQXhpcyA/ICd0b3AnIDogJ2xlZnQnO1xuICAgIGNvbnN0IG1heFByb3AgPSBpc1lBeGlzID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICAgIGNvbnN0IGNsaWVudFByb3AgPSBpc1lBeGlzID8gJ2NsaWVudEhlaWdodCcgOiAnY2xpZW50V2lkdGgnO1xuICAgIGNvbnN0IGVuZERpZmYgPSByZWN0cy5yZWZlcmVuY2VbbGVuZ3RoXSArIHJlY3RzLnJlZmVyZW5jZVtheGlzXSAtIGNvb3Jkc1theGlzXSAtIHJlY3RzLmZsb2F0aW5nW2xlbmd0aF07XG4gICAgY29uc3Qgc3RhcnREaWZmID0gY29vcmRzW2F4aXNdIC0gcmVjdHMucmVmZXJlbmNlW2F4aXNdO1xuICAgIGNvbnN0IGFycm93T2Zmc2V0UGFyZW50ID0gYXdhaXQgKHBsYXRmb3JtLmdldE9mZnNldFBhcmVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpKTtcbiAgICBsZXQgY2xpZW50U2l6ZSA9IGFycm93T2Zmc2V0UGFyZW50ID8gYXJyb3dPZmZzZXRQYXJlbnRbY2xpZW50UHJvcF0gOiAwO1xuXG4gICAgLy8gRE9NIHBsYXRmb3JtIGNhbiByZXR1cm4gYHdpbmRvd2AgYXMgdGhlIGBvZmZzZXRQYXJlbnRgLlxuICAgIGlmICghY2xpZW50U2l6ZSB8fCAhKGF3YWl0IChwbGF0Zm9ybS5pc0VsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzRWxlbWVudChhcnJvd09mZnNldFBhcmVudCkpKSkge1xuICAgICAgY2xpZW50U2l6ZSA9IGVsZW1lbnRzLmZsb2F0aW5nW2NsaWVudFByb3BdIHx8IHJlY3RzLmZsb2F0aW5nW2xlbmd0aF07XG4gICAgfVxuICAgIGNvbnN0IGNlbnRlclRvUmVmZXJlbmNlID0gZW5kRGlmZiAvIDIgLSBzdGFydERpZmYgLyAyO1xuXG4gICAgLy8gSWYgdGhlIHBhZGRpbmcgaXMgbGFyZ2UgZW5vdWdoIHRoYXQgaXQgY2F1c2VzIHRoZSBhcnJvdyB0byBubyBsb25nZXIgYmVcbiAgICAvLyBjZW50ZXJlZCwgbW9kaWZ5IHRoZSBwYWRkaW5nIHNvIHRoYXQgaXQgaXMgY2VudGVyZWQuXG4gICAgY29uc3QgbGFyZ2VzdFBvc3NpYmxlUGFkZGluZyA9IGNsaWVudFNpemUgLyAyIC0gYXJyb3dEaW1lbnNpb25zW2xlbmd0aF0gLyAyIC0gMTtcbiAgICBjb25zdCBtaW5QYWRkaW5nID0gbWluKHBhZGRpbmdPYmplY3RbbWluUHJvcF0sIGxhcmdlc3RQb3NzaWJsZVBhZGRpbmcpO1xuICAgIGNvbnN0IG1heFBhZGRpbmcgPSBtaW4ocGFkZGluZ09iamVjdFttYXhQcm9wXSwgbGFyZ2VzdFBvc3NpYmxlUGFkZGluZyk7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlIGFycm93IGRvZXNuJ3Qgb3ZlcmZsb3cgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaWYgdGhlIGNlbnRlclxuICAgIC8vIHBvaW50IGlzIG91dHNpZGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQncyBib3VuZHMuXG4gICAgY29uc3QgbWluJDEgPSBtaW5QYWRkaW5nO1xuICAgIGNvbnN0IG1heCA9IGNsaWVudFNpemUgLSBhcnJvd0RpbWVuc2lvbnNbbGVuZ3RoXSAtIG1heFBhZGRpbmc7XG4gICAgY29uc3QgY2VudGVyID0gY2xpZW50U2l6ZSAvIDIgLSBhcnJvd0RpbWVuc2lvbnNbbGVuZ3RoXSAvIDIgKyBjZW50ZXJUb1JlZmVyZW5jZTtcbiAgICBjb25zdCBvZmZzZXQgPSBjbGFtcChtaW4kMSwgY2VudGVyLCBtYXgpO1xuXG4gICAgLy8gSWYgdGhlIHJlZmVyZW5jZSBpcyBzbWFsbCBlbm91Z2ggdGhhdCB0aGUgYXJyb3cncyBwYWRkaW5nIGNhdXNlcyBpdCB0b1xuICAgIC8vIHRvIHBvaW50IHRvIG5vdGhpbmcgZm9yIGFuIGFsaWduZWQgcGxhY2VtZW50LCBhZGp1c3QgdGhlIG9mZnNldCBvZiB0aGVcbiAgICAvLyBmbG9hdGluZyBlbGVtZW50IGl0c2VsZi4gVGhpcyBzdG9wcyBgc2hpZnQoKWAgZnJvbSB0YWtpbmcgYWN0aW9uLCBidXQgY2FuXG4gICAgLy8gYmUgd29ya2VkIGFyb3VuZCBieSBjYWxsaW5nIGl0IGFnYWluIGFmdGVyIHRoZSBgYXJyb3coKWAgaWYgZGVzaXJlZC5cbiAgICBjb25zdCBzaG91bGRBZGRPZmZzZXQgPSBnZXRBbGlnbm1lbnQocGxhY2VtZW50KSAhPSBudWxsICYmIGNlbnRlciAhPSBvZmZzZXQgJiYgcmVjdHMucmVmZXJlbmNlW2xlbmd0aF0gLyAyIC0gKGNlbnRlciA8IG1pbiQxID8gbWluUGFkZGluZyA6IG1heFBhZGRpbmcpIC0gYXJyb3dEaW1lbnNpb25zW2xlbmd0aF0gLyAyIDwgMDtcbiAgICBjb25zdCBhbGlnbm1lbnRPZmZzZXQgPSBzaG91bGRBZGRPZmZzZXQgPyBjZW50ZXIgPCBtaW4kMSA/IG1pbiQxIC0gY2VudGVyIDogbWF4IC0gY2VudGVyIDogMDtcbiAgICByZXR1cm4ge1xuICAgICAgW2F4aXNdOiBjb29yZHNbYXhpc10gLSBhbGlnbm1lbnRPZmZzZXQsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIFtheGlzXTogb2Zmc2V0LFxuICAgICAgICBjZW50ZXJPZmZzZXQ6IGNlbnRlciAtIG9mZnNldCArIGFsaWdubWVudE9mZnNldFxuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBnZXRQbGFjZW1lbnRMaXN0KGFsaWdubWVudCwgYXV0b0FsaWdubWVudCwgYWxsb3dlZFBsYWNlbWVudHMpIHtcbiAgY29uc3QgYWxsb3dlZFBsYWNlbWVudHNTb3J0ZWRCeUFsaWdubWVudCA9IGFsaWdubWVudCA/IFsuLi5hbGxvd2VkUGxhY2VtZW50cy5maWx0ZXIocGxhY2VtZW50ID0+IGdldEFsaWdubWVudChwbGFjZW1lbnQpID09PSBhbGlnbm1lbnQpLCAuLi5hbGxvd2VkUGxhY2VtZW50cy5maWx0ZXIocGxhY2VtZW50ID0+IGdldEFsaWdubWVudChwbGFjZW1lbnQpICE9PSBhbGlnbm1lbnQpXSA6IGFsbG93ZWRQbGFjZW1lbnRzLmZpbHRlcihwbGFjZW1lbnQgPT4gZ2V0U2lkZShwbGFjZW1lbnQpID09PSBwbGFjZW1lbnQpO1xuICByZXR1cm4gYWxsb3dlZFBsYWNlbWVudHNTb3J0ZWRCeUFsaWdubWVudC5maWx0ZXIocGxhY2VtZW50ID0+IHtcbiAgICBpZiAoYWxpZ25tZW50KSB7XG4gICAgICByZXR1cm4gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkgPT09IGFsaWdubWVudCB8fCAoYXV0b0FsaWdubWVudCA/IGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KHBsYWNlbWVudCkgIT09IHBsYWNlbWVudCA6IGZhbHNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xufVxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgY2hvb3NpbmcgdGhlIHBsYWNlbWVudFxuICogdGhhdCBoYXMgdGhlIG1vc3Qgc3BhY2UgYXZhaWxhYmxlIGF1dG9tYXRpY2FsbHksIHdpdGhvdXQgbmVlZGluZyB0byBzcGVjaWZ5IGFcbiAqIHByZWZlcnJlZCBwbGFjZW1lbnQuIEFsdGVybmF0aXZlIHRvIGBmbGlwYC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9hdXRvUGxhY2VtZW50XG4gKi9cbmNvbnN0IGF1dG9QbGFjZW1lbnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2F1dG9QbGFjZW1lbnQnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIHZhciBfbWlkZGxld2FyZURhdGEkYXV0b1AsIF9taWRkbGV3YXJlRGF0YSRhdXRvUDIsIF9wbGFjZW1lbnRzVGhhdEZpdE9uRTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVjdHMsXG4gICAgICAgIG1pZGRsZXdhcmVEYXRhLFxuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIHBsYXRmb3JtLFxuICAgICAgICBlbGVtZW50c1xuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjcm9zc0F4aXMgPSBmYWxzZSxcbiAgICAgICAgYWxpZ25tZW50LFxuICAgICAgICBhbGxvd2VkUGxhY2VtZW50cyA9IHBsYWNlbWVudHMsXG4gICAgICAgIGF1dG9BbGlnbm1lbnQgPSB0cnVlLFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gICAgICBjb25zdCBwbGFjZW1lbnRzJDEgPSBhbGlnbm1lbnQgIT09IHVuZGVmaW5lZCB8fCBhbGxvd2VkUGxhY2VtZW50cyA9PT0gcGxhY2VtZW50cyA/IGdldFBsYWNlbWVudExpc3QoYWxpZ25tZW50IHx8IG51bGwsIGF1dG9BbGlnbm1lbnQsIGFsbG93ZWRQbGFjZW1lbnRzKSA6IGFsbG93ZWRQbGFjZW1lbnRzO1xuICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9ICgoX21pZGRsZXdhcmVEYXRhJGF1dG9QID0gbWlkZGxld2FyZURhdGEuYXV0b1BsYWNlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRhdXRvUC5pbmRleCkgfHwgMDtcbiAgICAgIGNvbnN0IGN1cnJlbnRQbGFjZW1lbnQgPSBwbGFjZW1lbnRzJDFbY3VycmVudEluZGV4XTtcbiAgICAgIGlmIChjdXJyZW50UGxhY2VtZW50ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgY29uc3QgYWxpZ25tZW50U2lkZXMgPSBnZXRBbGlnbm1lbnRTaWRlcyhjdXJyZW50UGxhY2VtZW50LCByZWN0cywgYXdhaXQgKHBsYXRmb3JtLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc1JUTChlbGVtZW50cy5mbG9hdGluZykpKTtcblxuICAgICAgLy8gTWFrZSBgY29tcHV0ZUNvb3Jkc2Agc3RhcnQgZnJvbSB0aGUgcmlnaHQgcGxhY2UuXG4gICAgICBpZiAocGxhY2VtZW50ICE9PSBjdXJyZW50UGxhY2VtZW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50cyQxWzBdXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgY3VycmVudE92ZXJmbG93cyA9IFtvdmVyZmxvd1tnZXRTaWRlKGN1cnJlbnRQbGFjZW1lbnQpXSwgb3ZlcmZsb3dbYWxpZ25tZW50U2lkZXNbMF1dLCBvdmVyZmxvd1thbGlnbm1lbnRTaWRlc1sxXV1dO1xuICAgICAgY29uc3QgYWxsT3ZlcmZsb3dzID0gWy4uLigoKF9taWRkbGV3YXJlRGF0YSRhdXRvUDIgPSBtaWRkbGV3YXJlRGF0YS5hdXRvUGxhY2VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJGF1dG9QMi5vdmVyZmxvd3MpIHx8IFtdKSwge1xuICAgICAgICBwbGFjZW1lbnQ6IGN1cnJlbnRQbGFjZW1lbnQsXG4gICAgICAgIG92ZXJmbG93czogY3VycmVudE92ZXJmbG93c1xuICAgICAgfV07XG4gICAgICBjb25zdCBuZXh0UGxhY2VtZW50ID0gcGxhY2VtZW50cyQxW2N1cnJlbnRJbmRleCArIDFdO1xuXG4gICAgICAvLyBUaGVyZSBhcmUgbW9yZSBwbGFjZW1lbnRzIHRvIGNoZWNrLlxuICAgICAgaWYgKG5leHRQbGFjZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBpbmRleDogY3VycmVudEluZGV4ICsgMSxcbiAgICAgICAgICAgIG92ZXJmbG93czogYWxsT3ZlcmZsb3dzXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcGxhY2VtZW50OiBuZXh0UGxhY2VtZW50XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgcGxhY2VtZW50c1NvcnRlZEJ5TW9zdFNwYWNlID0gYWxsT3ZlcmZsb3dzLm1hcChkID0+IHtcbiAgICAgICAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KGQucGxhY2VtZW50KTtcbiAgICAgICAgcmV0dXJuIFtkLnBsYWNlbWVudCwgYWxpZ25tZW50ICYmIGNyb3NzQXhpcyA/XG4gICAgICAgIC8vIENoZWNrIGFsb25nIHRoZSBtYWluQXhpcyBhbmQgbWFpbiBjcm9zc0F4aXMgc2lkZS5cbiAgICAgICAgZC5vdmVyZmxvd3Muc2xpY2UoMCwgMikucmVkdWNlKChhY2MsIHYpID0+IGFjYyArIHYsIDApIDpcbiAgICAgICAgLy8gQ2hlY2sgb25seSB0aGUgbWFpbkF4aXMuXG4gICAgICAgIGQub3ZlcmZsb3dzWzBdLCBkLm92ZXJmbG93c107XG4gICAgICB9KS5zb3J0KChhLCBiKSA9PiBhWzFdIC0gYlsxXSk7XG4gICAgICBjb25zdCBwbGFjZW1lbnRzVGhhdEZpdE9uRWFjaFNpZGUgPSBwbGFjZW1lbnRzU29ydGVkQnlNb3N0U3BhY2UuZmlsdGVyKGQgPT4gZFsyXS5zbGljZSgwLFxuICAgICAgLy8gQWxpZ25lZCBwbGFjZW1lbnRzIHNob3VsZCBub3QgY2hlY2sgdGhlaXIgb3Bwb3NpdGUgY3Jvc3NBeGlzXG4gICAgICAvLyBzaWRlLlxuICAgICAgZ2V0QWxpZ25tZW50KGRbMF0pID8gMiA6IDMpLmV2ZXJ5KHYgPT4gdiA8PSAwKSk7XG4gICAgICBjb25zdCByZXNldFBsYWNlbWVudCA9ICgoX3BsYWNlbWVudHNUaGF0Rml0T25FID0gcGxhY2VtZW50c1RoYXRGaXRPbkVhY2hTaWRlWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3BsYWNlbWVudHNUaGF0Rml0T25FWzBdKSB8fCBwbGFjZW1lbnRzU29ydGVkQnlNb3N0U3BhY2VbMF1bMF07XG4gICAgICBpZiAocmVzZXRQbGFjZW1lbnQgIT09IHBsYWNlbWVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGluZGV4OiBjdXJyZW50SW5kZXggKyAxLFxuICAgICAgICAgICAgb3ZlcmZsb3dzOiBhbGxPdmVyZmxvd3NcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICBwbGFjZW1lbnQ6IHJlc2V0UGxhY2VtZW50XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IGZsaXBwaW5nIHRoZSBgcGxhY2VtZW50YFxuICogaW4gb3JkZXIgdG8ga2VlcCBpdCBpbiB2aWV3IHdoZW4gdGhlIHByZWZlcnJlZCBwbGFjZW1lbnQocykgd2lsbCBvdmVyZmxvdyB0aGVcbiAqIGNsaXBwaW5nIGJvdW5kYXJ5LiBBbHRlcm5hdGl2ZSB0byBgYXV0b1BsYWNlbWVudGAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvZmxpcFxuICovXG5jb25zdCBmbGlwID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdmbGlwJyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICB2YXIgX21pZGRsZXdhcmVEYXRhJGZsaXA7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgbWlkZGxld2FyZURhdGEsXG4gICAgICAgIHJlY3RzLFxuICAgICAgICBpbml0aWFsUGxhY2VtZW50LFxuICAgICAgICBwbGF0Zm9ybSxcbiAgICAgICAgZWxlbWVudHNcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWFpbkF4aXM6IGNoZWNrTWFpbkF4aXMgPSB0cnVlLFxuICAgICAgICBjcm9zc0F4aXM6IGNoZWNrQ3Jvc3NBeGlzID0gdHJ1ZSxcbiAgICAgICAgZmFsbGJhY2tQbGFjZW1lbnRzOiBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMsXG4gICAgICAgIGZhbGxiYWNrU3RyYXRlZ3kgPSAnYmVzdEZpdCcsXG4gICAgICAgIGZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24gPSAnbm9uZScsXG4gICAgICAgIGZsaXBBbGlnbm1lbnQgPSB0cnVlLFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gICAgICBjb25zdCBzaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpO1xuICAgICAgY29uc3QgaXNCYXNlUGxhY2VtZW50ID0gZ2V0U2lkZShpbml0aWFsUGxhY2VtZW50KSA9PT0gaW5pdGlhbFBsYWNlbWVudDtcbiAgICAgIGNvbnN0IHJ0bCA9IGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZWxlbWVudHMuZmxvYXRpbmcpKTtcbiAgICAgIGNvbnN0IGZhbGxiYWNrUGxhY2VtZW50cyA9IHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyB8fCAoaXNCYXNlUGxhY2VtZW50IHx8ICFmbGlwQWxpZ25tZW50ID8gW2dldE9wcG9zaXRlUGxhY2VtZW50KGluaXRpYWxQbGFjZW1lbnQpXSA6IGdldEV4cGFuZGVkUGxhY2VtZW50cyhpbml0aWFsUGxhY2VtZW50KSk7XG4gICAgICBpZiAoIXNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyAmJiBmYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uICE9PSAnbm9uZScpIHtcbiAgICAgICAgZmFsbGJhY2tQbGFjZW1lbnRzLnB1c2goLi4uZ2V0T3Bwb3NpdGVBeGlzUGxhY2VtZW50cyhpbml0aWFsUGxhY2VtZW50LCBmbGlwQWxpZ25tZW50LCBmYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uLCBydGwpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBsYWNlbWVudHMgPSBbaW5pdGlhbFBsYWNlbWVudCwgLi4uZmFsbGJhY2tQbGFjZW1lbnRzXTtcbiAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIGRldGVjdE92ZXJmbG93T3B0aW9ucyk7XG4gICAgICBjb25zdCBvdmVyZmxvd3MgPSBbXTtcbiAgICAgIGxldCBvdmVyZmxvd3NEYXRhID0gKChfbWlkZGxld2FyZURhdGEkZmxpcCA9IG1pZGRsZXdhcmVEYXRhLmZsaXApID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkZmxpcC5vdmVyZmxvd3MpIHx8IFtdO1xuICAgICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgICAgb3ZlcmZsb3dzLnB1c2gob3ZlcmZsb3dbc2lkZV0pO1xuICAgICAgfVxuICAgICAgaWYgKGNoZWNrQ3Jvc3NBeGlzKSB7XG4gICAgICAgIGNvbnN0IHNpZGVzID0gZ2V0QWxpZ25tZW50U2lkZXMocGxhY2VtZW50LCByZWN0cywgcnRsKTtcbiAgICAgICAgb3ZlcmZsb3dzLnB1c2gob3ZlcmZsb3dbc2lkZXNbMF1dLCBvdmVyZmxvd1tzaWRlc1sxXV0pO1xuICAgICAgfVxuICAgICAgb3ZlcmZsb3dzRGF0YSA9IFsuLi5vdmVyZmxvd3NEYXRhLCB7XG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgb3ZlcmZsb3dzXG4gICAgICB9XTtcblxuICAgICAgLy8gT25lIG9yIG1vcmUgc2lkZXMgaXMgb3ZlcmZsb3dpbmcuXG4gICAgICBpZiAoIW92ZXJmbG93cy5ldmVyeShzaWRlID0+IHNpZGUgPD0gMCkpIHtcbiAgICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRmbGlwMiwgX292ZXJmbG93c0RhdGEkZmlsdGVyO1xuICAgICAgICBjb25zdCBuZXh0SW5kZXggPSAoKChfbWlkZGxld2FyZURhdGEkZmxpcDIgPSBtaWRkbGV3YXJlRGF0YS5mbGlwKSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJGZsaXAyLmluZGV4KSB8fCAwKSArIDE7XG4gICAgICAgIGNvbnN0IG5leHRQbGFjZW1lbnQgPSBwbGFjZW1lbnRzW25leHRJbmRleF07XG4gICAgICAgIGlmIChuZXh0UGxhY2VtZW50KSB7XG4gICAgICAgICAgLy8gVHJ5IG5leHQgcGxhY2VtZW50IGFuZCByZS1ydW4gdGhlIGxpZmVjeWNsZS5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBpbmRleDogbmV4dEluZGV4LFxuICAgICAgICAgICAgICBvdmVyZmxvd3M6IG92ZXJmbG93c0RhdGFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgICBwbGFjZW1lbnQ6IG5leHRQbGFjZW1lbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmlyc3QsIGZpbmQgdGhlIGNhbmRpZGF0ZXMgdGhhdCBmaXQgb24gdGhlIG1haW5BeGlzIHNpZGUgb2Ygb3ZlcmZsb3csXG4gICAgICAgIC8vIHRoZW4gZmluZCB0aGUgcGxhY2VtZW50IHRoYXQgZml0cyB0aGUgYmVzdCBvbiB0aGUgbWFpbiBjcm9zc0F4aXMgc2lkZS5cbiAgICAgICAgbGV0IHJlc2V0UGxhY2VtZW50ID0gKF9vdmVyZmxvd3NEYXRhJGZpbHRlciA9IG92ZXJmbG93c0RhdGEuZmlsdGVyKGQgPT4gZC5vdmVyZmxvd3NbMF0gPD0gMCkuc29ydCgoYSwgYikgPT4gYS5vdmVyZmxvd3NbMV0gLSBiLm92ZXJmbG93c1sxXSlbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfb3ZlcmZsb3dzRGF0YSRmaWx0ZXIucGxhY2VtZW50O1xuXG4gICAgICAgIC8vIE90aGVyd2lzZSBmYWxsYmFjay5cbiAgICAgICAgaWYgKCFyZXNldFBsYWNlbWVudCkge1xuICAgICAgICAgIHN3aXRjaCAoZmFsbGJhY2tTdHJhdGVneSkge1xuICAgICAgICAgICAgY2FzZSAnYmVzdEZpdCc6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgX292ZXJmbG93c0RhdGEkbWFwJHNvO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBsYWNlbWVudCA9IChfb3ZlcmZsb3dzRGF0YSRtYXAkc28gPSBvdmVyZmxvd3NEYXRhLm1hcChkID0+IFtkLnBsYWNlbWVudCwgZC5vdmVyZmxvd3MuZmlsdGVyKG92ZXJmbG93ID0+IG92ZXJmbG93ID4gMCkucmVkdWNlKChhY2MsIG92ZXJmbG93KSA9PiBhY2MgKyBvdmVyZmxvdywgMCldKS5zb3J0KChhLCBiKSA9PiBhWzFdIC0gYlsxXSlbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfb3ZlcmZsb3dzRGF0YSRtYXAkc29bMF07XG4gICAgICAgICAgICAgICAgaWYgKHBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgICAgcmVzZXRQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdpbml0aWFsUGxhY2VtZW50JzpcbiAgICAgICAgICAgICAgcmVzZXRQbGFjZW1lbnQgPSBpbml0aWFsUGxhY2VtZW50O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBsYWNlbWVudCAhPT0gcmVzZXRQbGFjZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgICAgcGxhY2VtZW50OiByZXNldFBsYWNlbWVudFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH07XG59O1xuXG5mdW5jdGlvbiBnZXRTaWRlT2Zmc2V0cyhvdmVyZmxvdywgcmVjdCkge1xuICByZXR1cm4ge1xuICAgIHRvcDogb3ZlcmZsb3cudG9wIC0gcmVjdC5oZWlnaHQsXG4gICAgcmlnaHQ6IG92ZXJmbG93LnJpZ2h0IC0gcmVjdC53aWR0aCxcbiAgICBib3R0b206IG92ZXJmbG93LmJvdHRvbSAtIHJlY3QuaGVpZ2h0LFxuICAgIGxlZnQ6IG92ZXJmbG93LmxlZnQgLSByZWN0LndpZHRoXG4gIH07XG59XG5mdW5jdGlvbiBpc0FueVNpZGVGdWxseUNsaXBwZWQob3ZlcmZsb3cpIHtcbiAgcmV0dXJuIHNpZGVzLnNvbWUoc2lkZSA9PiBvdmVyZmxvd1tzaWRlXSA+PSAwKTtcbn1cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBoaWRlIHRoZSBmbG9hdGluZyBlbGVtZW50IGluIGFwcGxpY2FibGUgc2l0dWF0aW9ucywgc3VjaCBhc1xuICogd2hlbiBpdCBpcyBub3QgaW4gdGhlIHNhbWUgY2xpcHBpbmcgY29udGV4dCBhcyB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvaGlkZVxuICovXG5jb25zdCBoaWRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdoaWRlJyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlY3RzXG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHN0cmF0ZWd5ID0gJ3JlZmVyZW5jZUhpZGRlbicsXG4gICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICAgIHN3aXRjaCAoc3RyYXRlZ3kpIHtcbiAgICAgICAgY2FzZSAncmVmZXJlbmNlSGlkZGVuJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICAgICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9ucyxcbiAgICAgICAgICAgICAgZWxlbWVudENvbnRleHQ6ICdyZWZlcmVuY2UnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhvdmVyZmxvdywgcmVjdHMucmVmZXJlbmNlKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VIaWRkZW5PZmZzZXRzOiBvZmZzZXRzLFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZUhpZGRlbjogaXNBbnlTaWRlRnVsbHlDbGlwcGVkKG9mZnNldHMpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdlc2NhcGVkJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICAgICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9ucyxcbiAgICAgICAgICAgICAgYWx0Qm91bmRhcnk6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0cy5mbG9hdGluZyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgZXNjYXBlZE9mZnNldHM6IG9mZnNldHMsXG4gICAgICAgICAgICAgICAgZXNjYXBlZDogaXNBbnlTaWRlRnVsbHlDbGlwcGVkKG9mZnNldHMpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcblxuZnVuY3Rpb24gZ2V0Qm91bmRpbmdSZWN0KHJlY3RzKSB7XG4gIGNvbnN0IG1pblggPSBtaW4oLi4ucmVjdHMubWFwKHJlY3QgPT4gcmVjdC5sZWZ0KSk7XG4gIGNvbnN0IG1pblkgPSBtaW4oLi4ucmVjdHMubWFwKHJlY3QgPT4gcmVjdC50b3ApKTtcbiAgY29uc3QgbWF4WCA9IG1heCguLi5yZWN0cy5tYXAocmVjdCA9PiByZWN0LnJpZ2h0KSk7XG4gIGNvbnN0IG1heFkgPSBtYXgoLi4ucmVjdHMubWFwKHJlY3QgPT4gcmVjdC5ib3R0b20pKTtcbiAgcmV0dXJuIHtcbiAgICB4OiBtaW5YLFxuICAgIHk6IG1pblksXG4gICAgd2lkdGg6IG1heFggLSBtaW5YLFxuICAgIGhlaWdodDogbWF4WSAtIG1pbllcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFJlY3RzQnlMaW5lKHJlY3RzKSB7XG4gIGNvbnN0IHNvcnRlZFJlY3RzID0gcmVjdHMuc2xpY2UoKS5zb3J0KChhLCBiKSA9PiBhLnkgLSBiLnkpO1xuICBjb25zdCBncm91cHMgPSBbXTtcbiAgbGV0IHByZXZSZWN0ID0gbnVsbDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3J0ZWRSZWN0cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHJlY3QgPSBzb3J0ZWRSZWN0c1tpXTtcbiAgICBpZiAoIXByZXZSZWN0IHx8IHJlY3QueSAtIHByZXZSZWN0LnkgPiBwcmV2UmVjdC5oZWlnaHQgLyAyKSB7XG4gICAgICBncm91cHMucHVzaChbcmVjdF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBncm91cHNbZ3JvdXBzLmxlbmd0aCAtIDFdLnB1c2gocmVjdCk7XG4gICAgfVxuICAgIHByZXZSZWN0ID0gcmVjdDtcbiAgfVxuICByZXR1cm4gZ3JvdXBzLm1hcChyZWN0ID0+IHJlY3RUb0NsaWVudFJlY3QoZ2V0Qm91bmRpbmdSZWN0KHJlY3QpKSk7XG59XG4vKipcbiAqIFByb3ZpZGVzIGltcHJvdmVkIHBvc2l0aW9uaW5nIGZvciBpbmxpbmUgcmVmZXJlbmNlIGVsZW1lbnRzIHRoYXQgY2FuIHNwYW5cbiAqIG92ZXIgbXVsdGlwbGUgbGluZXMsIHN1Y2ggYXMgaHlwZXJsaW5rcyBvciByYW5nZSBzZWxlY3Rpb25zLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2lubGluZVxuICovXG5jb25zdCBpbmxpbmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2lubGluZScsXG4gICAgb3B0aW9ucyxcbiAgICBhc3luYyBmbihzdGF0ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIGVsZW1lbnRzLFxuICAgICAgICByZWN0cyxcbiAgICAgICAgcGxhdGZvcm0sXG4gICAgICAgIHN0cmF0ZWd5XG4gICAgICB9ID0gc3RhdGU7XG4gICAgICAvLyBBIE1vdXNlRXZlbnQncyBjbGllbnR7WCxZfSBjb29yZHMgY2FuIGJlIHVwIHRvIDIgcGl4ZWxzIG9mZiBhXG4gICAgICAvLyBDbGllbnRSZWN0J3MgYm91bmRzLCBkZXNwaXRlIHRoZSBldmVudCBsaXN0ZW5lciBiZWluZyB0cmlnZ2VyZWQuIEFcbiAgICAgIC8vIHBhZGRpbmcgb2YgMiBzZWVtcyB0byBoYW5kbGUgdGhpcyBpc3N1ZS5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFkZGluZyA9IDIsXG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gICAgICBjb25zdCBuYXRpdmVDbGllbnRSZWN0cyA9IEFycmF5LmZyb20oKGF3YWl0IChwbGF0Zm9ybS5nZXRDbGllbnRSZWN0cyA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uZ2V0Q2xpZW50UmVjdHMoZWxlbWVudHMucmVmZXJlbmNlKSkpIHx8IFtdKTtcbiAgICAgIGNvbnN0IGNsaWVudFJlY3RzID0gZ2V0UmVjdHNCeUxpbmUobmF0aXZlQ2xpZW50UmVjdHMpO1xuICAgICAgY29uc3QgZmFsbGJhY2sgPSByZWN0VG9DbGllbnRSZWN0KGdldEJvdW5kaW5nUmVjdChuYXRpdmVDbGllbnRSZWN0cykpO1xuICAgICAgY29uc3QgcGFkZGluZ09iamVjdCA9IGdldFBhZGRpbmdPYmplY3QocGFkZGluZyk7XG4gICAgICBmdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB7XG4gICAgICAgIC8vIFRoZXJlIGFyZSB0d28gcmVjdHMgYW5kIHRoZXkgYXJlIGRpc2pvaW5lZC5cbiAgICAgICAgaWYgKGNsaWVudFJlY3RzLmxlbmd0aCA9PT0gMiAmJiBjbGllbnRSZWN0c1swXS5sZWZ0ID4gY2xpZW50UmVjdHNbMV0ucmlnaHQgJiYgeCAhPSBudWxsICYmIHkgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IHJlY3QgaW4gd2hpY2ggdGhlIHBvaW50IGlzIGZ1bGx5IGluc2lkZS5cbiAgICAgICAgICByZXR1cm4gY2xpZW50UmVjdHMuZmluZChyZWN0ID0+IHggPiByZWN0LmxlZnQgLSBwYWRkaW5nT2JqZWN0LmxlZnQgJiYgeCA8IHJlY3QucmlnaHQgKyBwYWRkaW5nT2JqZWN0LnJpZ2h0ICYmIHkgPiByZWN0LnRvcCAtIHBhZGRpbmdPYmplY3QudG9wICYmIHkgPCByZWN0LmJvdHRvbSArIHBhZGRpbmdPYmplY3QuYm90dG9tKSB8fCBmYWxsYmFjaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZXJlIGFyZSAyIG9yIG1vcmUgY29ubmVjdGVkIHJlY3RzLlxuICAgICAgICBpZiAoY2xpZW50UmVjdHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICBpZiAoZ2V0U2lkZUF4aXMocGxhY2VtZW50KSA9PT0gJ3knKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdFJlY3QgPSBjbGllbnRSZWN0c1swXTtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RSZWN0ID0gY2xpZW50UmVjdHNbY2xpZW50UmVjdHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBjb25zdCBpc1RvcCA9IGdldFNpZGUocGxhY2VtZW50KSA9PT0gJ3RvcCc7XG4gICAgICAgICAgICBjb25zdCB0b3AgPSBmaXJzdFJlY3QudG9wO1xuICAgICAgICAgICAgY29uc3QgYm90dG9tID0gbGFzdFJlY3QuYm90dG9tO1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IGlzVG9wID8gZmlyc3RSZWN0LmxlZnQgOiBsYXN0UmVjdC5sZWZ0O1xuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBpc1RvcCA/IGZpcnN0UmVjdC5yaWdodCA6IGxhc3RSZWN0LnJpZ2h0O1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSByaWdodCAtIGxlZnQ7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICAgIGJvdHRvbSxcbiAgICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICAgIHg6IGxlZnQsXG4gICAgICAgICAgICAgIHk6IHRvcFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgaXNMZWZ0U2lkZSA9IGdldFNpZGUocGxhY2VtZW50KSA9PT0gJ2xlZnQnO1xuICAgICAgICAgIGNvbnN0IG1heFJpZ2h0ID0gbWF4KC4uLmNsaWVudFJlY3RzLm1hcChyZWN0ID0+IHJlY3QucmlnaHQpKTtcbiAgICAgICAgICBjb25zdCBtaW5MZWZ0ID0gbWluKC4uLmNsaWVudFJlY3RzLm1hcChyZWN0ID0+IHJlY3QubGVmdCkpO1xuICAgICAgICAgIGNvbnN0IG1lYXN1cmVSZWN0cyA9IGNsaWVudFJlY3RzLmZpbHRlcihyZWN0ID0+IGlzTGVmdFNpZGUgPyByZWN0LmxlZnQgPT09IG1pbkxlZnQgOiByZWN0LnJpZ2h0ID09PSBtYXhSaWdodCk7XG4gICAgICAgICAgY29uc3QgdG9wID0gbWVhc3VyZVJlY3RzWzBdLnRvcDtcbiAgICAgICAgICBjb25zdCBib3R0b20gPSBtZWFzdXJlUmVjdHNbbWVhc3VyZVJlY3RzLmxlbmd0aCAtIDFdLmJvdHRvbTtcbiAgICAgICAgICBjb25zdCBsZWZ0ID0gbWluTGVmdDtcbiAgICAgICAgICBjb25zdCByaWdodCA9IG1heFJpZ2h0O1xuICAgICAgICAgIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGJvdHRvbSAtIHRvcDtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgYm90dG9tLFxuICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgIHJpZ2h0LFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICB4OiBsZWZ0LFxuICAgICAgICAgICAgeTogdG9wXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgICB9XG4gICAgICBjb25zdCByZXNldFJlY3RzID0gYXdhaXQgcGxhdGZvcm0uZ2V0RWxlbWVudFJlY3RzKHtcbiAgICAgICAgcmVmZXJlbmNlOiB7XG4gICAgICAgICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG4gICAgICAgIH0sXG4gICAgICAgIGZsb2F0aW5nOiBlbGVtZW50cy5mbG9hdGluZyxcbiAgICAgICAgc3RyYXRlZ3lcbiAgICAgIH0pO1xuICAgICAgaWYgKHJlY3RzLnJlZmVyZW5jZS54ICE9PSByZXNldFJlY3RzLnJlZmVyZW5jZS54IHx8IHJlY3RzLnJlZmVyZW5jZS55ICE9PSByZXNldFJlY3RzLnJlZmVyZW5jZS55IHx8IHJlY3RzLnJlZmVyZW5jZS53aWR0aCAhPT0gcmVzZXRSZWN0cy5yZWZlcmVuY2Uud2lkdGggfHwgcmVjdHMucmVmZXJlbmNlLmhlaWdodCAhPT0gcmVzZXRSZWN0cy5yZWZlcmVuY2UuaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgIHJlY3RzOiByZXNldFJlY3RzXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfTtcbn07XG5cbi8vIEZvciB0eXBlIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5LCB0aGUgYE9mZnNldE9wdGlvbnNgIHR5cGUgd2FzIGFsc29cbi8vIERlcml2YWJsZS5cbmFzeW5jIGZ1bmN0aW9uIGNvbnZlcnRWYWx1ZVRvQ29vcmRzKHN0YXRlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBwbGFjZW1lbnQsXG4gICAgcGxhdGZvcm0sXG4gICAgZWxlbWVudHNcbiAgfSA9IHN0YXRlO1xuICBjb25zdCBydGwgPSBhd2FpdCAocGxhdGZvcm0uaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzUlRMKGVsZW1lbnRzLmZsb2F0aW5nKSk7XG4gIGNvbnN0IHNpZGUgPSBnZXRTaWRlKHBsYWNlbWVudCk7XG4gIGNvbnN0IGFsaWdubWVudCA9IGdldEFsaWdubWVudChwbGFjZW1lbnQpO1xuICBjb25zdCBpc1ZlcnRpY2FsID0gZ2V0U2lkZUF4aXMocGxhY2VtZW50KSA9PT0gJ3knO1xuICBjb25zdCBtYWluQXhpc011bHRpID0gWydsZWZ0JywgJ3RvcCddLmluY2x1ZGVzKHNpZGUpID8gLTEgOiAxO1xuICBjb25zdCBjcm9zc0F4aXNNdWx0aSA9IHJ0bCAmJiBpc1ZlcnRpY2FsID8gLTEgOiAxO1xuICBjb25zdCByYXdWYWx1ZSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gIGxldCB7XG4gICAgbWFpbkF4aXMsXG4gICAgY3Jvc3NBeGlzLFxuICAgIGFsaWdubWVudEF4aXNcbiAgfSA9IHR5cGVvZiByYXdWYWx1ZSA9PT0gJ251bWJlcicgPyB7XG4gICAgbWFpbkF4aXM6IHJhd1ZhbHVlLFxuICAgIGNyb3NzQXhpczogMCxcbiAgICBhbGlnbm1lbnRBeGlzOiBudWxsXG4gIH0gOiB7XG4gICAgbWFpbkF4aXM6IDAsXG4gICAgY3Jvc3NBeGlzOiAwLFxuICAgIGFsaWdubWVudEF4aXM6IG51bGwsXG4gICAgLi4ucmF3VmFsdWVcbiAgfTtcbiAgaWYgKGFsaWdubWVudCAmJiB0eXBlb2YgYWxpZ25tZW50QXhpcyA9PT0gJ251bWJlcicpIHtcbiAgICBjcm9zc0F4aXMgPSBhbGlnbm1lbnQgPT09ICdlbmQnID8gYWxpZ25tZW50QXhpcyAqIC0xIDogYWxpZ25tZW50QXhpcztcbiAgfVxuICByZXR1cm4gaXNWZXJ0aWNhbCA/IHtcbiAgICB4OiBjcm9zc0F4aXMgKiBjcm9zc0F4aXNNdWx0aSxcbiAgICB5OiBtYWluQXhpcyAqIG1haW5BeGlzTXVsdGlcbiAgfSA6IHtcbiAgICB4OiBtYWluQXhpcyAqIG1haW5BeGlzTXVsdGksXG4gICAgeTogY3Jvc3NBeGlzICogY3Jvc3NBeGlzTXVsdGlcbiAgfTtcbn1cblxuLyoqXG4gKiBNb2RpZmllcyB0aGUgcGxhY2VtZW50IGJ5IHRyYW5zbGF0aW5nIHRoZSBmbG9hdGluZyBlbGVtZW50IGFsb25nIHRoZVxuICogc3BlY2lmaWVkIGF4ZXMuXG4gKiBBIG51bWJlciAoc2hvcnRoYW5kIGZvciBgbWFpbkF4aXNgIG9yIGRpc3RhbmNlKSwgb3IgYW4gYXhlcyBjb25maWd1cmF0aW9uXG4gKiBvYmplY3QgbWF5IGJlIHBhc3NlZC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9vZmZzZXRcbiAqL1xuY29uc3Qgb2Zmc2V0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSAwO1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ29mZnNldCcsXG4gICAgb3B0aW9ucyxcbiAgICBhc3luYyBmbihzdGF0ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCBkaWZmQ29vcmRzID0gYXdhaXQgY29udmVydFZhbHVlVG9Db29yZHMoc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCArIGRpZmZDb29yZHMueCxcbiAgICAgICAgeTogeSArIGRpZmZDb29yZHMueSxcbiAgICAgICAgZGF0YTogZGlmZkNvb3Jkc1xuICAgICAgfTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBzaGlmdGluZyBpdCBpbiBvcmRlciB0b1xuICoga2VlcCBpdCBpbiB2aWV3IHdoZW4gaXQgd2lsbCBvdmVyZmxvdyB0aGUgY2xpcHBpbmcgYm91bmRhcnkuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvc2hpZnRcbiAqL1xuY29uc3Qgc2hpZnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ3NoaWZ0JyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHBsYWNlbWVudFxuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBtYWluQXhpczogY2hlY2tNYWluQXhpcyA9IHRydWUsXG4gICAgICAgIGNyb3NzQXhpczogY2hlY2tDcm9zc0F4aXMgPSBmYWxzZSxcbiAgICAgICAgbGltaXRlciA9IHtcbiAgICAgICAgICBmbjogX3JlZiA9PiB7XG4gICAgICAgICAgICBsZXQge1xuICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICB5XG4gICAgICAgICAgICB9ID0gX3JlZjtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgIHlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gICAgICBjb25zdCBjb29yZHMgPSB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH07XG4gICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgICAgY29uc3QgY3Jvc3NBeGlzID0gZ2V0U2lkZUF4aXMoZ2V0U2lkZShwbGFjZW1lbnQpKTtcbiAgICAgIGNvbnN0IG1haW5BeGlzID0gZ2V0T3Bwb3NpdGVBeGlzKGNyb3NzQXhpcyk7XG4gICAgICBsZXQgbWFpbkF4aXNDb29yZCA9IGNvb3Jkc1ttYWluQXhpc107XG4gICAgICBsZXQgY3Jvc3NBeGlzQ29vcmQgPSBjb29yZHNbY3Jvc3NBeGlzXTtcbiAgICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICAgIGNvbnN0IG1pblNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gJ3RvcCcgOiAnbGVmdCc7XG4gICAgICAgIGNvbnN0IG1heFNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICAgICAgICBjb25zdCBtaW4gPSBtYWluQXhpc0Nvb3JkICsgb3ZlcmZsb3dbbWluU2lkZV07XG4gICAgICAgIGNvbnN0IG1heCA9IG1haW5BeGlzQ29vcmQgLSBvdmVyZmxvd1ttYXhTaWRlXTtcbiAgICAgICAgbWFpbkF4aXNDb29yZCA9IGNsYW1wKG1pbiwgbWFpbkF4aXNDb29yZCwgbWF4KTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGVja0Nyb3NzQXhpcykge1xuICAgICAgICBjb25zdCBtaW5TaWRlID0gY3Jvc3NBeGlzID09PSAneScgPyAndG9wJyA6ICdsZWZ0JztcbiAgICAgICAgY29uc3QgbWF4U2lkZSA9IGNyb3NzQXhpcyA9PT0gJ3knID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICAgICAgICBjb25zdCBtaW4gPSBjcm9zc0F4aXNDb29yZCArIG92ZXJmbG93W21pblNpZGVdO1xuICAgICAgICBjb25zdCBtYXggPSBjcm9zc0F4aXNDb29yZCAtIG92ZXJmbG93W21heFNpZGVdO1xuICAgICAgICBjcm9zc0F4aXNDb29yZCA9IGNsYW1wKG1pbiwgY3Jvc3NBeGlzQ29vcmQsIG1heCk7XG4gICAgICB9XG4gICAgICBjb25zdCBsaW1pdGVkQ29vcmRzID0gbGltaXRlci5mbih7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBbbWFpbkF4aXNdOiBtYWluQXhpc0Nvb3JkLFxuICAgICAgICBbY3Jvc3NBeGlzXTogY3Jvc3NBeGlzQ29vcmRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubGltaXRlZENvb3JkcyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHg6IGxpbWl0ZWRDb29yZHMueCAtIHgsXG4gICAgICAgICAgeTogbGltaXRlZENvb3Jkcy55IC0geVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07XG4vKipcbiAqIEJ1aWx0LWluIGBsaW1pdGVyYCB0aGF0IHdpbGwgc3RvcCBgc2hpZnQoKWAgYXQgYSBjZXJ0YWluIHBvaW50LlxuICovXG5jb25zdCBsaW1pdFNoaWZ0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG9wdGlvbnMsXG4gICAgZm4oc3RhdGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICByZWN0cyxcbiAgICAgICAgbWlkZGxld2FyZURhdGFcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb2Zmc2V0ID0gMCxcbiAgICAgICAgbWFpbkF4aXM6IGNoZWNrTWFpbkF4aXMgPSB0cnVlLFxuICAgICAgICBjcm9zc0F4aXM6IGNoZWNrQ3Jvc3NBeGlzID0gdHJ1ZVxuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICAgIGNvbnN0IGNvb3JkcyA9IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGNyb3NzQXhpcyA9IGdldFNpZGVBeGlzKHBsYWNlbWVudCk7XG4gICAgICBjb25zdCBtYWluQXhpcyA9IGdldE9wcG9zaXRlQXhpcyhjcm9zc0F4aXMpO1xuICAgICAgbGV0IG1haW5BeGlzQ29vcmQgPSBjb29yZHNbbWFpbkF4aXNdO1xuICAgICAgbGV0IGNyb3NzQXhpc0Nvb3JkID0gY29vcmRzW2Nyb3NzQXhpc107XG4gICAgICBjb25zdCByYXdPZmZzZXQgPSBldmFsdWF0ZShvZmZzZXQsIHN0YXRlKTtcbiAgICAgIGNvbnN0IGNvbXB1dGVkT2Zmc2V0ID0gdHlwZW9mIHJhd09mZnNldCA9PT0gJ251bWJlcicgPyB7XG4gICAgICAgIG1haW5BeGlzOiByYXdPZmZzZXQsXG4gICAgICAgIGNyb3NzQXhpczogMFxuICAgICAgfSA6IHtcbiAgICAgICAgbWFpbkF4aXM6IDAsXG4gICAgICAgIGNyb3NzQXhpczogMCxcbiAgICAgICAgLi4ucmF3T2Zmc2V0XG4gICAgICB9O1xuICAgICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgICAgY29uc3QgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICAgICAgY29uc3QgbGltaXRNaW4gPSByZWN0cy5yZWZlcmVuY2VbbWFpbkF4aXNdIC0gcmVjdHMuZmxvYXRpbmdbbGVuXSArIGNvbXB1dGVkT2Zmc2V0Lm1haW5BeGlzO1xuICAgICAgICBjb25zdCBsaW1pdE1heCA9IHJlY3RzLnJlZmVyZW5jZVttYWluQXhpc10gKyByZWN0cy5yZWZlcmVuY2VbbGVuXSAtIGNvbXB1dGVkT2Zmc2V0Lm1haW5BeGlzO1xuICAgICAgICBpZiAobWFpbkF4aXNDb29yZCA8IGxpbWl0TWluKSB7XG4gICAgICAgICAgbWFpbkF4aXNDb29yZCA9IGxpbWl0TWluO1xuICAgICAgICB9IGVsc2UgaWYgKG1haW5BeGlzQ29vcmQgPiBsaW1pdE1heCkge1xuICAgICAgICAgIG1haW5BeGlzQ29vcmQgPSBsaW1pdE1heDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNoZWNrQ3Jvc3NBeGlzKSB7XG4gICAgICAgIHZhciBfbWlkZGxld2FyZURhdGEkb2Zmc2UsIF9taWRkbGV3YXJlRGF0YSRvZmZzZTI7XG4gICAgICAgIGNvbnN0IGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgICAgIGNvbnN0IGlzT3JpZ2luU2lkZSA9IFsndG9wJywgJ2xlZnQnXS5pbmNsdWRlcyhnZXRTaWRlKHBsYWNlbWVudCkpO1xuICAgICAgICBjb25zdCBsaW1pdE1pbiA9IHJlY3RzLnJlZmVyZW5jZVtjcm9zc0F4aXNdIC0gcmVjdHMuZmxvYXRpbmdbbGVuXSArIChpc09yaWdpblNpZGUgPyAoKF9taWRkbGV3YXJlRGF0YSRvZmZzZSA9IG1pZGRsZXdhcmVEYXRhLm9mZnNldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRvZmZzZVtjcm9zc0F4aXNdKSB8fCAwIDogMCkgKyAoaXNPcmlnaW5TaWRlID8gMCA6IGNvbXB1dGVkT2Zmc2V0LmNyb3NzQXhpcyk7XG4gICAgICAgIGNvbnN0IGxpbWl0TWF4ID0gcmVjdHMucmVmZXJlbmNlW2Nyb3NzQXhpc10gKyByZWN0cy5yZWZlcmVuY2VbbGVuXSArIChpc09yaWdpblNpZGUgPyAwIDogKChfbWlkZGxld2FyZURhdGEkb2Zmc2UyID0gbWlkZGxld2FyZURhdGEub2Zmc2V0KSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJG9mZnNlMltjcm9zc0F4aXNdKSB8fCAwKSAtIChpc09yaWdpblNpZGUgPyBjb21wdXRlZE9mZnNldC5jcm9zc0F4aXMgOiAwKTtcbiAgICAgICAgaWYgKGNyb3NzQXhpc0Nvb3JkIDwgbGltaXRNaW4pIHtcbiAgICAgICAgICBjcm9zc0F4aXNDb29yZCA9IGxpbWl0TWluO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQXhpc0Nvb3JkID4gbGltaXRNYXgpIHtcbiAgICAgICAgICBjcm9zc0F4aXNDb29yZCA9IGxpbWl0TWF4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBbbWFpbkF4aXNdOiBtYWluQXhpc0Nvb3JkLFxuICAgICAgICBbY3Jvc3NBeGlzXTogY3Jvc3NBeGlzQ29vcmRcbiAgICAgIH07XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRoYXQgYWxsb3dzIHlvdSB0byBjaGFuZ2UgdGhlIHNpemUgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQg4oCUXG4gKiBmb3IgaW5zdGFuY2UsIHByZXZlbnQgaXQgZnJvbSBvdmVyZmxvd2luZyB0aGUgY2xpcHBpbmcgYm91bmRhcnkgb3IgbWF0Y2ggdGhlXG4gKiB3aWR0aCBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvc2l6ZVxuICovXG5jb25zdCBzaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdzaXplJyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgcmVjdHMsXG4gICAgICAgIHBsYXRmb3JtLFxuICAgICAgICBlbGVtZW50c1xuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBhcHBseSA9ICgpID0+IHt9LFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgICAgY29uc3Qgc2lkZSA9IGdldFNpZGUocGxhY2VtZW50KTtcbiAgICAgIGNvbnN0IGFsaWdubWVudCA9IGdldEFsaWdubWVudChwbGFjZW1lbnQpO1xuICAgICAgY29uc3QgaXNZQXhpcyA9IGdldFNpZGVBeGlzKHBsYWNlbWVudCkgPT09ICd5JztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSA9IHJlY3RzLmZsb2F0aW5nO1xuICAgICAgbGV0IGhlaWdodFNpZGU7XG4gICAgICBsZXQgd2lkdGhTaWRlO1xuICAgICAgaWYgKHNpZGUgPT09ICd0b3AnIHx8IHNpZGUgPT09ICdib3R0b20nKSB7XG4gICAgICAgIGhlaWdodFNpZGUgPSBzaWRlO1xuICAgICAgICB3aWR0aFNpZGUgPSBhbGlnbm1lbnQgPT09ICgoYXdhaXQgKHBsYXRmb3JtLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc1JUTChlbGVtZW50cy5mbG9hdGluZykpKSA/ICdzdGFydCcgOiAnZW5kJykgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2lkdGhTaWRlID0gc2lkZTtcbiAgICAgICAgaGVpZ2h0U2lkZSA9IGFsaWdubWVudCA9PT0gJ2VuZCcgPyAndG9wJyA6ICdib3R0b20nO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3ZlcmZsb3dBdmFpbGFibGVIZWlnaHQgPSBoZWlnaHQgLSBvdmVyZmxvd1toZWlnaHRTaWRlXTtcbiAgICAgIGNvbnN0IG92ZXJmbG93QXZhaWxhYmxlV2lkdGggPSB3aWR0aCAtIG92ZXJmbG93W3dpZHRoU2lkZV07XG4gICAgICBjb25zdCBub1NoaWZ0ID0gIXN0YXRlLm1pZGRsZXdhcmVEYXRhLnNoaWZ0O1xuICAgICAgbGV0IGF2YWlsYWJsZUhlaWdodCA9IG92ZXJmbG93QXZhaWxhYmxlSGVpZ2h0O1xuICAgICAgbGV0IGF2YWlsYWJsZVdpZHRoID0gb3ZlcmZsb3dBdmFpbGFibGVXaWR0aDtcbiAgICAgIGlmIChpc1lBeGlzKSB7XG4gICAgICAgIGNvbnN0IG1heGltdW1DbGlwcGluZ1dpZHRoID0gd2lkdGggLSBvdmVyZmxvdy5sZWZ0IC0gb3ZlcmZsb3cucmlnaHQ7XG4gICAgICAgIGF2YWlsYWJsZVdpZHRoID0gYWxpZ25tZW50IHx8IG5vU2hpZnQgPyBtaW4ob3ZlcmZsb3dBdmFpbGFibGVXaWR0aCwgbWF4aW11bUNsaXBwaW5nV2lkdGgpIDogbWF4aW11bUNsaXBwaW5nV2lkdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBtYXhpbXVtQ2xpcHBpbmdIZWlnaHQgPSBoZWlnaHQgLSBvdmVyZmxvdy50b3AgLSBvdmVyZmxvdy5ib3R0b207XG4gICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IGFsaWdubWVudCB8fCBub1NoaWZ0ID8gbWluKG92ZXJmbG93QXZhaWxhYmxlSGVpZ2h0LCBtYXhpbXVtQ2xpcHBpbmdIZWlnaHQpIDogbWF4aW11bUNsaXBwaW5nSGVpZ2h0O1xuICAgICAgfVxuICAgICAgaWYgKG5vU2hpZnQgJiYgIWFsaWdubWVudCkge1xuICAgICAgICBjb25zdCB4TWluID0gbWF4KG92ZXJmbG93LmxlZnQsIDApO1xuICAgICAgICBjb25zdCB4TWF4ID0gbWF4KG92ZXJmbG93LnJpZ2h0LCAwKTtcbiAgICAgICAgY29uc3QgeU1pbiA9IG1heChvdmVyZmxvdy50b3AsIDApO1xuICAgICAgICBjb25zdCB5TWF4ID0gbWF4KG92ZXJmbG93LmJvdHRvbSwgMCk7XG4gICAgICAgIGlmIChpc1lBeGlzKSB7XG4gICAgICAgICAgYXZhaWxhYmxlV2lkdGggPSB3aWR0aCAtIDIgKiAoeE1pbiAhPT0gMCB8fCB4TWF4ICE9PSAwID8geE1pbiArIHhNYXggOiBtYXgob3ZlcmZsb3cubGVmdCwgb3ZlcmZsb3cucmlnaHQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSBoZWlnaHQgLSAyICogKHlNaW4gIT09IDAgfHwgeU1heCAhPT0gMCA/IHlNaW4gKyB5TWF4IDogbWF4KG92ZXJmbG93LnRvcCwgb3ZlcmZsb3cuYm90dG9tKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGF3YWl0IGFwcGx5KHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGF2YWlsYWJsZVdpZHRoLFxuICAgICAgICBhdmFpbGFibGVIZWlnaHRcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbmV4dERpbWVuc2lvbnMgPSBhd2FpdCBwbGF0Zm9ybS5nZXREaW1lbnNpb25zKGVsZW1lbnRzLmZsb2F0aW5nKTtcbiAgICAgIGlmICh3aWR0aCAhPT0gbmV4dERpbWVuc2lvbnMud2lkdGggfHwgaGVpZ2h0ICE9PSBuZXh0RGltZW5zaW9ucy5oZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcmVjdHM6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9O1xufTtcblxuZXhwb3J0IHsgYXJyb3csIGF1dG9QbGFjZW1lbnQsIGNvbXB1dGVQb3NpdGlvbiwgZGV0ZWN0T3ZlcmZsb3csIGZsaXAsIGhpZGUsIGlubGluZSwgbGltaXRTaGlmdCwgb2Zmc2V0LCBzaGlmdCwgc2l6ZSB9O1xuIiwiZnVuY3Rpb24gZ2V0Tm9kZU5hbWUobm9kZSkge1xuICBpZiAoaXNOb2RlKG5vZGUpKSB7XG4gICAgcmV0dXJuIChub2RlLm5vZGVOYW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuICB9XG4gIC8vIE1vY2tlZCBub2RlcyBpbiB0ZXN0aW5nIGVudmlyb25tZW50cyBtYXkgbm90IGJlIGluc3RhbmNlcyBvZiBOb2RlLiBCeVxuICAvLyByZXR1cm5pbmcgYCNkb2N1bWVudGAgYW4gaW5maW5pdGUgbG9vcCB3b24ndCBvY2N1ci5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8yMzE3XG4gIHJldHVybiAnI2RvY3VtZW50Jztcbn1cbmZ1bmN0aW9uIGdldFdpbmRvdyhub2RlKSB7XG4gIHZhciBfbm9kZSRvd25lckRvY3VtZW50O1xuICByZXR1cm4gKG5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IChfbm9kZSRvd25lckRvY3VtZW50ID0gbm9kZS5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldykgfHwgd2luZG93O1xufVxuZnVuY3Rpb24gZ2V0RG9jdW1lbnRFbGVtZW50KG5vZGUpIHtcbiAgdmFyIF9yZWY7XG4gIHJldHVybiAoX3JlZiA9IChpc05vZGUobm9kZSkgPyBub2RlLm93bmVyRG9jdW1lbnQgOiBub2RlLmRvY3VtZW50KSB8fCB3aW5kb3cuZG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfcmVmLmRvY3VtZW50RWxlbWVudDtcbn1cbmZ1bmN0aW9uIGlzTm9kZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBOb2RlIHx8IHZhbHVlIGluc3RhbmNlb2YgZ2V0V2luZG93KHZhbHVlKS5Ob2RlO1xufVxuZnVuY3Rpb24gaXNFbGVtZW50KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEVsZW1lbnQgfHwgdmFsdWUgaW5zdGFuY2VvZiBnZXRXaW5kb3codmFsdWUpLkVsZW1lbnQ7XG59XG5mdW5jdGlvbiBpc0hUTUxFbGVtZW50KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8IHZhbHVlIGluc3RhbmNlb2YgZ2V0V2luZG93KHZhbHVlKS5IVE1MRWxlbWVudDtcbn1cbmZ1bmN0aW9uIGlzU2hhZG93Um9vdCh2YWx1ZSkge1xuICAvLyBCcm93c2VycyB3aXRob3V0IGBTaGFkb3dSb290YCBzdXBwb3J0LlxuICBpZiAodHlwZW9mIFNoYWRvd1Jvb3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QgfHwgdmFsdWUgaW5zdGFuY2VvZiBnZXRXaW5kb3codmFsdWUpLlNoYWRvd1Jvb3Q7XG59XG5mdW5jdGlvbiBpc092ZXJmbG93RWxlbWVudChlbGVtZW50KSB7XG4gIGNvbnN0IHtcbiAgICBvdmVyZmxvdyxcbiAgICBvdmVyZmxvd1gsXG4gICAgb3ZlcmZsb3dZLFxuICAgIGRpc3BsYXlcbiAgfSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIHJldHVybiAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW58Y2xpcC8udGVzdChvdmVyZmxvdyArIG92ZXJmbG93WSArIG92ZXJmbG93WCkgJiYgIVsnaW5saW5lJywgJ2NvbnRlbnRzJ10uaW5jbHVkZXMoZGlzcGxheSk7XG59XG5mdW5jdGlvbiBpc1RhYmxlRWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiBbJ3RhYmxlJywgJ3RkJywgJ3RoJ10uaW5jbHVkZXMoZ2V0Tm9kZU5hbWUoZWxlbWVudCkpO1xufVxuZnVuY3Rpb24gaXNDb250YWluaW5nQmxvY2soZWxlbWVudCkge1xuICBjb25zdCB3ZWJraXQgPSBpc1dlYktpdCgpO1xuICBjb25zdCBjc3MgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9Db250YWluaW5nX2Jsb2NrI2lkZW50aWZ5aW5nX3RoZV9jb250YWluaW5nX2Jsb2NrXG4gIHJldHVybiBjc3MudHJhbnNmb3JtICE9PSAnbm9uZScgfHwgY3NzLnBlcnNwZWN0aXZlICE9PSAnbm9uZScgfHwgKGNzcy5jb250YWluZXJUeXBlID8gY3NzLmNvbnRhaW5lclR5cGUgIT09ICdub3JtYWwnIDogZmFsc2UpIHx8ICF3ZWJraXQgJiYgKGNzcy5iYWNrZHJvcEZpbHRlciA/IGNzcy5iYWNrZHJvcEZpbHRlciAhPT0gJ25vbmUnIDogZmFsc2UpIHx8ICF3ZWJraXQgJiYgKGNzcy5maWx0ZXIgPyBjc3MuZmlsdGVyICE9PSAnbm9uZScgOiBmYWxzZSkgfHwgWyd0cmFuc2Zvcm0nLCAncGVyc3BlY3RpdmUnLCAnZmlsdGVyJ10uc29tZSh2YWx1ZSA9PiAoY3NzLndpbGxDaGFuZ2UgfHwgJycpLmluY2x1ZGVzKHZhbHVlKSkgfHwgWydwYWludCcsICdsYXlvdXQnLCAnc3RyaWN0JywgJ2NvbnRlbnQnXS5zb21lKHZhbHVlID0+IChjc3MuY29udGFpbiB8fCAnJykuaW5jbHVkZXModmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB7XG4gIGxldCBjdXJyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG4gIHdoaWxlIChpc0hUTUxFbGVtZW50KGN1cnJlbnROb2RlKSAmJiAhaXNMYXN0VHJhdmVyc2FibGVOb2RlKGN1cnJlbnROb2RlKSkge1xuICAgIGlmIChpc0NvbnRhaW5pbmdCbG9jayhjdXJyZW50Tm9kZSkpIHtcbiAgICAgIHJldHVybiBjdXJyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGN1cnJlbnROb2RlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBpc1dlYktpdCgpIHtcbiAgaWYgKHR5cGVvZiBDU1MgPT09ICd1bmRlZmluZWQnIHx8ICFDU1Muc3VwcG9ydHMpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIENTUy5zdXBwb3J0cygnLXdlYmtpdC1iYWNrZHJvcC1maWx0ZXInLCAnbm9uZScpO1xufVxuZnVuY3Rpb24gaXNMYXN0VHJhdmVyc2FibGVOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIFsnaHRtbCcsICdib2R5JywgJyNkb2N1bWVudCddLmluY2x1ZGVzKGdldE5vZGVOYW1lKG5vZGUpKTtcbn1cbmZ1bmN0aW9uIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0V2luZG93KGVsZW1lbnQpLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG59XG5mdW5jdGlvbiBnZXROb2RlU2Nyb2xsKGVsZW1lbnQpIHtcbiAgaWYgKGlzRWxlbWVudChlbGVtZW50KSkge1xuICAgIHJldHVybiB7XG4gICAgICBzY3JvbGxMZWZ0OiBlbGVtZW50LnNjcm9sbExlZnQsXG4gICAgICBzY3JvbGxUb3A6IGVsZW1lbnQuc2Nyb2xsVG9wXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQ6IGVsZW1lbnQucGFnZVhPZmZzZXQsXG4gICAgc2Nyb2xsVG9wOiBlbGVtZW50LnBhZ2VZT2Zmc2V0XG4gIH07XG59XG5mdW5jdGlvbiBnZXRQYXJlbnROb2RlKG5vZGUpIHtcbiAgaWYgKGdldE5vZGVOYW1lKG5vZGUpID09PSAnaHRtbCcpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBjb25zdCByZXN1bHQgPVxuICAvLyBTdGVwIGludG8gdGhlIHNoYWRvdyBET00gb2YgdGhlIHBhcmVudCBvZiBhIHNsb3R0ZWQgbm9kZS5cbiAgbm9kZS5hc3NpZ25lZFNsb3QgfHxcbiAgLy8gRE9NIEVsZW1lbnQgZGV0ZWN0ZWQuXG4gIG5vZGUucGFyZW50Tm9kZSB8fFxuICAvLyBTaGFkb3dSb290IGRldGVjdGVkLlxuICBpc1NoYWRvd1Jvb3Qobm9kZSkgJiYgbm9kZS5ob3N0IHx8XG4gIC8vIEZhbGxiYWNrLlxuICBnZXREb2N1bWVudEVsZW1lbnQobm9kZSk7XG4gIHJldHVybiBpc1NoYWRvd1Jvb3QocmVzdWx0KSA/IHJlc3VsdC5ob3N0IDogcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0TmVhcmVzdE92ZXJmbG93QW5jZXN0b3Iobm9kZSkge1xuICBjb25zdCBwYXJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShub2RlKTtcbiAgaWYgKGlzTGFzdFRyYXZlcnNhYmxlTm9kZShwYXJlbnROb2RlKSkge1xuICAgIHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQgPyBub2RlLm93bmVyRG9jdW1lbnQuYm9keSA6IG5vZGUuYm9keTtcbiAgfVxuICBpZiAoaXNIVE1MRWxlbWVudChwYXJlbnROb2RlKSAmJiBpc092ZXJmbG93RWxlbWVudChwYXJlbnROb2RlKSkge1xuICAgIHJldHVybiBwYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3RvcihwYXJlbnROb2RlKTtcbn1cbmZ1bmN0aW9uIGdldE92ZXJmbG93QW5jZXN0b3JzKG5vZGUsIGxpc3QpIHtcbiAgdmFyIF9ub2RlJG93bmVyRG9jdW1lbnQyO1xuICBpZiAobGlzdCA9PT0gdm9pZCAwKSB7XG4gICAgbGlzdCA9IFtdO1xuICB9XG4gIGNvbnN0IHNjcm9sbGFibGVBbmNlc3RvciA9IGdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yKG5vZGUpO1xuICBjb25zdCBpc0JvZHkgPSBzY3JvbGxhYmxlQW5jZXN0b3IgPT09ICgoX25vZGUkb3duZXJEb2N1bWVudDIgPSBub2RlLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRvd25lckRvY3VtZW50Mi5ib2R5KTtcbiAgY29uc3Qgd2luID0gZ2V0V2luZG93KHNjcm9sbGFibGVBbmNlc3Rvcik7XG4gIGlmIChpc0JvZHkpIHtcbiAgICByZXR1cm4gbGlzdC5jb25jYXQod2luLCB3aW4udmlzdWFsVmlld3BvcnQgfHwgW10sIGlzT3ZlcmZsb3dFbGVtZW50KHNjcm9sbGFibGVBbmNlc3RvcikgPyBzY3JvbGxhYmxlQW5jZXN0b3IgOiBbXSk7XG4gIH1cbiAgcmV0dXJuIGxpc3QuY29uY2F0KHNjcm9sbGFibGVBbmNlc3RvciwgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMoc2Nyb2xsYWJsZUFuY2VzdG9yKSk7XG59XG5cbmV4cG9ydCB7IGdldENvbXB1dGVkU3R5bGUsIGdldENvbnRhaW5pbmdCbG9jaywgZ2V0RG9jdW1lbnRFbGVtZW50LCBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3RvciwgZ2V0Tm9kZU5hbWUsIGdldE5vZGVTY3JvbGwsIGdldE92ZXJmbG93QW5jZXN0b3JzLCBnZXRQYXJlbnROb2RlLCBnZXRXaW5kb3csIGlzQ29udGFpbmluZ0Jsb2NrLCBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQsIGlzTGFzdFRyYXZlcnNhYmxlTm9kZSwgaXNOb2RlLCBpc092ZXJmbG93RWxlbWVudCwgaXNTaGFkb3dSb290LCBpc1RhYmxlRWxlbWVudCwgaXNXZWJLaXQgfTtcbiIsImltcG9ydCB7IHJlY3RUb0NsaWVudFJlY3QsIGNvbXB1dGVQb3NpdGlvbiBhcyBjb21wdXRlUG9zaXRpb24kMSB9IGZyb20gJ0BmbG9hdGluZy11aS9jb3JlJztcbmV4cG9ydCB7IGFycm93LCBhdXRvUGxhY2VtZW50LCBkZXRlY3RPdmVyZmxvdywgZmxpcCwgaGlkZSwgaW5saW5lLCBsaW1pdFNoaWZ0LCBvZmZzZXQsIHNoaWZ0LCBzaXplIH0gZnJvbSAnQGZsb2F0aW5nLXVpL2NvcmUnO1xuaW1wb3J0IHsgcm91bmQsIGNyZWF0ZUNvb3JkcywgbWF4LCBtaW4sIGZsb29yIH0gZnJvbSAnQGZsb2F0aW5nLXVpL3V0aWxzJztcbmltcG9ydCB7IGdldENvbXB1dGVkU3R5bGUsIGlzSFRNTEVsZW1lbnQsIGlzRWxlbWVudCwgZ2V0V2luZG93LCBpc1dlYktpdCwgZ2V0RG9jdW1lbnRFbGVtZW50LCBnZXROb2RlTmFtZSwgaXNPdmVyZmxvd0VsZW1lbnQsIGdldE5vZGVTY3JvbGwsIGdldE92ZXJmbG93QW5jZXN0b3JzLCBnZXRQYXJlbnROb2RlLCBpc0xhc3RUcmF2ZXJzYWJsZU5vZGUsIGlzQ29udGFpbmluZ0Jsb2NrLCBpc1RhYmxlRWxlbWVudCwgZ2V0Q29udGFpbmluZ0Jsb2NrIH0gZnJvbSAnQGZsb2F0aW5nLXVpL3V0aWxzL2RvbSc7XG5leHBvcnQgeyBnZXRPdmVyZmxvd0FuY2VzdG9ycyB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscy9kb20nO1xuXG5mdW5jdGlvbiBnZXRDc3NEaW1lbnNpb25zKGVsZW1lbnQpIHtcbiAgY29uc3QgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgLy8gSW4gdGVzdGluZyBlbnZpcm9ubWVudHMsIHRoZSBgd2lkdGhgIGFuZCBgaGVpZ2h0YCBwcm9wZXJ0aWVzIGFyZSBlbXB0eVxuICAvLyBzdHJpbmdzIGZvciBTVkcgZWxlbWVudHMsIHJldHVybmluZyBOYU4uIEZhbGxiYWNrIHRvIGAwYCBpbiB0aGlzIGNhc2UuXG4gIGxldCB3aWR0aCA9IHBhcnNlRmxvYXQoY3NzLndpZHRoKSB8fCAwO1xuICBsZXQgaGVpZ2h0ID0gcGFyc2VGbG9hdChjc3MuaGVpZ2h0KSB8fCAwO1xuICBjb25zdCBoYXNPZmZzZXQgPSBpc0hUTUxFbGVtZW50KGVsZW1lbnQpO1xuICBjb25zdCBvZmZzZXRXaWR0aCA9IGhhc09mZnNldCA/IGVsZW1lbnQub2Zmc2V0V2lkdGggOiB3aWR0aDtcbiAgY29uc3Qgb2Zmc2V0SGVpZ2h0ID0gaGFzT2Zmc2V0ID8gZWxlbWVudC5vZmZzZXRIZWlnaHQgOiBoZWlnaHQ7XG4gIGNvbnN0IHNob3VsZEZhbGxiYWNrID0gcm91bmQod2lkdGgpICE9PSBvZmZzZXRXaWR0aCB8fCByb3VuZChoZWlnaHQpICE9PSBvZmZzZXRIZWlnaHQ7XG4gIGlmIChzaG91bGRGYWxsYmFjaykge1xuICAgIHdpZHRoID0gb2Zmc2V0V2lkdGg7XG4gICAgaGVpZ2h0ID0gb2Zmc2V0SGVpZ2h0O1xuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgICQ6IHNob3VsZEZhbGxiYWNrXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVud3JhcEVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gIWlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQuY29udGV4dEVsZW1lbnQgOiBlbGVtZW50O1xufVxuXG5mdW5jdGlvbiBnZXRTY2FsZShlbGVtZW50KSB7XG4gIGNvbnN0IGRvbUVsZW1lbnQgPSB1bndyYXBFbGVtZW50KGVsZW1lbnQpO1xuICBpZiAoIWlzSFRNTEVsZW1lbnQoZG9tRWxlbWVudCkpIHtcbiAgICByZXR1cm4gY3JlYXRlQ29vcmRzKDEpO1xuICB9XG4gIGNvbnN0IHJlY3QgPSBkb21FbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgICRcbiAgfSA9IGdldENzc0RpbWVuc2lvbnMoZG9tRWxlbWVudCk7XG4gIGxldCB4ID0gKCQgPyByb3VuZChyZWN0LndpZHRoKSA6IHJlY3Qud2lkdGgpIC8gd2lkdGg7XG4gIGxldCB5ID0gKCQgPyByb3VuZChyZWN0LmhlaWdodCkgOiByZWN0LmhlaWdodCkgLyBoZWlnaHQ7XG5cbiAgLy8gMCwgTmFOLCBvciBJbmZpbml0eSBzaG91bGQgYWx3YXlzIGZhbGxiYWNrIHRvIDEuXG5cbiAgaWYgKCF4IHx8ICFOdW1iZXIuaXNGaW5pdGUoeCkpIHtcbiAgICB4ID0gMTtcbiAgfVxuICBpZiAoIXkgfHwgIU51bWJlci5pc0Zpbml0ZSh5KSkge1xuICAgIHkgPSAxO1xuICB9XG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5cbmNvbnN0IG5vT2Zmc2V0cyA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb29yZHMoMCk7XG5mdW5jdGlvbiBnZXRWaXN1YWxPZmZzZXRzKGVsZW1lbnQpIHtcbiAgY29uc3Qgd2luID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICBpZiAoIWlzV2ViS2l0KCkgfHwgIXdpbi52aXN1YWxWaWV3cG9ydCkge1xuICAgIHJldHVybiBub09mZnNldHM7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiB3aW4udmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdCxcbiAgICB5OiB3aW4udmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wXG4gIH07XG59XG5mdW5jdGlvbiBzaG91bGRBZGRWaXN1YWxPZmZzZXRzKGVsZW1lbnQsIGlzRml4ZWQsIGZsb2F0aW5nT2Zmc2V0UGFyZW50KSB7XG4gIGlmIChpc0ZpeGVkID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkID0gZmFsc2U7XG4gIH1cbiAgaWYgKCFmbG9hdGluZ09mZnNldFBhcmVudCB8fCBpc0ZpeGVkICYmIGZsb2F0aW5nT2Zmc2V0UGFyZW50ICE9PSBnZXRXaW5kb3coZWxlbWVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzRml4ZWQ7XG59XG5cbmZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBpbmNsdWRlU2NhbGUsIGlzRml4ZWRTdHJhdGVneSwgb2Zmc2V0UGFyZW50KSB7XG4gIGlmIChpbmNsdWRlU2NhbGUgPT09IHZvaWQgMCkge1xuICAgIGluY2x1ZGVTY2FsZSA9IGZhbHNlO1xuICB9XG4gIGlmIChpc0ZpeGVkU3RyYXRlZ3kgPT09IHZvaWQgMCkge1xuICAgIGlzRml4ZWRTdHJhdGVneSA9IGZhbHNlO1xuICB9XG4gIGNvbnN0IGNsaWVudFJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCBkb21FbGVtZW50ID0gdW53cmFwRWxlbWVudChlbGVtZW50KTtcbiAgbGV0IHNjYWxlID0gY3JlYXRlQ29vcmRzKDEpO1xuICBpZiAoaW5jbHVkZVNjYWxlKSB7XG4gICAgaWYgKG9mZnNldFBhcmVudCkge1xuICAgICAgaWYgKGlzRWxlbWVudChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICAgIHNjYWxlID0gZ2V0U2NhbGUob2Zmc2V0UGFyZW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGUgPSBnZXRTY2FsZShlbGVtZW50KTtcbiAgICB9XG4gIH1cbiAgY29uc3QgdmlzdWFsT2Zmc2V0cyA9IHNob3VsZEFkZFZpc3VhbE9mZnNldHMoZG9tRWxlbWVudCwgaXNGaXhlZFN0cmF0ZWd5LCBvZmZzZXRQYXJlbnQpID8gZ2V0VmlzdWFsT2Zmc2V0cyhkb21FbGVtZW50KSA6IGNyZWF0ZUNvb3JkcygwKTtcbiAgbGV0IHggPSAoY2xpZW50UmVjdC5sZWZ0ICsgdmlzdWFsT2Zmc2V0cy54KSAvIHNjYWxlLng7XG4gIGxldCB5ID0gKGNsaWVudFJlY3QudG9wICsgdmlzdWFsT2Zmc2V0cy55KSAvIHNjYWxlLnk7XG4gIGxldCB3aWR0aCA9IGNsaWVudFJlY3Qud2lkdGggLyBzY2FsZS54O1xuICBsZXQgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQgLyBzY2FsZS55O1xuICBpZiAoZG9tRWxlbWVudCkge1xuICAgIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhkb21FbGVtZW50KTtcbiAgICBjb25zdCBvZmZzZXRXaW4gPSBvZmZzZXRQYXJlbnQgJiYgaXNFbGVtZW50KG9mZnNldFBhcmVudCkgPyBnZXRXaW5kb3cob2Zmc2V0UGFyZW50KSA6IG9mZnNldFBhcmVudDtcbiAgICBsZXQgY3VycmVudElGcmFtZSA9IHdpbi5mcmFtZUVsZW1lbnQ7XG4gICAgd2hpbGUgKGN1cnJlbnRJRnJhbWUgJiYgb2Zmc2V0UGFyZW50ICYmIG9mZnNldFdpbiAhPT0gd2luKSB7XG4gICAgICBjb25zdCBpZnJhbWVTY2FsZSA9IGdldFNjYWxlKGN1cnJlbnRJRnJhbWUpO1xuICAgICAgY29uc3QgaWZyYW1lUmVjdCA9IGN1cnJlbnRJRnJhbWUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBjc3MgPSBnZXRDb21wdXRlZFN0eWxlKGN1cnJlbnRJRnJhbWUpO1xuICAgICAgY29uc3QgbGVmdCA9IGlmcmFtZVJlY3QubGVmdCArIChjdXJyZW50SUZyYW1lLmNsaWVudExlZnQgKyBwYXJzZUZsb2F0KGNzcy5wYWRkaW5nTGVmdCkpICogaWZyYW1lU2NhbGUueDtcbiAgICAgIGNvbnN0IHRvcCA9IGlmcmFtZVJlY3QudG9wICsgKGN1cnJlbnRJRnJhbWUuY2xpZW50VG9wICsgcGFyc2VGbG9hdChjc3MucGFkZGluZ1RvcCkpICogaWZyYW1lU2NhbGUueTtcbiAgICAgIHggKj0gaWZyYW1lU2NhbGUueDtcbiAgICAgIHkgKj0gaWZyYW1lU2NhbGUueTtcbiAgICAgIHdpZHRoICo9IGlmcmFtZVNjYWxlLng7XG4gICAgICBoZWlnaHQgKj0gaWZyYW1lU2NhbGUueTtcbiAgICAgIHggKz0gbGVmdDtcbiAgICAgIHkgKz0gdG9wO1xuICAgICAgY3VycmVudElGcmFtZSA9IGdldFdpbmRvdyhjdXJyZW50SUZyYW1lKS5mcmFtZUVsZW1lbnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZWN0VG9DbGllbnRSZWN0KHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdChfcmVmKSB7XG4gIGxldCB7XG4gICAgcmVjdCxcbiAgICBvZmZzZXRQYXJlbnQsXG4gICAgc3RyYXRlZ3lcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICBjb25zdCBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgaWYgKG9mZnNldFBhcmVudCA9PT0gZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgcmV0dXJuIHJlY3Q7XG4gIH1cbiAgbGV0IHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICBsZXQgc2NhbGUgPSBjcmVhdGVDb29yZHMoMSk7XG4gIGNvbnN0IG9mZnNldHMgPSBjcmVhdGVDb29yZHMoMCk7XG4gIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCB8fCAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgc3RyYXRlZ3kgIT09ICdmaXhlZCcpIHtcbiAgICBpZiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSAhPT0gJ2JvZHknIHx8IGlzT3ZlcmZsb3dFbGVtZW50KGRvY3VtZW50RWxlbWVudCkpIHtcbiAgICAgIHNjcm9sbCA9IGdldE5vZGVTY3JvbGwob2Zmc2V0UGFyZW50KTtcbiAgICB9XG4gICAgaWYgKGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgY29uc3Qgb2Zmc2V0UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQpO1xuICAgICAgc2NhbGUgPSBnZXRTY2FsZShvZmZzZXRQYXJlbnQpO1xuICAgICAgb2Zmc2V0cy54ID0gb2Zmc2V0UmVjdC54ICsgb2Zmc2V0UGFyZW50LmNsaWVudExlZnQ7XG4gICAgICBvZmZzZXRzLnkgPSBvZmZzZXRSZWN0LnkgKyBvZmZzZXRQYXJlbnQuY2xpZW50VG9wO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoOiByZWN0LndpZHRoICogc2NhbGUueCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0ICogc2NhbGUueSxcbiAgICB4OiByZWN0LnggKiBzY2FsZS54IC0gc2Nyb2xsLnNjcm9sbExlZnQgKiBzY2FsZS54ICsgb2Zmc2V0cy54LFxuICAgIHk6IHJlY3QueSAqIHNjYWxlLnkgLSBzY3JvbGwuc2Nyb2xsVG9wICogc2NhbGUueSArIG9mZnNldHMueVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRDbGllbnRSZWN0cyhlbGVtZW50KSB7XG4gIHJldHVybiBBcnJheS5mcm9tKGVsZW1lbnQuZ2V0Q2xpZW50UmVjdHMoKSk7XG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCkge1xuICAvLyBJZiA8aHRtbD4gaGFzIGEgQ1NTIHdpZHRoIGdyZWF0ZXIgdGhhbiB0aGUgdmlld3BvcnQsIHRoZW4gdGhpcyB3aWxsIGJlXG4gIC8vIGluY29ycmVjdCBmb3IgUlRMLlxuICByZXR1cm4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkubGVmdCArIGdldE5vZGVTY3JvbGwoZWxlbWVudCkuc2Nyb2xsTGVmdDtcbn1cblxuLy8gR2V0cyB0aGUgZW50aXJlIHNpemUgb2YgdGhlIHNjcm9sbGFibGUgZG9jdW1lbnQgYXJlYSwgZXZlbiBleHRlbmRpbmcgb3V0c2lkZVxuLy8gb2YgdGhlIGA8aHRtbD5gIGFuZCBgPGJvZHk+YCByZWN0IGJvdW5kcyBpZiBob3Jpem9udGFsbHkgc2Nyb2xsYWJsZS5cbmZ1bmN0aW9uIGdldERvY3VtZW50UmVjdChlbGVtZW50KSB7XG4gIGNvbnN0IGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIGNvbnN0IHNjcm9sbCA9IGdldE5vZGVTY3JvbGwoZWxlbWVudCk7XG4gIGNvbnN0IGJvZHkgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuYm9keTtcbiAgY29uc3Qgd2lkdGggPSBtYXgoaHRtbC5zY3JvbGxXaWR0aCwgaHRtbC5jbGllbnRXaWR0aCwgYm9keS5zY3JvbGxXaWR0aCwgYm9keS5jbGllbnRXaWR0aCk7XG4gIGNvbnN0IGhlaWdodCA9IG1heChodG1sLnNjcm9sbEhlaWdodCwgaHRtbC5jbGllbnRIZWlnaHQsIGJvZHkuc2Nyb2xsSGVpZ2h0LCBib2R5LmNsaWVudEhlaWdodCk7XG4gIGxldCB4ID0gLXNjcm9sbC5zY3JvbGxMZWZ0ICsgZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KTtcbiAgY29uc3QgeSA9IC1zY3JvbGwuc2Nyb2xsVG9wO1xuICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShib2R5KS5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgeCArPSBtYXgoaHRtbC5jbGllbnRXaWR0aCwgYm9keS5jbGllbnRXaWR0aCkgLSB3aWR0aDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgY29uc3QgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgY29uc3QgdmlzdWFsVmlld3BvcnQgPSB3aW4udmlzdWFsVmlld3BvcnQ7XG4gIGxldCB3aWR0aCA9IGh0bWwuY2xpZW50V2lkdGg7XG4gIGxldCBoZWlnaHQgPSBodG1sLmNsaWVudEhlaWdodDtcbiAgbGV0IHggPSAwO1xuICBsZXQgeSA9IDA7XG4gIGlmICh2aXN1YWxWaWV3cG9ydCkge1xuICAgIHdpZHRoID0gdmlzdWFsVmlld3BvcnQud2lkdGg7XG4gICAgaGVpZ2h0ID0gdmlzdWFsVmlld3BvcnQuaGVpZ2h0O1xuICAgIGNvbnN0IHZpc3VhbFZpZXdwb3J0QmFzZWQgPSBpc1dlYktpdCgpO1xuICAgIGlmICghdmlzdWFsVmlld3BvcnRCYXNlZCB8fCB2aXN1YWxWaWV3cG9ydEJhc2VkICYmIHN0cmF0ZWd5ID09PSAnZml4ZWQnKSB7XG4gICAgICB4ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdDtcbiAgICAgIHkgPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3A7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHgsXG4gICAgeVxuICB9O1xufVxuXG4vLyBSZXR1cm5zIHRoZSBpbm5lciBjbGllbnQgcmVjdCwgc3VidHJhY3Rpbmcgc2Nyb2xsYmFycyBpZiBwcmVzZW50LlxuZnVuY3Rpb24gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpIHtcbiAgY29uc3QgY2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCB0cnVlLCBzdHJhdGVneSA9PT0gJ2ZpeGVkJyk7XG4gIGNvbnN0IHRvcCA9IGNsaWVudFJlY3QudG9wICsgZWxlbWVudC5jbGllbnRUb3A7XG4gIGNvbnN0IGxlZnQgPSBjbGllbnRSZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudExlZnQ7XG4gIGNvbnN0IHNjYWxlID0gaXNIVE1MRWxlbWVudChlbGVtZW50KSA/IGdldFNjYWxlKGVsZW1lbnQpIDogY3JlYXRlQ29vcmRzKDEpO1xuICBjb25zdCB3aWR0aCA9IGVsZW1lbnQuY2xpZW50V2lkdGggKiBzY2FsZS54O1xuICBjb25zdCBoZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodCAqIHNjYWxlLnk7XG4gIGNvbnN0IHggPSBsZWZ0ICogc2NhbGUueDtcbiAgY29uc3QgeSA9IHRvcCAqIHNjYWxlLnk7XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHgsXG4gICAgeVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdEZyb21DbGlwcGluZ0FuY2VzdG9yKGVsZW1lbnQsIGNsaXBwaW5nQW5jZXN0b3IsIHN0cmF0ZWd5KSB7XG4gIGxldCByZWN0O1xuICBpZiAoY2xpcHBpbmdBbmNlc3RvciA9PT0gJ3ZpZXdwb3J0Jykge1xuICAgIHJlY3QgPSBnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpO1xuICB9IGVsc2UgaWYgKGNsaXBwaW5nQW5jZXN0b3IgPT09ICdkb2N1bWVudCcpIHtcbiAgICByZWN0ID0gZ2V0RG9jdW1lbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSk7XG4gIH0gZWxzZSBpZiAoaXNFbGVtZW50KGNsaXBwaW5nQW5jZXN0b3IpKSB7XG4gICAgcmVjdCA9IGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGNsaXBwaW5nQW5jZXN0b3IsIHN0cmF0ZWd5KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB2aXN1YWxPZmZzZXRzID0gZ2V0VmlzdWFsT2Zmc2V0cyhlbGVtZW50KTtcbiAgICByZWN0ID0ge1xuICAgICAgLi4uY2xpcHBpbmdBbmNlc3RvcixcbiAgICAgIHg6IGNsaXBwaW5nQW5jZXN0b3IueCAtIHZpc3VhbE9mZnNldHMueCxcbiAgICAgIHk6IGNsaXBwaW5nQW5jZXN0b3IueSAtIHZpc3VhbE9mZnNldHMueVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHJlY3RUb0NsaWVudFJlY3QocmVjdCk7XG59XG5mdW5jdGlvbiBoYXNGaXhlZFBvc2l0aW9uQW5jZXN0b3IoZWxlbWVudCwgc3RvcE5vZGUpIHtcbiAgY29uc3QgcGFyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG4gIGlmIChwYXJlbnROb2RlID09PSBzdG9wTm9kZSB8fCAhaXNFbGVtZW50KHBhcmVudE5vZGUpIHx8IGlzTGFzdFRyYXZlcnNhYmxlTm9kZShwYXJlbnROb2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnROb2RlKS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJyB8fCBoYXNGaXhlZFBvc2l0aW9uQW5jZXN0b3IocGFyZW50Tm9kZSwgc3RvcE5vZGUpO1xufVxuXG4vLyBBIFwiY2xpcHBpbmcgYW5jZXN0b3JcIiBpcyBhbiBgb3ZlcmZsb3dgIGVsZW1lbnQgd2l0aCB0aGUgY2hhcmFjdGVyaXN0aWMgb2Zcbi8vIGNsaXBwaW5nIChvciBoaWRpbmcpIGNoaWxkIGVsZW1lbnRzLiBUaGlzIHJldHVybnMgYWxsIGNsaXBwaW5nIGFuY2VzdG9yc1xuLy8gb2YgdGhlIGdpdmVuIGVsZW1lbnQgdXAgdGhlIHRyZWUuXG5mdW5jdGlvbiBnZXRDbGlwcGluZ0VsZW1lbnRBbmNlc3RvcnMoZWxlbWVudCwgY2FjaGUpIHtcbiAgY29uc3QgY2FjaGVkUmVzdWx0ID0gY2FjaGUuZ2V0KGVsZW1lbnQpO1xuICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgcmV0dXJuIGNhY2hlZFJlc3VsdDtcbiAgfVxuICBsZXQgcmVzdWx0ID0gZ2V0T3ZlcmZsb3dBbmNlc3RvcnMoZWxlbWVudCkuZmlsdGVyKGVsID0+IGlzRWxlbWVudChlbCkgJiYgZ2V0Tm9kZU5hbWUoZWwpICE9PSAnYm9keScpO1xuICBsZXQgY3VycmVudENvbnRhaW5pbmdCbG9ja0NvbXB1dGVkU3R5bGUgPSBudWxsO1xuICBjb25zdCBlbGVtZW50SXNGaXhlZCA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gPT09ICdmaXhlZCc7XG4gIGxldCBjdXJyZW50Tm9kZSA9IGVsZW1lbnRJc0ZpeGVkID8gZ2V0UGFyZW50Tm9kZShlbGVtZW50KSA6IGVsZW1lbnQ7XG5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NvbnRhaW5pbmdfYmxvY2sjaWRlbnRpZnlpbmdfdGhlX2NvbnRhaW5pbmdfYmxvY2tcbiAgd2hpbGUgKGlzRWxlbWVudChjdXJyZW50Tm9kZSkgJiYgIWlzTGFzdFRyYXZlcnNhYmxlTm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50Tm9kZSk7XG4gICAgY29uc3QgY3VycmVudE5vZGVJc0NvbnRhaW5pbmcgPSBpc0NvbnRhaW5pbmdCbG9jayhjdXJyZW50Tm9kZSk7XG4gICAgaWYgKCFjdXJyZW50Tm9kZUlzQ29udGFpbmluZyAmJiBjb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICBjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHNob3VsZERyb3BDdXJyZW50Tm9kZSA9IGVsZW1lbnRJc0ZpeGVkID8gIWN1cnJlbnROb2RlSXNDb250YWluaW5nICYmICFjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSA6ICFjdXJyZW50Tm9kZUlzQ29udGFpbmluZyAmJiBjb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSAnc3RhdGljJyAmJiAhIWN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlICYmIFsnYWJzb2x1dGUnLCAnZml4ZWQnXS5pbmNsdWRlcyhjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZS5wb3NpdGlvbikgfHwgaXNPdmVyZmxvd0VsZW1lbnQoY3VycmVudE5vZGUpICYmICFjdXJyZW50Tm9kZUlzQ29udGFpbmluZyAmJiBoYXNGaXhlZFBvc2l0aW9uQW5jZXN0b3IoZWxlbWVudCwgY3VycmVudE5vZGUpO1xuICAgIGlmIChzaG91bGREcm9wQ3VycmVudE5vZGUpIHtcbiAgICAgIC8vIERyb3Agbm9uLWNvbnRhaW5pbmcgYmxvY2tzLlxuICAgICAgcmVzdWx0ID0gcmVzdWx0LmZpbHRlcihhbmNlc3RvciA9PiBhbmNlc3RvciAhPT0gY3VycmVudE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZWNvcmQgbGFzdCBjb250YWluaW5nIGJsb2NrIGZvciBuZXh0IGl0ZXJhdGlvbi5cbiAgICAgIGN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlID0gY29tcHV0ZWRTdHlsZTtcbiAgICB9XG4gICAgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGN1cnJlbnROb2RlKTtcbiAgfVxuICBjYWNoZS5zZXQoZWxlbWVudCwgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gR2V0cyB0aGUgbWF4aW11bSBhcmVhIHRoYXQgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBpbiBkdWUgdG8gYW55IG51bWJlciBvZlxuLy8gY2xpcHBpbmcgYW5jZXN0b3JzLlxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdSZWN0KF9yZWYpIHtcbiAgbGV0IHtcbiAgICBlbGVtZW50LFxuICAgIGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeSxcbiAgICBzdHJhdGVneVxuICB9ID0gX3JlZjtcbiAgY29uc3QgZWxlbWVudENsaXBwaW5nQW5jZXN0b3JzID0gYm91bmRhcnkgPT09ICdjbGlwcGluZ0FuY2VzdG9ycycgPyBnZXRDbGlwcGluZ0VsZW1lbnRBbmNlc3RvcnMoZWxlbWVudCwgdGhpcy5fYykgOiBbXS5jb25jYXQoYm91bmRhcnkpO1xuICBjb25zdCBjbGlwcGluZ0FuY2VzdG9ycyA9IFsuLi5lbGVtZW50Q2xpcHBpbmdBbmNlc3RvcnMsIHJvb3RCb3VuZGFyeV07XG4gIGNvbnN0IGZpcnN0Q2xpcHBpbmdBbmNlc3RvciA9IGNsaXBwaW5nQW5jZXN0b3JzWzBdO1xuICBjb25zdCBjbGlwcGluZ1JlY3QgPSBjbGlwcGluZ0FuY2VzdG9ycy5yZWR1Y2UoKGFjY1JlY3QsIGNsaXBwaW5nQW5jZXN0b3IpID0+IHtcbiAgICBjb25zdCByZWN0ID0gZ2V0Q2xpZW50UmVjdEZyb21DbGlwcGluZ0FuY2VzdG9yKGVsZW1lbnQsIGNsaXBwaW5nQW5jZXN0b3IsIHN0cmF0ZWd5KTtcbiAgICBhY2NSZWN0LnRvcCA9IG1heChyZWN0LnRvcCwgYWNjUmVjdC50b3ApO1xuICAgIGFjY1JlY3QucmlnaHQgPSBtaW4ocmVjdC5yaWdodCwgYWNjUmVjdC5yaWdodCk7XG4gICAgYWNjUmVjdC5ib3R0b20gPSBtaW4ocmVjdC5ib3R0b20sIGFjY1JlY3QuYm90dG9tKTtcbiAgICBhY2NSZWN0LmxlZnQgPSBtYXgocmVjdC5sZWZ0LCBhY2NSZWN0LmxlZnQpO1xuICAgIHJldHVybiBhY2NSZWN0O1xuICB9LCBnZXRDbGllbnRSZWN0RnJvbUNsaXBwaW5nQW5jZXN0b3IoZWxlbWVudCwgZmlyc3RDbGlwcGluZ0FuY2VzdG9yLCBzdHJhdGVneSkpO1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiBjbGlwcGluZ1JlY3QucmlnaHQgLSBjbGlwcGluZ1JlY3QubGVmdCxcbiAgICBoZWlnaHQ6IGNsaXBwaW5nUmVjdC5ib3R0b20gLSBjbGlwcGluZ1JlY3QudG9wLFxuICAgIHg6IGNsaXBwaW5nUmVjdC5sZWZ0LFxuICAgIHk6IGNsaXBwaW5nUmVjdC50b3BcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0RGltZW5zaW9ucyhlbGVtZW50KSB7XG4gIHJldHVybiBnZXRDc3NEaW1lbnNpb25zKGVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiBnZXRSZWN0UmVsYXRpdmVUb09mZnNldFBhcmVudChlbGVtZW50LCBvZmZzZXRQYXJlbnQsIHN0cmF0ZWd5KSB7XG4gIGNvbnN0IGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICBjb25zdCBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgY29uc3QgaXNGaXhlZCA9IHN0cmF0ZWd5ID09PSAnZml4ZWQnO1xuICBjb25zdCByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIHRydWUsIGlzRml4ZWQsIG9mZnNldFBhcmVudCk7XG4gIGxldCBzY3JvbGwgPSB7XG4gICAgc2Nyb2xsTGVmdDogMCxcbiAgICBzY3JvbGxUb3A6IDBcbiAgfTtcbiAgY29uc3Qgb2Zmc2V0cyA9IGNyZWF0ZUNvb3JkcygwKTtcbiAgaWYgKGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50IHx8ICFpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiAhaXNGaXhlZCkge1xuICAgIGlmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpICE9PSAnYm9keScgfHwgaXNPdmVyZmxvd0VsZW1lbnQoZG9jdW1lbnRFbGVtZW50KSkge1xuICAgICAgc2Nyb2xsID0gZ2V0Tm9kZVNjcm9sbChvZmZzZXRQYXJlbnQpO1xuICAgIH1cbiAgICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IG9mZnNldFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50LCB0cnVlLCBpc0ZpeGVkLCBvZmZzZXRQYXJlbnQpO1xuICAgICAgb2Zmc2V0cy54ID0gb2Zmc2V0UmVjdC54ICsgb2Zmc2V0UGFyZW50LmNsaWVudExlZnQ7XG4gICAgICBvZmZzZXRzLnkgPSBvZmZzZXRSZWN0LnkgKyBvZmZzZXRQYXJlbnQuY2xpZW50VG9wO1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICBvZmZzZXRzLnggPSBnZXRXaW5kb3dTY3JvbGxCYXJYKGRvY3VtZW50RWxlbWVudCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgeDogcmVjdC5sZWZ0ICsgc2Nyb2xsLnNjcm9sbExlZnQgLSBvZmZzZXRzLngsXG4gICAgeTogcmVjdC50b3AgKyBzY3JvbGwuc2Nyb2xsVG9wIC0gb2Zmc2V0cy55LFxuICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50LCBwb2x5ZmlsbCkge1xuICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChwb2x5ZmlsbCkge1xuICAgIHJldHVybiBwb2x5ZmlsbChlbGVtZW50KTtcbiAgfVxuICByZXR1cm4gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG59XG5cbi8vIEdldHMgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgcG9zaXRpb25lZCBlbGVtZW50LiBIYW5kbGVzIHNvbWUgZWRnZSBjYXNlcyxcbi8vIHN1Y2ggYXMgdGFibGUgYW5jZXN0b3JzIGFuZCBjcm9zcyBicm93c2VyIGJ1Z3MuXG5mdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCwgcG9seWZpbGwpIHtcbiAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG4gIGxldCBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQsIHBvbHlmaWxsKTtcbiAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBpc1RhYmxlRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCwgcG9seWZpbGwpO1xuICB9XG4gIGlmIChvZmZzZXRQYXJlbnQgJiYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgPT09ICdodG1sJyB8fCBnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnYm9keScgJiYgZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uID09PSAnc3RhdGljJyAmJiAhaXNDb250YWluaW5nQmxvY2sob2Zmc2V0UGFyZW50KSkpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG4gIHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHx8IHdpbmRvdztcbn1cblxuY29uc3QgZ2V0RWxlbWVudFJlY3RzID0gYXN5bmMgZnVuY3Rpb24gKF9yZWYpIHtcbiAgbGV0IHtcbiAgICByZWZlcmVuY2UsXG4gICAgZmxvYXRpbmcsXG4gICAgc3RyYXRlZ3lcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGdldE9mZnNldFBhcmVudEZuID0gdGhpcy5nZXRPZmZzZXRQYXJlbnQgfHwgZ2V0T2Zmc2V0UGFyZW50O1xuICBjb25zdCBnZXREaW1lbnNpb25zRm4gPSB0aGlzLmdldERpbWVuc2lvbnM7XG4gIHJldHVybiB7XG4gICAgcmVmZXJlbmNlOiBnZXRSZWN0UmVsYXRpdmVUb09mZnNldFBhcmVudChyZWZlcmVuY2UsIGF3YWl0IGdldE9mZnNldFBhcmVudEZuKGZsb2F0aW5nKSwgc3RyYXRlZ3kpLFxuICAgIGZsb2F0aW5nOiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIC4uLihhd2FpdCBnZXREaW1lbnNpb25zRm4oZmxvYXRpbmcpKVxuICAgIH1cbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGlzUlRMKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZGlyZWN0aW9uID09PSAncnRsJztcbn1cblxuY29uc3QgcGxhdGZvcm0gPSB7XG4gIGNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0LFxuICBnZXREb2N1bWVudEVsZW1lbnQsXG4gIGdldENsaXBwaW5nUmVjdCxcbiAgZ2V0T2Zmc2V0UGFyZW50LFxuICBnZXRFbGVtZW50UmVjdHMsXG4gIGdldENsaWVudFJlY3RzLFxuICBnZXREaW1lbnNpb25zLFxuICBnZXRTY2FsZSxcbiAgaXNFbGVtZW50LFxuICBpc1JUTFxufTtcblxuLy8gaHR0cHM6Ly9zYW10aG9yLmF1LzIwMjEvb2JzZXJ2aW5nLWRvbS9cbmZ1bmN0aW9uIG9ic2VydmVNb3ZlKGVsZW1lbnQsIG9uTW92ZSkge1xuICBsZXQgaW8gPSBudWxsO1xuICBsZXQgdGltZW91dElkO1xuICBjb25zdCByb290ID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgIGlvICYmIGlvLmRpc2Nvbm5lY3QoKTtcbiAgICBpbyA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gcmVmcmVzaChza2lwLCB0aHJlc2hvbGQpIHtcbiAgICBpZiAoc2tpcCA9PT0gdm9pZCAwKSB7XG4gICAgICBza2lwID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aHJlc2hvbGQgPT09IHZvaWQgMCkge1xuICAgICAgdGhyZXNob2xkID0gMTtcbiAgICB9XG4gICAgY2xlYW51cCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIGxlZnQsXG4gICAgICB0b3AsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGlmICghc2tpcCkge1xuICAgICAgb25Nb3ZlKCk7XG4gICAgfVxuICAgIGlmICghd2lkdGggfHwgIWhlaWdodCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbnNldFRvcCA9IGZsb29yKHRvcCk7XG4gICAgY29uc3QgaW5zZXRSaWdodCA9IGZsb29yKHJvb3QuY2xpZW50V2lkdGggLSAobGVmdCArIHdpZHRoKSk7XG4gICAgY29uc3QgaW5zZXRCb3R0b20gPSBmbG9vcihyb290LmNsaWVudEhlaWdodCAtICh0b3AgKyBoZWlnaHQpKTtcbiAgICBjb25zdCBpbnNldExlZnQgPSBmbG9vcihsZWZ0KTtcbiAgICBjb25zdCByb290TWFyZ2luID0gLWluc2V0VG9wICsgXCJweCBcIiArIC1pbnNldFJpZ2h0ICsgXCJweCBcIiArIC1pbnNldEJvdHRvbSArIFwicHggXCIgKyAtaW5zZXRMZWZ0ICsgXCJweFwiO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICByb290TWFyZ2luLFxuICAgICAgdGhyZXNob2xkOiBtYXgoMCwgbWluKDEsIHRocmVzaG9sZCkpIHx8IDFcbiAgICB9O1xuICAgIGxldCBpc0ZpcnN0VXBkYXRlID0gdHJ1ZTtcbiAgICBmdW5jdGlvbiBoYW5kbGVPYnNlcnZlKGVudHJpZXMpIHtcbiAgICAgIGNvbnN0IHJhdGlvID0gZW50cmllc1swXS5pbnRlcnNlY3Rpb25SYXRpbztcbiAgICAgIGlmIChyYXRpbyAhPT0gdGhyZXNob2xkKSB7XG4gICAgICAgIGlmICghaXNGaXJzdFVwZGF0ZSkge1xuICAgICAgICAgIHJldHVybiByZWZyZXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyYXRpbykge1xuICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgcmVmcmVzaChmYWxzZSwgMWUtNyk7XG4gICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWZyZXNoKGZhbHNlLCByYXRpbyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlzRmlyc3RVcGRhdGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBPbGRlciBicm93c2VycyBkb24ndCBzdXBwb3J0IGEgYGRvY3VtZW50YCBhcyB0aGUgcm9vdCBhbmQgd2lsbCB0aHJvdyBhblxuICAgIC8vIGVycm9yLlxuICAgIHRyeSB7XG4gICAgICBpbyA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihoYW5kbGVPYnNlcnZlLCB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIC8vIEhhbmRsZSA8aWZyYW1lPnNcbiAgICAgICAgcm9vdDogcm9vdC5vd25lckRvY3VtZW50XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpbyA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihoYW5kbGVPYnNlcnZlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaW8ub2JzZXJ2ZShlbGVtZW50KTtcbiAgfVxuICByZWZyZXNoKHRydWUpO1xuICByZXR1cm4gY2xlYW51cDtcbn1cblxuLyoqXG4gKiBBdXRvbWF0aWNhbGx5IHVwZGF0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IHdoZW4gbmVjZXNzYXJ5LlxuICogU2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW4gdGhlIGZsb2F0aW5nIGVsZW1lbnQgaXMgbW91bnRlZCBvbiB0aGUgRE9NIG9yXG4gKiB2aXNpYmxlIG9uIHRoZSBzY3JlZW4uXG4gKiBAcmV0dXJucyBjbGVhbnVwIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGludm9rZWQgd2hlbiB0aGUgZmxvYXRpbmcgZWxlbWVudCBpc1xuICogcmVtb3ZlZCBmcm9tIHRoZSBET00gb3IgaGlkZGVuIGZyb20gdGhlIHNjcmVlbi5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9hdXRvVXBkYXRlXG4gKi9cbmZ1bmN0aW9uIGF1dG9VcGRhdGUocmVmZXJlbmNlLCBmbG9hdGluZywgdXBkYXRlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIGFuY2VzdG9yU2Nyb2xsID0gdHJ1ZSxcbiAgICBhbmNlc3RvclJlc2l6ZSA9IHRydWUsXG4gICAgZWxlbWVudFJlc2l6ZSA9IHR5cGVvZiBSZXNpemVPYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJyxcbiAgICBsYXlvdXRTaGlmdCA9IHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJyxcbiAgICBhbmltYXRpb25GcmFtZSA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCByZWZlcmVuY2VFbCA9IHVud3JhcEVsZW1lbnQocmVmZXJlbmNlKTtcbiAgY29uc3QgYW5jZXN0b3JzID0gYW5jZXN0b3JTY3JvbGwgfHwgYW5jZXN0b3JSZXNpemUgPyBbLi4uKHJlZmVyZW5jZUVsID8gZ2V0T3ZlcmZsb3dBbmNlc3RvcnMocmVmZXJlbmNlRWwpIDogW10pLCAuLi5nZXRPdmVyZmxvd0FuY2VzdG9ycyhmbG9hdGluZyldIDogW107XG4gIGFuY2VzdG9ycy5mb3JFYWNoKGFuY2VzdG9yID0+IHtcbiAgICBhbmNlc3RvclNjcm9sbCAmJiBhbmNlc3Rvci5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB1cGRhdGUsIHtcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9KTtcbiAgICBhbmNlc3RvclJlc2l6ZSAmJiBhbmNlc3Rvci5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGUpO1xuICB9KTtcbiAgY29uc3QgY2xlYW51cElvID0gcmVmZXJlbmNlRWwgJiYgbGF5b3V0U2hpZnQgPyBvYnNlcnZlTW92ZShyZWZlcmVuY2VFbCwgdXBkYXRlKSA6IG51bGw7XG4gIGxldCByZW9ic2VydmVGcmFtZSA9IC0xO1xuICBsZXQgcmVzaXplT2JzZXJ2ZXIgPSBudWxsO1xuICBpZiAoZWxlbWVudFJlc2l6ZSkge1xuICAgIHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKF9yZWYgPT4ge1xuICAgICAgbGV0IFtmaXJzdEVudHJ5XSA9IF9yZWY7XG4gICAgICBpZiAoZmlyc3RFbnRyeSAmJiBmaXJzdEVudHJ5LnRhcmdldCA9PT0gcmVmZXJlbmNlRWwgJiYgcmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgICAgLy8gUHJldmVudCB1cGRhdGUgbG9vcHMgd2hlbiB1c2luZyB0aGUgYHNpemVgIG1pZGRsZXdhcmUuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9hdGluZy11aS9mbG9hdGluZy11aS9pc3N1ZXMvMTc0MFxuICAgICAgICByZXNpemVPYnNlcnZlci51bm9ic2VydmUoZmxvYXRpbmcpO1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyZW9ic2VydmVGcmFtZSk7XG4gICAgICAgIHJlb2JzZXJ2ZUZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICByZXNpemVPYnNlcnZlciAmJiByZXNpemVPYnNlcnZlci5vYnNlcnZlKGZsb2F0aW5nKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB1cGRhdGUoKTtcbiAgICB9KTtcbiAgICBpZiAocmVmZXJlbmNlRWwgJiYgIWFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKHJlZmVyZW5jZUVsKTtcbiAgICB9XG4gICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShmbG9hdGluZyk7XG4gIH1cbiAgbGV0IGZyYW1lSWQ7XG4gIGxldCBwcmV2UmVmUmVjdCA9IGFuaW1hdGlvbkZyYW1lID8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHJlZmVyZW5jZSkgOiBudWxsO1xuICBpZiAoYW5pbWF0aW9uRnJhbWUpIHtcbiAgICBmcmFtZUxvb3AoKTtcbiAgfVxuICBmdW5jdGlvbiBmcmFtZUxvb3AoKSB7XG4gICAgY29uc3QgbmV4dFJlZlJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QocmVmZXJlbmNlKTtcbiAgICBpZiAocHJldlJlZlJlY3QgJiYgKG5leHRSZWZSZWN0LnggIT09IHByZXZSZWZSZWN0LnggfHwgbmV4dFJlZlJlY3QueSAhPT0gcHJldlJlZlJlY3QueSB8fCBuZXh0UmVmUmVjdC53aWR0aCAhPT0gcHJldlJlZlJlY3Qud2lkdGggfHwgbmV4dFJlZlJlY3QuaGVpZ2h0ICE9PSBwcmV2UmVmUmVjdC5oZWlnaHQpKSB7XG4gICAgICB1cGRhdGUoKTtcbiAgICB9XG4gICAgcHJldlJlZlJlY3QgPSBuZXh0UmVmUmVjdDtcbiAgICBmcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZyYW1lTG9vcCk7XG4gIH1cbiAgdXBkYXRlKCk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgYW5jZXN0b3JzLmZvckVhY2goYW5jZXN0b3IgPT4ge1xuICAgICAgYW5jZXN0b3JTY3JvbGwgJiYgYW5jZXN0b3IucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdXBkYXRlKTtcbiAgICAgIGFuY2VzdG9yUmVzaXplICYmIGFuY2VzdG9yLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZSk7XG4gICAgfSk7XG4gICAgY2xlYW51cElvICYmIGNsZWFudXBJbygpO1xuICAgIHJlc2l6ZU9ic2VydmVyICYmIHJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICByZXNpemVPYnNlcnZlciA9IG51bGw7XG4gICAgaWYgKGFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZUlkKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzIHRoYXQgd2lsbCBwbGFjZSB0aGUgZmxvYXRpbmcgZWxlbWVudFxuICogbmV4dCB0byBhIHJlZmVyZW5jZSBlbGVtZW50IHdoZW4gaXQgaXMgZ2l2ZW4gYSBjZXJ0YWluIENTUyBwb3NpdGlvbmluZ1xuICogc3RyYXRlZ3kuXG4gKi9cbmNvbnN0IGNvbXB1dGVQb3NpdGlvbiA9IChyZWZlcmVuY2UsIGZsb2F0aW5nLCBvcHRpb25zKSA9PiB7XG4gIC8vIFRoaXMgY2FjaGVzIHRoZSBleHBlbnNpdmUgYGdldENsaXBwaW5nRWxlbWVudEFuY2VzdG9yc2AgZnVuY3Rpb24gc28gdGhhdFxuICAvLyBtdWx0aXBsZSBsaWZlY3ljbGUgcmVzZXRzIHJlLXVzZSB0aGUgc2FtZSByZXN1bHQuIEl0IG9ubHkgbGl2ZXMgZm9yIGFcbiAgLy8gc2luZ2xlIGNhbGwuIElmIG90aGVyIGZ1bmN0aW9ucyBiZWNvbWUgZXhwZW5zaXZlLCB3ZSBjYW4gYWRkIHRoZW0gYXMgd2VsbC5cbiAgY29uc3QgY2FjaGUgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IG1lcmdlZE9wdGlvbnMgPSB7XG4gICAgcGxhdGZvcm0sXG4gICAgLi4ub3B0aW9uc1xuICB9O1xuICBjb25zdCBwbGF0Zm9ybVdpdGhDYWNoZSA9IHtcbiAgICAuLi5tZXJnZWRPcHRpb25zLnBsYXRmb3JtLFxuICAgIF9jOiBjYWNoZVxuICB9O1xuICByZXR1cm4gY29tcHV0ZVBvc2l0aW9uJDEocmVmZXJlbmNlLCBmbG9hdGluZywge1xuICAgIC4uLm1lcmdlZE9wdGlvbnMsXG4gICAgcGxhdGZvcm06IHBsYXRmb3JtV2l0aENhY2hlXG4gIH0pO1xufTtcblxuZXhwb3J0IHsgYXV0b1VwZGF0ZSwgY29tcHV0ZVBvc2l0aW9uLCBwbGF0Zm9ybSB9O1xuIiwiaW1wb3J0IG1lcmdlIGZyb20gJ2RlZXBtZXJnZSc7XG5pbXBvcnQgeyBzaG91bGRDZW50ZXJTdGVwIH0gZnJvbSAnLi9nZW5lcmFsJztcbmltcG9ydCB7XG4gIGF1dG9VcGRhdGUsXG4gIGFycm93LFxuICBjb21wdXRlUG9zaXRpb24sXG4gIGZsaXAsXG4gIGxpbWl0U2hpZnQsXG4gIHNoaWZ0XG59IGZyb20gJ0BmbG9hdGluZy11aS9kb20nO1xuXG4vKipcbiAqIEZsb2F0aW5nIFVJIE9wdGlvbnNcbiAqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBGbG9hdGluZ1VJT3B0aW9uc1xuICovXG5cbi8qKlxuICogRGV0ZXJtaW5lcyBvcHRpb25zIGZvciB0aGUgdG9vbHRpcCBhbmQgaW5pdGlhbGl6ZXMgZXZlbnQgbGlzdGVuZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RlcH0gc3RlcCBUaGUgc3RlcCBpbnN0YW5jZVxuICpcbiAqIEByZXR1cm4ge0Zsb2F0aW5nVUlPcHRpb25zfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0dXBUb29sdGlwKHN0ZXApIHtcbiAgaWYgKHN0ZXAuY2xlYW51cCkge1xuICAgIHN0ZXAuY2xlYW51cCgpO1xuICB9XG5cbiAgY29uc3QgYXR0YWNoVG9PcHRpb25zID0gc3RlcC5fZ2V0UmVzb2x2ZWRBdHRhY2hUb09wdGlvbnMoKTtcblxuICBsZXQgdGFyZ2V0ID0gYXR0YWNoVG9PcHRpb25zLmVsZW1lbnQ7XG4gIGNvbnN0IGZsb2F0aW5nVUlPcHRpb25zID0gZ2V0RmxvYXRpbmdVSU9wdGlvbnMoYXR0YWNoVG9PcHRpb25zLCBzdGVwKTtcbiAgY29uc3Qgc2hvdWxkQ2VudGVyID0gc2hvdWxkQ2VudGVyU3RlcChhdHRhY2hUb09wdGlvbnMpO1xuXG4gIGlmIChzaG91bGRDZW50ZXIpIHtcbiAgICB0YXJnZXQgPSBkb2N1bWVudC5ib2R5O1xuICAgIGNvbnN0IGNvbnRlbnQgPSBzdGVwLnNoZXBoZXJkRWxlbWVudENvbXBvbmVudC5nZXRFbGVtZW50KCk7XG4gICAgY29udGVudC5jbGFzc0xpc3QuYWRkKCdzaGVwaGVyZC1jZW50ZXJlZCcpO1xuICB9XG5cbiAgc3RlcC5jbGVhbnVwID0gYXV0b1VwZGF0ZSh0YXJnZXQsIHN0ZXAuZWwsICgpID0+IHtcbiAgICAvLyBUaGUgZWxlbWVudCBtaWdodCBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkIGJ5IHRoZSBlbmQgb2YgdGhlIHRvdXIuXG4gICAgaWYgKCFzdGVwLmVsKSB7XG4gICAgICBzdGVwLmNsZWFudXAoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZXRQb3NpdGlvbih0YXJnZXQsIHN0ZXAsIGZsb2F0aW5nVUlPcHRpb25zLCBzaG91bGRDZW50ZXIpO1xuICB9KTtcblxuICBzdGVwLnRhcmdldCA9IGF0dGFjaFRvT3B0aW9ucy5lbGVtZW50O1xuXG4gIHJldHVybiBmbG9hdGluZ1VJT3B0aW9ucztcbn1cblxuLyoqXG4gKiBNZXJnZSB0b29sdGlwIG9wdGlvbnMgaGFuZGxpbmcgbmVzdGVkIGtleXMuXG4gKlxuICogQHBhcmFtIHRvdXJPcHRpb25zIC0gVGhlIGRlZmF1bHQgdG91ciBvcHRpb25zLlxuICogQHBhcmFtIG9wdGlvbnMgLSBTdGVwIHNwZWNpZmljIG9wdGlvbnMuXG4gKlxuICogQHJldHVybiB7ZmxvYXRpbmdVSU9wdGlvbnM6IEZsb2F0aW5nVUlPcHRpb25zfVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VUb29sdGlwQ29uZmlnKHRvdXJPcHRpb25zLCBvcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgZmxvYXRpbmdVSU9wdGlvbnM6IG1lcmdlKFxuICAgICAgdG91ck9wdGlvbnMuZmxvYXRpbmdVSU9wdGlvbnMgfHwge30sXG4gICAgICBvcHRpb25zLmZsb2F0aW5nVUlPcHRpb25zIHx8IHt9XG4gICAgKVxuICB9O1xufVxuXG4vKipcbiAqIENsZWFudXAgZnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlIHN0ZXAgaXMgY2xvc2VkL2Rlc3Ryb3llZC5cbiAqXG4gKiBAcGFyYW0ge1N0ZXB9IHN0ZXBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlc3Ryb3lUb29sdGlwKHN0ZXApIHtcbiAgaWYgKHN0ZXAuY2xlYW51cCkge1xuICAgIHN0ZXAuY2xlYW51cCgpO1xuICB9XG5cbiAgc3RlcC5jbGVhbnVwID0gbnVsbDtcbn1cblxuLyoqXG4gKlxuICogQHJldHVybiB7UHJvbWlzZTwqPn1cbiAqL1xuZnVuY3Rpb24gc2V0UG9zaXRpb24odGFyZ2V0LCBzdGVwLCBmbG9hdGluZ1VJT3B0aW9ucywgc2hvdWxkQ2VudGVyKSB7XG4gIHJldHVybiAoXG4gICAgY29tcHV0ZVBvc2l0aW9uKHRhcmdldCwgc3RlcC5lbCwgZmxvYXRpbmdVSU9wdGlvbnMpXG4gICAgICAudGhlbihmbG9hdGluZ1VJcG9zaXRpb24oc3RlcCwgc2hvdWxkQ2VudGVyKSlcbiAgICAgIC8vIFdhaXQgYmVmb3JlIGZvcmNpbmcgZm9jdXMuXG4gICAgICAudGhlbihcbiAgICAgICAgKHN0ZXApID0+XG4gICAgICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcmVzb2x2ZShzdGVwKSwgMzAwKTtcbiAgICAgICAgICB9KVxuICAgICAgKVxuICAgICAgLy8gUmVwbGFjZXMgZm9jdXNBZnRlclJlbmRlciBtb2RpZmllci5cbiAgICAgIC50aGVuKChzdGVwKSA9PiB7XG4gICAgICAgIGlmIChzdGVwICYmIHN0ZXAuZWwpIHtcbiAgICAgICAgICBzdGVwLmVsLmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHN0ZXBcbiAqIEBwYXJhbSBzaG91bGRDZW50ZXJcbiAqIEByZXR1cm4ge2Z1bmN0aW9uKHt4OiAqLCB5OiAqLCBwbGFjZW1lbnQ6ICosIG1pZGRsZXdhcmVEYXRhOiAqfSk6IFByb21pc2U8dW5rbm93bj59XG4gKi9cbmZ1bmN0aW9uIGZsb2F0aW5nVUlwb3NpdGlvbihzdGVwLCBzaG91bGRDZW50ZXIpIHtcbiAgcmV0dXJuICh7IHgsIHksIHBsYWNlbWVudCwgbWlkZGxld2FyZURhdGEgfSkgPT4ge1xuICAgIGlmICghc3RlcC5lbCkge1xuICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZENlbnRlcikge1xuICAgICAgT2JqZWN0LmFzc2lnbihzdGVwLmVsLnN0eWxlLCB7XG4gICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgICBsZWZ0OiAnNTAlJyxcbiAgICAgICAgdG9wOiAnNTAlJyxcbiAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKC01MCUsIC01MCUpJ1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oc3RlcC5lbC5zdHlsZSwge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgbGVmdDogYCR7eH1weGAsXG4gICAgICAgIHRvcDogYCR7eX1weGBcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHN0ZXAuZWwuZGF0YXNldC5wb3BwZXJQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG5cbiAgICBwbGFjZUFycm93KHN0ZXAuZWwsIG1pZGRsZXdhcmVEYXRhKTtcblxuICAgIHJldHVybiBzdGVwO1xuICB9O1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0gZWxcbiAqIEBwYXJhbSBtaWRkbGV3YXJlRGF0YVxuICovXG5mdW5jdGlvbiBwbGFjZUFycm93KGVsLCBtaWRkbGV3YXJlRGF0YSkge1xuICBjb25zdCBhcnJvd0VsID0gZWwucXVlcnlTZWxlY3RvcignLnNoZXBoZXJkLWFycm93Jyk7XG4gIGlmIChhcnJvd0VsICYmIG1pZGRsZXdhcmVEYXRhLmFycm93KSB7XG4gICAgY29uc3QgeyB4OiBhcnJvd1gsIHk6IGFycm93WSB9ID0gbWlkZGxld2FyZURhdGEuYXJyb3c7XG4gICAgT2JqZWN0LmFzc2lnbihhcnJvd0VsLnN0eWxlLCB7XG4gICAgICBsZWZ0OiBhcnJvd1ggIT0gbnVsbCA/IGAke2Fycm93WH1weGAgOiAnJyxcbiAgICAgIHRvcDogYXJyb3dZICE9IG51bGwgPyBgJHthcnJvd1l9cHhgIDogJydcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEdldHMgdGhlIGBGbG9hdGluZyBVSWAgb3B0aW9ucyBmcm9tIGEgc2V0IG9mIGJhc2UgYGF0dGFjaFRvYCBvcHRpb25zXG4gKiBAcGFyYW0gYXR0YWNoVG9PcHRpb25zXG4gKiBAcGFyYW0ge1N0ZXB9IHN0ZXAgVGhlIHN0ZXAgaW5zdGFuY2VcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGbG9hdGluZ1VJT3B0aW9ucyhhdHRhY2hUb09wdGlvbnMsIHN0ZXApIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICBzdHJhdGVneTogJ2Fic29sdXRlJyxcbiAgICBtaWRkbGV3YXJlOiBbXVxuICB9O1xuXG4gIGNvbnN0IGFycm93RWwgPSBhZGRBcnJvdyhzdGVwKTtcblxuICBjb25zdCBzaG91bGRDZW50ZXIgPSBzaG91bGRDZW50ZXJTdGVwKGF0dGFjaFRvT3B0aW9ucyk7XG5cbiAgaWYgKCFzaG91bGRDZW50ZXIpIHtcbiAgICBvcHRpb25zLm1pZGRsZXdhcmUucHVzaChcbiAgICAgIGZsaXAoKSxcbiAgICAgIC8vIFJlcGxpY2F0ZSBQb3BwZXJKUyBkZWZhdWx0IGJlaGF2aW9yLlxuICAgICAgc2hpZnQoe1xuICAgICAgICBsaW1pdGVyOiBsaW1pdFNoaWZ0KCksXG4gICAgICAgIGNyb3NzQXhpczogdHJ1ZVxuICAgICAgfSlcbiAgICApO1xuXG4gICAgaWYgKGFycm93RWwpIHtcbiAgICAgIG9wdGlvbnMubWlkZGxld2FyZS5wdXNoKGFycm93KHsgZWxlbWVudDogYXJyb3dFbCB9KSk7XG4gICAgfVxuXG4gICAgb3B0aW9ucy5wbGFjZW1lbnQgPSBhdHRhY2hUb09wdGlvbnMub247XG4gIH1cblxuICByZXR1cm4gbWVyZ2Uoc3RlcC5vcHRpb25zLmZsb2F0aW5nVUlPcHRpb25zIHx8IHt9LCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N0ZXB9IHN0ZXBcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fGZhbHNlfG51bGx9XG4gKi9cbmZ1bmN0aW9uIGFkZEFycm93KHN0ZXApIHtcbiAgaWYgKHN0ZXAub3B0aW9ucy5hcnJvdyAmJiBzdGVwLmVsKSB7XG4gICAgcmV0dXJuIHN0ZXAuZWwucXVlcnlTZWxlY3RvcignLnNoZXBoZXJkLWFycm93Jyk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG4iLCJmdW5jdGlvbiBub29wKCkgeyB9XG5jb25zdCBpZGVudGl0eSA9IHggPT4geDtcbmZ1bmN0aW9uIGFzc2lnbih0YXIsIHNyYykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBmb3IgKGNvbnN0IGsgaW4gc3JjKVxuICAgICAgICB0YXJba10gPSBzcmNba107XG4gICAgcmV0dXJuIHRhcjtcbn1cbi8vIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vdGhlbi9pcy1wcm9taXNlL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBNSVQgTGljZW5zZSBodHRwczovL2dpdGh1Yi5jb20vdGhlbi9pcy1wcm9taXNlL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbmZ1bmN0aW9uIGlzX3Byb21pc2UodmFsdWUpIHtcbiAgICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nO1xufVxuZnVuY3Rpb24gYWRkX2xvY2F0aW9uKGVsZW1lbnQsIGZpbGUsIGxpbmUsIGNvbHVtbiwgY2hhcikge1xuICAgIGVsZW1lbnQuX19zdmVsdGVfbWV0YSA9IHtcbiAgICAgICAgbG9jOiB7IGZpbGUsIGxpbmUsIGNvbHVtbiwgY2hhciB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJ1bihmbikge1xuICAgIHJldHVybiBmbigpO1xufVxuZnVuY3Rpb24gYmxhbmtfb2JqZWN0KCkge1xuICAgIHJldHVybiBPYmplY3QuY3JlYXRlKG51bGwpO1xufVxuZnVuY3Rpb24gcnVuX2FsbChmbnMpIHtcbiAgICBmbnMuZm9yRWFjaChydW4pO1xufVxuZnVuY3Rpb24gaXNfZnVuY3Rpb24odGhpbmcpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaW5nID09PSAnZnVuY3Rpb24nO1xufVxuZnVuY3Rpb24gc2FmZV9ub3RfZXF1YWwoYSwgYikge1xuICAgIHJldHVybiBhICE9IGEgPyBiID09IGIgOiBhICE9PSBiIHx8ICgoYSAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcpIHx8IHR5cGVvZiBhID09PSAnZnVuY3Rpb24nKTtcbn1cbmxldCBzcmNfdXJsX2VxdWFsX2FuY2hvcjtcbmZ1bmN0aW9uIHNyY191cmxfZXF1YWwoZWxlbWVudF9zcmMsIHVybCkge1xuICAgIGlmICghc3JjX3VybF9lcXVhbF9hbmNob3IpIHtcbiAgICAgICAgc3JjX3VybF9lcXVhbF9hbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgfVxuICAgIHNyY191cmxfZXF1YWxfYW5jaG9yLmhyZWYgPSB1cmw7XG4gICAgcmV0dXJuIGVsZW1lbnRfc3JjID09PSBzcmNfdXJsX2VxdWFsX2FuY2hvci5ocmVmO1xufVxuZnVuY3Rpb24gbm90X2VxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gYSAhPSBhID8gYiA9PSBiIDogYSAhPT0gYjtcbn1cbmZ1bmN0aW9uIGlzX2VtcHR5KG9iaikge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlX3N0b3JlKHN0b3JlLCBuYW1lKSB7XG4gICAgaWYgKHN0b3JlICE9IG51bGwgJiYgdHlwZW9mIHN0b3JlLnN1YnNjcmliZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCcke25hbWV9JyBpcyBub3QgYSBzdG9yZSB3aXRoIGEgJ3N1YnNjcmliZScgbWV0aG9kYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gc3Vic2NyaWJlKHN0b3JlLCAuLi5jYWxsYmFja3MpIHtcbiAgICBpZiAoc3RvcmUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbm9vcDtcbiAgICB9XG4gICAgY29uc3QgdW5zdWIgPSBzdG9yZS5zdWJzY3JpYmUoLi4uY2FsbGJhY2tzKTtcbiAgICByZXR1cm4gdW5zdWIudW5zdWJzY3JpYmUgPyAoKSA9PiB1bnN1Yi51bnN1YnNjcmliZSgpIDogdW5zdWI7XG59XG5mdW5jdGlvbiBnZXRfc3RvcmVfdmFsdWUoc3RvcmUpIHtcbiAgICBsZXQgdmFsdWU7XG4gICAgc3Vic2NyaWJlKHN0b3JlLCBfID0+IHZhbHVlID0gXykoKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBjb21wb25lbnRfc3Vic2NyaWJlKGNvbXBvbmVudCwgc3RvcmUsIGNhbGxiYWNrKSB7XG4gICAgY29tcG9uZW50LiQkLm9uX2Rlc3Ryb3kucHVzaChzdWJzY3JpYmUoc3RvcmUsIGNhbGxiYWNrKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVfc2xvdChkZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGZuKSB7XG4gICAgaWYgKGRlZmluaXRpb24pIHtcbiAgICAgICAgY29uc3Qgc2xvdF9jdHggPSBnZXRfc2xvdF9jb250ZXh0KGRlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZm4pO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvblswXShzbG90X2N0eCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0X3Nsb3RfY29udGV4dChkZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGZuKSB7XG4gICAgcmV0dXJuIGRlZmluaXRpb25bMV0gJiYgZm5cbiAgICAgICAgPyBhc3NpZ24oJCRzY29wZS5jdHguc2xpY2UoKSwgZGVmaW5pdGlvblsxXShmbihjdHgpKSlcbiAgICAgICAgOiAkJHNjb3BlLmN0eDtcbn1cbmZ1bmN0aW9uIGdldF9zbG90X2NoYW5nZXMoZGVmaW5pdGlvbiwgJCRzY29wZSwgZGlydHksIGZuKSB7XG4gICAgaWYgKGRlZmluaXRpb25bMl0gJiYgZm4pIHtcbiAgICAgICAgY29uc3QgbGV0cyA9IGRlZmluaXRpb25bMl0oZm4oZGlydHkpKTtcbiAgICAgICAgaWYgKCQkc2NvcGUuZGlydHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGxldHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBsZXRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VkID0gW107XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBNYXRoLm1heCgkJHNjb3BlLmRpcnR5Lmxlbmd0aCwgbGV0cy5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIG1lcmdlZFtpXSA9ICQkc2NvcGUuZGlydHlbaV0gfCBsZXRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJCRzY29wZS5kaXJ0eSB8IGxldHM7XG4gICAgfVxuICAgIHJldHVybiAkJHNjb3BlLmRpcnR5O1xufVxuZnVuY3Rpb24gdXBkYXRlX3Nsb3RfYmFzZShzbG90LCBzbG90X2RlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgc2xvdF9jaGFuZ2VzLCBnZXRfc2xvdF9jb250ZXh0X2ZuKSB7XG4gICAgaWYgKHNsb3RfY2hhbmdlcykge1xuICAgICAgICBjb25zdCBzbG90X2NvbnRleHQgPSBnZXRfc2xvdF9jb250ZXh0KHNsb3RfZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBnZXRfc2xvdF9jb250ZXh0X2ZuKTtcbiAgICAgICAgc2xvdC5wKHNsb3RfY29udGV4dCwgc2xvdF9jaGFuZ2VzKTtcbiAgICB9XG59XG5mdW5jdGlvbiB1cGRhdGVfc2xvdChzbG90LCBzbG90X2RlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZGlydHksIGdldF9zbG90X2NoYW5nZXNfZm4sIGdldF9zbG90X2NvbnRleHRfZm4pIHtcbiAgICBjb25zdCBzbG90X2NoYW5nZXMgPSBnZXRfc2xvdF9jaGFuZ2VzKHNsb3RfZGVmaW5pdGlvbiwgJCRzY29wZSwgZGlydHksIGdldF9zbG90X2NoYW5nZXNfZm4pO1xuICAgIHVwZGF0ZV9zbG90X2Jhc2Uoc2xvdCwgc2xvdF9kZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIHNsb3RfY2hhbmdlcywgZ2V0X3Nsb3RfY29udGV4dF9mbik7XG59XG5mdW5jdGlvbiBnZXRfYWxsX2RpcnR5X2Zyb21fc2NvcGUoJCRzY29wZSkge1xuICAgIGlmICgkJHNjb3BlLmN0eC5sZW5ndGggPiAzMikge1xuICAgICAgICBjb25zdCBkaXJ0eSA9IFtdO1xuICAgICAgICBjb25zdCBsZW5ndGggPSAkJHNjb3BlLmN0eC5sZW5ndGggLyAzMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZGlydHlbaV0gPSAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlydHk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbmZ1bmN0aW9uIGV4Y2x1ZGVfaW50ZXJuYWxfcHJvcHMocHJvcHMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGsgaW4gcHJvcHMpXG4gICAgICAgIGlmIChrWzBdICE9PSAnJCcpXG4gICAgICAgICAgICByZXN1bHRba10gPSBwcm9wc1trXTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY29tcHV0ZV9yZXN0X3Byb3BzKHByb3BzLCBrZXlzKSB7XG4gICAgY29uc3QgcmVzdCA9IHt9O1xuICAgIGtleXMgPSBuZXcgU2V0KGtleXMpO1xuICAgIGZvciAoY29uc3QgayBpbiBwcm9wcylcbiAgICAgICAgaWYgKCFrZXlzLmhhcyhrKSAmJiBrWzBdICE9PSAnJCcpXG4gICAgICAgICAgICByZXN0W2tdID0gcHJvcHNba107XG4gICAgcmV0dXJuIHJlc3Q7XG59XG5mdW5jdGlvbiBjb21wdXRlX3Nsb3RzKHNsb3RzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2xvdHMpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gb25jZShmbikge1xuICAgIGxldCByYW4gPSBmYWxzZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKHJhbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmFuID0gdHJ1ZTtcbiAgICAgICAgZm4uY2FsbCh0aGlzLCAuLi5hcmdzKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbnVsbF90b19lbXB0eSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHNldF9zdG9yZV92YWx1ZShzdG9yZSwgcmV0LCB2YWx1ZSkge1xuICAgIHN0b3JlLnNldCh2YWx1ZSk7XG4gICAgcmV0dXJuIHJldDtcbn1cbmNvbnN0IGhhc19wcm9wID0gKG9iaiwgcHJvcCkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG5mdW5jdGlvbiBhY3Rpb25fZGVzdHJveWVyKGFjdGlvbl9yZXN1bHQpIHtcbiAgICByZXR1cm4gYWN0aW9uX3Jlc3VsdCAmJiBpc19mdW5jdGlvbihhY3Rpb25fcmVzdWx0LmRlc3Ryb3kpID8gYWN0aW9uX3Jlc3VsdC5kZXN0cm95IDogbm9vcDtcbn1cbmZ1bmN0aW9uIHNwbGl0X2Nzc191bml0KHZhbHVlKSB7XG4gICAgY29uc3Qgc3BsaXQgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLm1hdGNoKC9eXFxzKigtP1tcXGQuXSspKFteXFxzXSopXFxzKiQvKTtcbiAgICByZXR1cm4gc3BsaXQgPyBbcGFyc2VGbG9hdChzcGxpdFsxXSksIHNwbGl0WzJdIHx8ICdweCddIDogW3ZhbHVlLCAncHgnXTtcbn1cbmNvbnN0IGNvbnRlbnRlZGl0YWJsZV90cnV0aHlfdmFsdWVzID0gWycnLCB0cnVlLCAxLCAndHJ1ZScsICdjb250ZW50ZWRpdGFibGUnXTtcblxuY29uc3QgaXNfY2xpZW50ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG5sZXQgbm93ID0gaXNfY2xpZW50XG4gICAgPyAoKSA9PiB3aW5kb3cucGVyZm9ybWFuY2Uubm93KClcbiAgICA6ICgpID0+IERhdGUubm93KCk7XG5sZXQgcmFmID0gaXNfY2xpZW50ID8gY2IgPT4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNiKSA6IG5vb3A7XG4vLyB1c2VkIGludGVybmFsbHkgZm9yIHRlc3RpbmdcbmZ1bmN0aW9uIHNldF9ub3coZm4pIHtcbiAgICBub3cgPSBmbjtcbn1cbmZ1bmN0aW9uIHNldF9yYWYoZm4pIHtcbiAgICByYWYgPSBmbjtcbn1cblxuY29uc3QgdGFza3MgPSBuZXcgU2V0KCk7XG5mdW5jdGlvbiBydW5fdGFza3Mobm93KSB7XG4gICAgdGFza3MuZm9yRWFjaCh0YXNrID0+IHtcbiAgICAgICAgaWYgKCF0YXNrLmMobm93KSkge1xuICAgICAgICAgICAgdGFza3MuZGVsZXRlKHRhc2spO1xuICAgICAgICAgICAgdGFzay5mKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAodGFza3Muc2l6ZSAhPT0gMClcbiAgICAgICAgcmFmKHJ1bl90YXNrcyk7XG59XG4vKipcbiAqIEZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkhXG4gKi9cbmZ1bmN0aW9uIGNsZWFyX2xvb3BzKCkge1xuICAgIHRhc2tzLmNsZWFyKCk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdGFzayB0aGF0IHJ1bnMgb24gZWFjaCByYWYgZnJhbWVcbiAqIHVudGlsIGl0IHJldHVybnMgYSBmYWxzeSB2YWx1ZSBvciBpcyBhYm9ydGVkXG4gKi9cbmZ1bmN0aW9uIGxvb3AoY2FsbGJhY2spIHtcbiAgICBsZXQgdGFzaztcbiAgICBpZiAodGFza3Muc2l6ZSA9PT0gMClcbiAgICAgICAgcmFmKHJ1bl90YXNrcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvbWlzZTogbmV3IFByb21pc2UoZnVsZmlsbCA9PiB7XG4gICAgICAgICAgICB0YXNrcy5hZGQodGFzayA9IHsgYzogY2FsbGJhY2ssIGY6IGZ1bGZpbGwgfSk7XG4gICAgICAgIH0pLFxuICAgICAgICBhYm9ydCgpIHtcbiAgICAgICAgICAgIHRhc2tzLmRlbGV0ZSh0YXNrKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmNvbnN0IGdsb2JhbHMgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IHdpbmRvd1xuICAgIDogdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gZ2xvYmFsVGhpc1xuICAgICAgICA6IGdsb2JhbCk7XG5cbi8qKlxuICogUmVzaXplIG9ic2VydmVyIHNpbmdsZXRvbi5cbiAqIE9uZSBsaXN0ZW5lciBwZXIgZWxlbWVudCBvbmx5IVxuICogaHR0cHM6Ly9ncm91cHMuZ29vZ2xlLmNvbS9hL2Nocm9taXVtLm9yZy9nL2JsaW5rLWRldi9jL3o2aWVuT05VYjVBL20vRjUtVmNVWnRCQUFKXG4gKi9cbmNsYXNzIFJlc2l6ZU9ic2VydmVyU2luZ2xldG9uIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9ICdXZWFrTWFwJyBpbiBnbG9iYWxzID8gbmV3IFdlYWtNYXAoKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgb2JzZXJ2ZShlbGVtZW50LCBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnMuc2V0KGVsZW1lbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5fZ2V0T2JzZXJ2ZXIoKS5vYnNlcnZlKGVsZW1lbnQsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMuZGVsZXRlKGVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5fb2JzZXJ2ZXIudW5vYnNlcnZlKGVsZW1lbnQpOyAvLyB0aGlzIGxpbmUgY2FuIHByb2JhYmx5IGJlIHJlbW92ZWRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2dldE9ic2VydmVyKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLl9vYnNlcnZlcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKHRoaXMuX29ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKChlbnRyaWVzKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICBSZXNpemVPYnNlcnZlclNpbmdsZXRvbi5lbnRyaWVzLnNldChlbnRyeS50YXJnZXQsIGVudHJ5KTtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLl9saXN0ZW5lcnMuZ2V0KGVudHJ5LnRhcmdldCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYShlbnRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICB9XG59XG4vLyBOZWVkcyB0byBiZSB3cml0dGVuIGxpa2UgdGhpcyB0byBwYXNzIHRoZSB0cmVlLXNoYWtlLXRlc3RcblJlc2l6ZU9ic2VydmVyU2luZ2xldG9uLmVudHJpZXMgPSAnV2Vha01hcCcgaW4gZ2xvYmFscyA/IG5ldyBXZWFrTWFwKCkgOiB1bmRlZmluZWQ7XG5cbi8vIFRyYWNrIHdoaWNoIG5vZGVzIGFyZSBjbGFpbWVkIGR1cmluZyBoeWRyYXRpb24uIFVuY2xhaW1lZCBub2RlcyBjYW4gdGhlbiBiZSByZW1vdmVkIGZyb20gdGhlIERPTVxuLy8gYXQgdGhlIGVuZCBvZiBoeWRyYXRpb24gd2l0aG91dCB0b3VjaGluZyB0aGUgcmVtYWluaW5nIG5vZGVzLlxubGV0IGlzX2h5ZHJhdGluZyA9IGZhbHNlO1xuZnVuY3Rpb24gc3RhcnRfaHlkcmF0aW5nKCkge1xuICAgIGlzX2h5ZHJhdGluZyA9IHRydWU7XG59XG5mdW5jdGlvbiBlbmRfaHlkcmF0aW5nKCkge1xuICAgIGlzX2h5ZHJhdGluZyA9IGZhbHNlO1xufVxuZnVuY3Rpb24gdXBwZXJfYm91bmQobG93LCBoaWdoLCBrZXksIHZhbHVlKSB7XG4gICAgLy8gUmV0dXJuIGZpcnN0IGluZGV4IG9mIHZhbHVlIGxhcmdlciB0aGFuIGlucHV0IHZhbHVlIGluIHRoZSByYW5nZSBbbG93LCBoaWdoKVxuICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgIGNvbnN0IG1pZCA9IGxvdyArICgoaGlnaCAtIGxvdykgPj4gMSk7XG4gICAgICAgIGlmIChrZXkobWlkKSA8PSB2YWx1ZSkge1xuICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxvdztcbn1cbmZ1bmN0aW9uIGluaXRfaHlkcmF0ZSh0YXJnZXQpIHtcbiAgICBpZiAodGFyZ2V0Lmh5ZHJhdGVfaW5pdClcbiAgICAgICAgcmV0dXJuO1xuICAgIHRhcmdldC5oeWRyYXRlX2luaXQgPSB0cnVlO1xuICAgIC8vIFdlIGtub3cgdGhhdCBhbGwgY2hpbGRyZW4gaGF2ZSBjbGFpbV9vcmRlciB2YWx1ZXMgc2luY2UgdGhlIHVuY2xhaW1lZCBoYXZlIGJlZW4gZGV0YWNoZWQgaWYgdGFyZ2V0IGlzIG5vdCA8aGVhZD5cbiAgICBsZXQgY2hpbGRyZW4gPSB0YXJnZXQuY2hpbGROb2RlcztcbiAgICAvLyBJZiB0YXJnZXQgaXMgPGhlYWQ+LCB0aGVyZSBtYXkgYmUgY2hpbGRyZW4gd2l0aG91dCBjbGFpbV9vcmRlclxuICAgIGlmICh0YXJnZXQubm9kZU5hbWUgPT09ICdIRUFEJykge1xuICAgICAgICBjb25zdCBteUNoaWxkcmVuID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChub2RlLmNsYWltX29yZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBteUNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4gPSBteUNoaWxkcmVuO1xuICAgIH1cbiAgICAvKlxuICAgICogUmVvcmRlciBjbGFpbWVkIGNoaWxkcmVuIG9wdGltYWxseS5cbiAgICAqIFdlIGNhbiByZW9yZGVyIGNsYWltZWQgY2hpbGRyZW4gb3B0aW1hbGx5IGJ5IGZpbmRpbmcgdGhlIGxvbmdlc3Qgc3Vic2VxdWVuY2Ugb2ZcbiAgICAqIG5vZGVzIHRoYXQgYXJlIGFscmVhZHkgY2xhaW1lZCBpbiBvcmRlciBhbmQgb25seSBtb3ZpbmcgdGhlIHJlc3QuIFRoZSBsb25nZXN0XG4gICAgKiBzdWJzZXF1ZW5jZSBvZiBub2RlcyB0aGF0IGFyZSBjbGFpbWVkIGluIG9yZGVyIGNhbiBiZSBmb3VuZCBieVxuICAgICogY29tcHV0aW5nIHRoZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2YgLmNsYWltX29yZGVyIHZhbHVlcy5cbiAgICAqXG4gICAgKiBUaGlzIGFsZ29yaXRobSBpcyBvcHRpbWFsIGluIGdlbmVyYXRpbmcgdGhlIGxlYXN0IGFtb3VudCBvZiByZW9yZGVyIG9wZXJhdGlvbnNcbiAgICAqIHBvc3NpYmxlLlxuICAgICpcbiAgICAqIFByb29mOlxuICAgICogV2Uga25vdyB0aGF0LCBnaXZlbiBhIHNldCBvZiByZW9yZGVyaW5nIG9wZXJhdGlvbnMsIHRoZSBub2RlcyB0aGF0IGRvIG5vdCBtb3ZlXG4gICAgKiBhbHdheXMgZm9ybSBhbiBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlLCBzaW5jZSB0aGV5IGRvIG5vdCBtb3ZlIGFtb25nIGVhY2ggb3RoZXJcbiAgICAqIG1lYW5pbmcgdGhhdCB0aGV5IG11c3QgYmUgYWxyZWFkeSBvcmRlcmVkIGFtb25nIGVhY2ggb3RoZXIuIFRodXMsIHRoZSBtYXhpbWFsXG4gICAgKiBzZXQgb2Ygbm9kZXMgdGhhdCBkbyBub3QgbW92ZSBmb3JtIGEgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlLlxuICAgICovXG4gICAgLy8gQ29tcHV0ZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2VcbiAgICAvLyBtOiBzdWJzZXF1ZW5jZSBsZW5ndGggaiA9PiBpbmRleCBrIG9mIHNtYWxsZXN0IHZhbHVlIHRoYXQgZW5kcyBhbiBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlIG9mIGxlbmd0aCBqXG4gICAgY29uc3QgbSA9IG5ldyBJbnQzMkFycmF5KGNoaWxkcmVuLmxlbmd0aCArIDEpO1xuICAgIC8vIFByZWRlY2Vzc29yIGluZGljZXMgKyAxXG4gICAgY29uc3QgcCA9IG5ldyBJbnQzMkFycmF5KGNoaWxkcmVuLmxlbmd0aCk7XG4gICAgbVswXSA9IC0xO1xuICAgIGxldCBsb25nZXN0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSBjaGlsZHJlbltpXS5jbGFpbV9vcmRlcjtcbiAgICAgICAgLy8gRmluZCB0aGUgbGFyZ2VzdCBzdWJzZXF1ZW5jZSBsZW5ndGggc3VjaCB0aGF0IGl0IGVuZHMgaW4gYSB2YWx1ZSBsZXNzIHRoYW4gb3VyIGN1cnJlbnQgdmFsdWVcbiAgICAgICAgLy8gdXBwZXJfYm91bmQgcmV0dXJucyBmaXJzdCBncmVhdGVyIHZhbHVlLCBzbyB3ZSBzdWJ0cmFjdCBvbmVcbiAgICAgICAgLy8gd2l0aCBmYXN0IHBhdGggZm9yIHdoZW4gd2UgYXJlIG9uIHRoZSBjdXJyZW50IGxvbmdlc3Qgc3Vic2VxdWVuY2VcbiAgICAgICAgY29uc3Qgc2VxTGVuID0gKChsb25nZXN0ID4gMCAmJiBjaGlsZHJlblttW2xvbmdlc3RdXS5jbGFpbV9vcmRlciA8PSBjdXJyZW50KSA/IGxvbmdlc3QgKyAxIDogdXBwZXJfYm91bmQoMSwgbG9uZ2VzdCwgaWR4ID0+IGNoaWxkcmVuW21baWR4XV0uY2xhaW1fb3JkZXIsIGN1cnJlbnQpKSAtIDE7XG4gICAgICAgIHBbaV0gPSBtW3NlcUxlbl0gKyAxO1xuICAgICAgICBjb25zdCBuZXdMZW4gPSBzZXFMZW4gKyAxO1xuICAgICAgICAvLyBXZSBjYW4gZ3VhcmFudGVlIHRoYXQgY3VycmVudCBpcyB0aGUgc21hbGxlc3QgdmFsdWUuIE90aGVyd2lzZSwgd2Ugd291bGQgaGF2ZSBnZW5lcmF0ZWQgYSBsb25nZXIgc2VxdWVuY2UuXG4gICAgICAgIG1bbmV3TGVuXSA9IGk7XG4gICAgICAgIGxvbmdlc3QgPSBNYXRoLm1heChuZXdMZW4sIGxvbmdlc3QpO1xuICAgIH1cbiAgICAvLyBUaGUgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlIG9mIG5vZGVzIChpbml0aWFsbHkgcmV2ZXJzZWQpXG4gICAgY29uc3QgbGlzID0gW107XG4gICAgLy8gVGhlIHJlc3Qgb2YgdGhlIG5vZGVzLCBub2RlcyB0aGF0IHdpbGwgYmUgbW92ZWRcbiAgICBjb25zdCB0b01vdmUgPSBbXTtcbiAgICBsZXQgbGFzdCA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgZm9yIChsZXQgY3VyID0gbVtsb25nZXN0XSArIDE7IGN1ciAhPSAwOyBjdXIgPSBwW2N1ciAtIDFdKSB7XG4gICAgICAgIGxpcy5wdXNoKGNoaWxkcmVuW2N1ciAtIDFdKTtcbiAgICAgICAgZm9yICg7IGxhc3QgPj0gY3VyOyBsYXN0LS0pIHtcbiAgICAgICAgICAgIHRvTW92ZS5wdXNoKGNoaWxkcmVuW2xhc3RdKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0LS07XG4gICAgfVxuICAgIGZvciAoOyBsYXN0ID49IDA7IGxhc3QtLSkge1xuICAgICAgICB0b01vdmUucHVzaChjaGlsZHJlbltsYXN0XSk7XG4gICAgfVxuICAgIGxpcy5yZXZlcnNlKCk7XG4gICAgLy8gV2Ugc29ydCB0aGUgbm9kZXMgYmVpbmcgbW92ZWQgdG8gZ3VhcmFudGVlIHRoYXQgdGhlaXIgaW5zZXJ0aW9uIG9yZGVyIG1hdGNoZXMgdGhlIGNsYWltIG9yZGVyXG4gICAgdG9Nb3ZlLnNvcnQoKGEsIGIpID0+IGEuY2xhaW1fb3JkZXIgLSBiLmNsYWltX29yZGVyKTtcbiAgICAvLyBGaW5hbGx5LCB3ZSBtb3ZlIHRoZSBub2Rlc1xuICAgIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IHRvTW92ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB3aGlsZSAoaiA8IGxpcy5sZW5ndGggJiYgdG9Nb3ZlW2ldLmNsYWltX29yZGVyID49IGxpc1tqXS5jbGFpbV9vcmRlcikge1xuICAgICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IGogPCBsaXMubGVuZ3RoID8gbGlzW2pdIDogbnVsbDtcbiAgICAgICAgdGFyZ2V0Lmluc2VydEJlZm9yZSh0b01vdmVbaV0sIGFuY2hvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwZW5kKHRhcmdldCwgbm9kZSkge1xuICAgIHRhcmdldC5hcHBlbmRDaGlsZChub2RlKTtcbn1cbmZ1bmN0aW9uIGFwcGVuZF9zdHlsZXModGFyZ2V0LCBzdHlsZV9zaGVldF9pZCwgc3R5bGVzKSB7XG4gICAgY29uc3QgYXBwZW5kX3N0eWxlc190byA9IGdldF9yb290X2Zvcl9zdHlsZSh0YXJnZXQpO1xuICAgIGlmICghYXBwZW5kX3N0eWxlc190by5nZXRFbGVtZW50QnlJZChzdHlsZV9zaGVldF9pZCkpIHtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBlbGVtZW50KCdzdHlsZScpO1xuICAgICAgICBzdHlsZS5pZCA9IHN0eWxlX3NoZWV0X2lkO1xuICAgICAgICBzdHlsZS50ZXh0Q29udGVudCA9IHN0eWxlcztcbiAgICAgICAgYXBwZW5kX3N0eWxlc2hlZXQoYXBwZW5kX3N0eWxlc190bywgc3R5bGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldF9yb290X2Zvcl9zdHlsZShub2RlKSB7XG4gICAgaWYgKCFub2RlKVxuICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgY29uc3Qgcm9vdCA9IG5vZGUuZ2V0Um9vdE5vZGUgPyBub2RlLmdldFJvb3ROb2RlKCkgOiBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgaWYgKHJvb3QgJiYgcm9vdC5ob3N0KSB7XG4gICAgICAgIHJldHVybiByb290O1xuICAgIH1cbiAgICByZXR1cm4gbm9kZS5vd25lckRvY3VtZW50O1xufVxuZnVuY3Rpb24gYXBwZW5kX2VtcHR5X3N0eWxlc2hlZXQobm9kZSkge1xuICAgIGNvbnN0IHN0eWxlX2VsZW1lbnQgPSBlbGVtZW50KCdzdHlsZScpO1xuICAgIGFwcGVuZF9zdHlsZXNoZWV0KGdldF9yb290X2Zvcl9zdHlsZShub2RlKSwgc3R5bGVfZWxlbWVudCk7XG4gICAgcmV0dXJuIHN0eWxlX2VsZW1lbnQuc2hlZXQ7XG59XG5mdW5jdGlvbiBhcHBlbmRfc3R5bGVzaGVldChub2RlLCBzdHlsZSkge1xuICAgIGFwcGVuZChub2RlLmhlYWQgfHwgbm9kZSwgc3R5bGUpO1xuICAgIHJldHVybiBzdHlsZS5zaGVldDtcbn1cbmZ1bmN0aW9uIGFwcGVuZF9oeWRyYXRpb24odGFyZ2V0LCBub2RlKSB7XG4gICAgaWYgKGlzX2h5ZHJhdGluZykge1xuICAgICAgICBpbml0X2h5ZHJhdGUodGFyZ2V0KTtcbiAgICAgICAgaWYgKCh0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCA9PT0gdW5kZWZpbmVkKSB8fCAoKHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkICE9PSBudWxsKSAmJiAodGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQucGFyZW50Tm9kZSAhPT0gdGFyZ2V0KSkpIHtcbiAgICAgICAgICAgIHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkID0gdGFyZ2V0LmZpcnN0Q2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2tpcCBub2RlcyBvZiB1bmRlZmluZWQgb3JkZXJpbmdcbiAgICAgICAgd2hpbGUgKCh0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCAhPT0gbnVsbCkgJiYgKHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkLmNsYWltX29yZGVyID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCA9IHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlICE9PSB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCkge1xuICAgICAgICAgICAgLy8gV2Ugb25seSBpbnNlcnQgaWYgdGhlIG9yZGVyaW5nIG9mIHRoaXMgbm9kZSBzaG91bGQgYmUgbW9kaWZpZWQgb3IgdGhlIHBhcmVudCBub2RlIGlzIG5vdCB0YXJnZXRcbiAgICAgICAgICAgIGlmIChub2RlLmNsYWltX29yZGVyICE9PSB1bmRlZmluZWQgfHwgbm9kZS5wYXJlbnROb2RlICE9PSB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKG5vZGUsIHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChub2RlLnBhcmVudE5vZGUgIT09IHRhcmdldCB8fCBub2RlLm5leHRTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgIHRhcmdldC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpbnNlcnQodGFyZ2V0LCBub2RlLCBhbmNob3IpIHtcbiAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKG5vZGUsIGFuY2hvciB8fCBudWxsKTtcbn1cbmZ1bmN0aW9uIGluc2VydF9oeWRyYXRpb24odGFyZ2V0LCBub2RlLCBhbmNob3IpIHtcbiAgICBpZiAoaXNfaHlkcmF0aW5nICYmICFhbmNob3IpIHtcbiAgICAgICAgYXBwZW5kX2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlLnBhcmVudE5vZGUgIT09IHRhcmdldCB8fCBub2RlLm5leHRTaWJsaW5nICE9IGFuY2hvcikge1xuICAgICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKG5vZGUsIGFuY2hvciB8fCBudWxsKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZXRhY2gobm9kZSkge1xuICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRlc3Ryb3lfZWFjaChpdGVyYXRpb25zLCBkZXRhY2hpbmcpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJhdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGl0ZXJhdGlvbnNbaV0pXG4gICAgICAgICAgICBpdGVyYXRpb25zW2ldLmQoZGV0YWNoaW5nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBlbGVtZW50KG5hbWUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKTtcbn1cbmZ1bmN0aW9uIGVsZW1lbnRfaXMobmFtZSwgaXMpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lLCB7IGlzIH0pO1xufVxuZnVuY3Rpb24gb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllcyhvYmosIGV4Y2x1ZGUpIHtcbiAgICBjb25zdCB0YXJnZXQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGsgaW4gb2JqKSB7XG4gICAgICAgIGlmIChoYXNfcHJvcChvYmosIGspXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAmJiBleGNsdWRlLmluZGV4T2YoaykgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICB0YXJnZXRba10gPSBvYmpba107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIHN2Z19lbGVtZW50KG5hbWUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIG5hbWUpO1xufVxuZnVuY3Rpb24gdGV4dChkYXRhKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGRhdGEpO1xufVxuZnVuY3Rpb24gc3BhY2UoKSB7XG4gICAgcmV0dXJuIHRleHQoJyAnKTtcbn1cbmZ1bmN0aW9uIGVtcHR5KCkge1xuICAgIHJldHVybiB0ZXh0KCcnKTtcbn1cbmZ1bmN0aW9uIGNvbW1lbnQoY29udGVudCkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KGNvbnRlbnQpO1xufVxuZnVuY3Rpb24gbGlzdGVuKG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICByZXR1cm4gKCkgPT4gbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHByZXZlbnRfZGVmYXVsdChmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHN0b3BfcHJvcGFnYXRpb24oZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gc3RvcF9pbW1lZGlhdGVfcHJvcGFnYXRpb24oZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gc2VsZihmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzKVxuICAgICAgICAgICAgZm4uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRydXN0ZWQoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKGV2ZW50LmlzVHJ1c3RlZClcbiAgICAgICAgICAgIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH07XG59XG5mdW5jdGlvbiBhdHRyKG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICBlbHNlIGlmIChub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpICE9PSB2YWx1ZSlcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCB2YWx1ZSk7XG59XG4vKipcbiAqIExpc3Qgb2YgYXR0cmlidXRlcyB0aGF0IHNob3VsZCBhbHdheXMgYmUgc2V0IHRocm91Z2ggdGhlIGF0dHIgbWV0aG9kLFxuICogYmVjYXVzZSB1cGRhdGluZyB0aGVtIHRocm91Z2ggdGhlIHByb3BlcnR5IHNldHRlciBkb2Vzbid0IHdvcmsgcmVsaWFibHkuXG4gKiBJbiB0aGUgZXhhbXBsZSBvZiBgd2lkdGhgL2BoZWlnaHRgLCB0aGUgcHJvYmxlbSBpcyB0aGF0IHRoZSBzZXR0ZXIgb25seVxuICogYWNjZXB0cyBudW1lcmljIHZhbHVlcywgYnV0IHRoZSBhdHRyaWJ1dGUgY2FuIGFsc28gYmUgc2V0IHRvIGEgc3RyaW5nIGxpa2UgYDUwJWAuXG4gKiBJZiB0aGlzIGxpc3QgYmVjb21lcyB0b28gYmlnLCByZXRoaW5rIHRoaXMgYXBwcm9hY2guXG4gKi9cbmNvbnN0IGFsd2F5c19zZXRfdGhyb3VnaF9zZXRfYXR0cmlidXRlID0gWyd3aWR0aCcsICdoZWlnaHQnXTtcbmZ1bmN0aW9uIHNldF9hdHRyaWJ1dGVzKG5vZGUsIGF0dHJpYnV0ZXMpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhub2RlLl9fcHJvdG9fXyk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgICBpZiAoYXR0cmlidXRlc1trZXldID09IG51bGwpIHtcbiAgICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnc3R5bGUnKSB7XG4gICAgICAgICAgICBub2RlLnN0eWxlLmNzc1RleHQgPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnX192YWx1ZScpIHtcbiAgICAgICAgICAgIG5vZGUudmFsdWUgPSBub2RlW2tleV0gPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVzY3JpcHRvcnNba2V5XSAmJiBkZXNjcmlwdG9yc1trZXldLnNldCAmJiBhbHdheXNfc2V0X3Rocm91Z2hfc2V0X2F0dHJpYnV0ZS5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICAgICAgICBub2RlW2tleV0gPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhdHRyKG5vZGUsIGtleSwgYXR0cmlidXRlc1trZXldKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHNldF9zdmdfYXR0cmlidXRlcyhub2RlLCBhdHRyaWJ1dGVzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgICBhdHRyKG5vZGUsIGtleSwgYXR0cmlidXRlc1trZXldKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRfY3VzdG9tX2VsZW1lbnRfZGF0YV9tYXAobm9kZSwgZGF0YV9tYXApIHtcbiAgICBPYmplY3Qua2V5cyhkYXRhX21hcCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIHNldF9jdXN0b21fZWxlbWVudF9kYXRhKG5vZGUsIGtleSwgZGF0YV9tYXBba2V5XSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzZXRfY3VzdG9tX2VsZW1lbnRfZGF0YShub2RlLCBwcm9wLCB2YWx1ZSkge1xuICAgIGlmIChwcm9wIGluIG5vZGUpIHtcbiAgICAgICAgbm9kZVtwcm9wXSA9IHR5cGVvZiBub2RlW3Byb3BdID09PSAnYm9vbGVhbicgJiYgdmFsdWUgPT09ICcnID8gdHJ1ZSA6IHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXR0cihub2RlLCBwcm9wLCB2YWx1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0X2R5bmFtaWNfZWxlbWVudF9kYXRhKHRhZykge1xuICAgIHJldHVybiAoLy0vLnRlc3QodGFnKSkgPyBzZXRfY3VzdG9tX2VsZW1lbnRfZGF0YV9tYXAgOiBzZXRfYXR0cmlidXRlcztcbn1cbmZ1bmN0aW9uIHhsaW5rX2F0dHIobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCBhdHRyaWJ1dGUsIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGdldF9iaW5kaW5nX2dyb3VwX3ZhbHVlKGdyb3VwLCBfX3ZhbHVlLCBjaGVja2VkKSB7XG4gICAgY29uc3QgdmFsdWUgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoZ3JvdXBbaV0uY2hlY2tlZClcbiAgICAgICAgICAgIHZhbHVlLmFkZChncm91cFtpXS5fX3ZhbHVlKTtcbiAgICB9XG4gICAgaWYgKCFjaGVja2VkKSB7XG4gICAgICAgIHZhbHVlLmRlbGV0ZShfX3ZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LmZyb20odmFsdWUpO1xufVxuZnVuY3Rpb24gaW5pdF9iaW5kaW5nX2dyb3VwKGdyb3VwKSB7XG4gICAgbGV0IF9pbnB1dHM7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyogcHVzaCAqLyBwKC4uLmlucHV0cykge1xuICAgICAgICAgICAgX2lucHV0cyA9IGlucHV0cztcbiAgICAgICAgICAgIF9pbnB1dHMuZm9yRWFjaChpbnB1dCA9PiBncm91cC5wdXNoKGlucHV0KSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qIHJlbW92ZSAqLyByKCkge1xuICAgICAgICAgICAgX2lucHV0cy5mb3JFYWNoKGlucHV0ID0+IGdyb3VwLnNwbGljZShncm91cC5pbmRleE9mKGlucHV0KSwgMSkpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGluaXRfYmluZGluZ19ncm91cF9keW5hbWljKGdyb3VwLCBpbmRleGVzKSB7XG4gICAgbGV0IF9ncm91cCA9IGdldF9iaW5kaW5nX2dyb3VwKGdyb3VwKTtcbiAgICBsZXQgX2lucHV0cztcbiAgICBmdW5jdGlvbiBnZXRfYmluZGluZ19ncm91cChncm91cCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGdyb3VwID0gZ3JvdXBbaW5kZXhlc1tpXV0gPSBncm91cFtpbmRleGVzW2ldXSB8fCBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2goKSB7XG4gICAgICAgIF9pbnB1dHMuZm9yRWFjaChpbnB1dCA9PiBfZ3JvdXAucHVzaChpbnB1dCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgIF9pbnB1dHMuZm9yRWFjaChpbnB1dCA9PiBfZ3JvdXAuc3BsaWNlKF9ncm91cC5pbmRleE9mKGlucHV0KSwgMSkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICAvKiB1cGRhdGUgKi8gdShuZXdfaW5kZXhlcykge1xuICAgICAgICAgICAgaW5kZXhlcyA9IG5ld19pbmRleGVzO1xuICAgICAgICAgICAgY29uc3QgbmV3X2dyb3VwID0gZ2V0X2JpbmRpbmdfZ3JvdXAoZ3JvdXApO1xuICAgICAgICAgICAgaWYgKG5ld19ncm91cCAhPT0gX2dyb3VwKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgX2dyb3VwID0gbmV3X2dyb3VwO1xuICAgICAgICAgICAgICAgIHB1c2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyogcHVzaCAqLyBwKC4uLmlucHV0cykge1xuICAgICAgICAgICAgX2lucHV0cyA9IGlucHV0cztcbiAgICAgICAgICAgIHB1c2goKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyogcmVtb3ZlICovIHI6IHJlbW92ZVxuICAgIH07XG59XG5mdW5jdGlvbiB0b19udW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09ICcnID8gbnVsbCA6ICt2YWx1ZTtcbn1cbmZ1bmN0aW9uIHRpbWVfcmFuZ2VzX3RvX2FycmF5KHJhbmdlcykge1xuICAgIGNvbnN0IGFycmF5ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgYXJyYXkucHVzaCh7IHN0YXJ0OiByYW5nZXMuc3RhcnQoaSksIGVuZDogcmFuZ2VzLmVuZChpKSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuZnVuY3Rpb24gY2hpbGRyZW4oZWxlbWVudCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGVsZW1lbnQuY2hpbGROb2Rlcyk7XG59XG5mdW5jdGlvbiBpbml0X2NsYWltX2luZm8obm9kZXMpIHtcbiAgICBpZiAobm9kZXMuY2xhaW1faW5mbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5vZGVzLmNsYWltX2luZm8gPSB7IGxhc3RfaW5kZXg6IDAsIHRvdGFsX2NsYWltZWQ6IDAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbGFpbV9ub2RlKG5vZGVzLCBwcmVkaWNhdGUsIHByb2Nlc3NOb2RlLCBjcmVhdGVOb2RlLCBkb250VXBkYXRlTGFzdEluZGV4ID0gZmFsc2UpIHtcbiAgICAvLyBUcnkgdG8gZmluZCBub2RlcyBpbiBhbiBvcmRlciBzdWNoIHRoYXQgd2UgbGVuZ3RoZW4gdGhlIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZVxuICAgIGluaXRfY2xhaW1faW5mbyhub2Rlcyk7XG4gICAgY29uc3QgcmVzdWx0Tm9kZSA9ICgoKSA9PiB7XG4gICAgICAgIC8vIFdlIGZpcnN0IHRyeSB0byBmaW5kIGFuIGVsZW1lbnQgYWZ0ZXIgdGhlIHByZXZpb3VzIG9uZVxuICAgICAgICBmb3IgKGxldCBpID0gbm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4OyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXBsYWNlbWVudCA9IHByb2Nlc3NOb2RlKG5vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzW2ldID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZG9udFVwZGF0ZUxhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UsIHdlIHRyeSB0byBmaW5kIG9uZSBiZWZvcmVcbiAgICAgICAgLy8gV2UgaXRlcmF0ZSBpbiByZXZlcnNlIHNvIHRoYXQgd2UgZG9uJ3QgZ28gdG9vIGZhciBiYWNrXG4gICAgICAgIGZvciAobGV0IGkgPSBub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShub2RlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VtZW50ID0gcHJvY2Vzc05vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNbaV0gPSByZXBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFkb250VXBkYXRlTGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2luY2Ugd2Ugc3BsaWNlZCBiZWZvcmUgdGhlIGxhc3RfaW5kZXgsIHdlIGRlY3JlYXNlIGl0XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBjYW4ndCBmaW5kIGFueSBtYXRjaGluZyBub2RlLCB3ZSBjcmVhdGUgYSBuZXcgb25lXG4gICAgICAgIHJldHVybiBjcmVhdGVOb2RlKCk7XG4gICAgfSkoKTtcbiAgICByZXN1bHROb2RlLmNsYWltX29yZGVyID0gbm9kZXMuY2xhaW1faW5mby50b3RhbF9jbGFpbWVkO1xuICAgIG5vZGVzLmNsYWltX2luZm8udG90YWxfY2xhaW1lZCArPSAxO1xuICAgIHJldHVybiByZXN1bHROb2RlO1xufVxuZnVuY3Rpb24gY2xhaW1fZWxlbWVudF9iYXNlKG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzLCBjcmVhdGVfZWxlbWVudCkge1xuICAgIHJldHVybiBjbGFpbV9ub2RlKG5vZGVzLCAobm9kZSkgPT4gbm9kZS5ub2RlTmFtZSA9PT0gbmFtZSwgKG5vZGUpID0+IHtcbiAgICAgICAgY29uc3QgcmVtb3ZlID0gW107XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbm9kZS5hdHRyaWJ1dGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGUgPSBub2RlLmF0dHJpYnV0ZXNbal07XG4gICAgICAgICAgICBpZiAoIWF0dHJpYnV0ZXNbYXR0cmlidXRlLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlLnB1c2goYXR0cmlidXRlLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlbW92ZS5mb3JFYWNoKHYgPT4gbm9kZS5yZW1vdmVBdHRyaWJ1dGUodikpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sICgpID0+IGNyZWF0ZV9lbGVtZW50KG5hbWUpKTtcbn1cbmZ1bmN0aW9uIGNsYWltX2VsZW1lbnQobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gY2xhaW1fZWxlbWVudF9iYXNlKG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzLCBlbGVtZW50KTtcbn1cbmZ1bmN0aW9uIGNsYWltX3N2Z19lbGVtZW50KG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIGNsYWltX2VsZW1lbnRfYmFzZShub2RlcywgbmFtZSwgYXR0cmlidXRlcywgc3ZnX2VsZW1lbnQpO1xufVxuZnVuY3Rpb24gY2xhaW1fdGV4dChub2RlcywgZGF0YSkge1xuICAgIHJldHVybiBjbGFpbV9ub2RlKG5vZGVzLCAobm9kZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gMywgKG5vZGUpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YVN0ciA9ICcnICsgZGF0YTtcbiAgICAgICAgaWYgKG5vZGUuZGF0YS5zdGFydHNXaXRoKGRhdGFTdHIpKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5kYXRhLmxlbmd0aCAhPT0gZGF0YVN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5zcGxpdFRleHQoZGF0YVN0ci5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5kYXRhID0gZGF0YVN0cjtcbiAgICAgICAgfVxuICAgIH0sICgpID0+IHRleHQoZGF0YSksIHRydWUgLy8gVGV4dCBub2RlcyBzaG91bGQgbm90IHVwZGF0ZSBsYXN0IGluZGV4IHNpbmNlIGl0IGlzIGxpa2VseSBub3Qgd29ydGggaXQgdG8gZWxpbWluYXRlIGFuIGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2YgYWN0dWFsIGVsZW1lbnRzXG4gICAgKTtcbn1cbmZ1bmN0aW9uIGNsYWltX3NwYWNlKG5vZGVzKSB7XG4gICAgcmV0dXJuIGNsYWltX3RleHQobm9kZXMsICcgJyk7XG59XG5mdW5jdGlvbiBjbGFpbV9jb21tZW50KG5vZGVzLCBkYXRhKSB7XG4gICAgcmV0dXJuIGNsYWltX25vZGUobm9kZXMsIChub2RlKSA9PiBub2RlLm5vZGVUeXBlID09PSA4LCAobm9kZSkgPT4ge1xuICAgICAgICBub2RlLmRhdGEgPSAnJyArIGRhdGE7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSwgKCkgPT4gY29tbWVudChkYXRhKSwgdHJ1ZSk7XG59XG5mdW5jdGlvbiBmaW5kX2NvbW1lbnQobm9kZXMsIHRleHQsIHN0YXJ0KSB7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgbm9kZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCAvKiBjb21tZW50IG5vZGUgKi8gJiYgbm9kZS50ZXh0Q29udGVudC50cmltKCkgPT09IHRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2Rlcy5sZW5ndGg7XG59XG5mdW5jdGlvbiBjbGFpbV9odG1sX3RhZyhub2RlcywgaXNfc3ZnKSB7XG4gICAgLy8gZmluZCBodG1sIG9wZW5pbmcgdGFnXG4gICAgY29uc3Qgc3RhcnRfaW5kZXggPSBmaW5kX2NvbW1lbnQobm9kZXMsICdIVE1MX1RBR19TVEFSVCcsIDApO1xuICAgIGNvbnN0IGVuZF9pbmRleCA9IGZpbmRfY29tbWVudChub2RlcywgJ0hUTUxfVEFHX0VORCcsIHN0YXJ0X2luZGV4KTtcbiAgICBpZiAoc3RhcnRfaW5kZXggPT09IGVuZF9pbmRleCkge1xuICAgICAgICByZXR1cm4gbmV3IEh0bWxUYWdIeWRyYXRpb24odW5kZWZpbmVkLCBpc19zdmcpO1xuICAgIH1cbiAgICBpbml0X2NsYWltX2luZm8obm9kZXMpO1xuICAgIGNvbnN0IGh0bWxfdGFnX25vZGVzID0gbm9kZXMuc3BsaWNlKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDEpO1xuICAgIGRldGFjaChodG1sX3RhZ19ub2Rlc1swXSk7XG4gICAgZGV0YWNoKGh0bWxfdGFnX25vZGVzW2h0bWxfdGFnX25vZGVzLmxlbmd0aCAtIDFdKTtcbiAgICBjb25zdCBjbGFpbWVkX25vZGVzID0gaHRtbF90YWdfbm9kZXMuc2xpY2UoMSwgaHRtbF90YWdfbm9kZXMubGVuZ3RoIC0gMSk7XG4gICAgZm9yIChjb25zdCBuIG9mIGNsYWltZWRfbm9kZXMpIHtcbiAgICAgICAgbi5jbGFpbV9vcmRlciA9IG5vZGVzLmNsYWltX2luZm8udG90YWxfY2xhaW1lZDtcbiAgICAgICAgbm9kZXMuY2xhaW1faW5mby50b3RhbF9jbGFpbWVkICs9IDE7XG4gICAgfVxuICAgIHJldHVybiBuZXcgSHRtbFRhZ0h5ZHJhdGlvbihjbGFpbWVkX25vZGVzLCBpc19zdmcpO1xufVxuZnVuY3Rpb24gc2V0X2RhdGEodGV4dCwgZGF0YSkge1xuICAgIGRhdGEgPSAnJyArIGRhdGE7XG4gICAgaWYgKHRleHQuZGF0YSA9PT0gZGF0YSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHRleHQuZGF0YSA9IGRhdGE7XG59XG5mdW5jdGlvbiBzZXRfZGF0YV9jb250ZW50ZWRpdGFibGUodGV4dCwgZGF0YSkge1xuICAgIGRhdGEgPSAnJyArIGRhdGE7XG4gICAgaWYgKHRleHQud2hvbGVUZXh0ID09PSBkYXRhKVxuICAgICAgICByZXR1cm47XG4gICAgdGV4dC5kYXRhID0gZGF0YTtcbn1cbmZ1bmN0aW9uIHNldF9kYXRhX21heWJlX2NvbnRlbnRlZGl0YWJsZSh0ZXh0LCBkYXRhLCBhdHRyX3ZhbHVlKSB7XG4gICAgaWYgKH5jb250ZW50ZWRpdGFibGVfdHJ1dGh5X3ZhbHVlcy5pbmRleE9mKGF0dHJfdmFsdWUpKSB7XG4gICAgICAgIHNldF9kYXRhX2NvbnRlbnRlZGl0YWJsZSh0ZXh0LCBkYXRhKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNldF9kYXRhKHRleHQsIGRhdGEpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldF9pbnB1dF92YWx1ZShpbnB1dCwgdmFsdWUpIHtcbiAgICBpbnB1dC52YWx1ZSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xufVxuZnVuY3Rpb24gc2V0X2lucHV0X3R5cGUoaW5wdXQsIHR5cGUpIHtcbiAgICB0cnkge1xuICAgICAgICBpbnB1dC50eXBlID0gdHlwZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldF9zdHlsZShub2RlLCBrZXksIHZhbHVlLCBpbXBvcnRhbnQpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBub2RlLnN0eWxlLnJlbW92ZVByb3BlcnR5KGtleSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBub2RlLnN0eWxlLnNldFByb3BlcnR5KGtleSwgdmFsdWUsIGltcG9ydGFudCA/ICdpbXBvcnRhbnQnIDogJycpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNlbGVjdF9vcHRpb24oc2VsZWN0LCB2YWx1ZSwgbW91bnRpbmcpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdC5vcHRpb25zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IHNlbGVjdC5vcHRpb25zW2ldO1xuICAgICAgICBpZiAob3B0aW9uLl9fdmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghbW91bnRpbmcgfHwgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZWxlY3Quc2VsZWN0ZWRJbmRleCA9IC0xOyAvLyBubyBvcHRpb24gc2hvdWxkIGJlIHNlbGVjdGVkXG4gICAgfVxufVxuZnVuY3Rpb24gc2VsZWN0X29wdGlvbnMoc2VsZWN0LCB2YWx1ZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZWN0Lm9wdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gc2VsZWN0Lm9wdGlvbnNbaV07XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IH52YWx1ZS5pbmRleE9mKG9wdGlvbi5fX3ZhbHVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZWxlY3RfdmFsdWUoc2VsZWN0KSB7XG4gICAgY29uc3Qgc2VsZWN0ZWRfb3B0aW9uID0gc2VsZWN0LnF1ZXJ5U2VsZWN0b3IoJzpjaGVja2VkJyk7XG4gICAgcmV0dXJuIHNlbGVjdGVkX29wdGlvbiAmJiBzZWxlY3RlZF9vcHRpb24uX192YWx1ZTtcbn1cbmZ1bmN0aW9uIHNlbGVjdF9tdWx0aXBsZV92YWx1ZShzZWxlY3QpIHtcbiAgICByZXR1cm4gW10ubWFwLmNhbGwoc2VsZWN0LnF1ZXJ5U2VsZWN0b3JBbGwoJzpjaGVja2VkJyksIG9wdGlvbiA9PiBvcHRpb24uX192YWx1ZSk7XG59XG4vLyB1bmZvcnR1bmF0ZWx5IHRoaXMgY2FuJ3QgYmUgYSBjb25zdGFudCBhcyB0aGF0IHdvdWxkbid0IGJlIHRyZWUtc2hha2VhYmxlXG4vLyBzbyB3ZSBjYWNoZSB0aGUgcmVzdWx0IGluc3RlYWRcbmxldCBjcm9zc29yaWdpbjtcbmZ1bmN0aW9uIGlzX2Nyb3Nzb3JpZ2luKCkge1xuICAgIGlmIChjcm9zc29yaWdpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNyb3Nzb3JpZ2luID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHZvaWQgd2luZG93LnBhcmVudC5kb2N1bWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNyb3Nzb3JpZ2luID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3Jvc3NvcmlnaW47XG59XG5mdW5jdGlvbiBhZGRfaWZyYW1lX3Jlc2l6ZV9saXN0ZW5lcihub2RlLCBmbikge1xuICAgIGNvbnN0IGNvbXB1dGVkX3N0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICBpZiAoY29tcHV0ZWRfc3R5bGUucG9zaXRpb24gPT09ICdzdGF0aWMnKSB7XG4gICAgICAgIG5vZGUuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgIH1cbiAgICBjb25zdCBpZnJhbWUgPSBlbGVtZW50KCdpZnJhbWUnKTtcbiAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5OiBibG9jazsgcG9zaXRpb246IGFic29sdXRlOyB0b3A6IDA7IGxlZnQ6IDA7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7ICcgK1xuICAgICAgICAnb3ZlcmZsb3c6IGhpZGRlbjsgYm9yZGVyOiAwOyBvcGFjaXR5OiAwOyBwb2ludGVyLWV2ZW50czogbm9uZTsgei1pbmRleDogLTE7Jyk7XG4gICAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgIGlmcmFtZS50YWJJbmRleCA9IC0xO1xuICAgIGNvbnN0IGNyb3Nzb3JpZ2luID0gaXNfY3Jvc3NvcmlnaW4oKTtcbiAgICBsZXQgdW5zdWJzY3JpYmU7XG4gICAgaWYgKGNyb3Nzb3JpZ2luKSB7XG4gICAgICAgIGlmcmFtZS5zcmMgPSBcImRhdGE6dGV4dC9odG1sLDxzY3JpcHQ+b25yZXNpemU9ZnVuY3Rpb24oKXtwYXJlbnQucG9zdE1lc3NhZ2UoMCwnKicpfTwvc2NyaXB0PlwiO1xuICAgICAgICB1bnN1YnNjcmliZSA9IGxpc3Rlbih3aW5kb3csICdtZXNzYWdlJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBpZnJhbWUuY29udGVudFdpbmRvdylcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmcmFtZS5zcmMgPSAnYWJvdXQ6YmxhbmsnO1xuICAgICAgICBpZnJhbWUub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUgPSBsaXN0ZW4oaWZyYW1lLmNvbnRlbnRXaW5kb3csICdyZXNpemUnLCBmbik7XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgYW4gaW5pdGlhbCByZXNpemUgZXZlbnQgaXMgZmlyZWQgX2FmdGVyXyB0aGUgaWZyYW1lIGlzIGxvYWRlZCAod2hpY2ggaXMgYXN5bmNocm9ub3VzKVxuICAgICAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdmVsdGVqcy9zdmVsdGUvaXNzdWVzLzQyMzNcbiAgICAgICAgICAgIGZuKCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGFwcGVuZChub2RlLCBpZnJhbWUpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChjcm9zc29yaWdpbikge1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh1bnN1YnNjcmliZSAmJiBpZnJhbWUuY29udGVudFdpbmRvdykge1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBkZXRhY2goaWZyYW1lKTtcbiAgICB9O1xufVxuY29uc3QgcmVzaXplX29ic2VydmVyX2NvbnRlbnRfYm94ID0gLyogQF9fUFVSRV9fICovIG5ldyBSZXNpemVPYnNlcnZlclNpbmdsZXRvbih7IGJveDogJ2NvbnRlbnQtYm94JyB9KTtcbmNvbnN0IHJlc2l6ZV9vYnNlcnZlcl9ib3JkZXJfYm94ID0gLyogQF9fUFVSRV9fICovIG5ldyBSZXNpemVPYnNlcnZlclNpbmdsZXRvbih7IGJveDogJ2JvcmRlci1ib3gnIH0pO1xuY29uc3QgcmVzaXplX29ic2VydmVyX2RldmljZV9waXhlbF9jb250ZW50X2JveCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgUmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24oeyBib3g6ICdkZXZpY2UtcGl4ZWwtY29udGVudC1ib3gnIH0pO1xuZnVuY3Rpb24gdG9nZ2xlX2NsYXNzKGVsZW1lbnQsIG5hbWUsIHRvZ2dsZSkge1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0W3RvZ2dsZSA/ICdhZGQnIDogJ3JlbW92ZSddKG5hbWUpO1xufVxuZnVuY3Rpb24gY3VzdG9tX2V2ZW50KHR5cGUsIGRldGFpbCwgeyBidWJibGVzID0gZmFsc2UsIGNhbmNlbGFibGUgPSBmYWxzZSB9ID0ge30pIHtcbiAgICBjb25zdCBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgZS5pbml0Q3VzdG9tRXZlbnQodHlwZSwgYnViYmxlcywgY2FuY2VsYWJsZSwgZGV0YWlsKTtcbiAgICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5X3NlbGVjdG9yX2FsbChzZWxlY3RvciwgcGFyZW50ID0gZG9jdW1lbnQuYm9keSkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHBhcmVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSk7XG59XG5mdW5jdGlvbiBoZWFkX3NlbGVjdG9yKG5vZGVJZCwgaGVhZCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBzdGFydGVkID0gMDtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgaGVhZC5jaGlsZE5vZGVzKSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSA4IC8qIGNvbW1lbnQgbm9kZSAqLykge1xuICAgICAgICAgICAgY29uc3QgY29tbWVudCA9IG5vZGUudGV4dENvbnRlbnQudHJpbSgpO1xuICAgICAgICAgICAgaWYgKGNvbW1lbnQgPT09IGBIRUFEXyR7bm9kZUlkfV9FTkRgKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRlZCAtPSAxO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29tbWVudCA9PT0gYEhFQURfJHtub2RlSWR9X1NUQVJUYCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ZWQgKz0gMTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGFydGVkID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNsYXNzIEh0bWxUYWcge1xuICAgIGNvbnN0cnVjdG9yKGlzX3N2ZyA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuaXNfc3ZnID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNfc3ZnID0gaXNfc3ZnO1xuICAgICAgICB0aGlzLmUgPSB0aGlzLm4gPSBudWxsO1xuICAgIH1cbiAgICBjKGh0bWwpIHtcbiAgICAgICAgdGhpcy5oKGh0bWwpO1xuICAgIH1cbiAgICBtKGh0bWwsIHRhcmdldCwgYW5jaG9yID0gbnVsbCkge1xuICAgICAgICBpZiAoIXRoaXMuZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNfc3ZnKVxuICAgICAgICAgICAgICAgIHRoaXMuZSA9IHN2Z19lbGVtZW50KHRhcmdldC5ub2RlTmFtZSk7XG4gICAgICAgICAgICAvKiogIzczNjQgIHRhcmdldCBmb3IgPHRlbXBsYXRlPiBtYXkgYmUgcHJvdmlkZWQgYXMgI2RvY3VtZW50LWZyYWdtZW50KDExKSAqL1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuZSA9IGVsZW1lbnQoKHRhcmdldC5ub2RlVHlwZSA9PT0gMTEgPyAnVEVNUExBVEUnIDogdGFyZ2V0Lm5vZGVOYW1lKSk7XG4gICAgICAgICAgICB0aGlzLnQgPSB0YXJnZXQudGFnTmFtZSAhPT0gJ1RFTVBMQVRFJyA/IHRhcmdldCA6IHRhcmdldC5jb250ZW50O1xuICAgICAgICAgICAgdGhpcy5jKGh0bWwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaShhbmNob3IpO1xuICAgIH1cbiAgICBoKGh0bWwpIHtcbiAgICAgICAgdGhpcy5lLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgIHRoaXMubiA9IEFycmF5LmZyb20odGhpcy5lLm5vZGVOYW1lID09PSAnVEVNUExBVEUnID8gdGhpcy5lLmNvbnRlbnQuY2hpbGROb2RlcyA6IHRoaXMuZS5jaGlsZE5vZGVzKTtcbiAgICB9XG4gICAgaShhbmNob3IpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGluc2VydCh0aGlzLnQsIHRoaXMubltpXSwgYW5jaG9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwKGh0bWwpIHtcbiAgICAgICAgdGhpcy5kKCk7XG4gICAgICAgIHRoaXMuaChodG1sKTtcbiAgICAgICAgdGhpcy5pKHRoaXMuYSk7XG4gICAgfVxuICAgIGQoKSB7XG4gICAgICAgIHRoaXMubi5mb3JFYWNoKGRldGFjaCk7XG4gICAgfVxufVxuY2xhc3MgSHRtbFRhZ0h5ZHJhdGlvbiBleHRlbmRzIEh0bWxUYWcge1xuICAgIGNvbnN0cnVjdG9yKGNsYWltZWRfbm9kZXMsIGlzX3N2ZyA9IGZhbHNlKSB7XG4gICAgICAgIHN1cGVyKGlzX3N2Zyk7XG4gICAgICAgIHRoaXMuZSA9IHRoaXMubiA9IG51bGw7XG4gICAgICAgIHRoaXMubCA9IGNsYWltZWRfbm9kZXM7XG4gICAgfVxuICAgIGMoaHRtbCkge1xuICAgICAgICBpZiAodGhpcy5sKSB7XG4gICAgICAgICAgICB0aGlzLm4gPSB0aGlzLmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdXBlci5jKGh0bWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGkoYW5jaG9yKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpbnNlcnRfaHlkcmF0aW9uKHRoaXMudCwgdGhpcy5uW2ldLCBhbmNob3IpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYXR0cmlidXRlX3RvX29iamVjdChhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgb2YgYXR0cmlidXRlcykge1xuICAgICAgICByZXN1bHRbYXR0cmlidXRlLm5hbWVdID0gYXR0cmlidXRlLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0X2N1c3RvbV9lbGVtZW50c19zbG90cyhlbGVtZW50KSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZWxlbWVudC5jaGlsZE5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgcmVzdWx0W25vZGUuc2xvdCB8fCAnZGVmYXVsdCddID0gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY29uc3RydWN0X3N2ZWx0ZV9jb21wb25lbnQoY29tcG9uZW50LCBwcm9wcykge1xuICAgIHJldHVybiBuZXcgY29tcG9uZW50KHByb3BzKTtcbn1cblxuLy8gd2UgbmVlZCB0byBzdG9yZSB0aGUgaW5mb3JtYXRpb24gZm9yIG11bHRpcGxlIGRvY3VtZW50cyBiZWNhdXNlIGEgU3ZlbHRlIGFwcGxpY2F0aW9uIGNvdWxkIGFsc28gY29udGFpbiBpZnJhbWVzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vc3ZlbHRlanMvc3ZlbHRlL2lzc3Vlcy8zNjI0XG5jb25zdCBtYW5hZ2VkX3N0eWxlcyA9IG5ldyBNYXAoKTtcbmxldCBhY3RpdmUgPSAwO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Rhcmtza3lhcHAvc3RyaW5nLWhhc2gvYmxvYi9tYXN0ZXIvaW5kZXguanNcbmZ1bmN0aW9uIGhhc2goc3RyKSB7XG4gICAgbGV0IGhhc2ggPSA1MzgxO1xuICAgIGxldCBpID0gc3RyLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKVxuICAgICAgICBoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgXiBzdHIuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gaGFzaCA+Pj4gMDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZV9zdHlsZV9pbmZvcm1hdGlvbihkb2MsIG5vZGUpIHtcbiAgICBjb25zdCBpbmZvID0geyBzdHlsZXNoZWV0OiBhcHBlbmRfZW1wdHlfc3R5bGVzaGVldChub2RlKSwgcnVsZXM6IHt9IH07XG4gICAgbWFuYWdlZF9zdHlsZXMuc2V0KGRvYywgaW5mbyk7XG4gICAgcmV0dXJuIGluZm87XG59XG5mdW5jdGlvbiBjcmVhdGVfcnVsZShub2RlLCBhLCBiLCBkdXJhdGlvbiwgZGVsYXksIGVhc2UsIGZuLCB1aWQgPSAwKSB7XG4gICAgY29uc3Qgc3RlcCA9IDE2LjY2NiAvIGR1cmF0aW9uO1xuICAgIGxldCBrZXlmcmFtZXMgPSAne1xcbic7XG4gICAgZm9yIChsZXQgcCA9IDA7IHAgPD0gMTsgcCArPSBzdGVwKSB7XG4gICAgICAgIGNvbnN0IHQgPSBhICsgKGIgLSBhKSAqIGVhc2UocCk7XG4gICAgICAgIGtleWZyYW1lcyArPSBwICogMTAwICsgYCV7JHtmbih0LCAxIC0gdCl9fVxcbmA7XG4gICAgfVxuICAgIGNvbnN0IHJ1bGUgPSBrZXlmcmFtZXMgKyBgMTAwJSB7JHtmbihiLCAxIC0gYil9fVxcbn1gO1xuICAgIGNvbnN0IG5hbWUgPSBgX19zdmVsdGVfJHtoYXNoKHJ1bGUpfV8ke3VpZH1gO1xuICAgIGNvbnN0IGRvYyA9IGdldF9yb290X2Zvcl9zdHlsZShub2RlKTtcbiAgICBjb25zdCB7IHN0eWxlc2hlZXQsIHJ1bGVzIH0gPSBtYW5hZ2VkX3N0eWxlcy5nZXQoZG9jKSB8fCBjcmVhdGVfc3R5bGVfaW5mb3JtYXRpb24oZG9jLCBub2RlKTtcbiAgICBpZiAoIXJ1bGVzW25hbWVdKSB7XG4gICAgICAgIHJ1bGVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgc3R5bGVzaGVldC5pbnNlcnRSdWxlKGBAa2V5ZnJhbWVzICR7bmFtZX0gJHtydWxlfWAsIHN0eWxlc2hlZXQuY3NzUnVsZXMubGVuZ3RoKTtcbiAgICB9XG4gICAgY29uc3QgYW5pbWF0aW9uID0gbm9kZS5zdHlsZS5hbmltYXRpb24gfHwgJyc7XG4gICAgbm9kZS5zdHlsZS5hbmltYXRpb24gPSBgJHthbmltYXRpb24gPyBgJHthbmltYXRpb259LCBgIDogJyd9JHtuYW1lfSAke2R1cmF0aW9ufW1zIGxpbmVhciAke2RlbGF5fW1zIDEgYm90aGA7XG4gICAgYWN0aXZlICs9IDE7XG4gICAgcmV0dXJuIG5hbWU7XG59XG5mdW5jdGlvbiBkZWxldGVfcnVsZShub2RlLCBuYW1lKSB7XG4gICAgY29uc3QgcHJldmlvdXMgPSAobm9kZS5zdHlsZS5hbmltYXRpb24gfHwgJycpLnNwbGl0KCcsICcpO1xuICAgIGNvbnN0IG5leHQgPSBwcmV2aW91cy5maWx0ZXIobmFtZVxuICAgICAgICA/IGFuaW0gPT4gYW5pbS5pbmRleE9mKG5hbWUpIDwgMCAvLyByZW1vdmUgc3BlY2lmaWMgYW5pbWF0aW9uXG4gICAgICAgIDogYW5pbSA9PiBhbmltLmluZGV4T2YoJ19fc3ZlbHRlJykgPT09IC0xIC8vIHJlbW92ZSBhbGwgU3ZlbHRlIGFuaW1hdGlvbnNcbiAgICApO1xuICAgIGNvbnN0IGRlbGV0ZWQgPSBwcmV2aW91cy5sZW5ndGggLSBuZXh0Lmxlbmd0aDtcbiAgICBpZiAoZGVsZXRlZCkge1xuICAgICAgICBub2RlLnN0eWxlLmFuaW1hdGlvbiA9IG5leHQuam9pbignLCAnKTtcbiAgICAgICAgYWN0aXZlIC09IGRlbGV0ZWQ7XG4gICAgICAgIGlmICghYWN0aXZlKVxuICAgICAgICAgICAgY2xlYXJfcnVsZXMoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbGVhcl9ydWxlcygpIHtcbiAgICByYWYoKCkgPT4ge1xuICAgICAgICBpZiAoYWN0aXZlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBtYW5hZ2VkX3N0eWxlcy5mb3JFYWNoKGluZm8gPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBvd25lck5vZGUgfSA9IGluZm8uc3R5bGVzaGVldDtcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5vIG93bmVyTm9kZSBpZiBpdCBydW5zIG9uIGpzZG9tLlxuICAgICAgICAgICAgaWYgKG93bmVyTm9kZSlcbiAgICAgICAgICAgICAgICBkZXRhY2gob3duZXJOb2RlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG1hbmFnZWRfc3R5bGVzLmNsZWFyKCk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZV9hbmltYXRpb24obm9kZSwgZnJvbSwgZm4sIHBhcmFtcykge1xuICAgIGlmICghZnJvbSlcbiAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgY29uc3QgdG8gPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGlmIChmcm9tLmxlZnQgPT09IHRvLmxlZnQgJiYgZnJvbS5yaWdodCA9PT0gdG8ucmlnaHQgJiYgZnJvbS50b3AgPT09IHRvLnRvcCAmJiBmcm9tLmJvdHRvbSA9PT0gdG8uYm90dG9tKVxuICAgICAgICByZXR1cm4gbm9vcDtcbiAgICBjb25zdCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSAzMDAsIGVhc2luZyA9IGlkZW50aXR5LCBcbiAgICAvLyBAdHMtaWdub3JlIHRvZG86IHNob3VsZCB0aGlzIGJlIHNlcGFyYXRlZCBmcm9tIGRlc3RydWN0dXJpbmc/IE9yIHN0YXJ0L2VuZCBhZGRlZCB0byBwdWJsaWMgYXBpIGFuZCBkb2N1bWVudGF0aW9uP1xuICAgIHN0YXJ0OiBzdGFydF90aW1lID0gbm93KCkgKyBkZWxheSwgXG4gICAgLy8gQHRzLWlnbm9yZSB0b2RvOlxuICAgIGVuZCA9IHN0YXJ0X3RpbWUgKyBkdXJhdGlvbiwgdGljayA9IG5vb3AsIGNzcyB9ID0gZm4obm9kZSwgeyBmcm9tLCB0byB9LCBwYXJhbXMpO1xuICAgIGxldCBydW5uaW5nID0gdHJ1ZTtcbiAgICBsZXQgc3RhcnRlZCA9IGZhbHNlO1xuICAgIGxldCBuYW1lO1xuICAgIGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgICBpZiAoY3NzKSB7XG4gICAgICAgICAgICBuYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgMCwgMSwgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIGNzcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZWxheSkge1xuICAgICAgICAgICAgc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgaWYgKGNzcylcbiAgICAgICAgICAgIGRlbGV0ZV9ydWxlKG5vZGUsIG5hbWUpO1xuICAgICAgICBydW5uaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIGxvb3Aobm93ID0+IHtcbiAgICAgICAgaWYgKCFzdGFydGVkICYmIG5vdyA+PSBzdGFydF90aW1lKSB7XG4gICAgICAgICAgICBzdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRlZCAmJiBub3cgPj0gZW5kKSB7XG4gICAgICAgICAgICB0aWNrKDEsIDApO1xuICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydGVkKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gbm93IC0gc3RhcnRfdGltZTtcbiAgICAgICAgICAgIGNvbnN0IHQgPSAwICsgMSAqIGVhc2luZyhwIC8gZHVyYXRpb24pO1xuICAgICAgICAgICAgdGljayh0LCAxIC0gdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgc3RhcnQoKTtcbiAgICB0aWNrKDAsIDEpO1xuICAgIHJldHVybiBzdG9wO1xufVxuZnVuY3Rpb24gZml4X3Bvc2l0aW9uKG5vZGUpIHtcbiAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgaWYgKHN0eWxlLnBvc2l0aW9uICE9PSAnYWJzb2x1dGUnICYmIHN0eWxlLnBvc2l0aW9uICE9PSAnZml4ZWQnKSB7XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gc3R5bGU7XG4gICAgICAgIGNvbnN0IGEgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBub2RlLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgbm9kZS5zdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICBub2RlLnN0eWxlLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgYWRkX3RyYW5zZm9ybShub2RlLCBhKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRfdHJhbnNmb3JtKG5vZGUsIGEpIHtcbiAgICBjb25zdCBiID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAoYS5sZWZ0ICE9PSBiLmxlZnQgfHwgYS50b3AgIT09IGIudG9wKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gc3R5bGUudHJhbnNmb3JtID09PSAnbm9uZScgPyAnJyA6IHN0eWxlLnRyYW5zZm9ybTtcbiAgICAgICAgbm9kZS5zdHlsZS50cmFuc2Zvcm0gPSBgJHt0cmFuc2Zvcm19IHRyYW5zbGF0ZSgke2EubGVmdCAtIGIubGVmdH1weCwgJHthLnRvcCAtIGIudG9wfXB4KWA7XG4gICAgfVxufVxuXG5sZXQgY3VycmVudF9jb21wb25lbnQ7XG5mdW5jdGlvbiBzZXRfY3VycmVudF9jb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgY3VycmVudF9jb21wb25lbnQgPSBjb21wb25lbnQ7XG59XG5mdW5jdGlvbiBnZXRfY3VycmVudF9jb21wb25lbnQoKSB7XG4gICAgaWYgKCFjdXJyZW50X2NvbXBvbmVudClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiBjYWxsZWQgb3V0c2lkZSBjb21wb25lbnQgaW5pdGlhbGl6YXRpb24nKTtcbiAgICByZXR1cm4gY3VycmVudF9jb21wb25lbnQ7XG59XG4vKipcbiAqIFNjaGVkdWxlcyBhIGNhbGxiYWNrIHRvIHJ1biBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyB1cGRhdGVkIGFmdGVyIGFueSBzdGF0ZSBjaGFuZ2UuXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdGhlIGNhbGxiYWNrIHJ1bnMgd2lsbCBiZSBiZWZvcmUgdGhlIGluaXRpYWwgYG9uTW91bnRgXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3MjcnVuLXRpbWUtc3ZlbHRlLWJlZm9yZXVwZGF0ZVxuICovXG5mdW5jdGlvbiBiZWZvcmVVcGRhdGUoZm4pIHtcbiAgICBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5iZWZvcmVfdXBkYXRlLnB1c2goZm4pO1xufVxuLyoqXG4gKiBUaGUgYG9uTW91bnRgIGZ1bmN0aW9uIHNjaGVkdWxlcyBhIGNhbGxiYWNrIHRvIHJ1biBhcyBzb29uIGFzIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZCB0byB0aGUgRE9NLlxuICogSXQgbXVzdCBiZSBjYWxsZWQgZHVyaW5nIHRoZSBjb21wb25lbnQncyBpbml0aWFsaXNhdGlvbiAoYnV0IGRvZXNuJ3QgbmVlZCB0byBsaXZlICppbnNpZGUqIHRoZSBjb21wb25lbnQ7XG4gKiBpdCBjYW4gYmUgY2FsbGVkIGZyb20gYW4gZXh0ZXJuYWwgbW9kdWxlKS5cbiAqXG4gKiBgb25Nb3VudGAgZG9lcyBub3QgcnVuIGluc2lkZSBhIFtzZXJ2ZXItc2lkZSBjb21wb25lbnRdKC9kb2NzI3J1bi10aW1lLXNlcnZlci1zaWRlLWNvbXBvbmVudC1hcGkpLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzI3J1bi10aW1lLXN2ZWx0ZS1vbm1vdW50XG4gKi9cbmZ1bmN0aW9uIG9uTW91bnQoZm4pIHtcbiAgICBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5vbl9tb3VudC5wdXNoKGZuKTtcbn1cbi8qKlxuICogU2NoZWR1bGVzIGEgY2FsbGJhY2sgdG8gcnVuIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gdXBkYXRlZC5cbiAqXG4gKiBUaGUgZmlyc3QgdGltZSB0aGUgY2FsbGJhY2sgcnVucyB3aWxsIGJlIGFmdGVyIHRoZSBpbml0aWFsIGBvbk1vdW50YFxuICovXG5mdW5jdGlvbiBhZnRlclVwZGF0ZShmbikge1xuICAgIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmFmdGVyX3VwZGF0ZS5wdXNoKGZuKTtcbn1cbi8qKlxuICogU2NoZWR1bGVzIGEgY2FsbGJhY2sgdG8gcnVuIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIHVubW91bnRlZC5cbiAqXG4gKiBPdXQgb2YgYG9uTW91bnRgLCBgYmVmb3JlVXBkYXRlYCwgYGFmdGVyVXBkYXRlYCBhbmQgYG9uRGVzdHJveWAsIHRoaXMgaXMgdGhlXG4gKiBvbmx5IG9uZSB0aGF0IHJ1bnMgaW5zaWRlIGEgc2VydmVyLXNpZGUgY29tcG9uZW50LlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzI3J1bi10aW1lLXN2ZWx0ZS1vbmRlc3Ryb3lcbiAqL1xuZnVuY3Rpb24gb25EZXN0cm95KGZuKSB7XG4gICAgZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQub25fZGVzdHJveS5wdXNoKGZuKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBldmVudCBkaXNwYXRjaGVyIHRoYXQgY2FuIGJlIHVzZWQgdG8gZGlzcGF0Y2ggW2NvbXBvbmVudCBldmVudHNdKC9kb2NzI3RlbXBsYXRlLXN5bnRheC1jb21wb25lbnQtZGlyZWN0aXZlcy1vbi1ldmVudG5hbWUpLlxuICogRXZlbnQgZGlzcGF0Y2hlcnMgYXJlIGZ1bmN0aW9ucyB0aGF0IGNhbiB0YWtlIHR3byBhcmd1bWVudHM6IGBuYW1lYCBhbmQgYGRldGFpbGAuXG4gKlxuICogQ29tcG9uZW50IGV2ZW50cyBjcmVhdGVkIHdpdGggYGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcmAgY3JlYXRlIGFcbiAqIFtDdXN0b21FdmVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0N1c3RvbUV2ZW50KS5cbiAqIFRoZXNlIGV2ZW50cyBkbyBub3QgW2J1YmJsZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9MZWFybi9KYXZhU2NyaXB0L0J1aWxkaW5nX2Jsb2Nrcy9FdmVudHMjRXZlbnRfYnViYmxpbmdfYW5kX2NhcHR1cmUpLlxuICogVGhlIGBkZXRhaWxgIGFyZ3VtZW50IGNvcnJlc3BvbmRzIHRvIHRoZSBbQ3VzdG9tRXZlbnQuZGV0YWlsXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnQvZGV0YWlsKVxuICogcHJvcGVydHkgYW5kIGNhbiBjb250YWluIGFueSB0eXBlIG9mIGRhdGEuXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3MjcnVuLXRpbWUtc3ZlbHRlLWNyZWF0ZWV2ZW50ZGlzcGF0Y2hlclxuICovXG5mdW5jdGlvbiBjcmVhdGVFdmVudERpc3BhdGNoZXIoKSB7XG4gICAgY29uc3QgY29tcG9uZW50ID0gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCk7XG4gICAgcmV0dXJuICh0eXBlLCBkZXRhaWwsIHsgY2FuY2VsYWJsZSA9IGZhbHNlIH0gPSB7fSkgPT4ge1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSBjb21wb25lbnQuJCQuY2FsbGJhY2tzW3R5cGVdO1xuICAgICAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAvLyBUT0RPIGFyZSB0aGVyZSBzaXR1YXRpb25zIHdoZXJlIGV2ZW50cyBjb3VsZCBiZSBkaXNwYXRjaGVkXG4gICAgICAgICAgICAvLyBpbiBhIHNlcnZlciAobm9uLURPTSkgZW52aXJvbm1lbnQ/XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IGN1c3RvbV9ldmVudCh0eXBlLCBkZXRhaWwsIHsgY2FuY2VsYWJsZSB9KTtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5zbGljZSgpLmZvckVhY2goZm4gPT4ge1xuICAgICAgICAgICAgICAgIGZuLmNhbGwoY29tcG9uZW50LCBldmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG4gKiBBc3NvY2lhdGVzIGFuIGFyYml0cmFyeSBgY29udGV4dGAgb2JqZWN0IHdpdGggdGhlIGN1cnJlbnQgY29tcG9uZW50IGFuZCB0aGUgc3BlY2lmaWVkIGBrZXlgXG4gKiBhbmQgcmV0dXJucyB0aGF0IG9iamVjdC4gVGhlIGNvbnRleHQgaXMgdGhlbiBhdmFpbGFibGUgdG8gY2hpbGRyZW4gb2YgdGhlIGNvbXBvbmVudFxuICogKGluY2x1ZGluZyBzbG90dGVkIGNvbnRlbnQpIHdpdGggYGdldENvbnRleHRgLlxuICpcbiAqIExpa2UgbGlmZWN5Y2xlIGZ1bmN0aW9ucywgdGhpcyBtdXN0IGJlIGNhbGxlZCBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzI3J1bi10aW1lLXN2ZWx0ZS1zZXRjb250ZXh0XG4gKi9cbmZ1bmN0aW9uIHNldENvbnRleHQoa2V5LCBjb250ZXh0KSB7XG4gICAgZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dC5zZXQoa2V5LCBjb250ZXh0KTtcbiAgICByZXR1cm4gY29udGV4dDtcbn1cbi8qKlxuICogUmV0cmlldmVzIHRoZSBjb250ZXh0IHRoYXQgYmVsb25ncyB0byB0aGUgY2xvc2VzdCBwYXJlbnQgY29tcG9uZW50IHdpdGggdGhlIHNwZWNpZmllZCBga2V5YC5cbiAqIE11c3QgYmUgY2FsbGVkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24uXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3MjcnVuLXRpbWUtc3ZlbHRlLWdldGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gZ2V0Q29udGV4dChrZXkpIHtcbiAgICByZXR1cm4gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dC5nZXQoa2V5KTtcbn1cbi8qKlxuICogUmV0cmlldmVzIHRoZSB3aG9sZSBjb250ZXh0IG1hcCB0aGF0IGJlbG9uZ3MgdG8gdGhlIGNsb3Nlc3QgcGFyZW50IGNvbXBvbmVudC5cbiAqIE11c3QgYmUgY2FsbGVkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24uIFVzZWZ1bCwgZm9yIGV4YW1wbGUsIGlmIHlvdVxuICogcHJvZ3JhbW1hdGljYWxseSBjcmVhdGUgYSBjb21wb25lbnQgYW5kIHdhbnQgdG8gcGFzcyB0aGUgZXhpc3RpbmcgY29udGV4dCB0byBpdC5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcyNydW4tdGltZS1zdmVsdGUtZ2V0YWxsY29udGV4dHNcbiAqL1xuZnVuY3Rpb24gZ2V0QWxsQ29udGV4dHMoKSB7XG4gICAgcmV0dXJuIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmNvbnRleHQ7XG59XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgZ2l2ZW4gYGtleWAgaGFzIGJlZW4gc2V0IGluIHRoZSBjb250ZXh0IG9mIGEgcGFyZW50IGNvbXBvbmVudC5cbiAqIE11c3QgYmUgY2FsbGVkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24uXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3MjcnVuLXRpbWUtc3ZlbHRlLWhhc2NvbnRleHRcbiAqL1xuZnVuY3Rpb24gaGFzQ29udGV4dChrZXkpIHtcbiAgICByZXR1cm4gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dC5oYXMoa2V5KTtcbn1cbi8vIFRPRE8gZmlndXJlIG91dCBpZiB3ZSBzdGlsbCB3YW50IHRvIHN1cHBvcnRcbi8vIHNob3J0aGFuZCBldmVudHMsIG9yIGlmIHdlIHdhbnQgdG8gaW1wbGVtZW50XG4vLyBhIHJlYWwgYnViYmxpbmcgbWVjaGFuaXNtXG5mdW5jdGlvbiBidWJibGUoY29tcG9uZW50LCBldmVudCkge1xuICAgIGNvbnN0IGNhbGxiYWNrcyA9IGNvbXBvbmVudC4kJC5jYWxsYmFja3NbZXZlbnQudHlwZV07XG4gICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGNhbGxiYWNrcy5zbGljZSgpLmZvckVhY2goZm4gPT4gZm4uY2FsbCh0aGlzLCBldmVudCkpO1xuICAgIH1cbn1cblxuY29uc3QgZGlydHlfY29tcG9uZW50cyA9IFtdO1xuY29uc3QgaW50cm9zID0geyBlbmFibGVkOiBmYWxzZSB9O1xuY29uc3QgYmluZGluZ19jYWxsYmFja3MgPSBbXTtcbmxldCByZW5kZXJfY2FsbGJhY2tzID0gW107XG5jb25zdCBmbHVzaF9jYWxsYmFja3MgPSBbXTtcbmNvbnN0IHJlc29sdmVkX3Byb21pc2UgPSAvKiBAX19QVVJFX18gKi8gUHJvbWlzZS5yZXNvbHZlKCk7XG5sZXQgdXBkYXRlX3NjaGVkdWxlZCA9IGZhbHNlO1xuZnVuY3Rpb24gc2NoZWR1bGVfdXBkYXRlKCkge1xuICAgIGlmICghdXBkYXRlX3NjaGVkdWxlZCkge1xuICAgICAgICB1cGRhdGVfc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgcmVzb2x2ZWRfcHJvbWlzZS50aGVuKGZsdXNoKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0aWNrKCkge1xuICAgIHNjaGVkdWxlX3VwZGF0ZSgpO1xuICAgIHJldHVybiByZXNvbHZlZF9wcm9taXNlO1xufVxuZnVuY3Rpb24gYWRkX3JlbmRlcl9jYWxsYmFjayhmbikge1xuICAgIHJlbmRlcl9jYWxsYmFja3MucHVzaChmbik7XG59XG5mdW5jdGlvbiBhZGRfZmx1c2hfY2FsbGJhY2soZm4pIHtcbiAgICBmbHVzaF9jYWxsYmFja3MucHVzaChmbik7XG59XG4vLyBmbHVzaCgpIGNhbGxzIGNhbGxiYWNrcyBpbiB0aGlzIG9yZGVyOlxuLy8gMS4gQWxsIGJlZm9yZVVwZGF0ZSBjYWxsYmFja3MsIGluIG9yZGVyOiBwYXJlbnRzIGJlZm9yZSBjaGlsZHJlblxuLy8gMi4gQWxsIGJpbmQ6dGhpcyBjYWxsYmFja3MsIGluIHJldmVyc2Ugb3JkZXI6IGNoaWxkcmVuIGJlZm9yZSBwYXJlbnRzLlxuLy8gMy4gQWxsIGFmdGVyVXBkYXRlIGNhbGxiYWNrcywgaW4gb3JkZXI6IHBhcmVudHMgYmVmb3JlIGNoaWxkcmVuLiBFWENFUFRcbi8vICAgIGZvciBhZnRlclVwZGF0ZXMgY2FsbGVkIGR1cmluZyB0aGUgaW5pdGlhbCBvbk1vdW50LCB3aGljaCBhcmUgY2FsbGVkIGluXG4vLyAgICByZXZlcnNlIG9yZGVyOiBjaGlsZHJlbiBiZWZvcmUgcGFyZW50cy5cbi8vIFNpbmNlIGNhbGxiYWNrcyBtaWdodCB1cGRhdGUgY29tcG9uZW50IHZhbHVlcywgd2hpY2ggY291bGQgdHJpZ2dlciBhbm90aGVyXG4vLyBjYWxsIHRvIGZsdXNoKCksIHRoZSBmb2xsb3dpbmcgc3RlcHMgZ3VhcmQgYWdhaW5zdCB0aGlzOlxuLy8gMS4gRHVyaW5nIGJlZm9yZVVwZGF0ZSwgYW55IHVwZGF0ZWQgY29tcG9uZW50cyB3aWxsIGJlIGFkZGVkIHRvIHRoZVxuLy8gICAgZGlydHlfY29tcG9uZW50cyBhcnJheSBhbmQgd2lsbCBjYXVzZSBhIHJlZW50cmFudCBjYWxsIHRvIGZsdXNoKCkuIEJlY2F1c2Vcbi8vICAgIHRoZSBmbHVzaCBpbmRleCBpcyBrZXB0IG91dHNpZGUgdGhlIGZ1bmN0aW9uLCB0aGUgcmVlbnRyYW50IGNhbGwgd2lsbCBwaWNrXG4vLyAgICB1cCB3aGVyZSB0aGUgZWFybGllciBjYWxsIGxlZnQgb2ZmIGFuZCBnbyB0aHJvdWdoIGFsbCBkaXJ0eSBjb21wb25lbnRzLiBUaGVcbi8vICAgIGN1cnJlbnRfY29tcG9uZW50IHZhbHVlIGlzIHNhdmVkIGFuZCByZXN0b3JlZCBzbyB0aGF0IHRoZSByZWVudHJhbnQgY2FsbCB3aWxsXG4vLyAgICBub3QgaW50ZXJmZXJlIHdpdGggdGhlIFwicGFyZW50XCIgZmx1c2goKSBjYWxsLlxuLy8gMi4gYmluZDp0aGlzIGNhbGxiYWNrcyBjYW5ub3QgdHJpZ2dlciBuZXcgZmx1c2goKSBjYWxscy5cbi8vIDMuIER1cmluZyBhZnRlclVwZGF0ZSwgYW55IHVwZGF0ZWQgY29tcG9uZW50cyB3aWxsIE5PVCBoYXZlIHRoZWlyIGFmdGVyVXBkYXRlXG4vLyAgICBjYWxsYmFjayBjYWxsZWQgYSBzZWNvbmQgdGltZTsgdGhlIHNlZW5fY2FsbGJhY2tzIHNldCwgb3V0c2lkZSB0aGUgZmx1c2goKVxuLy8gICAgZnVuY3Rpb24sIGd1YXJhbnRlZXMgdGhpcyBiZWhhdmlvci5cbmNvbnN0IHNlZW5fY2FsbGJhY2tzID0gbmV3IFNldCgpO1xubGV0IGZsdXNoaWR4ID0gMDsgLy8gRG8gKm5vdCogbW92ZSB0aGlzIGluc2lkZSB0aGUgZmx1c2goKSBmdW5jdGlvblxuZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgLy8gRG8gbm90IHJlZW50ZXIgZmx1c2ggd2hpbGUgZGlydHkgY29tcG9uZW50cyBhcmUgdXBkYXRlZCwgYXMgdGhpcyBjYW5cbiAgICAvLyByZXN1bHQgaW4gYW4gaW5maW5pdGUgbG9vcC4gSW5zdGVhZCwgbGV0IHRoZSBpbm5lciBmbHVzaCBoYW5kbGUgaXQuXG4gICAgLy8gUmVlbnRyYW5jeSBpcyBvayBhZnRlcndhcmRzIGZvciBiaW5kaW5ncyBldGMuXG4gICAgaWYgKGZsdXNoaWR4ICE9PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2F2ZWRfY29tcG9uZW50ID0gY3VycmVudF9jb21wb25lbnQ7XG4gICAgZG8ge1xuICAgICAgICAvLyBmaXJzdCwgY2FsbCBiZWZvcmVVcGRhdGUgZnVuY3Rpb25zXG4gICAgICAgIC8vIGFuZCB1cGRhdGUgY29tcG9uZW50c1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgd2hpbGUgKGZsdXNoaWR4IDwgZGlydHlfY29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSBkaXJ0eV9jb21wb25lbnRzW2ZsdXNoaWR4XTtcbiAgICAgICAgICAgICAgICBmbHVzaGlkeCsrO1xuICAgICAgICAgICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChjb21wb25lbnQpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZShjb21wb25lbnQuJCQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyByZXNldCBkaXJ0eSBzdGF0ZSB0byBub3QgZW5kIHVwIGluIGEgZGVhZGxvY2tlZCBzdGF0ZSBhbmQgdGhlbiByZXRocm93XG4gICAgICAgICAgICBkaXJ0eV9jb21wb25lbnRzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBmbHVzaGlkeCA9IDA7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChudWxsKTtcbiAgICAgICAgZGlydHlfY29tcG9uZW50cy5sZW5ndGggPSAwO1xuICAgICAgICBmbHVzaGlkeCA9IDA7XG4gICAgICAgIHdoaWxlIChiaW5kaW5nX2NhbGxiYWNrcy5sZW5ndGgpXG4gICAgICAgICAgICBiaW5kaW5nX2NhbGxiYWNrcy5wb3AoKSgpO1xuICAgICAgICAvLyB0aGVuLCBvbmNlIGNvbXBvbmVudHMgYXJlIHVwZGF0ZWQsIGNhbGxcbiAgICAgICAgLy8gYWZ0ZXJVcGRhdGUgZnVuY3Rpb25zLiBUaGlzIG1heSBjYXVzZVxuICAgICAgICAvLyBzdWJzZXF1ZW50IHVwZGF0ZXMuLi5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW5kZXJfY2FsbGJhY2tzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IHJlbmRlcl9jYWxsYmFja3NbaV07XG4gICAgICAgICAgICBpZiAoIXNlZW5fY2FsbGJhY2tzLmhhcyhjYWxsYmFjaykpIHtcbiAgICAgICAgICAgICAgICAvLyAuLi5zbyBndWFyZCBhZ2FpbnN0IGluZmluaXRlIGxvb3BzXG4gICAgICAgICAgICAgICAgc2Vlbl9jYWxsYmFja3MuYWRkKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlbmRlcl9jYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgICB9IHdoaWxlIChkaXJ0eV9jb21wb25lbnRzLmxlbmd0aCk7XG4gICAgd2hpbGUgKGZsdXNoX2NhbGxiYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgZmx1c2hfY2FsbGJhY2tzLnBvcCgpKCk7XG4gICAgfVxuICAgIHVwZGF0ZV9zY2hlZHVsZWQgPSBmYWxzZTtcbiAgICBzZWVuX2NhbGxiYWNrcy5jbGVhcigpO1xuICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChzYXZlZF9jb21wb25lbnQpO1xufVxuZnVuY3Rpb24gdXBkYXRlKCQkKSB7XG4gICAgaWYgKCQkLmZyYWdtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICQkLnVwZGF0ZSgpO1xuICAgICAgICBydW5fYWxsKCQkLmJlZm9yZV91cGRhdGUpO1xuICAgICAgICBjb25zdCBkaXJ0eSA9ICQkLmRpcnR5O1xuICAgICAgICAkJC5kaXJ0eSA9IFstMV07XG4gICAgICAgICQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50LnAoJCQuY3R4LCBkaXJ0eSk7XG4gICAgICAgICQkLmFmdGVyX3VwZGF0ZS5mb3JFYWNoKGFkZF9yZW5kZXJfY2FsbGJhY2spO1xuICAgIH1cbn1cbi8qKlxuICogVXNlZnVsIGZvciBleGFtcGxlIHRvIGV4ZWN1dGUgcmVtYWluaW5nIGBhZnRlclVwZGF0ZWAgY2FsbGJhY2tzIGJlZm9yZSBleGVjdXRpbmcgYGRlc3Ryb3lgLlxuICovXG5mdW5jdGlvbiBmbHVzaF9yZW5kZXJfY2FsbGJhY2tzKGZucykge1xuICAgIGNvbnN0IGZpbHRlcmVkID0gW107XG4gICAgY29uc3QgdGFyZ2V0cyA9IFtdO1xuICAgIHJlbmRlcl9jYWxsYmFja3MuZm9yRWFjaCgoYykgPT4gZm5zLmluZGV4T2YoYykgPT09IC0xID8gZmlsdGVyZWQucHVzaChjKSA6IHRhcmdldHMucHVzaChjKSk7XG4gICAgdGFyZ2V0cy5mb3JFYWNoKChjKSA9PiBjKCkpO1xuICAgIHJlbmRlcl9jYWxsYmFja3MgPSBmaWx0ZXJlZDtcbn1cblxubGV0IHByb21pc2U7XG5mdW5jdGlvbiB3YWl0KCkge1xuICAgIGlmICghcHJvbWlzZSkge1xuICAgICAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIHByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBwcm9taXNlID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwcm9taXNlO1xufVxuZnVuY3Rpb24gZGlzcGF0Y2gobm9kZSwgZGlyZWN0aW9uLCBraW5kKSB7XG4gICAgbm9kZS5kaXNwYXRjaEV2ZW50KGN1c3RvbV9ldmVudChgJHtkaXJlY3Rpb24gPyAnaW50cm8nIDogJ291dHJvJ30ke2tpbmR9YCkpO1xufVxuY29uc3Qgb3V0cm9pbmcgPSBuZXcgU2V0KCk7XG5sZXQgb3V0cm9zO1xuZnVuY3Rpb24gZ3JvdXBfb3V0cm9zKCkge1xuICAgIG91dHJvcyA9IHtcbiAgICAgICAgcjogMCxcbiAgICAgICAgYzogW10sXG4gICAgICAgIHA6IG91dHJvcyAvLyBwYXJlbnQgZ3JvdXBcbiAgICB9O1xufVxuZnVuY3Rpb24gY2hlY2tfb3V0cm9zKCkge1xuICAgIGlmICghb3V0cm9zLnIpIHtcbiAgICAgICAgcnVuX2FsbChvdXRyb3MuYyk7XG4gICAgfVxuICAgIG91dHJvcyA9IG91dHJvcy5wO1xufVxuZnVuY3Rpb24gdHJhbnNpdGlvbl9pbihibG9jaywgbG9jYWwpIHtcbiAgICBpZiAoYmxvY2sgJiYgYmxvY2suaSkge1xuICAgICAgICBvdXRyb2luZy5kZWxldGUoYmxvY2spO1xuICAgICAgICBibG9jay5pKGxvY2FsKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0cmFuc2l0aW9uX291dChibG9jaywgbG9jYWwsIGRldGFjaCwgY2FsbGJhY2spIHtcbiAgICBpZiAoYmxvY2sgJiYgYmxvY2subykge1xuICAgICAgICBpZiAob3V0cm9pbmcuaGFzKGJsb2NrKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgb3V0cm9pbmcuYWRkKGJsb2NrKTtcbiAgICAgICAgb3V0cm9zLmMucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICBvdXRyb2luZy5kZWxldGUoYmxvY2spO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRldGFjaClcbiAgICAgICAgICAgICAgICAgICAgYmxvY2suZCgxKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYmxvY2subyhsb2NhbCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxufVxuY29uc3QgbnVsbF90cmFuc2l0aW9uID0geyBkdXJhdGlvbjogMCB9O1xuZnVuY3Rpb24gY3JlYXRlX2luX3RyYW5zaXRpb24obm9kZSwgZm4sIHBhcmFtcykge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7IGRpcmVjdGlvbjogJ2luJyB9O1xuICAgIGxldCBjb25maWcgPSBmbihub2RlLCBwYXJhbXMsIG9wdGlvbnMpO1xuICAgIGxldCBydW5uaW5nID0gZmFsc2U7XG4gICAgbGV0IGFuaW1hdGlvbl9uYW1lO1xuICAgIGxldCB0YXNrO1xuICAgIGxldCB1aWQgPSAwO1xuICAgIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgICAgIGlmIChhbmltYXRpb25fbmFtZSlcbiAgICAgICAgICAgIGRlbGV0ZV9ydWxlKG5vZGUsIGFuaW1hdGlvbl9uYW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ28oKSB7XG4gICAgICAgIGNvbnN0IHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDMwMCwgZWFzaW5nID0gaWRlbnRpdHksIHRpY2sgPSBub29wLCBjc3MgfSA9IGNvbmZpZyB8fCBudWxsX3RyYW5zaXRpb247XG4gICAgICAgIGlmIChjc3MpXG4gICAgICAgICAgICBhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIDAsIDEsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBjc3MsIHVpZCsrKTtcbiAgICAgICAgdGljaygwLCAxKTtcbiAgICAgICAgY29uc3Qgc3RhcnRfdGltZSA9IG5vdygpICsgZGVsYXk7XG4gICAgICAgIGNvbnN0IGVuZF90aW1lID0gc3RhcnRfdGltZSArIGR1cmF0aW9uO1xuICAgICAgICBpZiAodGFzaylcbiAgICAgICAgICAgIHRhc2suYWJvcnQoKTtcbiAgICAgICAgcnVubmluZyA9IHRydWU7XG4gICAgICAgIGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4gZGlzcGF0Y2gobm9kZSwgdHJ1ZSwgJ3N0YXJ0JykpO1xuICAgICAgICB0YXNrID0gbG9vcChub3cgPT4ge1xuICAgICAgICAgICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAobm93ID49IGVuZF90aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpY2soMSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKG5vZGUsIHRydWUsICdlbmQnKTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm93ID49IHN0YXJ0X3RpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdCA9IGVhc2luZygobm93IC0gc3RhcnRfdGltZSkgLyBkdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHRpY2sodCwgMSAtIHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydW5uaW5nO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGV0IHN0YXJ0ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydCgpIHtcbiAgICAgICAgICAgIGlmIChzdGFydGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgZGVsZXRlX3J1bGUobm9kZSk7XG4gICAgICAgICAgICBpZiAoaXNfZnVuY3Rpb24oY29uZmlnKSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZyhvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB3YWl0KCkudGhlbihnbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnbygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICAgICAgc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBlbmQoKSB7XG4gICAgICAgICAgICBpZiAocnVubmluZykge1xuICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICBydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlX291dF90cmFuc2l0aW9uKG5vZGUsIGZuLCBwYXJhbXMpIHtcbiAgICBjb25zdCBvcHRpb25zID0geyBkaXJlY3Rpb246ICdvdXQnIH07XG4gICAgbGV0IGNvbmZpZyA9IGZuKG5vZGUsIHBhcmFtcywgb3B0aW9ucyk7XG4gICAgbGV0IHJ1bm5pbmcgPSB0cnVlO1xuICAgIGxldCBhbmltYXRpb25fbmFtZTtcbiAgICBjb25zdCBncm91cCA9IG91dHJvcztcbiAgICBncm91cC5yICs9IDE7XG4gICAgZnVuY3Rpb24gZ28oKSB7XG4gICAgICAgIGNvbnN0IHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDMwMCwgZWFzaW5nID0gaWRlbnRpdHksIHRpY2sgPSBub29wLCBjc3MgfSA9IGNvbmZpZyB8fCBudWxsX3RyYW5zaXRpb247XG4gICAgICAgIGlmIChjc3MpXG4gICAgICAgICAgICBhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIDEsIDAsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBjc3MpO1xuICAgICAgICBjb25zdCBzdGFydF90aW1lID0gbm93KCkgKyBkZWxheTtcbiAgICAgICAgY29uc3QgZW5kX3RpbWUgPSBzdGFydF90aW1lICsgZHVyYXRpb247XG4gICAgICAgIGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4gZGlzcGF0Y2gobm9kZSwgZmFsc2UsICdzdGFydCcpKTtcbiAgICAgICAgbG9vcChub3cgPT4ge1xuICAgICAgICAgICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAobm93ID49IGVuZF90aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpY2soMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKG5vZGUsIGZhbHNlLCAnZW5kJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghLS1ncm91cC5yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdpbGwgcmVzdWx0IGluIGBlbmQoKWAgYmVpbmcgY2FsbGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gd2UgZG9uJ3QgbmVlZCB0byBjbGVhbiB1cCBoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICBydW5fYWxsKGdyb3VwLmMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5vdyA+PSBzdGFydF90aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBlYXNpbmcoKG5vdyAtIHN0YXJ0X3RpbWUpIC8gZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB0aWNrKDEgLSB0LCB0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcnVubmluZztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChpc19mdW5jdGlvbihjb25maWcpKSB7XG4gICAgICAgIHdhaXQoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZyhvcHRpb25zKTtcbiAgICAgICAgICAgIGdvKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ28oKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5kKHJlc2V0KSB7XG4gICAgICAgICAgICBpZiAocmVzZXQgJiYgY29uZmlnLnRpY2spIHtcbiAgICAgICAgICAgICAgICBjb25maWcudGljaygxLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChydW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbl9uYW1lKVxuICAgICAgICAgICAgICAgICAgICBkZWxldGVfcnVsZShub2RlLCBhbmltYXRpb25fbmFtZSk7XG4gICAgICAgICAgICAgICAgcnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZV9iaWRpcmVjdGlvbmFsX3RyYW5zaXRpb24obm9kZSwgZm4sIHBhcmFtcywgaW50cm8pIHtcbiAgICBjb25zdCBvcHRpb25zID0geyBkaXJlY3Rpb246ICdib3RoJyB9O1xuICAgIGxldCBjb25maWcgPSBmbihub2RlLCBwYXJhbXMsIG9wdGlvbnMpO1xuICAgIGxldCB0ID0gaW50cm8gPyAwIDogMTtcbiAgICBsZXQgcnVubmluZ19wcm9ncmFtID0gbnVsbDtcbiAgICBsZXQgcGVuZGluZ19wcm9ncmFtID0gbnVsbDtcbiAgICBsZXQgYW5pbWF0aW9uX25hbWUgPSBudWxsO1xuICAgIGZ1bmN0aW9uIGNsZWFyX2FuaW1hdGlvbigpIHtcbiAgICAgICAgaWYgKGFuaW1hdGlvbl9uYW1lKVxuICAgICAgICAgICAgZGVsZXRlX3J1bGUobm9kZSwgYW5pbWF0aW9uX25hbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbml0KHByb2dyYW0sIGR1cmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IGQgPSAocHJvZ3JhbS5iIC0gdCk7XG4gICAgICAgIGR1cmF0aW9uICo9IE1hdGguYWJzKGQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYTogdCxcbiAgICAgICAgICAgIGI6IHByb2dyYW0uYixcbiAgICAgICAgICAgIGQsXG4gICAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICAgIHN0YXJ0OiBwcm9ncmFtLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBwcm9ncmFtLnN0YXJ0ICsgZHVyYXRpb24sXG4gICAgICAgICAgICBncm91cDogcHJvZ3JhbS5ncm91cFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnbyhiKSB7XG4gICAgICAgIGNvbnN0IHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDMwMCwgZWFzaW5nID0gaWRlbnRpdHksIHRpY2sgPSBub29wLCBjc3MgfSA9IGNvbmZpZyB8fCBudWxsX3RyYW5zaXRpb247XG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSB7XG4gICAgICAgICAgICBzdGFydDogbm93KCkgKyBkZWxheSxcbiAgICAgICAgICAgIGJcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFiKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIHRvZG86IGltcHJvdmUgdHlwaW5nc1xuICAgICAgICAgICAgcHJvZ3JhbS5ncm91cCA9IG91dHJvcztcbiAgICAgICAgICAgIG91dHJvcy5yICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bm5pbmdfcHJvZ3JhbSB8fCBwZW5kaW5nX3Byb2dyYW0pIHtcbiAgICAgICAgICAgIHBlbmRpbmdfcHJvZ3JhbSA9IHByb2dyYW07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiB0aGlzIGlzIGFuIGludHJvLCBhbmQgdGhlcmUncyBhIGRlbGF5LCB3ZSBuZWVkIHRvIGRvXG4gICAgICAgICAgICAvLyBhbiBpbml0aWFsIHRpY2sgYW5kL29yIGFwcGx5IENTUyBhbmltYXRpb24gaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIGlmIChjc3MpIHtcbiAgICAgICAgICAgICAgICBjbGVhcl9hbmltYXRpb24oKTtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIHQsIGIsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBjc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGIpXG4gICAgICAgICAgICAgICAgdGljaygwLCAxKTtcbiAgICAgICAgICAgIHJ1bm5pbmdfcHJvZ3JhbSA9IGluaXQocHJvZ3JhbSwgZHVyYXRpb24pO1xuICAgICAgICAgICAgYWRkX3JlbmRlcl9jYWxsYmFjaygoKSA9PiBkaXNwYXRjaChub2RlLCBiLCAnc3RhcnQnKSk7XG4gICAgICAgICAgICBsb29wKG5vdyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBlbmRpbmdfcHJvZ3JhbSAmJiBub3cgPiBwZW5kaW5nX3Byb2dyYW0uc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVubmluZ19wcm9ncmFtID0gaW5pdChwZW5kaW5nX3Byb2dyYW0sIGR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ19wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2gobm9kZSwgcnVubmluZ19wcm9ncmFtLmIsICdzdGFydCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3NzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhcl9hbmltYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbl9uYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgdCwgcnVubmluZ19wcm9ncmFtLmIsIHJ1bm5pbmdfcHJvZ3JhbS5kdXJhdGlvbiwgMCwgZWFzaW5nLCBjb25maWcuY3NzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocnVubmluZ19wcm9ncmFtKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub3cgPj0gcnVubmluZ19wcm9ncmFtLmVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGljayh0ID0gcnVubmluZ19wcm9ncmFtLmIsIDEgLSB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKG5vZGUsIHJ1bm5pbmdfcHJvZ3JhbS5iLCAnZW5kJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBlbmRpbmdfcHJvZ3JhbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlJ3JlIGRvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVubmluZ19wcm9ncmFtLmIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW50cm8g4oCUIHdlIGNhbiB0aWR5IHVwIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyX2FuaW1hdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3V0cm8g4oCUIG5lZWRzIHRvIGJlIGNvb3JkaW5hdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghLS1ydW5uaW5nX3Byb2dyYW0uZ3JvdXAucilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bl9hbGwocnVubmluZ19wcm9ncmFtLmdyb3VwLmMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmdfcHJvZ3JhbSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobm93ID49IHJ1bm5pbmdfcHJvZ3JhbS5zdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IG5vdyAtIHJ1bm5pbmdfcHJvZ3JhbS5zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBydW5uaW5nX3Byb2dyYW0uYSArIHJ1bm5pbmdfcHJvZ3JhbS5kICogZWFzaW5nKHAgLyBydW5uaW5nX3Byb2dyYW0uZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGljayh0LCAxIC0gdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhKHJ1bm5pbmdfcHJvZ3JhbSB8fCBwZW5kaW5nX3Byb2dyYW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcnVuKGIpIHtcbiAgICAgICAgICAgIGlmIChpc19mdW5jdGlvbihjb25maWcpKSB7XG4gICAgICAgICAgICAgICAgd2FpdCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZyhvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgZ28oYik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnbyhiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW5kKCkge1xuICAgICAgICAgICAgY2xlYXJfYW5pbWF0aW9uKCk7XG4gICAgICAgICAgICBydW5uaW5nX3Byb2dyYW0gPSBwZW5kaW5nX3Byb2dyYW0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlX3Byb21pc2UocHJvbWlzZSwgaW5mbykge1xuICAgIGNvbnN0IHRva2VuID0gaW5mby50b2tlbiA9IHt9O1xuICAgIGZ1bmN0aW9uIHVwZGF0ZSh0eXBlLCBpbmRleCwga2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoaW5mby50b2tlbiAhPT0gdG9rZW4pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGluZm8ucmVzb2x2ZWQgPSB2YWx1ZTtcbiAgICAgICAgbGV0IGNoaWxkX2N0eCA9IGluZm8uY3R4O1xuICAgICAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNoaWxkX2N0eCA9IGNoaWxkX2N0eC5zbGljZSgpO1xuICAgICAgICAgICAgY2hpbGRfY3R4W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBibG9jayA9IHR5cGUgJiYgKGluZm8uY3VycmVudCA9IHR5cGUpKGNoaWxkX2N0eCk7XG4gICAgICAgIGxldCBuZWVkc19mbHVzaCA9IGZhbHNlO1xuICAgICAgICBpZiAoaW5mby5ibG9jaykge1xuICAgICAgICAgICAgaWYgKGluZm8uYmxvY2tzKSB7XG4gICAgICAgICAgICAgICAgaW5mby5ibG9ja3MuZm9yRWFjaCgoYmxvY2ssIGkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT09IGluZGV4ICYmIGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cF9vdXRyb3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25fb3V0KGJsb2NrLCAxLCAxLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZm8uYmxvY2tzW2ldID09PSBibG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvLmJsb2Nrc1tpXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja19vdXRyb3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5mby5ibG9jay5kKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmxvY2suYygpO1xuICAgICAgICAgICAgdHJhbnNpdGlvbl9pbihibG9jaywgMSk7XG4gICAgICAgICAgICBibG9jay5tKGluZm8ubW91bnQoKSwgaW5mby5hbmNob3IpO1xuICAgICAgICAgICAgbmVlZHNfZmx1c2ggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGluZm8uYmxvY2sgPSBibG9jaztcbiAgICAgICAgaWYgKGluZm8uYmxvY2tzKVxuICAgICAgICAgICAgaW5mby5ibG9ja3NbaW5kZXhdID0gYmxvY2s7XG4gICAgICAgIGlmIChuZWVkc19mbHVzaCkge1xuICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNfcHJvbWlzZShwcm9taXNlKSkge1xuICAgICAgICBjb25zdCBjdXJyZW50X2NvbXBvbmVudCA9IGdldF9jdXJyZW50X2NvbXBvbmVudCgpO1xuICAgICAgICBwcm9taXNlLnRoZW4odmFsdWUgPT4ge1xuICAgICAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KGN1cnJlbnRfY29tcG9uZW50KTtcbiAgICAgICAgICAgIHVwZGF0ZShpbmZvLnRoZW4sIDEsIGluZm8udmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChudWxsKTtcbiAgICAgICAgfSwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KGN1cnJlbnRfY29tcG9uZW50KTtcbiAgICAgICAgICAgIHVwZGF0ZShpbmZvLmNhdGNoLCAyLCBpbmZvLmVycm9yLCBlcnJvcik7XG4gICAgICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQobnVsbCk7XG4gICAgICAgICAgICBpZiAoIWluZm8uaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGlmIHdlIHByZXZpb3VzbHkgaGFkIGEgdGhlbi9jYXRjaCBibG9jaywgZGVzdHJveSBpdFxuICAgICAgICBpZiAoaW5mby5jdXJyZW50ICE9PSBpbmZvLnBlbmRpbmcpIHtcbiAgICAgICAgICAgIHVwZGF0ZShpbmZvLnBlbmRpbmcsIDApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChpbmZvLmN1cnJlbnQgIT09IGluZm8udGhlbikge1xuICAgICAgICAgICAgdXBkYXRlKGluZm8udGhlbiwgMSwgaW5mby52YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpbmZvLnJlc29sdmVkID0gcHJvbWlzZTtcbiAgICB9XG59XG5mdW5jdGlvbiB1cGRhdGVfYXdhaXRfYmxvY2tfYnJhbmNoKGluZm8sIGN0eCwgZGlydHkpIHtcbiAgICBjb25zdCBjaGlsZF9jdHggPSBjdHguc2xpY2UoKTtcbiAgICBjb25zdCB7IHJlc29sdmVkIH0gPSBpbmZvO1xuICAgIGlmIChpbmZvLmN1cnJlbnQgPT09IGluZm8udGhlbikge1xuICAgICAgICBjaGlsZF9jdHhbaW5mby52YWx1ZV0gPSByZXNvbHZlZDtcbiAgICB9XG4gICAgaWYgKGluZm8uY3VycmVudCA9PT0gaW5mby5jYXRjaCkge1xuICAgICAgICBjaGlsZF9jdHhbaW5mby5lcnJvcl0gPSByZXNvbHZlZDtcbiAgICB9XG4gICAgaW5mby5ibG9jay5wKGNoaWxkX2N0eCwgZGlydHkpO1xufVxuXG5mdW5jdGlvbiBkZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcbiAgICBibG9jay5kKDEpO1xuICAgIGxvb2t1cC5kZWxldGUoYmxvY2sua2V5KTtcbn1cbmZ1bmN0aW9uIG91dHJvX2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcbiAgICB0cmFuc2l0aW9uX291dChibG9jaywgMSwgMSwgKCkgPT4ge1xuICAgICAgICBsb29rdXAuZGVsZXRlKGJsb2NrLmtleSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBmaXhfYW5kX2Rlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCkge1xuICAgIGJsb2NrLmYoKTtcbiAgICBkZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApO1xufVxuZnVuY3Rpb24gZml4X2FuZF9vdXRyb19hbmRfZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKSB7XG4gICAgYmxvY2suZigpO1xuICAgIG91dHJvX2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApO1xufVxuZnVuY3Rpb24gdXBkYXRlX2tleWVkX2VhY2gob2xkX2Jsb2NrcywgZGlydHksIGdldF9rZXksIGR5bmFtaWMsIGN0eCwgbGlzdCwgbG9va3VwLCBub2RlLCBkZXN0cm95LCBjcmVhdGVfZWFjaF9ibG9jaywgbmV4dCwgZ2V0X2NvbnRleHQpIHtcbiAgICBsZXQgbyA9IG9sZF9ibG9ja3MubGVuZ3RoO1xuICAgIGxldCBuID0gbGlzdC5sZW5ndGg7XG4gICAgbGV0IGkgPSBvO1xuICAgIGNvbnN0IG9sZF9pbmRleGVzID0ge307XG4gICAgd2hpbGUgKGktLSlcbiAgICAgICAgb2xkX2luZGV4ZXNbb2xkX2Jsb2Nrc1tpXS5rZXldID0gaTtcbiAgICBjb25zdCBuZXdfYmxvY2tzID0gW107XG4gICAgY29uc3QgbmV3X2xvb2t1cCA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBkZWx0YXMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgdXBkYXRlcyA9IFtdO1xuICAgIGkgPSBuO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgY29uc3QgY2hpbGRfY3R4ID0gZ2V0X2NvbnRleHQoY3R4LCBsaXN0LCBpKTtcbiAgICAgICAgY29uc3Qga2V5ID0gZ2V0X2tleShjaGlsZF9jdHgpO1xuICAgICAgICBsZXQgYmxvY2sgPSBsb29rdXAuZ2V0KGtleSk7XG4gICAgICAgIGlmICghYmxvY2spIHtcbiAgICAgICAgICAgIGJsb2NrID0gY3JlYXRlX2VhY2hfYmxvY2soa2V5LCBjaGlsZF9jdHgpO1xuICAgICAgICAgICAgYmxvY2suYygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGR5bmFtaWMpIHtcbiAgICAgICAgICAgIC8vIGRlZmVyIHVwZGF0ZXMgdW50aWwgYWxsIHRoZSBET00gc2h1ZmZsaW5nIGlzIGRvbmVcbiAgICAgICAgICAgIHVwZGF0ZXMucHVzaCgoKSA9PiBibG9jay5wKGNoaWxkX2N0eCwgZGlydHkpKTtcbiAgICAgICAgfVxuICAgICAgICBuZXdfbG9va3VwLnNldChrZXksIG5ld19ibG9ja3NbaV0gPSBibG9jayk7XG4gICAgICAgIGlmIChrZXkgaW4gb2xkX2luZGV4ZXMpXG4gICAgICAgICAgICBkZWx0YXMuc2V0KGtleSwgTWF0aC5hYnMoaSAtIG9sZF9pbmRleGVzW2tleV0pKTtcbiAgICB9XG4gICAgY29uc3Qgd2lsbF9tb3ZlID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IGRpZF9tb3ZlID0gbmV3IFNldCgpO1xuICAgIGZ1bmN0aW9uIGluc2VydChibG9jaykge1xuICAgICAgICB0cmFuc2l0aW9uX2luKGJsb2NrLCAxKTtcbiAgICAgICAgYmxvY2subShub2RlLCBuZXh0KTtcbiAgICAgICAgbG9va3VwLnNldChibG9jay5rZXksIGJsb2NrKTtcbiAgICAgICAgbmV4dCA9IGJsb2NrLmZpcnN0O1xuICAgICAgICBuLS07XG4gICAgfVxuICAgIHdoaWxlIChvICYmIG4pIHtcbiAgICAgICAgY29uc3QgbmV3X2Jsb2NrID0gbmV3X2Jsb2Nrc1tuIC0gMV07XG4gICAgICAgIGNvbnN0IG9sZF9ibG9jayA9IG9sZF9ibG9ja3NbbyAtIDFdO1xuICAgICAgICBjb25zdCBuZXdfa2V5ID0gbmV3X2Jsb2NrLmtleTtcbiAgICAgICAgY29uc3Qgb2xkX2tleSA9IG9sZF9ibG9jay5rZXk7XG4gICAgICAgIGlmIChuZXdfYmxvY2sgPT09IG9sZF9ibG9jaykge1xuICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICAgICAgbmV4dCA9IG5ld19ibG9jay5maXJzdDtcbiAgICAgICAgICAgIG8tLTtcbiAgICAgICAgICAgIG4tLTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghbmV3X2xvb2t1cC5oYXMob2xkX2tleSkpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBvbGQgYmxvY2tcbiAgICAgICAgICAgIGRlc3Ryb3kob2xkX2Jsb2NrLCBsb29rdXApO1xuICAgICAgICAgICAgby0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFsb29rdXAuaGFzKG5ld19rZXkpIHx8IHdpbGxfbW92ZS5oYXMobmV3X2tleSkpIHtcbiAgICAgICAgICAgIGluc2VydChuZXdfYmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRpZF9tb3ZlLmhhcyhvbGRfa2V5KSkge1xuICAgICAgICAgICAgby0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlbHRhcy5nZXQobmV3X2tleSkgPiBkZWx0YXMuZ2V0KG9sZF9rZXkpKSB7XG4gICAgICAgICAgICBkaWRfbW92ZS5hZGQobmV3X2tleSk7XG4gICAgICAgICAgICBpbnNlcnQobmV3X2Jsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdpbGxfbW92ZS5hZGQob2xkX2tleSk7XG4gICAgICAgICAgICBvLS07XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKG8tLSkge1xuICAgICAgICBjb25zdCBvbGRfYmxvY2sgPSBvbGRfYmxvY2tzW29dO1xuICAgICAgICBpZiAoIW5ld19sb29rdXAuaGFzKG9sZF9ibG9jay5rZXkpKVxuICAgICAgICAgICAgZGVzdHJveShvbGRfYmxvY2ssIGxvb2t1cCk7XG4gICAgfVxuICAgIHdoaWxlIChuKVxuICAgICAgICBpbnNlcnQobmV3X2Jsb2Nrc1tuIC0gMV0pO1xuICAgIHJ1bl9hbGwodXBkYXRlcyk7XG4gICAgcmV0dXJuIG5ld19ibG9ja3M7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZV9lYWNoX2tleXMoY3R4LCBsaXN0LCBnZXRfY29udGV4dCwgZ2V0X2tleSkge1xuICAgIGNvbnN0IGtleXMgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGdldF9rZXkoZ2V0X2NvbnRleHQoY3R4LCBsaXN0LCBpKSk7XG4gICAgICAgIGlmIChrZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBoYXZlIGR1cGxpY2F0ZSBrZXlzIGluIGEga2V5ZWQgZWFjaCcpO1xuICAgICAgICB9XG4gICAgICAgIGtleXMuYWRkKGtleSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRfc3ByZWFkX3VwZGF0ZShsZXZlbHMsIHVwZGF0ZXMpIHtcbiAgICBjb25zdCB1cGRhdGUgPSB7fTtcbiAgICBjb25zdCB0b19udWxsX291dCA9IHt9O1xuICAgIGNvbnN0IGFjY291bnRlZF9mb3IgPSB7ICQkc2NvcGU6IDEgfTtcbiAgICBsZXQgaSA9IGxldmVscy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICBjb25zdCBvID0gbGV2ZWxzW2ldO1xuICAgICAgICBjb25zdCBuID0gdXBkYXRlc1tpXTtcbiAgICAgICAgaWYgKG4pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG8pIHtcbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gbikpXG4gICAgICAgICAgICAgICAgICAgIHRvX251bGxfb3V0W2tleV0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbikge1xuICAgICAgICAgICAgICAgIGlmICghYWNjb3VudGVkX2ZvcltrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVtrZXldID0gbltrZXldO1xuICAgICAgICAgICAgICAgICAgICBhY2NvdW50ZWRfZm9yW2tleV0gPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldmVsc1tpXSA9IG47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvKSB7XG4gICAgICAgICAgICAgICAgYWNjb3VudGVkX2ZvcltrZXldID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0b19udWxsX291dCkge1xuICAgICAgICBpZiAoIShrZXkgaW4gdXBkYXRlKSlcbiAgICAgICAgICAgIHVwZGF0ZVtrZXldID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gdXBkYXRlO1xufVxuZnVuY3Rpb24gZ2V0X3NwcmVhZF9vYmplY3Qoc3ByZWFkX3Byb3BzKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBzcHJlYWRfcHJvcHMgPT09ICdvYmplY3QnICYmIHNwcmVhZF9wcm9wcyAhPT0gbnVsbCA/IHNwcmVhZF9wcm9wcyA6IHt9O1xufVxuXG5jb25zdCBfYm9vbGVhbl9hdHRyaWJ1dGVzID0gW1xuICAgICdhbGxvd2Z1bGxzY3JlZW4nLFxuICAgICdhbGxvd3BheW1lbnRyZXF1ZXN0JyxcbiAgICAnYXN5bmMnLFxuICAgICdhdXRvZm9jdXMnLFxuICAgICdhdXRvcGxheScsXG4gICAgJ2NoZWNrZWQnLFxuICAgICdjb250cm9scycsXG4gICAgJ2RlZmF1bHQnLFxuICAgICdkZWZlcicsXG4gICAgJ2Rpc2FibGVkJyxcbiAgICAnZm9ybW5vdmFsaWRhdGUnLFxuICAgICdoaWRkZW4nLFxuICAgICdpbmVydCcsXG4gICAgJ2lzbWFwJyxcbiAgICAnbG9vcCcsXG4gICAgJ211bHRpcGxlJyxcbiAgICAnbXV0ZWQnLFxuICAgICdub21vZHVsZScsXG4gICAgJ25vdmFsaWRhdGUnLFxuICAgICdvcGVuJyxcbiAgICAncGxheXNpbmxpbmUnLFxuICAgICdyZWFkb25seScsXG4gICAgJ3JlcXVpcmVkJyxcbiAgICAncmV2ZXJzZWQnLFxuICAgICdzZWxlY3RlZCdcbl07XG4vKipcbiAqIExpc3Qgb2YgSFRNTCBib29sZWFuIGF0dHJpYnV0ZXMgKGUuZy4gYDxpbnB1dCBkaXNhYmxlZD5gKS5cbiAqIFNvdXJjZTogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sXG4gKi9cbmNvbnN0IGJvb2xlYW5fYXR0cmlidXRlcyA9IG5ldyBTZXQoWy4uLl9ib29sZWFuX2F0dHJpYnV0ZXNdKTtcblxuLyoqIHJlZ2V4IG9mIGFsbCBodG1sIHZvaWQgZWxlbWVudCBuYW1lcyAqL1xuY29uc3Qgdm9pZF9lbGVtZW50X25hbWVzID0gL14oPzphcmVhfGJhc2V8YnJ8Y29sfGNvbW1hbmR8ZW1iZWR8aHJ8aW1nfGlucHV0fGtleWdlbnxsaW5rfG1ldGF8cGFyYW18c291cmNlfHRyYWNrfHdicikkLztcbmZ1bmN0aW9uIGlzX3ZvaWQobmFtZSkge1xuICAgIHJldHVybiB2b2lkX2VsZW1lbnRfbmFtZXMudGVzdChuYW1lKSB8fCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09ICchZG9jdHlwZSc7XG59XG5cbmNvbnN0IGludmFsaWRfYXR0cmlidXRlX25hbWVfY2hhcmFjdGVyID0gL1tcXHMnXCI+Lz1cXHV7RkREMH0tXFx1e0ZERUZ9XFx1e0ZGRkV9XFx1e0ZGRkZ9XFx1ezFGRkZFfVxcdXsxRkZGRn1cXHV7MkZGRkV9XFx1ezJGRkZGfVxcdXszRkZGRX1cXHV7M0ZGRkZ9XFx1ezRGRkZFfVxcdXs0RkZGRn1cXHV7NUZGRkV9XFx1ezVGRkZGfVxcdXs2RkZGRX1cXHV7NkZGRkZ9XFx1ezdGRkZFfVxcdXs3RkZGRn1cXHV7OEZGRkV9XFx1ezhGRkZGfVxcdXs5RkZGRX1cXHV7OUZGRkZ9XFx1e0FGRkZFfVxcdXtBRkZGRn1cXHV7QkZGRkV9XFx1e0JGRkZGfVxcdXtDRkZGRX1cXHV7Q0ZGRkZ9XFx1e0RGRkZFfVxcdXtERkZGRn1cXHV7RUZGRkV9XFx1e0VGRkZGfVxcdXtGRkZGRX1cXHV7RkZGRkZ9XFx1ezEwRkZGRX1cXHV7MTBGRkZGfV0vdTtcbi8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2F0dHJpYnV0ZXMtMlxuLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI25vbmNoYXJhY3RlclxuZnVuY3Rpb24gc3ByZWFkKGFyZ3MsIGF0dHJzX3RvX2FkZCkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBPYmplY3QuYXNzaWduKHt9LCAuLi5hcmdzKTtcbiAgICBpZiAoYXR0cnNfdG9fYWRkKSB7XG4gICAgICAgIGNvbnN0IGNsYXNzZXNfdG9fYWRkID0gYXR0cnNfdG9fYWRkLmNsYXNzZXM7XG4gICAgICAgIGNvbnN0IHN0eWxlc190b19hZGQgPSBhdHRyc190b19hZGQuc3R5bGVzO1xuICAgICAgICBpZiAoY2xhc3Nlc190b19hZGQpIHtcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzLmNsYXNzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLmNsYXNzID0gY2xhc3Nlc190b19hZGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLmNsYXNzICs9ICcgJyArIGNsYXNzZXNfdG9fYWRkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdHlsZXNfdG9fYWRkKSB7XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlcy5zdHlsZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5zdHlsZSA9IHN0eWxlX29iamVjdF90b19zdHJpbmcoc3R5bGVzX3RvX2FkZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnN0eWxlID0gc3R5bGVfb2JqZWN0X3RvX3N0cmluZyhtZXJnZV9zc3Jfc3R5bGVzKGF0dHJpYnV0ZXMuc3R5bGUsIHN0eWxlc190b19hZGQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgc3RyID0gJyc7XG4gICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgICAgaWYgKGludmFsaWRfYXR0cmlidXRlX25hbWVfY2hhcmFjdGVyLnRlc3QobmFtZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB0cnVlKVxuICAgICAgICAgICAgc3RyICs9ICcgJyArIG5hbWU7XG4gICAgICAgIGVsc2UgaWYgKGJvb2xlYW5fYXR0cmlidXRlcy5oYXMobmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgICAgIHN0ciArPSAnICcgKyBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHN0ciArPSBgICR7bmFtZX09XCIke3ZhbHVlfVwiYDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBtZXJnZV9zc3Jfc3R5bGVzKHN0eWxlX2F0dHJpYnV0ZSwgc3R5bGVfZGlyZWN0aXZlKSB7XG4gICAgY29uc3Qgc3R5bGVfb2JqZWN0ID0ge307XG4gICAgZm9yIChjb25zdCBpbmRpdmlkdWFsX3N0eWxlIG9mIHN0eWxlX2F0dHJpYnV0ZS5zcGxpdCgnOycpKSB7XG4gICAgICAgIGNvbnN0IGNvbG9uX2luZGV4ID0gaW5kaXZpZHVhbF9zdHlsZS5pbmRleE9mKCc6Jyk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBpbmRpdmlkdWFsX3N0eWxlLnNsaWNlKDAsIGNvbG9uX2luZGV4KS50cmltKCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gaW5kaXZpZHVhbF9zdHlsZS5zbGljZShjb2xvbl9pbmRleCArIDEpLnRyaW0oKTtcbiAgICAgICAgaWYgKCFuYW1lKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHN0eWxlX29iamVjdFtuYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gc3R5bGVfZGlyZWN0aXZlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gc3R5bGVfZGlyZWN0aXZlW25hbWVdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHN0eWxlX29iamVjdFtuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHN0eWxlX29iamVjdFtuYW1lXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3R5bGVfb2JqZWN0O1xufVxuY29uc3QgQVRUUl9SRUdFWCA9IC9bJlwiXS9nO1xuY29uc3QgQ09OVEVOVF9SRUdFWCA9IC9bJjxdL2c7XG4vKipcbiAqIE5vdGU6IHRoaXMgbWV0aG9kIGlzIHBlcmZvcm1hbmNlIHNlbnNpdGl2ZSBhbmQgaGFzIGJlZW4gb3B0aW1pemVkXG4gKiBodHRwczovL2dpdGh1Yi5jb20vc3ZlbHRlanMvc3ZlbHRlL3B1bGwvNTcwMVxuICovXG5mdW5jdGlvbiBlc2NhcGUodmFsdWUsIGlzX2F0dHIgPSBmYWxzZSkge1xuICAgIGNvbnN0IHN0ciA9IFN0cmluZyh2YWx1ZSk7XG4gICAgY29uc3QgcGF0dGVybiA9IGlzX2F0dHIgPyBBVFRSX1JFR0VYIDogQ09OVEVOVF9SRUdFWDtcbiAgICBwYXR0ZXJuLmxhc3RJbmRleCA9IDA7XG4gICAgbGV0IGVzY2FwZWQgPSAnJztcbiAgICBsZXQgbGFzdCA9IDA7XG4gICAgd2hpbGUgKHBhdHRlcm4udGVzdChzdHIpKSB7XG4gICAgICAgIGNvbnN0IGkgPSBwYXR0ZXJuLmxhc3RJbmRleCAtIDE7XG4gICAgICAgIGNvbnN0IGNoID0gc3RyW2ldO1xuICAgICAgICBlc2NhcGVkICs9IHN0ci5zdWJzdHJpbmcobGFzdCwgaSkgKyAoY2ggPT09ICcmJyA/ICcmYW1wOycgOiAoY2ggPT09ICdcIicgPyAnJnF1b3Q7JyA6ICcmbHQ7JykpO1xuICAgICAgICBsYXN0ID0gaSArIDE7XG4gICAgfVxuICAgIHJldHVybiBlc2NhcGVkICsgc3RyLnN1YnN0cmluZyhsYXN0KTtcbn1cbmZ1bmN0aW9uIGVzY2FwZV9hdHRyaWJ1dGVfdmFsdWUodmFsdWUpIHtcbiAgICAvLyBrZWVwIGJvb2xlYW5zLCBudWxsLCBhbmQgdW5kZWZpbmVkIGZvciB0aGUgc2FrZSBvZiBgc3ByZWFkYFxuICAgIGNvbnN0IHNob3VsZF9lc2NhcGUgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8ICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKTtcbiAgICByZXR1cm4gc2hvdWxkX2VzY2FwZSA/IGVzY2FwZSh2YWx1ZSwgdHJ1ZSkgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGVzY2FwZV9vYmplY3Qob2JqKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gZXNjYXBlX2F0dHJpYnV0ZV92YWx1ZShvYmpba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBlYWNoKGl0ZW1zLCBmbikge1xuICAgIGxldCBzdHIgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHN0ciArPSBmbihpdGVtc1tpXSwgaSk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG5jb25zdCBtaXNzaW5nX2NvbXBvbmVudCA9IHtcbiAgICAkJHJlbmRlcjogKCkgPT4gJydcbn07XG5mdW5jdGlvbiB2YWxpZGF0ZV9jb21wb25lbnQoY29tcG9uZW50LCBuYW1lKSB7XG4gICAgaWYgKCFjb21wb25lbnQgfHwgIWNvbXBvbmVudC4kJHJlbmRlcikge1xuICAgICAgICBpZiAobmFtZSA9PT0gJ3N2ZWx0ZTpjb21wb25lbnQnKVxuICAgICAgICAgICAgbmFtZSArPSAnIHRoaXM9ey4uLn0nO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYDwke25hbWV9PiBpcyBub3QgYSB2YWxpZCBTU1IgY29tcG9uZW50LiBZb3UgbWF5IG5lZWQgdG8gcmV2aWV3IHlvdXIgYnVpbGQgY29uZmlnIHRvIGVuc3VyZSB0aGF0IGRlcGVuZGVuY2llcyBhcmUgY29tcGlsZWQsIHJhdGhlciB0aGFuIGltcG9ydGVkIGFzIHByZS1jb21waWxlZCBtb2R1bGVzLiBPdGhlcndpc2UgeW91IG1heSBuZWVkIHRvIGZpeCBhIDwke25hbWV9Pi5gKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbn1cbmZ1bmN0aW9uIGRlYnVnKGZpbGUsIGxpbmUsIGNvbHVtbiwgdmFsdWVzKSB7XG4gICAgY29uc29sZS5sb2coYHtAZGVidWd9ICR7ZmlsZSA/IGZpbGUgKyAnICcgOiAnJ30oJHtsaW5lfToke2NvbHVtbn0pYCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUubG9nKHZhbHVlcyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgIHJldHVybiAnJztcbn1cbmxldCBvbl9kZXN0cm95O1xuZnVuY3Rpb24gY3JlYXRlX3Nzcl9jb21wb25lbnQoZm4pIHtcbiAgICBmdW5jdGlvbiAkJHJlbmRlcihyZXN1bHQsIHByb3BzLCBiaW5kaW5ncywgc2xvdHMsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgcGFyZW50X2NvbXBvbmVudCA9IGN1cnJlbnRfY29tcG9uZW50O1xuICAgICAgICBjb25zdCAkJCA9IHtcbiAgICAgICAgICAgIG9uX2Rlc3Ryb3ksXG4gICAgICAgICAgICBjb250ZXh0OiBuZXcgTWFwKGNvbnRleHQgfHwgKHBhcmVudF9jb21wb25lbnQgPyBwYXJlbnRfY29tcG9uZW50LiQkLmNvbnRleHQgOiBbXSkpLFxuICAgICAgICAgICAgLy8gdGhlc2Ugd2lsbCBiZSBpbW1lZGlhdGVseSBkaXNjYXJkZWRcbiAgICAgICAgICAgIG9uX21vdW50OiBbXSxcbiAgICAgICAgICAgIGJlZm9yZV91cGRhdGU6IFtdLFxuICAgICAgICAgICAgYWZ0ZXJfdXBkYXRlOiBbXSxcbiAgICAgICAgICAgIGNhbGxiYWNrczogYmxhbmtfb2JqZWN0KClcbiAgICAgICAgfTtcbiAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KHsgJCQgfSk7XG4gICAgICAgIGNvbnN0IGh0bWwgPSBmbihyZXN1bHQsIHByb3BzLCBiaW5kaW5ncywgc2xvdHMpO1xuICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQocGFyZW50X2NvbXBvbmVudCk7XG4gICAgICAgIHJldHVybiBodG1sO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICByZW5kZXI6IChwcm9wcyA9IHt9LCB7ICQkc2xvdHMgPSB7fSwgY29udGV4dCA9IG5ldyBNYXAoKSB9ID0ge30pID0+IHtcbiAgICAgICAgICAgIG9uX2Rlc3Ryb3kgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgdGl0bGU6ICcnLCBoZWFkOiAnJywgY3NzOiBuZXcgU2V0KCkgfTtcbiAgICAgICAgICAgIGNvbnN0IGh0bWwgPSAkJHJlbmRlcihyZXN1bHQsIHByb3BzLCB7fSwgJCRzbG90cywgY29udGV4dCk7XG4gICAgICAgICAgICBydW5fYWxsKG9uX2Rlc3Ryb3kpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBodG1sLFxuICAgICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBBcnJheS5mcm9tKHJlc3VsdC5jc3MpLm1hcChjc3MgPT4gY3NzLmNvZGUpLmpvaW4oJ1xcbicpLFxuICAgICAgICAgICAgICAgICAgICBtYXA6IG51bGwgLy8gVE9ET1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaGVhZDogcmVzdWx0LnRpdGxlICsgcmVzdWx0LmhlYWRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgICQkcmVuZGVyXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGFkZF9hdHRyaWJ1dGUobmFtZSwgdmFsdWUsIGJvb2xlYW4pIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCAoYm9vbGVhbiAmJiAhdmFsdWUpKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgY29uc3QgYXNzaWdubWVudCA9IChib29sZWFuICYmIHZhbHVlID09PSB0cnVlKSA/ICcnIDogYD1cIiR7ZXNjYXBlKHZhbHVlLCB0cnVlKX1cImA7XG4gICAgcmV0dXJuIGAgJHtuYW1lfSR7YXNzaWdubWVudH1gO1xufVxuZnVuY3Rpb24gYWRkX2NsYXNzZXMoY2xhc3Nlcykge1xuICAgIHJldHVybiBjbGFzc2VzID8gYCBjbGFzcz1cIiR7Y2xhc3Nlc31cImAgOiAnJztcbn1cbmZ1bmN0aW9uIHN0eWxlX29iamVjdF90b19zdHJpbmcoc3R5bGVfb2JqZWN0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHN0eWxlX29iamVjdClcbiAgICAgICAgLmZpbHRlcihrZXkgPT4gc3R5bGVfb2JqZWN0W2tleV0pXG4gICAgICAgIC5tYXAoa2V5ID0+IGAke2tleX06ICR7ZXNjYXBlX2F0dHJpYnV0ZV92YWx1ZShzdHlsZV9vYmplY3Rba2V5XSl9O2ApXG4gICAgICAgIC5qb2luKCcgJyk7XG59XG5mdW5jdGlvbiBhZGRfc3R5bGVzKHN0eWxlX29iamVjdCkge1xuICAgIGNvbnN0IHN0eWxlcyA9IHN0eWxlX29iamVjdF90b19zdHJpbmcoc3R5bGVfb2JqZWN0KTtcbiAgICByZXR1cm4gc3R5bGVzID8gYCBzdHlsZT1cIiR7c3R5bGVzfVwiYCA6ICcnO1xufVxuXG5mdW5jdGlvbiBiaW5kKGNvbXBvbmVudCwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBpbmRleCA9IGNvbXBvbmVudC4kJC5wcm9wc1tuYW1lXTtcbiAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb21wb25lbnQuJCQuYm91bmRbaW5kZXhdID0gY2FsbGJhY2s7XG4gICAgICAgIGNhbGxiYWNrKGNvbXBvbmVudC4kJC5jdHhbaW5kZXhdKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVfY29tcG9uZW50KGJsb2NrKSB7XG4gICAgYmxvY2sgJiYgYmxvY2suYygpO1xufVxuZnVuY3Rpb24gY2xhaW1fY29tcG9uZW50KGJsb2NrLCBwYXJlbnRfbm9kZXMpIHtcbiAgICBibG9jayAmJiBibG9jay5sKHBhcmVudF9ub2Rlcyk7XG59XG5mdW5jdGlvbiBtb3VudF9jb21wb25lbnQoY29tcG9uZW50LCB0YXJnZXQsIGFuY2hvciwgY3VzdG9tRWxlbWVudCkge1xuICAgIGNvbnN0IHsgZnJhZ21lbnQsIGFmdGVyX3VwZGF0ZSB9ID0gY29tcG9uZW50LiQkO1xuICAgIGZyYWdtZW50ICYmIGZyYWdtZW50Lm0odGFyZ2V0LCBhbmNob3IpO1xuICAgIGlmICghY3VzdG9tRWxlbWVudCkge1xuICAgICAgICAvLyBvbk1vdW50IGhhcHBlbnMgYmVmb3JlIHRoZSBpbml0aWFsIGFmdGVyVXBkYXRlXG4gICAgICAgIGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3X29uX2Rlc3Ryb3kgPSBjb21wb25lbnQuJCQub25fbW91bnQubWFwKHJ1bikuZmlsdGVyKGlzX2Z1bmN0aW9uKTtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBjb21wb25lbnQgd2FzIGRlc3Ryb3llZCBpbW1lZGlhdGVseVxuICAgICAgICAgICAgLy8gaXQgd2lsbCB1cGRhdGUgdGhlIGAkJC5vbl9kZXN0cm95YCByZWZlcmVuY2UgdG8gYG51bGxgLlxuICAgICAgICAgICAgLy8gdGhlIGRlc3RydWN0dXJlZCBvbl9kZXN0cm95IG1heSBzdGlsbCByZWZlcmVuY2UgdG8gdGhlIG9sZCBhcnJheVxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC4kJC5vbl9kZXN0cm95KSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LiQkLm9uX2Rlc3Ryb3kucHVzaCguLi5uZXdfb25fZGVzdHJveSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBFZGdlIGNhc2UgLSBjb21wb25lbnQgd2FzIGRlc3Ryb3llZCBpbW1lZGlhdGVseSxcbiAgICAgICAgICAgICAgICAvLyBtb3N0IGxpa2VseSBhcyBhIHJlc3VsdCBvZiBhIGJpbmRpbmcgaW5pdGlhbGlzaW5nXG4gICAgICAgICAgICAgICAgcnVuX2FsbChuZXdfb25fZGVzdHJveSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21wb25lbnQuJCQub25fbW91bnQgPSBbXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFmdGVyX3VwZGF0ZS5mb3JFYWNoKGFkZF9yZW5kZXJfY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gZGVzdHJveV9jb21wb25lbnQoY29tcG9uZW50LCBkZXRhY2hpbmcpIHtcbiAgICBjb25zdCAkJCA9IGNvbXBvbmVudC4kJDtcbiAgICBpZiAoJCQuZnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICAgICAgZmx1c2hfcmVuZGVyX2NhbGxiYWNrcygkJC5hZnRlcl91cGRhdGUpO1xuICAgICAgICBydW5fYWxsKCQkLm9uX2Rlc3Ryb3kpO1xuICAgICAgICAkJC5mcmFnbWVudCAmJiAkJC5mcmFnbWVudC5kKGRldGFjaGluZyk7XG4gICAgICAgIC8vIFRPRE8gbnVsbCBvdXQgb3RoZXIgcmVmcywgaW5jbHVkaW5nIGNvbXBvbmVudC4kJCAoYnV0IG5lZWQgdG9cbiAgICAgICAgLy8gcHJlc2VydmUgZmluYWwgc3RhdGU/KVxuICAgICAgICAkJC5vbl9kZXN0cm95ID0gJCQuZnJhZ21lbnQgPSBudWxsO1xuICAgICAgICAkJC5jdHggPSBbXTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYWtlX2RpcnR5KGNvbXBvbmVudCwgaSkge1xuICAgIGlmIChjb21wb25lbnQuJCQuZGlydHlbMF0gPT09IC0xKSB7XG4gICAgICAgIGRpcnR5X2NvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xuICAgICAgICBzY2hlZHVsZV91cGRhdGUoKTtcbiAgICAgICAgY29tcG9uZW50LiQkLmRpcnR5LmZpbGwoMCk7XG4gICAgfVxuICAgIGNvbXBvbmVudC4kJC5kaXJ0eVsoaSAvIDMxKSB8IDBdIHw9ICgxIDw8IChpICUgMzEpKTtcbn1cbmZ1bmN0aW9uIGluaXQoY29tcG9uZW50LCBvcHRpb25zLCBpbnN0YW5jZSwgY3JlYXRlX2ZyYWdtZW50LCBub3RfZXF1YWwsIHByb3BzLCBhcHBlbmRfc3R5bGVzLCBkaXJ0eSA9IFstMV0pIHtcbiAgICBjb25zdCBwYXJlbnRfY29tcG9uZW50ID0gY3VycmVudF9jb21wb25lbnQ7XG4gICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgY29uc3QgJCQgPSBjb21wb25lbnQuJCQgPSB7XG4gICAgICAgIGZyYWdtZW50OiBudWxsLFxuICAgICAgICBjdHg6IFtdLFxuICAgICAgICAvLyBzdGF0ZVxuICAgICAgICBwcm9wcyxcbiAgICAgICAgdXBkYXRlOiBub29wLFxuICAgICAgICBub3RfZXF1YWwsXG4gICAgICAgIGJvdW5kOiBibGFua19vYmplY3QoKSxcbiAgICAgICAgLy8gbGlmZWN5Y2xlXG4gICAgICAgIG9uX21vdW50OiBbXSxcbiAgICAgICAgb25fZGVzdHJveTogW10sXG4gICAgICAgIG9uX2Rpc2Nvbm5lY3Q6IFtdLFxuICAgICAgICBiZWZvcmVfdXBkYXRlOiBbXSxcbiAgICAgICAgYWZ0ZXJfdXBkYXRlOiBbXSxcbiAgICAgICAgY29udGV4dDogbmV3IE1hcChvcHRpb25zLmNvbnRleHQgfHwgKHBhcmVudF9jb21wb25lbnQgPyBwYXJlbnRfY29tcG9uZW50LiQkLmNvbnRleHQgOiBbXSkpLFxuICAgICAgICAvLyBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgY2FsbGJhY2tzOiBibGFua19vYmplY3QoKSxcbiAgICAgICAgZGlydHksXG4gICAgICAgIHNraXBfYm91bmQ6IGZhbHNlLFxuICAgICAgICByb290OiBvcHRpb25zLnRhcmdldCB8fCBwYXJlbnRfY29tcG9uZW50LiQkLnJvb3RcbiAgICB9O1xuICAgIGFwcGVuZF9zdHlsZXMgJiYgYXBwZW5kX3N0eWxlcygkJC5yb290KTtcbiAgICBsZXQgcmVhZHkgPSBmYWxzZTtcbiAgICAkJC5jdHggPSBpbnN0YW5jZVxuICAgICAgICA/IGluc3RhbmNlKGNvbXBvbmVudCwgb3B0aW9ucy5wcm9wcyB8fCB7fSwgKGksIHJldCwgLi4ucmVzdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByZXN0Lmxlbmd0aCA/IHJlc3RbMF0gOiByZXQ7XG4gICAgICAgICAgICBpZiAoJCQuY3R4ICYmIG5vdF9lcXVhbCgkJC5jdHhbaV0sICQkLmN0eFtpXSA9IHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmICghJCQuc2tpcF9ib3VuZCAmJiAkJC5ib3VuZFtpXSlcbiAgICAgICAgICAgICAgICAgICAgJCQuYm91bmRbaV0odmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChyZWFkeSlcbiAgICAgICAgICAgICAgICAgICAgbWFrZV9kaXJ0eShjb21wb25lbnQsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSlcbiAgICAgICAgOiBbXTtcbiAgICAkJC51cGRhdGUoKTtcbiAgICByZWFkeSA9IHRydWU7XG4gICAgcnVuX2FsbCgkJC5iZWZvcmVfdXBkYXRlKTtcbiAgICAvLyBgZmFsc2VgIGFzIGEgc3BlY2lhbCBjYXNlIG9mIG5vIERPTSBjb21wb25lbnRcbiAgICAkJC5mcmFnbWVudCA9IGNyZWF0ZV9mcmFnbWVudCA/IGNyZWF0ZV9mcmFnbWVudCgkJC5jdHgpIDogZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMudGFyZ2V0KSB7XG4gICAgICAgIGlmIChvcHRpb25zLmh5ZHJhdGUpIHtcbiAgICAgICAgICAgIHN0YXJ0X2h5ZHJhdGluZygpO1xuICAgICAgICAgICAgY29uc3Qgbm9kZXMgPSBjaGlsZHJlbihvcHRpb25zLnRhcmdldCk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgJCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQubChub2Rlcyk7XG4gICAgICAgICAgICBub2Rlcy5mb3JFYWNoKGRldGFjaCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgJCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQuYygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmludHJvKVxuICAgICAgICAgICAgdHJhbnNpdGlvbl9pbihjb21wb25lbnQuJCQuZnJhZ21lbnQpO1xuICAgICAgICBtb3VudF9jb21wb25lbnQoY29tcG9uZW50LCBvcHRpb25zLnRhcmdldCwgb3B0aW9ucy5hbmNob3IsIG9wdGlvbnMuY3VzdG9tRWxlbWVudCk7XG4gICAgICAgIGVuZF9oeWRyYXRpbmcoKTtcbiAgICAgICAgZmx1c2goKTtcbiAgICB9XG4gICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KHBhcmVudF9jb21wb25lbnQpO1xufVxubGV0IFN2ZWx0ZUVsZW1lbnQ7XG5pZiAodHlwZW9mIEhUTUxFbGVtZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgU3ZlbHRlRWxlbWVudCA9IGNsYXNzIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgb25fbW91bnQgfSA9IHRoaXMuJCQ7XG4gICAgICAgICAgICB0aGlzLiQkLm9uX2Rpc2Nvbm5lY3QgPSBvbl9tb3VudC5tYXAocnVuKS5maWx0ZXIoaXNfZnVuY3Rpb24pO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSB0b2RvOiBpbXByb3ZlIHR5cGluZ3NcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuJCQuc2xvdHRlZCkge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgdG9kbzogaW1wcm92ZSB0eXBpbmdzXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZCh0aGlzLiQkLnNsb3R0ZWRba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGF0dHIsIF9vbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXNbYXR0cl0gPSBuZXdWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgIHJ1bl9hbGwodGhpcy4kJC5vbl9kaXNjb25uZWN0KTtcbiAgICAgICAgfVxuICAgICAgICAkZGVzdHJveSgpIHtcbiAgICAgICAgICAgIGRlc3Ryb3lfY29tcG9uZW50KHRoaXMsIDEpO1xuICAgICAgICAgICAgdGhpcy4kZGVzdHJveSA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgJG9uKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBUT0RPIHNob3VsZCB0aGlzIGRlbGVnYXRlIHRvIGFkZEV2ZW50TGlzdGVuZXI/XG4gICAgICAgICAgICBpZiAoIWlzX2Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub29wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gKHRoaXMuJCQuY2FsbGJhY2tzW3R5cGVdIHx8ICh0aGlzLiQkLmNhbGxiYWNrc1t0eXBlXSA9IFtdKSk7XG4gICAgICAgICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gY2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAkc2V0KCQkcHJvcHMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiQkc2V0ICYmICFpc19lbXB0eSgkJHByb3BzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJCQuc2tpcF9ib3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy4kJHNldCgkJHByb3BzKTtcbiAgICAgICAgICAgICAgICB0aGlzLiQkLnNraXBfYm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIFN2ZWx0ZSBjb21wb25lbnRzLiBVc2VkIHdoZW4gZGV2PWZhbHNlLlxuICovXG5jbGFzcyBTdmVsdGVDb21wb25lbnQge1xuICAgICRkZXN0cm95KCkge1xuICAgICAgICBkZXN0cm95X2NvbXBvbmVudCh0aGlzLCAxKTtcbiAgICAgICAgdGhpcy4kZGVzdHJveSA9IG5vb3A7XG4gICAgfVxuICAgICRvbih0eXBlLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIWlzX2Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gKHRoaXMuJCQuY2FsbGJhY2tzW3R5cGVdIHx8ICh0aGlzLiQkLmNhbGxiYWNrc1t0eXBlXSA9IFtdKSk7XG4gICAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gY2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spO1xuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSlcbiAgICAgICAgICAgICAgICBjYWxsYmFja3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgJHNldCgkJHByb3BzKSB7XG4gICAgICAgIGlmICh0aGlzLiQkc2V0ICYmICFpc19lbXB0eSgkJHByb3BzKSkge1xuICAgICAgICAgICAgdGhpcy4kJC5za2lwX2JvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuJCRzZXQoJCRwcm9wcyk7XG4gICAgICAgICAgICB0aGlzLiQkLnNraXBfYm91bmQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hfZGV2KHR5cGUsIGRldGFpbCkge1xuICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoY3VzdG9tX2V2ZW50KHR5cGUsIE9iamVjdC5hc3NpZ24oeyB2ZXJzaW9uOiAnMy41OS4yJyB9LCBkZXRhaWwpLCB7IGJ1YmJsZXM6IHRydWUgfSkpO1xufVxuZnVuY3Rpb24gYXBwZW5kX2Rldih0YXJnZXQsIG5vZGUpIHtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTUluc2VydCcsIHsgdGFyZ2V0LCBub2RlIH0pO1xuICAgIGFwcGVuZCh0YXJnZXQsIG5vZGUpO1xufVxuZnVuY3Rpb24gYXBwZW5kX2h5ZHJhdGlvbl9kZXYodGFyZ2V0LCBub2RlKSB7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01JbnNlcnQnLCB7IHRhcmdldCwgbm9kZSB9KTtcbiAgICBhcHBlbmRfaHlkcmF0aW9uKHRhcmdldCwgbm9kZSk7XG59XG5mdW5jdGlvbiBpbnNlcnRfZGV2KHRhcmdldCwgbm9kZSwgYW5jaG9yKSB7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01JbnNlcnQnLCB7IHRhcmdldCwgbm9kZSwgYW5jaG9yIH0pO1xuICAgIGluc2VydCh0YXJnZXQsIG5vZGUsIGFuY2hvcik7XG59XG5mdW5jdGlvbiBpbnNlcnRfaHlkcmF0aW9uX2Rldih0YXJnZXQsIG5vZGUsIGFuY2hvcikge1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NSW5zZXJ0JywgeyB0YXJnZXQsIG5vZGUsIGFuY2hvciB9KTtcbiAgICBpbnNlcnRfaHlkcmF0aW9uKHRhcmdldCwgbm9kZSwgYW5jaG9yKTtcbn1cbmZ1bmN0aW9uIGRldGFjaF9kZXYobm9kZSkge1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NUmVtb3ZlJywgeyBub2RlIH0pO1xuICAgIGRldGFjaChub2RlKTtcbn1cbmZ1bmN0aW9uIGRldGFjaF9iZXR3ZWVuX2RldihiZWZvcmUsIGFmdGVyKSB7XG4gICAgd2hpbGUgKGJlZm9yZS5uZXh0U2libGluZyAmJiBiZWZvcmUubmV4dFNpYmxpbmcgIT09IGFmdGVyKSB7XG4gICAgICAgIGRldGFjaF9kZXYoYmVmb3JlLm5leHRTaWJsaW5nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZXRhY2hfYmVmb3JlX2RldihhZnRlcikge1xuICAgIHdoaWxlIChhZnRlci5wcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgICAgZGV0YWNoX2RldihhZnRlci5wcmV2aW91c1NpYmxpbmcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRldGFjaF9hZnRlcl9kZXYoYmVmb3JlKSB7XG4gICAgd2hpbGUgKGJlZm9yZS5uZXh0U2libGluZykge1xuICAgICAgICBkZXRhY2hfZGV2KGJlZm9yZS5uZXh0U2libGluZyk7XG4gICAgfVxufVxuZnVuY3Rpb24gbGlzdGVuX2Rldihub2RlLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucywgaGFzX3ByZXZlbnRfZGVmYXVsdCwgaGFzX3N0b3BfcHJvcGFnYXRpb24sIGhhc19zdG9wX2ltbWVkaWF0ZV9wcm9wYWdhdGlvbikge1xuICAgIGNvbnN0IG1vZGlmaWVycyA9IG9wdGlvbnMgPT09IHRydWUgPyBbJ2NhcHR1cmUnXSA6IG9wdGlvbnMgPyBBcnJheS5mcm9tKE9iamVjdC5rZXlzKG9wdGlvbnMpKSA6IFtdO1xuICAgIGlmIChoYXNfcHJldmVudF9kZWZhdWx0KVxuICAgICAgICBtb2RpZmllcnMucHVzaCgncHJldmVudERlZmF1bHQnKTtcbiAgICBpZiAoaGFzX3N0b3BfcHJvcGFnYXRpb24pXG4gICAgICAgIG1vZGlmaWVycy5wdXNoKCdzdG9wUHJvcGFnYXRpb24nKTtcbiAgICBpZiAoaGFzX3N0b3BfaW1tZWRpYXRlX3Byb3BhZ2F0aW9uKVxuICAgICAgICBtb2RpZmllcnMucHVzaCgnc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uJyk7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01BZGRFdmVudExpc3RlbmVyJywgeyBub2RlLCBldmVudCwgaGFuZGxlciwgbW9kaWZpZXJzIH0pO1xuICAgIGNvbnN0IGRpc3Bvc2UgPSBsaXN0ZW4obm9kZSwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NUmVtb3ZlRXZlbnRMaXN0ZW5lcicsIHsgbm9kZSwgZXZlbnQsIGhhbmRsZXIsIG1vZGlmaWVycyB9KTtcbiAgICAgICAgZGlzcG9zZSgpO1xuICAgIH07XG59XG5mdW5jdGlvbiBhdHRyX2Rldihub2RlLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgYXR0cihub2RlLCBhdHRyaWJ1dGUsIHZhbHVlKTtcbiAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01SZW1vdmVBdHRyaWJ1dGUnLCB7IG5vZGUsIGF0dHJpYnV0ZSB9KTtcbiAgICBlbHNlXG4gICAgICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NU2V0QXR0cmlidXRlJywgeyBub2RlLCBhdHRyaWJ1dGUsIHZhbHVlIH0pO1xufVxuZnVuY3Rpb24gcHJvcF9kZXYobm9kZSwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgbm9kZVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVNldFByb3BlcnR5JywgeyBub2RlLCBwcm9wZXJ0eSwgdmFsdWUgfSk7XG59XG5mdW5jdGlvbiBkYXRhc2V0X2Rldihub2RlLCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICBub2RlLmRhdGFzZXRbcHJvcGVydHldID0gdmFsdWU7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01TZXREYXRhc2V0JywgeyBub2RlLCBwcm9wZXJ0eSwgdmFsdWUgfSk7XG59XG5mdW5jdGlvbiBzZXRfZGF0YV9kZXYodGV4dCwgZGF0YSkge1xuICAgIGRhdGEgPSAnJyArIGRhdGE7XG4gICAgaWYgKHRleHQuZGF0YSA9PT0gZGF0YSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NU2V0RGF0YScsIHsgbm9kZTogdGV4dCwgZGF0YSB9KTtcbiAgICB0ZXh0LmRhdGEgPSBkYXRhO1xufVxuZnVuY3Rpb24gc2V0X2RhdGFfY29udGVudGVkaXRhYmxlX2Rldih0ZXh0LCBkYXRhKSB7XG4gICAgZGF0YSA9ICcnICsgZGF0YTtcbiAgICBpZiAodGV4dC53aG9sZVRleHQgPT09IGRhdGEpXG4gICAgICAgIHJldHVybjtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVNldERhdGEnLCB7IG5vZGU6IHRleHQsIGRhdGEgfSk7XG4gICAgdGV4dC5kYXRhID0gZGF0YTtcbn1cbmZ1bmN0aW9uIHNldF9kYXRhX21heWJlX2NvbnRlbnRlZGl0YWJsZV9kZXYodGV4dCwgZGF0YSwgYXR0cl92YWx1ZSkge1xuICAgIGlmICh+Y29udGVudGVkaXRhYmxlX3RydXRoeV92YWx1ZXMuaW5kZXhPZihhdHRyX3ZhbHVlKSkge1xuICAgICAgICBzZXRfZGF0YV9jb250ZW50ZWRpdGFibGVfZGV2KHRleHQsIGRhdGEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2V0X2RhdGFfZGV2KHRleHQsIGRhdGEpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlX2VhY2hfYXJndW1lbnQoYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdzdHJpbmcnICYmICEoYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmICdsZW5ndGgnIGluIGFyZykpIHtcbiAgICAgICAgbGV0IG1zZyA9ICd7I2VhY2h9IG9ubHkgaXRlcmF0ZXMgb3ZlciBhcnJheS1saWtlIG9iamVjdHMuJztcbiAgICAgICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgYXJnICYmIFN5bWJvbC5pdGVyYXRvciBpbiBhcmcpIHtcbiAgICAgICAgICAgIG1zZyArPSAnIFlvdSBjYW4gdXNlIGEgc3ByZWFkIHRvIGNvbnZlcnQgdGhpcyBpdGVyYWJsZSBpbnRvIGFuIGFycmF5Lic7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVfc2xvdHMobmFtZSwgc2xvdCwga2V5cykge1xuICAgIGZvciAoY29uc3Qgc2xvdF9rZXkgb2YgT2JqZWN0LmtleXMoc2xvdCkpIHtcbiAgICAgICAgaWYgKCF+a2V5cy5pbmRleE9mKHNsb3Rfa2V5KSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGA8JHtuYW1lfT4gcmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBzbG90IFwiJHtzbG90X2tleX1cIi5gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlX2R5bmFtaWNfZWxlbWVudCh0YWcpIHtcbiAgICBjb25zdCBpc19zdHJpbmcgPSB0eXBlb2YgdGFnID09PSAnc3RyaW5nJztcbiAgICBpZiAodGFnICYmICFpc19zdHJpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCc8c3ZlbHRlOmVsZW1lbnQ+IGV4cGVjdHMgXCJ0aGlzXCIgYXR0cmlidXRlIHRvIGJlIGEgc3RyaW5nLicpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlX3ZvaWRfZHluYW1pY19lbGVtZW50KHRhZykge1xuICAgIGlmICh0YWcgJiYgaXNfdm9pZCh0YWcpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgPHN2ZWx0ZTplbGVtZW50IHRoaXM9XCIke3RhZ31cIj4gaXMgc2VsZi1jbG9zaW5nIGFuZCBjYW5ub3QgaGF2ZSBjb250ZW50LmApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbnN0cnVjdF9zdmVsdGVfY29tcG9uZW50X2Rldihjb21wb25lbnQsIHByb3BzKSB7XG4gICAgY29uc3QgZXJyb3JfbWVzc2FnZSA9ICd0aGlzPXsuLi59IG9mIDxzdmVsdGU6Y29tcG9uZW50PiBzaG91bGQgc3BlY2lmeSBhIFN2ZWx0ZSBjb21wb25lbnQuJztcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IG5ldyBjb21wb25lbnQocHJvcHMpO1xuICAgICAgICBpZiAoIWluc3RhbmNlLiQkIHx8ICFpbnN0YW5jZS4kc2V0IHx8ICFpbnN0YW5jZS4kb24gfHwgIWluc3RhbmNlLiRkZXN0cm95KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JfbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZSB9ID0gZXJyO1xuICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnICYmIG1lc3NhZ2UuaW5kZXhPZignaXMgbm90IGEgY29uc3RydWN0b3InKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcl9tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgU3ZlbHRlIGNvbXBvbmVudHMgd2l0aCBzb21lIG1pbm9yIGRldi1lbmhhbmNlbWVudHMuIFVzZWQgd2hlbiBkZXY9dHJ1ZS5cbiAqL1xuY2xhc3MgU3ZlbHRlQ29tcG9uZW50RGV2IGV4dGVuZHMgU3ZlbHRlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucyB8fCAoIW9wdGlvbnMudGFyZ2V0ICYmICFvcHRpb25zLiQkaW5saW5lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ3RhcmdldCcgaXMgYSByZXF1aXJlZCBvcHRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG4gICAgJGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLiRkZXN0cm95KCk7XG4gICAgICAgIHRoaXMuJGRlc3Ryb3kgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0NvbXBvbmVudCB3YXMgYWxyZWFkeSBkZXN0cm95ZWQnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgICAgIH07XG4gICAgfVxuICAgICRjYXB0dXJlX3N0YXRlKCkgeyB9XG4gICAgJGluamVjdF9zdGF0ZSgpIHsgfVxufVxuLyoqXG4gKiBCYXNlIGNsYXNzIHRvIGNyZWF0ZSBzdHJvbmdseSB0eXBlZCBTdmVsdGUgY29tcG9uZW50cy5cbiAqIFRoaXMgb25seSBleGlzdHMgZm9yIHR5cGluZyBwdXJwb3NlcyBhbmQgc2hvdWxkIGJlIHVzZWQgaW4gYC5kLnRzYCBmaWxlcy5cbiAqXG4gKiAjIyMgRXhhbXBsZTpcbiAqXG4gKiBZb3UgaGF2ZSBjb21wb25lbnQgbGlicmFyeSBvbiBucG0gY2FsbGVkIGBjb21wb25lbnQtbGlicmFyeWAsIGZyb20gd2hpY2hcbiAqIHlvdSBleHBvcnQgYSBjb21wb25lbnQgY2FsbGVkIGBNeUNvbXBvbmVudGAuIEZvciBTdmVsdGUrVHlwZVNjcmlwdCB1c2VycyxcbiAqIHlvdSB3YW50IHRvIHByb3ZpZGUgdHlwaW5ncy4gVGhlcmVmb3JlIHlvdSBjcmVhdGUgYSBgaW5kZXguZC50c2A6XG4gKiBgYGB0c1xuICogaW1wb3J0IHsgU3ZlbHRlQ29tcG9uZW50VHlwZWQgfSBmcm9tIFwic3ZlbHRlXCI7XG4gKiBleHBvcnQgY2xhc3MgTXlDb21wb25lbnQgZXh0ZW5kcyBTdmVsdGVDb21wb25lbnRUeXBlZDx7Zm9vOiBzdHJpbmd9PiB7fVxuICogYGBgXG4gKiBUeXBpbmcgdGhpcyBtYWtlcyBpdCBwb3NzaWJsZSBmb3IgSURFcyBsaWtlIFZTIENvZGUgd2l0aCB0aGUgU3ZlbHRlIGV4dGVuc2lvblxuICogdG8gcHJvdmlkZSBpbnRlbGxpc2Vuc2UgYW5kIHRvIHVzZSB0aGUgY29tcG9uZW50IGxpa2UgdGhpcyBpbiBhIFN2ZWx0ZSBmaWxlXG4gKiB3aXRoIFR5cGVTY3JpcHQ6XG4gKiBgYGBzdmVsdGVcbiAqIDxzY3JpcHQgbGFuZz1cInRzXCI+XG4gKiBcdGltcG9ydCB7IE15Q29tcG9uZW50IH0gZnJvbSBcImNvbXBvbmVudC1saWJyYXJ5XCI7XG4gKiA8L3NjcmlwdD5cbiAqIDxNeUNvbXBvbmVudCBmb289eydiYXInfSAvPlxuICogYGBgXG4gKlxuICogIyMjIyBXaHkgbm90IG1ha2UgdGhpcyBwYXJ0IG9mIGBTdmVsdGVDb21wb25lbnQoRGV2KWA/XG4gKiBCZWNhdXNlXG4gKiBgYGB0c1xuICogY2xhc3MgQVN1YmNsYXNzT2ZTdmVsdGVDb21wb25lbnQgZXh0ZW5kcyBTdmVsdGVDb21wb25lbnQ8e2Zvbzogc3RyaW5nfT4ge31cbiAqIGNvbnN0IGNvbXBvbmVudDogdHlwZW9mIFN2ZWx0ZUNvbXBvbmVudCA9IEFTdWJjbGFzc09mU3ZlbHRlQ29tcG9uZW50O1xuICogYGBgXG4gKiB3aWxsIHRocm93IGEgdHlwZSBlcnJvciwgc28gd2UgbmVlZCB0byBzZXBhcmF0ZSB0aGUgbW9yZSBzdHJpY3RseSB0eXBlZCBjbGFzcy5cbiAqL1xuY2xhc3MgU3ZlbHRlQ29tcG9uZW50VHlwZWQgZXh0ZW5kcyBTdmVsdGVDb21wb25lbnREZXYge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG4gICAgfVxufVxuZnVuY3Rpb24gbG9vcF9ndWFyZCh0aW1lb3V0KSB7XG4gICAgY29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChEYXRlLm5vdygpIC0gc3RhcnQgPiB0aW1lb3V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luZmluaXRlIGxvb3AgZGV0ZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmV4cG9ydCB7IEh0bWxUYWcsIEh0bWxUYWdIeWRyYXRpb24sIFJlc2l6ZU9ic2VydmVyU2luZ2xldG9uLCBTdmVsdGVDb21wb25lbnQsIFN2ZWx0ZUNvbXBvbmVudERldiwgU3ZlbHRlQ29tcG9uZW50VHlwZWQsIFN2ZWx0ZUVsZW1lbnQsIGFjdGlvbl9kZXN0cm95ZXIsIGFkZF9hdHRyaWJ1dGUsIGFkZF9jbGFzc2VzLCBhZGRfZmx1c2hfY2FsbGJhY2ssIGFkZF9pZnJhbWVfcmVzaXplX2xpc3RlbmVyLCBhZGRfbG9jYXRpb24sIGFkZF9yZW5kZXJfY2FsbGJhY2ssIGFkZF9zdHlsZXMsIGFkZF90cmFuc2Zvcm0sIGFmdGVyVXBkYXRlLCBhcHBlbmQsIGFwcGVuZF9kZXYsIGFwcGVuZF9lbXB0eV9zdHlsZXNoZWV0LCBhcHBlbmRfaHlkcmF0aW9uLCBhcHBlbmRfaHlkcmF0aW9uX2RldiwgYXBwZW5kX3N0eWxlcywgYXNzaWduLCBhdHRyLCBhdHRyX2RldiwgYXR0cmlidXRlX3RvX29iamVjdCwgYmVmb3JlVXBkYXRlLCBiaW5kLCBiaW5kaW5nX2NhbGxiYWNrcywgYmxhbmtfb2JqZWN0LCBidWJibGUsIGNoZWNrX291dHJvcywgY2hpbGRyZW4sIGNsYWltX2NvbW1lbnQsIGNsYWltX2NvbXBvbmVudCwgY2xhaW1fZWxlbWVudCwgY2xhaW1faHRtbF90YWcsIGNsYWltX3NwYWNlLCBjbGFpbV9zdmdfZWxlbWVudCwgY2xhaW1fdGV4dCwgY2xlYXJfbG9vcHMsIGNvbW1lbnQsIGNvbXBvbmVudF9zdWJzY3JpYmUsIGNvbXB1dGVfcmVzdF9wcm9wcywgY29tcHV0ZV9zbG90cywgY29uc3RydWN0X3N2ZWx0ZV9jb21wb25lbnQsIGNvbnN0cnVjdF9zdmVsdGVfY29tcG9uZW50X2RldiwgY29udGVudGVkaXRhYmxlX3RydXRoeV92YWx1ZXMsIGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciwgY3JlYXRlX2FuaW1hdGlvbiwgY3JlYXRlX2JpZGlyZWN0aW9uYWxfdHJhbnNpdGlvbiwgY3JlYXRlX2NvbXBvbmVudCwgY3JlYXRlX2luX3RyYW5zaXRpb24sIGNyZWF0ZV9vdXRfdHJhbnNpdGlvbiwgY3JlYXRlX3Nsb3QsIGNyZWF0ZV9zc3JfY29tcG9uZW50LCBjdXJyZW50X2NvbXBvbmVudCwgY3VzdG9tX2V2ZW50LCBkYXRhc2V0X2RldiwgZGVidWcsIGRlc3Ryb3lfYmxvY2ssIGRlc3Ryb3lfY29tcG9uZW50LCBkZXN0cm95X2VhY2gsIGRldGFjaCwgZGV0YWNoX2FmdGVyX2RldiwgZGV0YWNoX2JlZm9yZV9kZXYsIGRldGFjaF9iZXR3ZWVuX2RldiwgZGV0YWNoX2RldiwgZGlydHlfY29tcG9uZW50cywgZGlzcGF0Y2hfZGV2LCBlYWNoLCBlbGVtZW50LCBlbGVtZW50X2lzLCBlbXB0eSwgZW5kX2h5ZHJhdGluZywgZXNjYXBlLCBlc2NhcGVfYXR0cmlidXRlX3ZhbHVlLCBlc2NhcGVfb2JqZWN0LCBleGNsdWRlX2ludGVybmFsX3Byb3BzLCBmaXhfYW5kX2Rlc3Ryb3lfYmxvY2ssIGZpeF9hbmRfb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2ssIGZpeF9wb3NpdGlvbiwgZmx1c2gsIGZsdXNoX3JlbmRlcl9jYWxsYmFja3MsIGdldEFsbENvbnRleHRzLCBnZXRDb250ZXh0LCBnZXRfYWxsX2RpcnR5X2Zyb21fc2NvcGUsIGdldF9iaW5kaW5nX2dyb3VwX3ZhbHVlLCBnZXRfY3VycmVudF9jb21wb25lbnQsIGdldF9jdXN0b21fZWxlbWVudHNfc2xvdHMsIGdldF9yb290X2Zvcl9zdHlsZSwgZ2V0X3Nsb3RfY2hhbmdlcywgZ2V0X3NwcmVhZF9vYmplY3QsIGdldF9zcHJlYWRfdXBkYXRlLCBnZXRfc3RvcmVfdmFsdWUsIGdsb2JhbHMsIGdyb3VwX291dHJvcywgaGFuZGxlX3Byb21pc2UsIGhhc0NvbnRleHQsIGhhc19wcm9wLCBoZWFkX3NlbGVjdG9yLCBpZGVudGl0eSwgaW5pdCwgaW5pdF9iaW5kaW5nX2dyb3VwLCBpbml0X2JpbmRpbmdfZ3JvdXBfZHluYW1pYywgaW5zZXJ0LCBpbnNlcnRfZGV2LCBpbnNlcnRfaHlkcmF0aW9uLCBpbnNlcnRfaHlkcmF0aW9uX2RldiwgaW50cm9zLCBpbnZhbGlkX2F0dHJpYnV0ZV9uYW1lX2NoYXJhY3RlciwgaXNfY2xpZW50LCBpc19jcm9zc29yaWdpbiwgaXNfZW1wdHksIGlzX2Z1bmN0aW9uLCBpc19wcm9taXNlLCBpc192b2lkLCBsaXN0ZW4sIGxpc3Rlbl9kZXYsIGxvb3AsIGxvb3BfZ3VhcmQsIG1lcmdlX3Nzcl9zdHlsZXMsIG1pc3NpbmdfY29tcG9uZW50LCBtb3VudF9jb21wb25lbnQsIG5vb3AsIG5vdF9lcXVhbCwgbm93LCBudWxsX3RvX2VtcHR5LCBvYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzLCBvbkRlc3Ryb3ksIG9uTW91bnQsIG9uY2UsIG91dHJvX2FuZF9kZXN0cm95X2Jsb2NrLCBwcmV2ZW50X2RlZmF1bHQsIHByb3BfZGV2LCBxdWVyeV9zZWxlY3Rvcl9hbGwsIHJhZiwgcmVzaXplX29ic2VydmVyX2JvcmRlcl9ib3gsIHJlc2l6ZV9vYnNlcnZlcl9jb250ZW50X2JveCwgcmVzaXplX29ic2VydmVyX2RldmljZV9waXhlbF9jb250ZW50X2JveCwgcnVuLCBydW5fYWxsLCBzYWZlX25vdF9lcXVhbCwgc2NoZWR1bGVfdXBkYXRlLCBzZWxlY3RfbXVsdGlwbGVfdmFsdWUsIHNlbGVjdF9vcHRpb24sIHNlbGVjdF9vcHRpb25zLCBzZWxlY3RfdmFsdWUsIHNlbGYsIHNldENvbnRleHQsIHNldF9hdHRyaWJ1dGVzLCBzZXRfY3VycmVudF9jb21wb25lbnQsIHNldF9jdXN0b21fZWxlbWVudF9kYXRhLCBzZXRfY3VzdG9tX2VsZW1lbnRfZGF0YV9tYXAsIHNldF9kYXRhLCBzZXRfZGF0YV9jb250ZW50ZWRpdGFibGUsIHNldF9kYXRhX2NvbnRlbnRlZGl0YWJsZV9kZXYsIHNldF9kYXRhX2Rldiwgc2V0X2RhdGFfbWF5YmVfY29udGVudGVkaXRhYmxlLCBzZXRfZGF0YV9tYXliZV9jb250ZW50ZWRpdGFibGVfZGV2LCBzZXRfZHluYW1pY19lbGVtZW50X2RhdGEsIHNldF9pbnB1dF90eXBlLCBzZXRfaW5wdXRfdmFsdWUsIHNldF9ub3csIHNldF9yYWYsIHNldF9zdG9yZV92YWx1ZSwgc2V0X3N0eWxlLCBzZXRfc3ZnX2F0dHJpYnV0ZXMsIHNwYWNlLCBzcGxpdF9jc3NfdW5pdCwgc3ByZWFkLCBzcmNfdXJsX2VxdWFsLCBzdGFydF9oeWRyYXRpbmcsIHN0b3BfaW1tZWRpYXRlX3Byb3BhZ2F0aW9uLCBzdG9wX3Byb3BhZ2F0aW9uLCBzdWJzY3JpYmUsIHN2Z19lbGVtZW50LCB0ZXh0LCB0aWNrLCB0aW1lX3Jhbmdlc190b19hcnJheSwgdG9fbnVtYmVyLCB0b2dnbGVfY2xhc3MsIHRyYW5zaXRpb25faW4sIHRyYW5zaXRpb25fb3V0LCB0cnVzdGVkLCB1cGRhdGVfYXdhaXRfYmxvY2tfYnJhbmNoLCB1cGRhdGVfa2V5ZWRfZWFjaCwgdXBkYXRlX3Nsb3QsIHVwZGF0ZV9zbG90X2Jhc2UsIHZhbGlkYXRlX2NvbXBvbmVudCwgdmFsaWRhdGVfZHluYW1pY19lbGVtZW50LCB2YWxpZGF0ZV9lYWNoX2FyZ3VtZW50LCB2YWxpZGF0ZV9lYWNoX2tleXMsIHZhbGlkYXRlX3Nsb3RzLCB2YWxpZGF0ZV9zdG9yZSwgdmFsaWRhdGVfdm9pZF9keW5hbWljX2VsZW1lbnQsIHhsaW5rX2F0dHIgfTtcbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICcuLi91dGlscy90eXBlLWNoZWNrJztcblxuICBleHBvcnQgbGV0IGNvbmZpZywgc3RlcDtcbiAgbGV0IGFjdGlvbiwgY2xhc3NlcywgZGlzYWJsZWQsIGxhYmVsLCBzZWNvbmRhcnksIHRleHQ7XG5cbiAgJDoge1xuICAgIGFjdGlvbiA9IGNvbmZpZy5hY3Rpb24gPyBjb25maWcuYWN0aW9uLmJpbmQoc3RlcC50b3VyKSA6IG51bGw7XG4gICAgY2xhc3NlcyA9IGNvbmZpZy5jbGFzc2VzO1xuICAgIGRpc2FibGVkID0gY29uZmlnLmRpc2FibGVkID8gZ2V0Q29uZmlnT3B0aW9uKGNvbmZpZy5kaXNhYmxlZCkgOiBmYWxzZTtcbiAgICBsYWJlbCA9IGNvbmZpZy5sYWJlbCA/IGdldENvbmZpZ09wdGlvbihjb25maWcubGFiZWwpIDogbnVsbDtcbiAgICBzZWNvbmRhcnkgPSBjb25maWcuc2Vjb25kYXJ5O1xuICAgIHRleHQgPSBjb25maWcudGV4dCA/IGdldENvbmZpZ09wdGlvbihjb25maWcudGV4dCkgOiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q29uZmlnT3B0aW9uKG9wdGlvbikge1xuICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbikpIHtcbiAgICAgIHJldHVybiBvcHRpb24gPSBvcHRpb24uY2FsbChzdGVwKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbjtcbiAgfVxuXG48L3NjcmlwdD5cblxuPHN0eWxlIGdsb2JhbD5cbiAgLnNoZXBoZXJkLWJ1dHRvbiB7XG4gICAgYmFja2dyb3VuZDogcmdiKDUwLCAxMzYsIDIzMCk7XG4gICAgYm9yZGVyOiAwO1xuICAgIGJvcmRlci1yYWRpdXM6IDNweDtcbiAgICBjb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjc1KTtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgbWFyZ2luLXJpZ2h0OiAwLjVyZW07XG4gICAgcGFkZGluZzogMC41cmVtIDEuNXJlbTtcbiAgICB0cmFuc2l0aW9uOiBhbGwgMC41cyBlYXNlO1xuICB9XG5cbiAgLnNoZXBoZXJkLWJ1dHRvbjpub3QoOmRpc2FibGVkKTpob3ZlciB7XG4gICAgYmFja2dyb3VuZDogcmdiKDI1LCAxMTEsIDIwNCk7XG4gICAgY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC43NSk7XG4gIH1cblxuICAuc2hlcGhlcmQtYnV0dG9uLnNoZXBoZXJkLWJ1dHRvbi1zZWNvbmRhcnkge1xuICAgIGJhY2tncm91bmQ6IHJnYigyNDEsIDI0MiwgMjQzKTtcbiAgICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjc1KTtcbiAgfVxuXG4gIC5zaGVwaGVyZC1idXR0b24uc2hlcGhlcmQtYnV0dG9uLXNlY29uZGFyeTpub3QoOmRpc2FibGVkKTpob3ZlciB7XG4gICAgYmFja2dyb3VuZDogcmdiKDIxNCwgMjE3LCAyMTkpO1xuICAgIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNzUpO1xuICB9XG5cbiAgLnNoZXBoZXJkLWJ1dHRvbjpkaXNhYmxlZCB7XG4gICAgY3Vyc29yOiBub3QtYWxsb3dlZDtcbiAgfVxuPC9zdHlsZT5cblxuPGJ1dHRvblxuICBhcmlhLWxhYmVsPVwie2xhYmVsID8gbGFiZWwgOiBudWxsfVwiXG4gIGNsYXNzPVwie2AkeyhjbGFzc2VzIHx8ICcnKX0gc2hlcGhlcmQtYnV0dG9uICR7KHNlY29uZGFyeSA/ICdzaGVwaGVyZC1idXR0b24tc2Vjb25kYXJ5JyA6ICcnKX1gfVwiXG4gIGRpc2FibGVkPXtkaXNhYmxlZH1cbiAgb246Y2xpY2s9e2FjdGlvbn1cbiAgdGFiaW5kZXg9XCIwXCJcbj5cbiAgICB7QGh0bWwgdGV4dH1cbjwvYnV0dG9uPlxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IFNoZXBoZXJkQnV0dG9uIGZyb20gJy4vc2hlcGhlcmQtYnV0dG9uLnN2ZWx0ZSc7XG5cbiAgZXhwb3J0IGxldCBzdGVwO1xuXG4gICQ6IGJ1dHRvbnMgPSBzdGVwLm9wdGlvbnMuYnV0dG9ucztcbjwvc2NyaXB0PlxuXG48c3R5bGUgZ2xvYmFsPlxuICAuc2hlcGhlcmQtZm9vdGVyIHtcbiAgICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiA1cHg7XG4gICAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDVweDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XG4gICAgcGFkZGluZzogMCAwLjc1cmVtIDAuNzVyZW07XG4gIH1cblxuICAuc2hlcGhlcmQtZm9vdGVyIC5zaGVwaGVyZC1idXR0b246bGFzdC1jaGlsZCB7XG4gICAgbWFyZ2luLXJpZ2h0OiAwO1xuICB9XG48L3N0eWxlPlxuXG48Zm9vdGVyIGNsYXNzPVwic2hlcGhlcmQtZm9vdGVyXCI+XG4gICAgeyNpZiBidXR0b25zfVxuICAgICAgICB7I2VhY2ggYnV0dG9ucyBhcyBjb25maWd9XG4gICAgICAgICAgPFNoZXBoZXJkQnV0dG9uXG4gICAgICAgICAgICB7Y29uZmlnfVxuICAgICAgICAgICAge3N0ZXB9XG4gICAgICAgICAgLz5cbiAgICAgICAgey9lYWNofVxuICAgIHsvaWZ9XG48L2Zvb3Rlcj5cbiIsIjxzY3JpcHQ+XG4gIGV4cG9ydCBsZXQgY2FuY2VsSWNvbiwgc3RlcDtcblxuICAvKipcbiAgICogQWRkIGEgY2xpY2sgbGlzdGVuZXIgdG8gdGhlIGNhbmNlbCBsaW5rIHRoYXQgY2FuY2VscyB0aGUgdG91clxuICAgKi9cbiAgY29uc3QgaGFuZGxlQ2FuY2VsQ2xpY2sgPSAoZSkgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBzdGVwLmNhbmNlbCgpO1xuICB9O1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBnbG9iYWw+XG4gIC5zaGVwaGVyZC1jYW5jZWwtaWNvbiB7XG4gICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG4gICAgYm9yZGVyOiBub25lO1xuICAgIGNvbG9yOiByZ2JhKDEyOCwgMTI4LCAxMjgsIDAuNzUpO1xuICAgIGZvbnQtc2l6ZTogMmVtO1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICBmb250LXdlaWdodDogbm9ybWFsO1xuICAgIG1hcmdpbjogMDtcbiAgICBwYWRkaW5nOiAwO1xuICAgIHRyYW5zaXRpb246IGNvbG9yIDAuNXMgZWFzZTtcbiAgfVxuXG4gIC5zaGVwaGVyZC1jYW5jZWwtaWNvbjpob3ZlciB7XG4gICAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC43NSk7XG4gIH1cblxuICAuc2hlcGhlcmQtaGFzLXRpdGxlIC5zaGVwaGVyZC1jb250ZW50IC5zaGVwaGVyZC1jYW5jZWwtaWNvbiB7XG4gICAgY29sb3I6IHJnYmEoMTI4LCAxMjgsIDEyOCwgMC43NSk7XG4gIH1cblxuICAuc2hlcGhlcmQtaGFzLXRpdGxlIC5zaGVwaGVyZC1jb250ZW50IC5zaGVwaGVyZC1jYW5jZWwtaWNvbjpob3ZlciB7XG4gICAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC43NSk7XG4gIH1cbjwvc3R5bGU+XG5cbjxidXR0b25cbiAgYXJpYS1sYWJlbD1cIntjYW5jZWxJY29uLmxhYmVsID8gY2FuY2VsSWNvbi5sYWJlbCA6ICdDbG9zZSBUb3VyJ31cIlxuICBjbGFzcz1cInNoZXBoZXJkLWNhbmNlbC1pY29uXCJcbiAgb246Y2xpY2s9e2hhbmRsZUNhbmNlbENsaWNrfVxuICB0eXBlPVwiYnV0dG9uXCJcbj5cbiAgPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+JnRpbWVzOzwvc3Bhbj5cbjwvYnV0dG9uPlxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgYWZ0ZXJVcGRhdGUgfSBmcm9tICdzdmVsdGUnO1xuICBpbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnLi4vdXRpbHMvdHlwZS1jaGVjayc7XG4gIFxuICBleHBvcnQgbGV0IGxhYmVsSWQsIGVsZW1lbnQsIHRpdGxlO1xuICBcbiAgYWZ0ZXJVcGRhdGUoKCkgPT4ge1xuICAgIGlmIChpc0Z1bmN0aW9uKHRpdGxlKSkge1xuICAgICAgdGl0bGUgPSB0aXRsZSgpO1xuICAgIH1cbiAgICBcbiAgICBlbGVtZW50LmlubmVySFRNTCA9IHRpdGxlO1xuICB9KTtcbjwvc2NyaXB0PlxuXG48c3R5bGUgZ2xvYmFsPlxuICAuc2hlcGhlcmQtdGl0bGUge1xuICAgIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNzUpO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZm9udC1zaXplOiAxcmVtO1xuICAgIGZvbnQtd2VpZ2h0OiBub3JtYWw7XG4gICAgZmxleDogMSAwIGF1dG87XG4gICAgbWFyZ2luOiAwO1xuICAgIHBhZGRpbmc6IDA7XG4gIH1cbjwvc3R5bGU+XG5cbjxoM1xuICBiaW5kOnRoaXM9e2VsZW1lbnR9XG4gIGlkPVwie2xhYmVsSWR9XCJcbiAgY2xhc3M9XCJzaGVwaGVyZC10aXRsZVwiXG4+XG48L2gzPlxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IFNoZXBoZXJkQ2FuY2VsSWNvbiBmcm9tICcuL3NoZXBoZXJkLWNhbmNlbC1pY29uLnN2ZWx0ZSc7XG4gIGltcG9ydCBTaGVwaGVyZFRpdGxlIGZyb20gJy4vc2hlcGhlcmQtdGl0bGUuc3ZlbHRlJztcblxuICBleHBvcnQgbGV0IGxhYmVsSWQsIHN0ZXA7XG4gIGxldCB0aXRsZSwgY2FuY2VsSWNvbjtcblxuICAkOiB7XG4gICAgICB0aXRsZSA9IHN0ZXAub3B0aW9ucy50aXRsZTtcbiAgICAgIGNhbmNlbEljb24gPSBzdGVwLm9wdGlvbnMuY2FuY2VsSWNvbjtcbiAgfVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBnbG9iYWw+XG4gIC5zaGVwaGVyZC1oZWFkZXIge1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogNXB4O1xuICAgIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiA1cHg7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtZW5kO1xuICAgIGxpbmUtaGVpZ2h0OiAyZW07XG4gICAgcGFkZGluZzogMC43NXJlbSAwLjc1cmVtIDA7XG4gIH1cblxuICAuc2hlcGhlcmQtaGFzLXRpdGxlIC5zaGVwaGVyZC1jb250ZW50IC5zaGVwaGVyZC1oZWFkZXIge1xuICAgIGJhY2tncm91bmQ6ICNlNmU2ZTY7XG4gICAgcGFkZGluZzogMWVtO1xuICB9XG48L3N0eWxlPlxuXG48aGVhZGVyIGNsYXNzPVwic2hlcGhlcmQtaGVhZGVyXCI+XG4gICAgeyNpZiB0aXRsZX1cbiAgICAgIDxTaGVwaGVyZFRpdGxlXG4gICAgICAgIHtsYWJlbElkfVxuICAgICAgICB7dGl0bGV9XG4gICAgICAvPlxuICAgIHsvaWZ9XG5cbiAgICB7I2lmIGNhbmNlbEljb24gJiYgY2FuY2VsSWNvbi5lbmFibGVkfVxuICAgICAgPFNoZXBoZXJkQ2FuY2VsSWNvblxuICAgICAgICB7Y2FuY2VsSWNvbn1cbiAgICAgICAge3N0ZXB9XG4gICAgICAvPlxuICAgIHsvaWZ9XG48L2hlYWRlcj5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IGFmdGVyVXBkYXRlIH0gZnJvbSAnc3ZlbHRlJztcbiAgaW1wb3J0IHsgaXNIVE1MRWxlbWVudCwgaXNGdW5jdGlvbiB9IGZyb20gJy4uL3V0aWxzL3R5cGUtY2hlY2snO1xuXG4gIGV4cG9ydCBsZXQgZGVzY3JpcHRpb25JZCwgZWxlbWVudCwgc3RlcDtcblxuICBhZnRlclVwZGF0ZSgoKSA9PiB7XG4gICAgbGV0IHsgdGV4dCB9ID0gc3RlcC5vcHRpb25zO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24odGV4dCkpIHtcbiAgICAgIHRleHQgPSB0ZXh0LmNhbGwoc3RlcCk7XG4gICAgfVxuXG4gICAgaWYgKGlzSFRNTEVsZW1lbnQodGV4dCkpIHtcbiAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQodGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gdGV4dDtcbiAgICB9XG4gIH0pO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBnbG9iYWw+XG4gIC5zaGVwaGVyZC10ZXh0IHtcbiAgICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjc1KTtcbiAgICBmb250LXNpemU6IDFyZW07XG4gICAgbGluZS1oZWlnaHQ6IDEuM2VtO1xuICAgIHBhZGRpbmc6IDAuNzVlbTtcbiAgfVxuXG4gIC5zaGVwaGVyZC10ZXh0IHAge1xuICAgIG1hcmdpbi10b3A6IDA7XG4gIH1cblxuICAuc2hlcGhlcmQtdGV4dCBwOmxhc3QtY2hpbGQge1xuICAgIG1hcmdpbi1ib3R0b206IDA7XG4gIH1cbjwvc3R5bGU+XG5cbjxkaXZcbiAgYmluZDp0aGlzPXtlbGVtZW50fVxuICBjbGFzcz1cInNoZXBoZXJkLXRleHRcIlxuICBpZD1cIntkZXNjcmlwdGlvbklkfVwiXG4+XG48L2Rpdj5cblxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IFNoZXBoZXJkRm9vdGVyIGZyb20gJy4vc2hlcGhlcmQtZm9vdGVyLnN2ZWx0ZSc7XG4gIGltcG9ydCBTaGVwaGVyZEhlYWRlciBmcm9tICcuL3NoZXBoZXJkLWhlYWRlci5zdmVsdGUnO1xuICBpbXBvcnQgU2hlcGhlcmRUZXh0IGZyb20gJy4vc2hlcGhlcmQtdGV4dC5zdmVsdGUnO1xuICBpbXBvcnQgeyBpc1VuZGVmaW5lZCB9IGZyb20gJy4uL3V0aWxzL3R5cGUtY2hlY2suanMnO1xuXG4gIGV4cG9ydCBsZXQgZGVzY3JpcHRpb25JZCwgbGFiZWxJZCwgc3RlcDtcbjwvc2NyaXB0PlxuXG48c3R5bGUgZ2xvYmFsPlxuICAuc2hlcGhlcmQtY29udGVudCB7XG4gICAgYm9yZGVyLXJhZGl1czogNXB4O1xuICAgIG91dGxpbmU6IG5vbmU7XG4gICAgcGFkZGluZzogMDtcbiAgfVxuPC9zdHlsZT5cblxuPGRpdlxuICBjbGFzcz1cInNoZXBoZXJkLWNvbnRlbnRcIlxuPlxuICB7I2lmICFpc1VuZGVmaW5lZChzdGVwLm9wdGlvbnMudGl0bGUpIHx8IChzdGVwLm9wdGlvbnMuY2FuY2VsSWNvbiAmJiBzdGVwLm9wdGlvbnMuY2FuY2VsSWNvbi5lbmFibGVkKX1cbiAgICA8U2hlcGhlcmRIZWFkZXJcbiAgICAgIHtsYWJlbElkfVxuICAgICAge3N0ZXB9XG4gICAgLz5cbiAgey9pZn1cblxuICB7I2lmICFpc1VuZGVmaW5lZChzdGVwLm9wdGlvbnMudGV4dCl9XG4gICAgPFNoZXBoZXJkVGV4dFxuICAgICAge2Rlc2NyaXB0aW9uSWR9XG4gICAgICB7c3RlcH1cbiAgICAvPlxuICB7L2lmfVxuXG4gIHsjaWYgQXJyYXkuaXNBcnJheShzdGVwLm9wdGlvbnMuYnV0dG9ucykgJiYgc3RlcC5vcHRpb25zLmJ1dHRvbnMubGVuZ3RofVxuICAgIDxTaGVwaGVyZEZvb3RlclxuICAgICAge3N0ZXB9XG4gICAgLz5cbiAgey9pZn1cbjwvZGl2PlxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgb25Nb3VudCwgYWZ0ZXJVcGRhdGUgfSBmcm9tICdzdmVsdGUnO1xuICBpbXBvcnQgU2hlcGhlcmRDb250ZW50IGZyb20gJy4vc2hlcGhlcmQtY29udGVudC5zdmVsdGUnO1xuICBpbXBvcnQgeyBpc1VuZGVmaW5lZCwgaXNTdHJpbmcgfSBmcm9tICcuLi91dGlscy90eXBlLWNoZWNrLmpzJztcblxuICBjb25zdCBLRVlfVEFCID0gOTtcbiAgY29uc3QgS0VZX0VTQyA9IDI3O1xuICBjb25zdCBMRUZUX0FSUk9XID0gMzc7XG4gIGNvbnN0IFJJR0hUX0FSUk9XID0gMzk7XG5cbiAgZXhwb3J0IGxldCBjbGFzc1ByZWZpeCwgZWxlbWVudCwgZGVzY3JpcHRpb25JZCwgZmlyc3RGb2N1c2FibGVFbGVtZW50LFxuICAgIGZvY3VzYWJsZUVsZW1lbnRzLCBsYWJlbElkLCBsYXN0Rm9jdXNhYmxlRWxlbWVudCwgc3RlcCwgZGF0YVN0ZXBJZDtcblxuICBsZXQgaGFzQ2FuY2VsSWNvbiwgaGFzVGl0bGUsIGNsYXNzZXM7XG5cbiAgJDoge1xuICAgIGhhc0NhbmNlbEljb24gPSBzdGVwLm9wdGlvbnMgJiYgc3RlcC5vcHRpb25zLmNhbmNlbEljb24gJiYgc3RlcC5vcHRpb25zLmNhbmNlbEljb24uZW5hYmxlZDtcbiAgICBoYXNUaXRsZSA9IHN0ZXAub3B0aW9ucyAmJiBzdGVwLm9wdGlvbnMudGl0bGU7XG4gIH1cblxuICBleHBvcnQgY29uc3QgZ2V0RWxlbWVudCA9ICgpID0+IGVsZW1lbnQ7XG5cbiAgb25Nb3VudCgoKSA9PiB7XG4gICAgLy8gR2V0IGFsbCBlbGVtZW50cyB0aGF0IGFyZSBmb2N1c2FibGVcbiAgICBkYXRhU3RlcElkID0geyBbYGRhdGEtJHtjbGFzc1ByZWZpeH1zaGVwaGVyZC1zdGVwLWlkYF06IHN0ZXAuaWQgfTtcbiAgICBmb2N1c2FibGVFbGVtZW50cyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnYVtocmVmXSwgYXJlYVtocmVmXSwgaW5wdXQ6bm90KFtkaXNhYmxlZF0pLCBzZWxlY3Q6bm90KFtkaXNhYmxlZF0pLCB0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSksIGJ1dHRvbjpub3QoW2Rpc2FibGVkXSksIFt0YWJpbmRleD1cIjBcIl0nKTtcbiAgICBmaXJzdEZvY3VzYWJsZUVsZW1lbnQgPSBmb2N1c2FibGVFbGVtZW50c1swXTtcbiAgICBsYXN0Rm9jdXNhYmxlRWxlbWVudCA9IGZvY3VzYWJsZUVsZW1lbnRzW2ZvY3VzYWJsZUVsZW1lbnRzLmxlbmd0aCAtIDFdO1xuICB9KTtcblxuICBhZnRlclVwZGF0ZSgoKSA9PiB7XG4gICAgaWYoY2xhc3NlcyAhPT0gc3RlcC5vcHRpb25zLmNsYXNzZXMpIHtcbiAgICAgIHVwZGF0ZUR5bmFtaWNDbGFzc2VzKCk7XG4gICAgfVxuICB9KTtcblxuICBmdW5jdGlvbiB1cGRhdGVEeW5hbWljQ2xhc3NlcygpIHtcbiAgICAgIHJlbW92ZUNsYXNzZXMoY2xhc3Nlcyk7XG4gICAgICBjbGFzc2VzID0gc3RlcC5vcHRpb25zLmNsYXNzZXM7XG4gICAgICBhZGRDbGFzc2VzKGNsYXNzZXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQ2xhc3NlcyhjbGFzc2VzKSB7XG4gICAgaWYgKGlzU3RyaW5nKGNsYXNzZXMpKSB7XG4gICAgICBjb25zdCBvbGRDbGFzc2VzID0gZ2V0Q2xhc3Nlc0FycmF5KGNsYXNzZXMpO1xuICAgICAgaWYgKG9sZENsYXNzZXMubGVuZ3RoKSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSguLi5vbGRDbGFzc2VzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRDbGFzc2VzKGNsYXNzZXMpIHtcbiAgICBpZihpc1N0cmluZyhjbGFzc2VzKSkge1xuICAgICAgY29uc3QgbmV3Q2xhc3NlcyA9IGdldENsYXNzZXNBcnJheShjbGFzc2VzKTtcbiAgICAgIGlmIChuZXdDbGFzc2VzLmxlbmd0aCkge1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoLi4ubmV3Q2xhc3Nlcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3Nlc0FycmF5KGNsYXNzZXMpIHtcbiAgICAgcmV0dXJuIGNsYXNzZXMuc3BsaXQoJyAnKS5maWx0ZXIoY2xhc3NOYW1lID0+ICEhY2xhc3NOYW1lLmxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0dXAga2V5ZG93biBldmVudHMgdG8gYWxsb3cgY2xvc2luZyB0aGUgbW9kYWwgd2l0aCBFU0NcbiAgICpcbiAgICogQm9ycm93ZWQgZnJvbSB0aGlzIGdyZWF0IHBvc3QhIGh0dHBzOi8vYml0c29mY28uZGUvYWNjZXNzaWJsZS1tb2RhbC1kaWFsb2cvXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25zdCBoYW5kbGVLZXlEb3duID0gKGUpID0+IHtcbiAgICBjb25zdCB7IHRvdXIgfSA9IHN0ZXA7XG4gICAgc3dpdGNoIChlLmtleUNvZGUpIHtcbiAgICAgIGNhc2UgS0VZX1RBQjpcbiAgICAgICAgaWYgKGZvY3VzYWJsZUVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBCYWNrd2FyZCB0YWJcbiAgICAgICAgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZmlyc3RGb2N1c2FibGVFbGVtZW50IHx8IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaGVwaGVyZC1lbGVtZW50JykpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGxhc3RGb2N1c2FibGVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBsYXN0Rm9jdXNhYmxlRWxlbWVudCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZmlyc3RGb2N1c2FibGVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBLRVlfRVNDOlxuICAgICAgICBpZiAodG91ci5vcHRpb25zLmV4aXRPbkVzYykge1xuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgc3RlcC5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTEVGVF9BUlJPVzpcbiAgICAgICAgaWYgKHRvdXIub3B0aW9ucy5rZXlib2FyZE5hdmlnYXRpb24pIHtcbiAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIHRvdXIuYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBSSUdIVF9BUlJPVzpcbiAgICAgICAgaWYgKHRvdXIub3B0aW9ucy5rZXlib2FyZE5hdmlnYXRpb24pIHtcbiAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIHRvdXIubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBnbG9iYWw+XG4gIC5zaGVwaGVyZC1lbGVtZW50IHtcbiAgICBiYWNrZ3JvdW5kOiAjZmZmO1xuICAgIGJvcmRlci1yYWRpdXM6IDVweDtcbiAgICBib3gtc2hhZG93OiAwIDFweCA0cHggcmdiYSgwLCAwLCAwLCAwLjIpO1xuICAgIG1heC13aWR0aDogNDAwcHg7XG4gICAgb3BhY2l0eTogMDtcbiAgICBvdXRsaW5lOiBub25lO1xuICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMC4zcywgdmlzaWJpbGl0eSAwLjNzO1xuICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgICB3aWR0aDogMTAwJTtcbiAgICB6LWluZGV4OiA5OTk5O1xuICB9XG5cbiAgLnNoZXBoZXJkLWVuYWJsZWQuc2hlcGhlcmQtZWxlbWVudCB7XG4gICAgb3BhY2l0eTogMTtcbiAgICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xuICB9XG5cbiAgLnNoZXBoZXJkLWVsZW1lbnRbZGF0YS1wb3BwZXItcmVmZXJlbmNlLWhpZGRlbl06bm90KC5zaGVwaGVyZC1jZW50ZXJlZCkge1xuICAgIG9wYWNpdHk6IDA7XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xuICB9XG5cbiAgLnNoZXBoZXJkLWVsZW1lbnQsIC5zaGVwaGVyZC1lbGVtZW50ICosXG4gIC5zaGVwaGVyZC1lbGVtZW50ICo6YWZ0ZXIsXG4gIC5zaGVwaGVyZC1lbGVtZW50ICo6YmVmb3JlIHtcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICB9XG5cbiAgLnNoZXBoZXJkLWFycm93LFxuICAuc2hlcGhlcmQtYXJyb3c6OmJlZm9yZSB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHdpZHRoOiAxNnB4O1xuICAgIGhlaWdodDogMTZweDtcbiAgICB6LWluZGV4OiAtMTtcbiAgfVxuXG4gIC5zaGVwaGVyZC1hcnJvdzpiZWZvcmUge1xuICAgIGNvbnRlbnQ6ICcnO1xuICAgIHRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTtcbiAgICBiYWNrZ3JvdW5kOiAjZmZmICA7XG4gIH1cblxuICAuc2hlcGhlcmQtZWxlbWVudFtkYXRhLXBvcHBlci1wbGFjZW1lbnRePSd0b3AnXSA+IC5zaGVwaGVyZC1hcnJvdyB7XG4gICAgYm90dG9tOiAtOHB4O1xuICB9XG5cbiAgLnNoZXBoZXJkLWVsZW1lbnRbZGF0YS1wb3BwZXItcGxhY2VtZW50Xj0nYm90dG9tJ10gPiAuc2hlcGhlcmQtYXJyb3cge1xuICAgIHRvcDogLThweDtcbiAgfVxuXG4gIC5zaGVwaGVyZC1lbGVtZW50W2RhdGEtcG9wcGVyLXBsYWNlbWVudF49J2xlZnQnXSA+IC5zaGVwaGVyZC1hcnJvdyB7XG4gICAgcmlnaHQ6IC04cHg7XG4gIH1cblxuICAuc2hlcGhlcmQtZWxlbWVudFtkYXRhLXBvcHBlci1wbGFjZW1lbnRePSdyaWdodCddID4gLnNoZXBoZXJkLWFycm93IHtcbiAgICBsZWZ0OiAtOHB4O1xuICB9XG5cbiAgLnNoZXBoZXJkLWVsZW1lbnQuc2hlcGhlcmQtY2VudGVyZWQgPiAuc2hlcGhlcmQtYXJyb3cge1xuICAgIG9wYWNpdHk6IDA7XG4gIH1cblxuXG4gIC8qKlxuICAqIEFycm93IG9uIHRvcCBvZiB0b29sdGlwIGNlbnRlcmVkIGhvcml6b250YWxseSwgd2l0aCB0aXRsZSBjb2xvclxuICAqL1xuICAuc2hlcGhlcmQtZWxlbWVudC5zaGVwaGVyZC1oYXMtdGl0bGVbZGF0YS1wb3BwZXItcGxhY2VtZW50Xj0nYm90dG9tJ10gPiAuc2hlcGhlcmQtYXJyb3c6OmJlZm9yZSB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2U2ZTZlNjtcbiAgfVxuXG4gIC5zaGVwaGVyZC10YXJnZXQtY2xpY2stZGlzYWJsZWQuc2hlcGhlcmQtZW5hYmxlZC5zaGVwaGVyZC10YXJnZXQsXG4gIC5zaGVwaGVyZC10YXJnZXQtY2xpY2stZGlzYWJsZWQuc2hlcGhlcmQtZW5hYmxlZC5zaGVwaGVyZC10YXJnZXQgKiB7XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gIH1cbjwvc3R5bGU+XG5cbjxkaXZcbiAgYXJpYS1kZXNjcmliZWRieT17IWlzVW5kZWZpbmVkKHN0ZXAub3B0aW9ucy50ZXh0KSA/IGRlc2NyaXB0aW9uSWQgOiBudWxsfVxuICBhcmlhLWxhYmVsbGVkYnk9e3N0ZXAub3B0aW9ucy50aXRsZSA/IGxhYmVsSWQgOiBudWxsfVxuICBiaW5kOnRoaXM9e2VsZW1lbnR9XG4gIGNsYXNzOnNoZXBoZXJkLWhhcy1jYW5jZWwtaWNvbj1cIntoYXNDYW5jZWxJY29ufVwiXG4gIGNsYXNzOnNoZXBoZXJkLWhhcy10aXRsZT1cIntoYXNUaXRsZX1cIlxuICBjbGFzczpzaGVwaGVyZC1lbGVtZW50PVwie3RydWV9XCJcbiAgey4uLmRhdGFTdGVwSWR9XG4gIG9uOmtleWRvd249e2hhbmRsZUtleURvd259XG4gIHJvbGU9XCJkaWFsb2dcIlxuICB0YWJpbmRleD1cIjBcIlxuPlxuICAgIHsjaWYgc3RlcC5vcHRpb25zLmFycm93ICYmIHN0ZXAub3B0aW9ucy5hdHRhY2hUbyAmJiBzdGVwLm9wdGlvbnMuYXR0YWNoVG8uZWxlbWVudCAmJiBzdGVwLm9wdGlvbnMuYXR0YWNoVG8ub259XG4gICAgICA8ZGl2IGNsYXNzPVwic2hlcGhlcmQtYXJyb3dcIiBkYXRhLXBvcHBlci1hcnJvdz48L2Rpdj5cbiAgICB7L2lmfVxuICA8U2hlcGhlcmRDb250ZW50XG4gICAge2Rlc2NyaXB0aW9uSWR9XG4gICAge2xhYmVsSWR9XG4gICAge3N0ZXB9XG4gIC8+XG48L2Rpdj5cbiIsImltcG9ydCBtZXJnZSBmcm9tICdkZWVwbWVyZ2UnO1xuaW1wb3J0IHsgRXZlbnRlZCB9IGZyb20gJy4vZXZlbnRlZC5qcyc7XG5pbXBvcnQgYXV0b0JpbmQgZnJvbSAnLi91dGlscy9hdXRvLWJpbmQuanMnO1xuaW1wb3J0IHtcbiAgaXNFbGVtZW50LFxuICBpc0hUTUxFbGVtZW50LFxuICBpc0Z1bmN0aW9uLFxuICBpc1VuZGVmaW5lZFxufSBmcm9tICcuL3V0aWxzL3R5cGUtY2hlY2suanMnO1xuaW1wb3J0IHsgYmluZEFkdmFuY2UgfSBmcm9tICcuL3V0aWxzL2JpbmQuanMnO1xuaW1wb3J0IHsgcGFyc2VBdHRhY2hUbywgbm9ybWFsaXplUHJlZml4LCB1dWlkIH0gZnJvbSAnLi91dGlscy9nZW5lcmFsLmpzJztcbmltcG9ydCB7XG4gIHNldHVwVG9vbHRpcCxcbiAgZGVzdHJveVRvb2x0aXAsXG4gIG1lcmdlVG9vbHRpcENvbmZpZ1xufSBmcm9tICcuL3V0aWxzL2Zsb2F0aW5nLXVpLmpzJztcbmltcG9ydCBTaGVwaGVyZEVsZW1lbnQgZnJvbSAnLi9jb21wb25lbnRzL3NoZXBoZXJkLWVsZW1lbnQuc3ZlbHRlJztcblxuLyoqXG4gKiBBIGNsYXNzIHJlcHJlc2VudGluZyBzdGVwcyB0byBiZSBhZGRlZCB0byBhIHRvdXIuXG4gKiBAZXh0ZW5kcyB7RXZlbnRlZH1cbiAqL1xuZXhwb3J0IGNsYXNzIFN0ZXAgZXh0ZW5kcyBFdmVudGVkIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIHN0ZXBcbiAgICogQHBhcmFtIHtUb3VyfSB0b3VyIFRoZSB0b3VyIGZvciB0aGUgc3RlcFxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgdGhlIHN0ZXBcbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmFycm93IFdoZXRoZXIgdG8gZGlzcGxheSB0aGUgYXJyb3cgZm9yIHRoZSB0b29sdGlwIG9yIG5vdC4gRGVmYXVsdHMgdG8gYHRydWVgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5hdHRhY2hUbyBUaGUgZWxlbWVudCB0aGUgc3RlcCBzaG91bGQgYmUgYXR0YWNoZWQgdG8gb24gdGhlIHBhZ2UuXG4gICAqIEFuIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgYGVsZW1lbnRgIGFuZCBgb25gLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBzdGVwID0gbmV3IFN0ZXAodG91ciwge1xuICAgKiAgIGF0dGFjaFRvOiB7IGVsZW1lbnQ6ICcuc29tZSAuc2VsZWN0b3ItcGF0aCcsIG9uOiAnbGVmdCcgfSxcbiAgICogICAuLi5tb3JlT3B0aW9uc1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIElmIHlvdSBkb27igJl0IHNwZWNpZnkgYW4gYGF0dGFjaFRvYCB0aGUgZWxlbWVudCB3aWxsIGFwcGVhciBpbiB0aGUgbWlkZGxlIG9mIHRoZSBzY3JlZW4uIFRoZSBzYW1lIHdpbGwgaGFwcGVuIGlmIHlvdXIgYGF0dGFjaFRvLmVsZW1lbnRgIGNhbGxiYWNrIHJldHVybnMgYG51bGxgLCBgdW5kZWZpbmVkYCwgb3IgYSBzZWxlY3RvciB0aGF0IGRvZXMgbm90IGV4aXN0IGluIHRoZSBET00uXG4gICAqIElmIHlvdSBvbWl0IHRoZSBgb25gIHBvcnRpb24gb2YgYGF0dGFjaFRvYCwgdGhlIGVsZW1lbnQgd2lsbCBzdGlsbCBiZSBoaWdobGlnaHRlZCwgYnV0IHRoZSB0b29sdGlwIHdpbGwgYXBwZWFyXG4gICAqIGluIHRoZSBtaWRkbGUgb2YgdGhlIHNjcmVlbiwgd2l0aG91dCBhbiBhcnJvdyBwb2ludGluZyB0byB0aGUgdGFyZ2V0LlxuICAgKiBJZiB0aGUgZWxlbWVudCB0byBoaWdobGlnaHQgZG9lcyBub3QgeWV0IGV4aXN0IHdoaWxlIGluc3RhbnRpYXRpbmcgdG91ciBzdGVwcywgeW91IG1heSB1c2UgbGF6eSBldmFsdWF0aW9uIGJ5IHN1cHBseWluZyBhIGZ1bmN0aW9uIHRvIGBhdHRhY2hUby5lbGVtZW50YC4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGluIHRoZSBgYmVmb3JlLXNob3dgIHBoYXNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xIVE1MRWxlbWVudHxmdW5jdGlvbn0gb3B0aW9ucy5hdHRhY2hUby5lbGVtZW50IEFuIGVsZW1lbnQgc2VsZWN0b3Igc3RyaW5nLCBET00gZWxlbWVudCwgb3IgYSBmdW5jdGlvbiAocmV0dXJuaW5nIGEgc2VsZWN0b3IsIGEgRE9NIGVsZW1lbnQsIGBudWxsYCBvciBgdW5kZWZpbmVkYCkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmF0dGFjaFRvLm9uIFRoZSBvcHRpb25hbCBkaXJlY3Rpb24gdG8gcGxhY2UgdGhlIEZsb2F0aW5nVUkgdG9vbHRpcCByZWxhdGl2ZSB0byB0aGUgZWxlbWVudC5cbiAgICogICAtIFBvc3NpYmxlIHN0cmluZyB2YWx1ZXM6ICd0b3AnLCAndG9wLXN0YXJ0JywgJ3RvcC1lbmQnLCAnYm90dG9tJywgJ2JvdHRvbS1zdGFydCcsICdib3R0b20tZW5kJywgJ3JpZ2h0JywgJ3JpZ2h0LXN0YXJ0JywgJ3JpZ2h0LWVuZCcsICdsZWZ0JywgJ2xlZnQtc3RhcnQnLCAnbGVmdC1lbmQnXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmFkdmFuY2VPbiBBbiBhY3Rpb24gb24gdGhlIHBhZ2Ugd2hpY2ggc2hvdWxkIGFkdmFuY2Ugc2hlcGhlcmQgdG8gdGhlIG5leHQgc3RlcC5cbiAgICogSXQgc2hvdWxkIGJlIGFuIG9iamVjdCB3aXRoIGEgc3RyaW5nIGBzZWxlY3RvcmAgYW5kIGFuIGBldmVudGAgbmFtZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBzdGVwID0gbmV3IFN0ZXAodG91ciwge1xuICAgKiAgIGFkdmFuY2VPbjogeyBzZWxlY3RvcjogJy5zb21lIC5zZWxlY3Rvci1wYXRoJywgZXZlbnQ6ICdjbGljaycgfSxcbiAgICogICAuLi5tb3JlT3B0aW9uc1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqIGBldmVudGAgZG9lc27igJl0IGhhdmUgdG8gYmUgYW4gZXZlbnQgaW5zaWRlIHRoZSB0b3VyLCBpdCBjYW4gYmUgYW55IGV2ZW50IGZpcmVkIG9uIGFueSBlbGVtZW50IG9uIHRoZSBwYWdlLlxuICAgKiBZb3UgY2FuIGFsc28gYWx3YXlzIG1hbnVhbGx5IGFkdmFuY2UgdGhlIFRvdXIgYnkgY2FsbGluZyBgbXlUb3VyLm5leHQoKWAuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdGlvbnMuYmVmb3JlU2hvd1Byb21pc2UgQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBwcm9taXNlLlxuICAgKiBXaGVuIHRoZSBwcm9taXNlIHJlc29sdmVzLCB0aGUgcmVzdCBvZiB0aGUgYHNob3dgIGNvZGUgZm9yIHRoZSBzdGVwIHdpbGwgZXhlY3V0ZS5cbiAgICogQHBhcmFtIHtPYmplY3RbXX0gb3B0aW9ucy5idXR0b25zIEFuIGFycmF5IG9mIGJ1dHRvbnMgdG8gYWRkIHRvIHRoZSBzdGVwLiBUaGVzZSB3aWxsIGJlIHJlbmRlcmVkIGluIGFcbiAgICogZm9vdGVyIGJlbG93IHRoZSBtYWluIGJvZHkgdGV4dC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0aW9ucy5idXR0b25zLmJ1dHRvbi5hY3Rpb24gQSBmdW5jdGlvbiBleGVjdXRlZCB3aGVuIHRoZSBidXR0b24gaXMgY2xpY2tlZCBvbi5cbiAgICogSXQgaXMgYXV0b21hdGljYWxseSBib3VuZCB0byB0aGUgYHRvdXJgIHRoZSBzdGVwIGlzIGFzc29jaWF0ZWQgd2l0aCwgc28gdGhpbmdzIGxpa2UgYHRoaXMubmV4dGAgd2lsbFxuICAgKiB3b3JrIGluc2lkZSB0aGUgYWN0aW9uLlxuICAgKiBZb3UgY2FuIHVzZSBhY3Rpb24gdG8gc2tpcCBzdGVwcyBvciBuYXZpZ2F0ZSB0byBzcGVjaWZpYyBzdGVwcywgd2l0aCBzb21ldGhpbmcgbGlrZTpcbiAgICogYGBganNcbiAgICogYWN0aW9uKCkge1xuICAgKiAgIHJldHVybiB0aGlzLnNob3coJ3NvbWVfc3RlcF9uYW1lJyk7XG4gICAqIH1cbiAgICogYGBgXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmJ1dHRvbnMuYnV0dG9uLmNsYXNzZXMgRXh0cmEgY2xhc3NlcyB0byBhcHBseSB0byB0aGUgYDxhPmBcbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmJ1dHRvbnMuYnV0dG9uLmRpc2FibGVkIFNob3VsZCB0aGUgYnV0dG9uIGJlIGRpc2FibGVkP1xuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5idXR0b25zLmJ1dHRvbi5sYWJlbCBUaGUgYXJpYS1sYWJlbCB0ZXh0IG9mIHRoZSBidXR0b25cbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmJ1dHRvbnMuYnV0dG9uLnNlY29uZGFyeSBJZiB0cnVlLCBhIHNoZXBoZXJkLWJ1dHRvbi1zZWNvbmRhcnkgY2xhc3MgaXMgYXBwbGllZCB0byB0aGUgYnV0dG9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmJ1dHRvbnMuYnV0dG9uLnRleHQgVGhlIEhUTUwgdGV4dCBvZiB0aGUgYnV0dG9uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5jYW5DbGlja1RhcmdldCBBIGJvb2xlYW4sIHRoYXQgd2hlbiBzZXQgdG8gZmFsc2UsIHdpbGwgc2V0IGBwb2ludGVyLWV2ZW50czogbm9uZWAgb24gdGhlIHRhcmdldFxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5jYW5jZWxJY29uIE9wdGlvbnMgZm9yIHRoZSBjYW5jZWwgaWNvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuY2FuY2VsSWNvbi5lbmFibGVkIFNob3VsZCBhIGNhbmNlbCDigJzinJXigJ0gYmUgc2hvd24gaW4gdGhlIGhlYWRlciBvZiB0aGUgc3RlcD9cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY2FuY2VsSWNvbi5sYWJlbCBUaGUgbGFiZWwgdG8gYWRkIGZvciBgYXJpYS1sYWJlbGBcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY2xhc3NlcyBBIHN0cmluZyBvZiBleHRyYSBjbGFzc2VzIHRvIGFkZCB0byB0aGUgc3RlcCdzIGNvbnRlbnQgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuaGlnaGxpZ2h0Q2xhc3MgQW4gZXh0cmEgY2xhc3MgdG8gYXBwbHkgdG8gdGhlIGBhdHRhY2hUb2AgZWxlbWVudCB3aGVuIGl0IGlzXG4gICAqIGhpZ2hsaWdodGVkICh0aGF0IGlzLCB3aGVuIGl0cyBzdGVwIGlzIGFjdGl2ZSkuIFlvdSBjYW4gdGhlbiB0YXJnZXQgdGhhdCBzZWxlY3RvciBpbiB5b3VyIENTUy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuaWQgVGhlIHN0cmluZyB0byB1c2UgYXMgdGhlIGBpZGAgZm9yIHRoZSBzdGVwLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5tb2RhbE92ZXJsYXlPcGVuaW5nUGFkZGluZyBBbiBhbW91bnQgb2YgcGFkZGluZyB0byBhZGQgYXJvdW5kIHRoZSBtb2RhbCBvdmVybGF5IG9wZW5pbmdcbiAgICogQHBhcmFtIHtudW1iZXIgfCB7IHRvcExlZnQ6IG51bWJlciwgYm90dG9tTGVmdDogbnVtYmVyLCBib3R0b21SaWdodDogbnVtYmVyLCB0b3BSaWdodDogbnVtYmVyIH19IG9wdGlvbnMubW9kYWxPdmVybGF5T3BlbmluZ1JhZGl1cyBBbiBhbW91bnQgb2YgYm9yZGVyIHJhZGl1cyB0byBhZGQgYXJvdW5kIHRoZSBtb2RhbCBvdmVybGF5IG9wZW5pbmdcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuZmxvYXRpbmdVSU9wdGlvbnMgRXh0cmEgb3B0aW9ucyB0byBwYXNzIHRvIEZsb2F0aW5nVUlcbiAgICogQHBhcmFtIHtib29sZWFufE9iamVjdH0gb3B0aW9ucy5zY3JvbGxUbyBTaG91bGQgdGhlIGVsZW1lbnQgYmUgc2Nyb2xsZWQgdG8gd2hlbiB0aGlzIHN0ZXAgaXMgc2hvd24/IElmIHRydWUsIHVzZXMgdGhlIGRlZmF1bHQgYHNjcm9sbEludG9WaWV3YCxcbiAgICogaWYgYW4gb2JqZWN0LCBwYXNzZXMgdGhhdCBvYmplY3QgYXMgdGhlIHBhcmFtcyB0byBgc2Nyb2xsSW50b1ZpZXdgIGkuZS4gYHtiZWhhdmlvcjogJ3Ntb290aCcsIGJsb2NrOiAnY2VudGVyJ31gXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdGlvbnMuc2Nyb2xsVG9IYW5kbGVyIEEgZnVuY3Rpb24gdGhhdCBsZXRzIHlvdSBvdmVycmlkZSB0aGUgZGVmYXVsdCBzY3JvbGxUbyBiZWhhdmlvciBhbmRcbiAgICogZGVmaW5lIGEgY3VzdG9tIGFjdGlvbiB0byBkbyB0aGUgc2Nyb2xsaW5nLCBhbmQgcG9zc2libHkgb3RoZXIgbG9naWMuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdGlvbnMuc2hvd09uIEEgZnVuY3Rpb24gdGhhdCwgd2hlbiBpdCByZXR1cm5zIGB0cnVlYCwgd2lsbCBzaG93IHRoZSBzdGVwLlxuICAgKiBJZiBpdCByZXR1cm5zIGZhbHNlLCB0aGUgc3RlcCB3aWxsIGJlIHNraXBwZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRleHQgVGhlIHRleHQgaW4gdGhlIGJvZHkgb2YgdGhlIHN0ZXAuIEl0IGNhbiBiZSBvbmUgb2YgdGhyZWUgdHlwZXM6XG4gICAqIGBgYFxuICAgKiAtIEhUTUwgc3RyaW5nXG4gICAqIC0gYEhUTUxFbGVtZW50YCBvYmplY3RcbiAgICogLSBgRnVuY3Rpb25gIHRvIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIHN0ZXAgaXMgYnVpbHQuIEl0IG11c3QgcmV0dXJuIG9uZSB0aGUgdHdvIG9wdGlvbnMgYWJvdmUuXG4gICAqIGBgYFxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50aXRsZSBUaGUgc3RlcCdzIHRpdGxlLiBJdCBiZWNvbWVzIGFuIGBoM2AgYXQgdGhlIHRvcCBvZiB0aGUgc3RlcC4gSXQgY2FuIGJlIG9uZSBvZiB0d28gdHlwZXM6XG4gICAqIGBgYFxuICAgKiAtIEhUTUwgc3RyaW5nXG4gICAqIC0gYEZ1bmN0aW9uYCB0byBiZSBleGVjdXRlZCB3aGVuIHRoZSBzdGVwIGlzIGJ1aWx0LiBJdCBtdXN0IHJldHVybiBIVE1MIHN0cmluZy5cbiAgICogYGBgXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLndoZW4gWW91IGNhbiBkZWZpbmUgYHNob3dgLCBgaGlkZWAsIGV0YyBldmVudHMgaW5zaWRlIGB3aGVuYC4gRm9yIGV4YW1wbGU6XG4gICAqIGBgYGpzXG4gICAqIHdoZW46IHtcbiAgICogICBzaG93OiBmdW5jdGlvbigpIHtcbiAgICogICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcbiAgICogICB9XG4gICAqIH1cbiAgICogYGBgXG4gICAqIEByZXR1cm4ge1N0ZXB9IFRoZSBuZXdseSBjcmVhdGVkIFN0ZXAgaW5zdGFuY2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKHRvdXIsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKHRvdXIsIG9wdGlvbnMpO1xuICAgIHRoaXMudG91ciA9IHRvdXI7XG4gICAgdGhpcy5jbGFzc1ByZWZpeCA9IHRoaXMudG91ci5vcHRpb25zXG4gICAgICA/IG5vcm1hbGl6ZVByZWZpeCh0aGlzLnRvdXIub3B0aW9ucy5jbGFzc1ByZWZpeClcbiAgICAgIDogJyc7XG4gICAgdGhpcy5zdHlsZXMgPSB0b3VyLnN0eWxlcztcblxuICAgIC8qKlxuICAgICAqIFJlc29sdmVkIGF0dGFjaFRvIG9wdGlvbnMuIER1ZSB0byBsYXp5IGV2YWx1YXRpb24sIHdlIG9ubHkgcmVzb2x2ZSB0aGUgb3B0aW9ucyBkdXJpbmcgYGJlZm9yZS1zaG93YCBwaGFzZS5cbiAgICAgKiBEbyBub3QgdXNlIHRoaXMgZGlyZWN0bHksIHVzZSB0aGUgX2dldFJlc29sdmVkQXR0YWNoVG9PcHRpb25zIG1ldGhvZCBpbnN0ZWFkLlxuICAgICAqIEB0eXBlIHtudWxsfHt9fHtlbGVtZW50LCB0b319XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9yZXNvbHZlZEF0dGFjaFRvID0gbnVsbDtcblxuICAgIGF1dG9CaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5fc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbCB0aGUgdG91clxuICAgKiBUcmlnZ2VycyB0aGUgYGNhbmNlbGAgZXZlbnRcbiAgICovXG4gIGNhbmNlbCgpIHtcbiAgICB0aGlzLnRvdXIuY2FuY2VsKCk7XG4gICAgdGhpcy50cmlnZ2VyKCdjYW5jZWwnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wbGV0ZSB0aGUgdG91clxuICAgKiBUcmlnZ2VycyB0aGUgYGNvbXBsZXRlYCBldmVudFxuICAgKi9cbiAgY29tcGxldGUoKSB7XG4gICAgdGhpcy50b3VyLmNvbXBsZXRlKCk7XG4gICAgdGhpcy50cmlnZ2VyKCdjb21wbGV0ZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgc3RlcCwgZGVsZXRlIHRoZSBzdGVwJ3MgZWxlbWVudCwgYW5kIGRlc3Ryb3kgdGhlIEZsb2F0aW5nVUkgaW5zdGFuY2UgZm9yIHRoZSBzdGVwLlxuICAgKiBUcmlnZ2VycyBgZGVzdHJveWAgZXZlbnRcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgZGVzdHJveVRvb2x0aXAodGhpcyk7XG5cbiAgICBpZiAoaXNIVE1MRWxlbWVudCh0aGlzLmVsKSkge1xuICAgICAgdGhpcy5lbC5yZW1vdmUoKTtcbiAgICAgIHRoaXMuZWwgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZVN0ZXBUYXJnZXRPbkhpZGUoKTtcblxuICAgIHRoaXMudHJpZ2dlcignZGVzdHJveScpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRvdXIgZm9yIHRoZSBzdGVwXG4gICAqIEByZXR1cm4ge1RvdXJ9IFRoZSB0b3VyIGluc3RhbmNlXG4gICAqL1xuICBnZXRUb3VyKCkge1xuICAgIHJldHVybiB0aGlzLnRvdXI7XG4gIH1cblxuICAvKipcbiAgICogSGlkZSB0aGUgc3RlcFxuICAgKi9cbiAgaGlkZSgpIHtcbiAgICB0aGlzLnRvdXIubW9kYWwuaGlkZSgpO1xuXG4gICAgdGhpcy50cmlnZ2VyKCdiZWZvcmUtaGlkZScpO1xuXG4gICAgaWYgKHRoaXMuZWwpIHtcbiAgICAgIHRoaXMuZWwuaGlkZGVuID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVTdGVwVGFyZ2V0T25IaWRlKCk7XG5cbiAgICB0aGlzLnRyaWdnZXIoJ2hpZGUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlcyBhdHRhY2hUbyBvcHRpb25zLlxuICAgKiBAcmV0dXJucyB7e318e2VsZW1lbnQsIG9ufX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZXNvbHZlQXR0YWNoVG9PcHRpb25zKCkge1xuICAgIHRoaXMuX3Jlc29sdmVkQXR0YWNoVG8gPSBwYXJzZUF0dGFjaFRvKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlZEF0dGFjaFRvO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc2VsZWN0b3IgZm9yIHJlc29sdmVkIGF0dGFjaFRvIG9wdGlvbnMuXG4gICAqIEByZXR1cm5zIHt7fXx7ZWxlbWVudCwgb259fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldFJlc29sdmVkQXR0YWNoVG9PcHRpb25zKCkge1xuICAgIGlmICh0aGlzLl9yZXNvbHZlZEF0dGFjaFRvID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUF0dGFjaFRvT3B0aW9ucygpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlZEF0dGFjaFRvO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBzdGVwIGlzIG9wZW4gYW5kIHZpc2libGVcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3RlcCBpcyBvcGVuIGFuZCB2aXNpYmxlXG4gICAqL1xuICBpc09wZW4oKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5lbCAmJiAhdGhpcy5lbC5oaWRkZW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyYXBzIGBfc2hvd2AgYW5kIGVuc3VyZXMgYGJlZm9yZVNob3dQcm9taXNlYCByZXNvbHZlcyBiZWZvcmUgY2FsbGluZyBzaG93XG4gICAqIEByZXR1cm4geyp8UHJvbWlzZX1cbiAgICovXG4gIHNob3coKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odGhpcy5vcHRpb25zLmJlZm9yZVNob3dQcm9taXNlKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLm9wdGlvbnMuYmVmb3JlU2hvd1Byb21pc2UoKSkudGhlbigoKSA9PlxuICAgICAgICB0aGlzLl9zaG93KClcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fc2hvdygpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBvcHRpb25zIG9mIHRoZSBzdGVwLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgdGhlIHN0ZXBcbiAgICovXG4gIHVwZGF0ZVN0ZXBPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICBpZiAodGhpcy5zaGVwaGVyZEVsZW1lbnRDb21wb25lbnQpIHtcbiAgICAgIHRoaXMuc2hlcGhlcmRFbGVtZW50Q29tcG9uZW50LiRzZXQoeyBzdGVwOiB0aGlzIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlbGVtZW50IGZvciB0aGUgc3RlcFxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudHxudWxsfHVuZGVmaW5lZH0gVGhlIGVsZW1lbnQgaW5zdGFuY2UuIHVuZGVmaW5lZCBpZiBpdCBoYXMgbmV2ZXIgYmVlbiBzaG93biwgbnVsbCBpZiBpdCBoYXMgYmVlbiBkZXN0cm95ZWRcbiAgICovXG4gIGdldEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdGFyZ2V0IGZvciB0aGUgc3RlcFxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudHxudWxsfHVuZGVmaW5lZH0gVGhlIGVsZW1lbnQgaW5zdGFuY2UuIHVuZGVmaW5lZCBpZiBpdCBoYXMgbmV2ZXIgYmVlbiBzaG93biwgbnVsbCBpZiBxdWVyeSBzdHJpbmcgaGFzIG5vdCBiZWVuIGZvdW5kXG4gICAqL1xuICBnZXRUYXJnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFyZ2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgU2hlcGhlcmQgZWxlbWVudCBmb3Igc3RlcCBiYXNlZCBvbiBvcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9IFRoZSBET00gZWxlbWVudCBmb3IgdGhlIHN0ZXAgdG9vbHRpcFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NyZWF0ZVRvb2x0aXBDb250ZW50KCkge1xuICAgIGNvbnN0IGRlc2NyaXB0aW9uSWQgPSBgJHt0aGlzLmlkfS1kZXNjcmlwdGlvbmA7XG4gICAgY29uc3QgbGFiZWxJZCA9IGAke3RoaXMuaWR9LWxhYmVsYDtcblxuICAgIHRoaXMuc2hlcGhlcmRFbGVtZW50Q29tcG9uZW50ID0gbmV3IFNoZXBoZXJkRWxlbWVudCh7XG4gICAgICB0YXJnZXQ6IHRoaXMudG91ci5vcHRpb25zLnN0ZXBzQ29udGFpbmVyIHx8IGRvY3VtZW50LmJvZHksXG4gICAgICBwcm9wczoge1xuICAgICAgICBjbGFzc1ByZWZpeDogdGhpcy5jbGFzc1ByZWZpeCxcbiAgICAgICAgZGVzY3JpcHRpb25JZCxcbiAgICAgICAgbGFiZWxJZCxcbiAgICAgICAgc3RlcDogdGhpcyxcbiAgICAgICAgc3R5bGVzOiB0aGlzLnN0eWxlc1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuc2hlcGhlcmRFbGVtZW50Q29tcG9uZW50LmdldEVsZW1lbnQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBhIGN1c3RvbSBzY3JvbGxUb0hhbmRsZXIgaXMgZGVmaW5lZCwgY2FsbCB0aGF0LCBvdGhlcndpc2UgZG8gdGhlIGdlbmVyaWNcbiAgICogc2Nyb2xsSW50b1ZpZXcgY2FsbC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufE9iamVjdH0gc2Nyb2xsVG9PcHRpb25zIElmIHRydWUsIHVzZXMgdGhlIGRlZmF1bHQgYHNjcm9sbEludG9WaWV3YCxcbiAgICogaWYgYW4gb2JqZWN0LCBwYXNzZXMgdGhhdCBvYmplY3QgYXMgdGhlIHBhcmFtcyB0byBgc2Nyb2xsSW50b1ZpZXdgIGkuZS4gYHsgYmVoYXZpb3I6ICdzbW9vdGgnLCBibG9jazogJ2NlbnRlcicgfWBcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zY3JvbGxUbyhzY3JvbGxUb09wdGlvbnMpIHtcbiAgICBjb25zdCB7IGVsZW1lbnQgfSA9IHRoaXMuX2dldFJlc29sdmVkQXR0YWNoVG9PcHRpb25zKCk7XG5cbiAgICBpZiAoaXNGdW5jdGlvbih0aGlzLm9wdGlvbnMuc2Nyb2xsVG9IYW5kbGVyKSkge1xuICAgICAgdGhpcy5vcHRpb25zLnNjcm9sbFRvSGFuZGxlcihlbGVtZW50KTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgaXNFbGVtZW50KGVsZW1lbnQpICYmXG4gICAgICB0eXBlb2YgZWxlbWVudC5zY3JvbGxJbnRvVmlldyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICkge1xuICAgICAgZWxlbWVudC5zY3JvbGxJbnRvVmlldyhzY3JvbGxUb09wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBfZ2V0Q2xhc3NPcHRpb25zIGdldHMgYWxsIHBvc3NpYmxlIGNsYXNzZXMgZm9yIHRoZSBzdGVwXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdGVwT3B0aW9ucyBUaGUgc3RlcCBzcGVjaWZpYyBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IHVuaXF1ZSBzdHJpbmcgZnJvbSBhcnJheSBvZiBjbGFzc2VzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0Q2xhc3NPcHRpb25zKHN0ZXBPcHRpb25zKSB7XG4gICAgY29uc3QgZGVmYXVsdFN0ZXBPcHRpb25zID1cbiAgICAgIHRoaXMudG91ciAmJiB0aGlzLnRvdXIub3B0aW9ucyAmJiB0aGlzLnRvdXIub3B0aW9ucy5kZWZhdWx0U3RlcE9wdGlvbnM7XG4gICAgY29uc3Qgc3RlcENsYXNzZXMgPSBzdGVwT3B0aW9ucy5jbGFzc2VzID8gc3RlcE9wdGlvbnMuY2xhc3NlcyA6ICcnO1xuICAgIGNvbnN0IGRlZmF1bHRTdGVwT3B0aW9uc0NsYXNzZXMgPVxuICAgICAgZGVmYXVsdFN0ZXBPcHRpb25zICYmIGRlZmF1bHRTdGVwT3B0aW9ucy5jbGFzc2VzXG4gICAgICAgID8gZGVmYXVsdFN0ZXBPcHRpb25zLmNsYXNzZXNcbiAgICAgICAgOiAnJztcbiAgICBjb25zdCBhbGxDbGFzc2VzID0gW1xuICAgICAgLi4uc3RlcENsYXNzZXMuc3BsaXQoJyAnKSxcbiAgICAgIC4uLmRlZmF1bHRTdGVwT3B0aW9uc0NsYXNzZXMuc3BsaXQoJyAnKVxuICAgIF07XG4gICAgY29uc3QgdW5pcUNsYXNzZXMgPSBuZXcgU2V0KGFsbENsYXNzZXMpO1xuXG4gICAgcmV0dXJuIEFycmF5LmZyb20odW5pcUNsYXNzZXMpLmpvaW4oJyAnKS50cmltKCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgb3B0aW9ucyBmb3IgdGhlIHN0ZXAsIG1hcHMgYHdoZW5gIHRvIGV2ZW50cywgc2V0cyB1cCBidXR0b25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIGZvciB0aGUgc3RlcFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldE9wdGlvbnMob3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IHRvdXJPcHRpb25zID1cbiAgICAgIHRoaXMudG91ciAmJiB0aGlzLnRvdXIub3B0aW9ucyAmJiB0aGlzLnRvdXIub3B0aW9ucy5kZWZhdWx0U3RlcE9wdGlvbnM7XG5cbiAgICB0b3VyT3B0aW9ucyA9IG1lcmdlKHt9LCB0b3VyT3B0aW9ucyB8fCB7fSk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKFxuICAgICAge1xuICAgICAgICBhcnJvdzogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHRvdXJPcHRpb25zLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIG1lcmdlVG9vbHRpcENvbmZpZyh0b3VyT3B0aW9ucywgb3B0aW9ucylcbiAgICApO1xuXG4gICAgY29uc3QgeyB3aGVuIH0gPSB0aGlzLm9wdGlvbnM7XG5cbiAgICB0aGlzLm9wdGlvbnMuY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzT3B0aW9ucyhvcHRpb25zKTtcblxuICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIHRoaXMuaWQgPSB0aGlzLm9wdGlvbnMuaWQgfHwgYHN0ZXAtJHt1dWlkKCl9YDtcblxuICAgIGlmICh3aGVuKSB7XG4gICAgICBPYmplY3Qua2V5cyh3aGVuKS5mb3JFYWNoKChldmVudCkgPT4ge1xuICAgICAgICB0aGlzLm9uKGV2ZW50LCB3aGVuW2V2ZW50XSwgdGhpcyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBlbGVtZW50IGFuZCBzZXQgdXAgdGhlIEZsb2F0aW5nVUkgaW5zdGFuY2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXR1cEVsZW1lbnRzKCkge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5lbCkpIHtcbiAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMuZWwgPSB0aGlzLl9jcmVhdGVUb29sdGlwQ29udGVudCgpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5hZHZhbmNlT24pIHtcbiAgICAgIGJpbmRBZHZhbmNlKHRoaXMpO1xuICAgIH1cblxuICAgIC8vIFRoZSB0b29sdGlwIGltcGxlbWVudGF0aW9uIGRldGFpbHMgYXJlIGhhbmRsZWQgb3V0c2lkZSBvZiB0aGUgU3RlcFxuICAgIC8vIG9iamVjdC5cbiAgICBzZXR1cFRvb2x0aXAodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogVHJpZ2dlcnMgYGJlZm9yZS1zaG93YCwgZ2VuZXJhdGVzIHRoZSB0b29sdGlwIERPTSBjb250ZW50LFxuICAgKiBzZXRzIHVwIGEgRmxvYXRpbmdVSSBpbnN0YW5jZSBmb3IgdGhlIHRvb2x0aXAsIHRoZW4gdHJpZ2dlcnMgYHNob3dgLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Nob3coKSB7XG4gICAgdGhpcy50cmlnZ2VyKCdiZWZvcmUtc2hvdycpO1xuXG4gICAgLy8gRm9yY2UgcmVzb2x2ZSB0byBtYWtlIHN1cmUgdGhlIG9wdGlvbnMgYXJlIHVwZGF0ZWQgb24gc3Vic2VxdWVudCBzaG93cy5cbiAgICB0aGlzLl9yZXNvbHZlQXR0YWNoVG9PcHRpb25zKCk7XG4gICAgdGhpcy5fc2V0dXBFbGVtZW50cygpO1xuXG4gICAgaWYgKCF0aGlzLnRvdXIubW9kYWwpIHtcbiAgICAgIHRoaXMudG91ci5fc2V0dXBNb2RhbCgpO1xuICAgIH1cblxuICAgIHRoaXMudG91ci5tb2RhbC5zZXR1cEZvclN0ZXAodGhpcyk7XG4gICAgdGhpcy5fc3R5bGVUYXJnZXRFbGVtZW50Rm9yU3RlcCh0aGlzKTtcbiAgICB0aGlzLmVsLmhpZGRlbiA9IGZhbHNlO1xuXG4gICAgLy8gc3RhcnQgc2Nyb2xsaW5nIHRvIHRhcmdldCBiZWZvcmUgc2hvd2luZyB0aGUgc3RlcFxuICAgIGlmICh0aGlzLm9wdGlvbnMuc2Nyb2xsVG8pIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLl9zY3JvbGxUbyh0aGlzLm9wdGlvbnMuc2Nyb2xsVG8pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5lbC5oaWRkZW4gPSBmYWxzZTtcblxuICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLnNoZXBoZXJkRWxlbWVudENvbXBvbmVudC5nZXRFbGVtZW50KCk7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy50YXJnZXQgfHwgZG9jdW1lbnQuYm9keTtcbiAgICB0YXJnZXQuY2xhc3NMaXN0LmFkZChgJHt0aGlzLmNsYXNzUHJlZml4fXNoZXBoZXJkLWVuYWJsZWRgKTtcbiAgICB0YXJnZXQuY2xhc3NMaXN0LmFkZChgJHt0aGlzLmNsYXNzUHJlZml4fXNoZXBoZXJkLXRhcmdldGApO1xuICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZCgnc2hlcGhlcmQtZW5hYmxlZCcpO1xuXG4gICAgdGhpcy50cmlnZ2VyKCdzaG93Jyk7XG4gIH1cblxuICAvKipcbiAgICogTW9kdWxhdGVzIHRoZSBzdHlsZXMgb2YgdGhlIHBhc3NlZCBzdGVwJ3MgdGFyZ2V0IGVsZW1lbnQsIGJhc2VkIG9uIHRoZSBzdGVwJ3Mgb3B0aW9ucyBhbmRcbiAgICogdGhlIHRvdXIncyBgbW9kYWxgIG9wdGlvbiwgdG8gdmlzdWFsbHkgZW1waGFzaXplIHRoZSBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSBzdGVwIFRoZSBzdGVwIG9iamVjdCB0aGF0IGF0dGFjaGVzIHRvIHRoZSBlbGVtZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc3R5bGVUYXJnZXRFbGVtZW50Rm9yU3RlcChzdGVwKSB7XG4gICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IHN0ZXAudGFyZ2V0O1xuXG4gICAgaWYgKCF0YXJnZXRFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHN0ZXAub3B0aW9ucy5oaWdobGlnaHRDbGFzcykge1xuICAgICAgdGFyZ2V0RWxlbWVudC5jbGFzc0xpc3QuYWRkKHN0ZXAub3B0aW9ucy5oaWdobGlnaHRDbGFzcyk7XG4gICAgfVxuXG4gICAgdGFyZ2V0RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdzaGVwaGVyZC10YXJnZXQtY2xpY2stZGlzYWJsZWQnKTtcblxuICAgIGlmIChzdGVwLm9wdGlvbnMuY2FuQ2xpY2tUYXJnZXQgPT09IGZhbHNlKSB7XG4gICAgICB0YXJnZXRFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3NoZXBoZXJkLXRhcmdldC1jbGljay1kaXNhYmxlZCcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIGEgc3RlcCBpcyBoaWRkZW4sIHJlbW92ZSB0aGUgaGlnaGxpZ2h0Q2xhc3MgYW5kICdzaGVwaGVyZC1lbmFibGVkJ1xuICAgKiBhbmQgJ3NoZXBoZXJkLXRhcmdldCcgY2xhc3Nlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VwZGF0ZVN0ZXBUYXJnZXRPbkhpZGUoKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy50YXJnZXQgfHwgZG9jdW1lbnQuYm9keTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0Q2xhc3MpIHtcbiAgICAgIHRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMub3B0aW9ucy5oaWdobGlnaHRDbGFzcyk7XG4gICAgfVxuXG4gICAgdGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICAnc2hlcGhlcmQtdGFyZ2V0LWNsaWNrLWRpc2FibGVkJyxcbiAgICAgIGAke3RoaXMuY2xhc3NQcmVmaXh9c2hlcGhlcmQtZW5hYmxlZGAsXG4gICAgICBgJHt0aGlzLmNsYXNzUHJlZml4fXNoZXBoZXJkLXRhcmdldGBcbiAgICApO1xuICB9XG59XG4iLCIvKipcbiAqIENsZWFudXAgdGhlIHN0ZXBzIGFuZCBzZXQgcG9pbnRlckV2ZW50cyBiYWNrIHRvICdhdXRvJ1xuICogQHBhcmFtIHRvdXIgVGhlIHRvdXIgb2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhbnVwU3RlcHModG91cikge1xuICBpZiAodG91cikge1xuICAgIGNvbnN0IHsgc3RlcHMgfSA9IHRvdXI7XG5cbiAgICBzdGVwcy5mb3JFYWNoKChzdGVwKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIHN0ZXAub3B0aW9ucyAmJlxuICAgICAgICBzdGVwLm9wdGlvbnMuY2FuQ2xpY2tUYXJnZXQgPT09IGZhbHNlICYmXG4gICAgICAgIHN0ZXAub3B0aW9ucy5hdHRhY2hUb1xuICAgICAgKSB7XG4gICAgICAgIGlmIChzdGVwLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgc3RlcC50YXJnZXQuY2xhc3NMaXN0LnJlbW92ZSgnc2hlcGhlcmQtdGFyZ2V0LWNsaWNrLWRpc2FibGVkJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuIiwiLyoqXG4gKiBHZW5lcmF0ZXMgdGhlIHN2ZyBwYXRoIGRhdGEgZm9yIGEgcm91bmRlZCByZWN0YW5nbGUgb3ZlcmxheVxuICogQHBhcmFtIHtPYmplY3R9IGRpbWVuc2lvbiAtIERpbWVuc2lvbnMgb2YgcmVjdGFuZ2xlLlxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gV2lkdGguXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gSGVpZ2h0LlxuICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdIC0gT2Zmc2V0IGZyb20gdG9wIGxlZnQgY29ybmVyIGluIHggYXhpcy4gZGVmYXVsdCAwLlxuICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdIC0gT2Zmc2V0IGZyb20gdG9wIGxlZnQgY29ybmVyIGluIHkgYXhpcy4gZGVmYXVsdCAwLlxuICogQHBhcmFtIHtudW1iZXIgfCB7IHRvcExlZnQ6IG51bWJlciwgdG9wUmlnaHQ6IG51bWJlciwgYm90dG9tUmlnaHQ6IG51bWJlciwgYm90dG9tTGVmdDogbnVtYmVyIH19IFtyPTBdIC0gQ29ybmVyIFJhZGl1cy4gS2VlcCB0aGlzIHNtYWxsZXIgdGhhbiBoYWxmIG9mIHdpZHRoIG9yIGhlaWdodC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gUm91bmRlZCByZWN0YW5nbGUgb3ZlcmxheSBwYXRoIGRhdGEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlT3ZlcmxheVBhdGgoeyB3aWR0aCwgaGVpZ2h0LCB4ID0gMCwgeSA9IDAsIHIgPSAwIH0pIHtcbiAgY29uc3QgeyBpbm5lcldpZHRoOiB3LCBpbm5lckhlaWdodDogaCB9ID0gd2luZG93O1xuICBjb25zdCB7XG4gICAgdG9wTGVmdCA9IDAsXG4gICAgdG9wUmlnaHQgPSAwLFxuICAgIGJvdHRvbVJpZ2h0ID0gMCxcbiAgICBib3R0b21MZWZ0ID0gMFxuICB9ID0gdHlwZW9mIHIgPT09ICdudW1iZXInXG4gICAgPyB7IHRvcExlZnQ6IHIsIHRvcFJpZ2h0OiByLCBib3R0b21SaWdodDogciwgYm90dG9tTGVmdDogciB9XG4gICAgOiByO1xuXG4gIHJldHVybiBgTSR7d30sJHtofVxcXG5IMFxcXG5WMFxcXG5IJHt3fVxcXG5WJHtofVxcXG5aXFxcbk0ke3ggKyB0b3BMZWZ0fSwke3l9XFxcbmEke3RvcExlZnR9LCR7dG9wTGVmdH0sMCwwLDAtJHt0b3BMZWZ0fSwke3RvcExlZnR9XFxcblYke2hlaWdodCArIHkgLSBib3R0b21MZWZ0fVxcXG5hJHtib3R0b21MZWZ0fSwke2JvdHRvbUxlZnR9LDAsMCwwLCR7Ym90dG9tTGVmdH0sJHtib3R0b21MZWZ0fVxcXG5IJHt3aWR0aCArIHggLSBib3R0b21SaWdodH1cXFxuYSR7Ym90dG9tUmlnaHR9LCR7Ym90dG9tUmlnaHR9LDAsMCwwLCR7Ym90dG9tUmlnaHR9LSR7Ym90dG9tUmlnaHR9XFxcblYke3kgKyB0b3BSaWdodH1cXFxuYSR7dG9wUmlnaHR9LCR7dG9wUmlnaHR9LDAsMCwwLSR7dG9wUmlnaHR9LSR7dG9wUmlnaHR9XFxcblpgO1xufVxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgdXVpZCB9IGZyb20gJy4uL3V0aWxzL2dlbmVyYWwuanMnO1xuICBpbXBvcnQgeyBtYWtlT3ZlcmxheVBhdGggfSBmcm9tICcuLi91dGlscy9vdmVybGF5LXBhdGguanMnO1xuXG4gIGV4cG9ydCBsZXQgZWxlbWVudCwgb3BlbmluZ1Byb3BlcnRpZXM7XG4gIGNvbnN0IGd1aWQgPSB1dWlkKCk7XG4gIGxldCBtb2RhbElzVmlzaWJsZSA9IGZhbHNlO1xuICBsZXQgcmFmSWQgPSB1bmRlZmluZWQ7XG4gIGxldCBwYXRoRGVmaW5pdGlvbjtcblxuICAkOiBwYXRoRGVmaW5pdGlvbiA9IG1ha2VPdmVybGF5UGF0aChvcGVuaW5nUHJvcGVydGllcyk7XG5cbiAgY2xvc2VNb2RhbE9wZW5pbmcoKTtcblxuICBleHBvcnQgY29uc3QgZ2V0RWxlbWVudCA9ICgpID0+IGVsZW1lbnQ7XG5cbiAgZXhwb3J0IGZ1bmN0aW9uIGNsb3NlTW9kYWxPcGVuaW5nKCkge1xuICAgIG9wZW5pbmdQcm9wZXJ0aWVzID0ge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDAsXG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHI6IDBcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEhpZGUgdGhlIG1vZGFsIG92ZXJsYXlcbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiBoaWRlKCkge1xuICAgIG1vZGFsSXNWaXNpYmxlID0gZmFsc2U7XG5cbiAgICAvLyBFbnN1cmUgd2UgY2xlYW51cCBhbGwgZXZlbnQgbGlzdGVuZXJzIHdoZW4gd2UgaGlkZSB0aGUgbW9kYWxcbiAgICBfY2xlYW51cFN0ZXBFdmVudExpc3RlbmVycygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZXMgdGhlIGJvdW5kcyBvZiB0aGUgZWxlbWVudCB3ZSB3YW50IHRoZSBvcGVuaW5nIG92ZXJ0b3Agb2YgdG8gc2V0IHRoZSBkaW1lbnNpb25zIG9mIHRoZSBvcGVuaW5nIGFuZCBwb3NpdGlvbiBpdFxuICAgKiBAcGFyYW0ge051bWJlcn0gbW9kYWxPdmVybGF5T3BlbmluZ1BhZGRpbmcgQW4gYW1vdW50IG9mIHBhZGRpbmcgdG8gYWRkIGFyb3VuZCB0aGUgbW9kYWwgb3ZlcmxheSBvcGVuaW5nXG4gICAqIEBwYXJhbSB7TnVtYmVyIHwgeyB0b3BMZWZ0OiBOdW1iZXIsIGJvdHRvbUxlZnQ6IE51bWJlciwgYm90dG9tUmlnaHQ6IE51bWJlciwgdG9wUmlnaHQ6IE51bWJlciB9fSBtb2RhbE92ZXJsYXlPcGVuaW5nUmFkaXVzIEFuIGFtb3VudCBvZiBib3JkZXIgcmFkaXVzIHRvIGFkZCBhcm91bmQgdGhlIG1vZGFsIG92ZXJsYXkgb3BlbmluZ1xuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBzY3JvbGxQYXJlbnQgVGhlIHNjcm9sbGFibGUgcGFyZW50IG9mIHRoZSB0YXJnZXQgZWxlbWVudFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXRFbGVtZW50IFRoZSBlbGVtZW50IHRoZSBvcGVuaW5nIHdpbGwgZXhwb3NlXG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcG9zaXRpb25Nb2RhbChcbiAgICBtb2RhbE92ZXJsYXlPcGVuaW5nUGFkZGluZyA9IDAsXG4gICAgbW9kYWxPdmVybGF5T3BlbmluZ1JhZGl1cyA9IDAsXG4gICAgc2Nyb2xsUGFyZW50LFxuICAgIHRhcmdldEVsZW1lbnRcbiAgKSB7XG4gICAgaWYgKHRhcmdldEVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHsgeSwgaGVpZ2h0IH0gPSBfZ2V0VmlzaWJsZUhlaWdodCh0YXJnZXRFbGVtZW50LCBzY3JvbGxQYXJlbnQpO1xuICAgICAgY29uc3QgeyB4LCB3aWR0aCwgbGVmdCB9ID0gdGFyZ2V0RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgLy8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGlzIG5vdCBjb25zaXN0ZW50LiBTb21lIGJyb3dzZXJzIHVzZSB4IGFuZCB5LCB3aGlsZSBvdGhlcnMgdXNlIGxlZnQgYW5kIHRvcFxuICAgICAgb3BlbmluZ1Byb3BlcnRpZXMgPSB7XG4gICAgICAgIHdpZHRoOiB3aWR0aCArIG1vZGFsT3ZlcmxheU9wZW5pbmdQYWRkaW5nICogMixcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQgKyBtb2RhbE92ZXJsYXlPcGVuaW5nUGFkZGluZyAqIDIsXG4gICAgICAgIHg6ICh4IHx8IGxlZnQpIC0gbW9kYWxPdmVybGF5T3BlbmluZ1BhZGRpbmcsXG4gICAgICAgIHk6IHkgLSBtb2RhbE92ZXJsYXlPcGVuaW5nUGFkZGluZyxcbiAgICAgICAgcjogbW9kYWxPdmVybGF5T3BlbmluZ1JhZGl1c1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xvc2VNb2RhbE9wZW5pbmcoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSWYgbW9kYWwgaXMgZW5hYmxlZCwgc2V0dXAgdGhlIHN2ZyBtYXNrIG9wZW5pbmcgYW5kIG1vZGFsIG92ZXJsYXkgZm9yIHRoZSBzdGVwXG4gICAqIEBwYXJhbSB7U3RlcH0gc3RlcCBUaGUgc3RlcCBpbnN0YW5jZVxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHNldHVwRm9yU3RlcChzdGVwKSB7XG4gICAgLy8gRW5zdXJlIHdlIG1vdmUgbGlzdGVuZXJzIGZyb20gdGhlIHByZXZpb3VzIHN0ZXAsIGJlZm9yZSB3ZSBzZXR1cCBuZXcgb25lc1xuICAgIF9jbGVhbnVwU3RlcEV2ZW50TGlzdGVuZXJzKCk7XG5cbiAgICBpZiAoc3RlcC50b3VyLm9wdGlvbnMudXNlTW9kYWxPdmVybGF5KSB7XG4gICAgICBfc3R5bGVGb3JTdGVwKHN0ZXApO1xuICAgICAgc2hvdygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoaWRlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNob3cgdGhlIG1vZGFsIG92ZXJsYXlcbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiBzaG93KCkge1xuICAgIG1vZGFsSXNWaXNpYmxlID0gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0IF9wcmV2ZW50TW9kYWxCb2R5VG91Y2ggPSAoZSkgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfTtcblxuICBjb25zdCBfcHJldmVudE1vZGFsT3ZlcmxheVRvdWNoID0gKGUpID0+IHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgdG91Y2htb3ZlIGV2ZW50IGxpc3RlbmVyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfYWRkU3RlcEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIC8vIFByZXZlbnRzIHdpbmRvdyBmcm9tIG1vdmluZyBvbiB0b3VjaC5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgX3ByZXZlbnRNb2RhbEJvZHlUb3VjaCwge1xuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWwgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBsb29wIGFuZCByZW1vdmUgdG91Y2htb3ZlIGV2ZW50IGxpc3RlbmVyc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX2NsZWFudXBTdGVwRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKHJhZklkKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyYWZJZCk7XG4gICAgICByYWZJZCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgX3ByZXZlbnRNb2RhbEJvZHlUb3VjaCwge1xuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdHlsZSB0aGUgbW9kYWwgZm9yIHRoZSBzdGVwXG4gICAqIEBwYXJhbSB7U3RlcH0gc3RlcCBUaGUgc3RlcCB0byBzdHlsZSB0aGUgb3BlbmluZyBmb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9zdHlsZUZvclN0ZXAoc3RlcCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1vZGFsT3ZlcmxheU9wZW5pbmdQYWRkaW5nLFxuICAgICAgbW9kYWxPdmVybGF5T3BlbmluZ1JhZGl1c1xuICAgIH0gPSBzdGVwLm9wdGlvbnM7XG5cbiAgICBjb25zdCBzY3JvbGxQYXJlbnQgPSBfZ2V0U2Nyb2xsUGFyZW50KHN0ZXAudGFyZ2V0KTtcblxuICAgIC8vIFNldHVwIHJlY3Vyc2l2ZSBmdW5jdGlvbiB0byBjYWxsIHJlcXVlc3RBbmltYXRpb25GcmFtZSB0byB1cGRhdGUgdGhlIG1vZGFsIG9wZW5pbmcgcG9zaXRpb25cbiAgICBjb25zdCByYWZMb29wID0gKCkgPT4ge1xuICAgICAgcmFmSWQgPSB1bmRlZmluZWQ7XG4gICAgICBwb3NpdGlvbk1vZGFsKFxuICAgICAgICBtb2RhbE92ZXJsYXlPcGVuaW5nUGFkZGluZyxcbiAgICAgICAgbW9kYWxPdmVybGF5T3BlbmluZ1JhZGl1cyxcbiAgICAgICAgc2Nyb2xsUGFyZW50LFxuICAgICAgICBzdGVwLnRhcmdldFxuICAgICAgKTtcbiAgICAgIHJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZkxvb3ApO1xuICAgIH07XG5cbiAgICByYWZMb29wKCk7XG5cbiAgICBfYWRkU3RlcEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cblxuICAvKipcbiAgICogRmluZCB0aGUgY2xvc2VzdCBzY3JvbGxhYmxlIHBhcmVudCBlbGVtZW50XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgVGhlIHRhcmdldCBlbGVtZW50XG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9nZXRTY3JvbGxQYXJlbnQoZWxlbWVudCkge1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgaXNIdG1sRWxlbWVudCA9IGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbiAgICBjb25zdCBvdmVyZmxvd1kgPVxuICAgICAgaXNIdG1sRWxlbWVudCAmJiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5vdmVyZmxvd1k7XG4gICAgY29uc3QgaXNTY3JvbGxhYmxlID0gb3ZlcmZsb3dZICE9PSAnaGlkZGVuJyAmJiBvdmVyZmxvd1kgIT09ICd2aXNpYmxlJztcblxuICAgIGlmIChpc1Njcm9sbGFibGUgJiYgZWxlbWVudC5zY3JvbGxIZWlnaHQgPj0gZWxlbWVudC5jbGllbnRIZWlnaHQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIHJldHVybiBfZ2V0U2Nyb2xsUGFyZW50KGVsZW1lbnQucGFyZW50RWxlbWVudCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB2aXNpYmxlIGhlaWdodCBvZiB0aGUgdGFyZ2V0IGVsZW1lbnQgcmVsYXRpdmUgdG8gaXRzIHNjcm9sbFBhcmVudC5cbiAgICogSWYgdGhlcmUgaXMgbm8gc2Nyb2xsIHBhcmVudCwgdGhlIGhlaWdodCBvZiB0aGUgZWxlbWVudCBpcyByZXR1cm5lZC5cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgdGFyZ2V0IGVsZW1lbnRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW3Njcm9sbFBhcmVudF0gVGhlIHNjcm9sbGFibGUgcGFyZW50IGVsZW1lbnRcbiAgICogQHJldHVybnMge3t5OiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9nZXRWaXNpYmxlSGVpZ2h0KGVsZW1lbnQsIHNjcm9sbFBhcmVudCkge1xuICAgIGNvbnN0IGVsZW1lbnRSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgdG9wID0gZWxlbWVudFJlY3QueSB8fCBlbGVtZW50UmVjdC50b3A7XG4gICAgbGV0IGJvdHRvbSA9IGVsZW1lbnRSZWN0LmJvdHRvbSB8fCB0b3AgKyBlbGVtZW50UmVjdC5oZWlnaHQ7XG5cbiAgICBpZiAoc2Nyb2xsUGFyZW50KSB7XG4gICAgICBjb25zdCBzY3JvbGxSZWN0ID0gc2Nyb2xsUGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3Qgc2Nyb2xsVG9wID0gc2Nyb2xsUmVjdC55IHx8IHNjcm9sbFJlY3QudG9wO1xuICAgICAgY29uc3Qgc2Nyb2xsQm90dG9tID0gc2Nyb2xsUmVjdC5ib3R0b20gfHwgc2Nyb2xsVG9wICsgc2Nyb2xsUmVjdC5oZWlnaHQ7XG5cbiAgICAgIHRvcCA9IE1hdGgubWF4KHRvcCwgc2Nyb2xsVG9wKTtcbiAgICAgIGJvdHRvbSA9IE1hdGgubWluKGJvdHRvbSwgc2Nyb2xsQm90dG9tKTtcbiAgICB9XG5cbiAgICBjb25zdCBoZWlnaHQgPSBNYXRoLm1heChib3R0b20gLSB0b3AsIDApOyAvLyBEZWZhdWx0IHRvIDAgaWYgaGVpZ2h0IGlzIG5lZ2F0aXZlXG5cbiAgICByZXR1cm4geyB5OiB0b3AsIGhlaWdodCB9O1xuICB9XG48L3NjcmlwdD5cblxuPHN2Z1xuICBiaW5kOnRoaXM9e2VsZW1lbnR9XG4gIGNsYXNzPXtgJHtcbiAgICBtb2RhbElzVmlzaWJsZSA/ICdzaGVwaGVyZC1tb2RhbC1pcy12aXNpYmxlJyA6ICcnXG4gIH0gc2hlcGhlcmQtbW9kYWwtb3ZlcmxheS1jb250YWluZXJgfVxuICBvbjp0b3VjaG1vdmU9e19wcmV2ZW50TW9kYWxPdmVybGF5VG91Y2h9XG4+XG4gIDxwYXRoIGQ9e3BhdGhEZWZpbml0aW9ufSAvPlxuPC9zdmc+XG5cbjxzdHlsZSBnbG9iYWw+XG4gIC5zaGVwaGVyZC1tb2RhbC1vdmVybGF5LWNvbnRhaW5lciB7XG4gICAgaGVpZ2h0OiAwO1xuICAgIGxlZnQ6IDA7XG4gICAgb3BhY2l0eTogMDtcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICB0b3A6IDA7XG4gICAgdHJhbnNpdGlvbjogYWxsIDAuM3MgZWFzZS1vdXQsIGhlaWdodCAwbXMgMC4zcywgb3BhY2l0eSAwLjNzIDBtcztcbiAgICB3aWR0aDogMTAwdnc7XG4gICAgei1pbmRleDogOTk5NztcbiAgfVxuXG4gIC5zaGVwaGVyZC1tb2RhbC1vdmVybGF5LWNvbnRhaW5lci5zaGVwaGVyZC1tb2RhbC1pcy12aXNpYmxlIHtcbiAgICBoZWlnaHQ6IDEwMHZoO1xuICAgIG9wYWNpdHk6IDAuNTtcbiAgICB0cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlLW91dCwgaGVpZ2h0IDBzIDBzLCBvcGFjaXR5IDAuM3MgMHM7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVaKDApO1xuICB9XG5cbiAgLnNoZXBoZXJkLW1vZGFsLW92ZXJsYXktY29udGFpbmVyLnNoZXBoZXJkLW1vZGFsLWlzLXZpc2libGUgcGF0aCB7XG4gICAgcG9pbnRlci1ldmVudHM6IGFsbDtcbiAgfVxuPC9zdHlsZT5cbiIsImltcG9ydCB7IEV2ZW50ZWQgfSBmcm9tICcuL2V2ZW50ZWQuanMnO1xuaW1wb3J0IHsgU3RlcCB9IGZyb20gJy4vc3RlcC5qcyc7XG5pbXBvcnQgYXV0b0JpbmQgZnJvbSAnLi91dGlscy9hdXRvLWJpbmQuanMnO1xuaW1wb3J0IHtcbiAgaXNIVE1MRWxlbWVudCxcbiAgaXNGdW5jdGlvbixcbiAgaXNTdHJpbmcsXG4gIGlzVW5kZWZpbmVkXG59IGZyb20gJy4vdXRpbHMvdHlwZS1jaGVjay5qcyc7XG5pbXBvcnQgeyBjbGVhbnVwU3RlcHMgfSBmcm9tICcuL3V0aWxzL2NsZWFudXAuanMnO1xuaW1wb3J0IHsgbm9ybWFsaXplUHJlZml4LCB1dWlkIH0gZnJvbSAnLi91dGlscy9nZW5lcmFsLmpzJztcbmltcG9ydCBTaGVwaGVyZE1vZGFsIGZyb20gJy4vY29tcG9uZW50cy9zaGVwaGVyZC1tb2RhbC5zdmVsdGUnO1xuXG5jb25zdCBTaGVwaGVyZCA9IG5ldyBFdmVudGVkKCk7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIHRoZSBzaXRlIHRvdXJcbiAqIEBleHRlbmRzIHtFdmVudGVkfVxuICovXG5leHBvcnQgY2xhc3MgVG91ciBleHRlbmRzIEV2ZW50ZWQge1xuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIHRoZSB0b3VyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbiB8IGZ1bmN0aW9uKCk6IGJvb2xlYW4gfCBQcm9taXNlPGJvb2xlYW4+IHwgZnVuY3Rpb24oKTogUHJvbWlzZTxib29sZWFuPn0gb3B0aW9ucy5jb25maXJtQ2FuY2VsIElmIHRydWUsIHdpbGwgaXNzdWUgYSBgd2luZG93LmNvbmZpcm1gIGJlZm9yZSBjYW5jZWxsaW5nLlxuICAgKiBJZiBpdCBpcyBhIGZ1bmN0aW9uKHN1cHBvcnQgQXN5bmMgRnVuY3Rpb24pLCBpdCB3aWxsIGJlIGNhbGxlZCBhbmQgd2FpdCBmb3IgdGhlIHJldHVybiB2YWx1ZSwgYW5kIHdpbGwgb25seSBiZSBjYW5jZWxsZWQgaWYgdGhlIHZhbHVlIHJldHVybmVkIGlzIHRydWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY29uZmlybUNhbmNlbE1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gZGlzcGxheSBpbiB0aGUgYHdpbmRvdy5jb25maXJtYCBkaWFsb2dcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY2xhc3NQcmVmaXggVGhlIHByZWZpeCB0byBhZGQgdG8gdGhlIGBzaGVwaGVyZC1lbmFibGVkYCBhbmQgYHNoZXBoZXJkLXRhcmdldGAgY2xhc3MgbmFtZXMgYXMgd2VsbCBhcyB0aGUgYGRhdGEtc2hlcGhlcmQtc3RlcC1pZGAuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmRlZmF1bHRTdGVwT3B0aW9ucyBEZWZhdWx0IG9wdGlvbnMgZm9yIFN0ZXBzICh7QGxpbmsgU3RlcCNjb25zdHJ1Y3Rvcn0pLCBjcmVhdGVkIHRocm91Z2ggYGFkZFN0ZXBgXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5leGl0T25Fc2MgRXhpdGluZyB0aGUgdG91ciB3aXRoIHRoZSBlc2NhcGUga2V5IHdpbGwgYmUgZW5hYmxlZCB1bmxlc3MgdGhpcyBpcyBleHBsaWNpdGx5XG4gICAqIHNldCB0byBmYWxzZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmtleWJvYXJkTmF2aWdhdGlvbiBOYXZpZ2F0aW5nIHRoZSB0b3VyIHZpYSBsZWZ0IGFuZCByaWdodCBhcnJvdyBrZXlzIHdpbGwgYmUgZW5hYmxlZFxuICAgKiB1bmxlc3MgdGhpcyBpcyBleHBsaWNpdGx5IHNldCB0byBmYWxzZS5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gb3B0aW9ucy5zdGVwc0NvbnRhaW5lciBBbiBvcHRpb25hbCBjb250YWluZXIgZWxlbWVudCBmb3IgdGhlIHN0ZXBzLlxuICAgKiBJZiBub3Qgc2V0LCB0aGUgc3RlcHMgd2lsbCBiZSBhcHBlbmRlZCB0byBgZG9jdW1lbnQuYm9keWAuXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG9wdGlvbnMubW9kYWxDb250YWluZXIgQW4gb3B0aW9uYWwgY29udGFpbmVyIGVsZW1lbnQgZm9yIHRoZSBtb2RhbC5cbiAgICogSWYgbm90IHNldCwgdGhlIG1vZGFsIHdpbGwgYmUgYXBwZW5kZWQgdG8gYGRvY3VtZW50LmJvZHlgLlxuICAgKiBAcGFyYW0ge29iamVjdFtdIHwgU3RlcFtdfSBvcHRpb25zLnN0ZXBzIEFuIGFycmF5IG9mIHN0ZXAgb3B0aW9ucyBvYmplY3RzIG9yIFN0ZXAgaW5zdGFuY2VzIHRvIGluaXRpYWxpemUgdGhlIHRvdXIgd2l0aFxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50b3VyTmFtZSBBbiBvcHRpb25hbCBcIm5hbWVcIiBmb3IgdGhlIHRvdXIuIFRoaXMgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgdGhlIHRvdXInc1xuICAgKiBkeW5hbWljYWxseSBnZW5lcmF0ZWQgYGlkYCBwcm9wZXJ0eS5cbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnVzZU1vZGFsT3ZlcmxheSBXaGV0aGVyIG9yIG5vdCBzdGVwcyBzaG91bGQgYmUgcGxhY2VkIGFib3ZlIGEgZGFya2VuZWRcbiAgICogbW9kYWwgb3ZlcmxheS4gSWYgdHJ1ZSwgdGhlIG92ZXJsYXkgd2lsbCBjcmVhdGUgYW4gb3BlbmluZyBhcm91bmQgdGhlIHRhcmdldCBlbGVtZW50IHNvIHRoYXQgaXRcbiAgICogY2FuIHJlbWFpbiBpbnRlcmFjdGl2ZVxuICAgKiBAcmV0dXJucyB7VG91cn1cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuXG4gICAgYXV0b0JpbmQodGhpcyk7XG5cbiAgICBjb25zdCBkZWZhdWx0VG91ck9wdGlvbnMgPSB7XG4gICAgICBleGl0T25Fc2M6IHRydWUsXG4gICAgICBrZXlib2FyZE5hdmlnYXRpb246IHRydWVcbiAgICB9O1xuXG4gICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFRvdXJPcHRpb25zLCBvcHRpb25zKTtcbiAgICB0aGlzLmNsYXNzUHJlZml4ID0gbm9ybWFsaXplUHJlZml4KHRoaXMub3B0aW9ucy5jbGFzc1ByZWZpeCk7XG4gICAgdGhpcy5zdGVwcyA9IFtdO1xuICAgIHRoaXMuYWRkU3RlcHModGhpcy5vcHRpb25zLnN0ZXBzKTtcblxuICAgIC8vIFBhc3MgdGhlc2UgZXZlbnRzIG9udG8gdGhlIGdsb2JhbCBTaGVwaGVyZCBvYmplY3RcbiAgICBjb25zdCBldmVudHMgPSBbXG4gICAgICAnYWN0aXZlJyxcbiAgICAgICdjYW5jZWwnLFxuICAgICAgJ2NvbXBsZXRlJyxcbiAgICAgICdpbmFjdGl2ZScsXG4gICAgICAnc2hvdycsXG4gICAgICAnc3RhcnQnXG4gICAgXTtcbiAgICBldmVudHMubWFwKChldmVudCkgPT4ge1xuICAgICAgKChlKSA9PiB7XG4gICAgICAgIHRoaXMub24oZSwgKG9wdHMpID0+IHtcbiAgICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgICBvcHRzLnRvdXIgPSB0aGlzO1xuICAgICAgICAgIFNoZXBoZXJkLnRyaWdnZXIoZSwgb3B0cyk7XG4gICAgICAgIH0pO1xuICAgICAgfSkoZXZlbnQpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fc2V0VG91cklEKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgbmV3IHN0ZXAgdG8gdGhlIHRvdXJcbiAgICogQHBhcmFtIHtPYmplY3R8U3RlcH0gb3B0aW9ucyBBbiBvYmplY3QgY29udGFpbmluZyBzdGVwIG9wdGlvbnMgb3IgYSBTdGVwIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgb3B0aW9uYWwgaW5kZXggdG8gaW5zZXJ0IHRoZSBzdGVwIGF0LiBJZiB1bmRlZmluZWQsIHRoZSBzdGVwXG4gICAqIGlzIGFkZGVkIHRvIHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgKiBAcmV0dXJuIHtTdGVwfSBUaGUgbmV3bHkgYWRkZWQgc3RlcFxuICAgKi9cbiAgYWRkU3RlcChvcHRpb25zLCBpbmRleCkge1xuICAgIGxldCBzdGVwID0gb3B0aW9ucztcblxuICAgIGlmICghKHN0ZXAgaW5zdGFuY2VvZiBTdGVwKSkge1xuICAgICAgc3RlcCA9IG5ldyBTdGVwKHRoaXMsIHN0ZXApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGVwLnRvdXIgPSB0aGlzO1xuICAgIH1cblxuICAgIGlmICghaXNVbmRlZmluZWQoaW5kZXgpKSB7XG4gICAgICB0aGlzLnN0ZXBzLnNwbGljZShpbmRleCwgMCwgc3RlcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RlcHMucHVzaChzdGVwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RlcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgbXVsdGlwbGUgc3RlcHMgdG8gdGhlIHRvdXJcbiAgICogQHBhcmFtIHtBcnJheTxvYmplY3Q+IHwgQXJyYXk8U3RlcD59IHN0ZXBzIFRoZSBzdGVwcyB0byBhZGQgdG8gdGhlIHRvdXJcbiAgICovXG4gIGFkZFN0ZXBzKHN0ZXBzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3RlcHMpKSB7XG4gICAgICBzdGVwcy5mb3JFYWNoKChzdGVwKSA9PiB7XG4gICAgICAgIHRoaXMuYWRkU3RlcChzdGVwKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdvIHRvIHRoZSBwcmV2aW91cyBzdGVwIGluIHRoZSB0b3VyXG4gICAqL1xuICBiYWNrKCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5zdGVwcy5pbmRleE9mKHRoaXMuY3VycmVudFN0ZXApO1xuICAgIHRoaXMuc2hvdyhpbmRleCAtIDEsIGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxscyBfZG9uZSgpIHRyaWdnZXJpbmcgdGhlICdjYW5jZWwnIGV2ZW50XG4gICAqIElmIGBjb25maXJtQ2FuY2VsYCBpcyB0cnVlLCB3aWxsIHNob3cgYSB3aW5kb3cuY29uZmlybSBiZWZvcmUgY2FuY2VsbGluZ1xuICAgKiBJZiBgY29uZmlybUNhbmNlbGAgaXMgYSBmdW5jdGlvbiwgd2lsbCBjYWxsIGl0IGFuZCB3YWl0IGZvciB0aGUgcmV0dXJuIHZhbHVlLFxuICAgKiBhbmQgb25seSBjYW5jZWwgd2hlbiB0aGUgdmFsdWUgcmV0dXJuZWQgaXMgdHJ1ZVxuICAgKi9cbiAgYXN5bmMgY2FuY2VsKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuY29uZmlybUNhbmNlbCkge1xuICAgICAgY29uc3QgY29uZmlybUNhbmNlbElzRnVuY3Rpb24gPVxuICAgICAgICB0eXBlb2YgdGhpcy5vcHRpb25zLmNvbmZpcm1DYW5jZWwgPT09ICdmdW5jdGlvbic7XG4gICAgICBjb25zdCBjYW5jZWxNZXNzYWdlID1cbiAgICAgICAgdGhpcy5vcHRpb25zLmNvbmZpcm1DYW5jZWxNZXNzYWdlIHx8XG4gICAgICAgICdBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gc3RvcCB0aGUgdG91cj8nO1xuICAgICAgY29uc3Qgc3RvcFRvdXIgPSBjb25maXJtQ2FuY2VsSXNGdW5jdGlvblxuICAgICAgICA/IGF3YWl0IHRoaXMub3B0aW9ucy5jb25maXJtQ2FuY2VsKClcbiAgICAgICAgOiB3aW5kb3cuY29uZmlybShjYW5jZWxNZXNzYWdlKTtcbiAgICAgIGlmIChzdG9wVG91cikge1xuICAgICAgICB0aGlzLl9kb25lKCdjYW5jZWwnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZG9uZSgnY2FuY2VsJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxzIF9kb25lKCkgdHJpZ2dlcmluZyB0aGUgYGNvbXBsZXRlYCBldmVudFxuICAgKi9cbiAgY29tcGxldGUoKSB7XG4gICAgdGhpcy5fZG9uZSgnY29tcGxldGUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzdGVwIGZyb20gYSBnaXZlbiBpZFxuICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGlkIFRoZSBpZCBvZiB0aGUgc3RlcCB0byByZXRyaWV2ZVxuICAgKiBAcmV0dXJuIHtTdGVwfSBUaGUgc3RlcCBjb3JyZXNwb25kaW5nIHRvIHRoZSBgaWRgXG4gICAqL1xuICBnZXRCeUlkKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RlcHMuZmluZCgoc3RlcCkgPT4ge1xuICAgICAgcmV0dXJuIHN0ZXAuaWQgPT09IGlkO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgc3RlcFxuICAgKiBAcmV0dXJucyB7U3RlcHxudWxsfVxuICAgKi9cbiAgZ2V0Q3VycmVudFN0ZXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFN0ZXA7XG4gIH1cblxuICAvKipcbiAgICogSGlkZSB0aGUgY3VycmVudCBzdGVwXG4gICAqL1xuICBoaWRlKCkge1xuICAgIGNvbnN0IGN1cnJlbnRTdGVwID0gdGhpcy5nZXRDdXJyZW50U3RlcCgpO1xuXG4gICAgaWYgKGN1cnJlbnRTdGVwKSB7XG4gICAgICByZXR1cm4gY3VycmVudFN0ZXAuaGlkZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgdG91ciBpcyBhY3RpdmVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQWN0aXZlKCkge1xuICAgIHJldHVybiBTaGVwaGVyZC5hY3RpdmVUb3VyID09PSB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdvIHRvIHRoZSBuZXh0IHN0ZXAgaW4gdGhlIHRvdXJcbiAgICogSWYgd2UgYXJlIGF0IHRoZSBlbmQsIGNhbGwgYGNvbXBsZXRlYFxuICAgKi9cbiAgbmV4dCgpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuc3RlcHMuaW5kZXhPZih0aGlzLmN1cnJlbnRTdGVwKTtcblxuICAgIGlmIChpbmRleCA9PT0gdGhpcy5zdGVwcy5sZW5ndGggLSAxKSB7XG4gICAgICB0aGlzLmNvbXBsZXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2hvdyhpbmRleCArIDEsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBzdGVwIGZyb20gdGhlIHRvdXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIGlkIGZvciB0aGUgc3RlcCB0byByZW1vdmVcbiAgICovXG4gIHJlbW92ZVN0ZXAobmFtZSkge1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmdldEN1cnJlbnRTdGVwKCk7XG5cbiAgICAvLyBGaW5kIHRoZSBzdGVwLCBkZXN0cm95IGl0IGFuZCByZW1vdmUgaXQgZnJvbSB0aGlzLnN0ZXBzXG4gICAgdGhpcy5zdGVwcy5zb21lKChzdGVwLCBpKSA9PiB7XG4gICAgICBpZiAoc3RlcC5pZCA9PT0gbmFtZSkge1xuICAgICAgICBpZiAoc3RlcC5pc09wZW4oKSkge1xuICAgICAgICAgIHN0ZXAuaGlkZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RlcC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuc3RlcHMuc3BsaWNlKGksIDEpO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGN1cnJlbnQgJiYgY3VycmVudC5pZCA9PT0gbmFtZSkge1xuICAgICAgdGhpcy5jdXJyZW50U3RlcCA9IHVuZGVmaW5lZDtcblxuICAgICAgLy8gSWYgd2UgaGF2ZSBzdGVwcyBsZWZ0LCBzaG93IHRoZSBmaXJzdCBvbmUsIG90aGVyd2lzZSBqdXN0IGNhbmNlbCB0aGUgdG91clxuICAgICAgdGhpcy5zdGVwcy5sZW5ndGggPyB0aGlzLnNob3coMCkgOiB0aGlzLmNhbmNlbCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTaG93IGEgc3BlY2lmaWMgc3RlcCBpbiB0aGUgdG91clxuICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGtleSBUaGUga2V5IHRvIGxvb2sgdXAgdGhlIHN0ZXAgYnlcbiAgICogQHBhcmFtIHtCb29sZWFufSBmb3J3YXJkIFRydWUgaWYgd2UgYXJlIGdvaW5nIGZvcndhcmQsIGZhbHNlIGlmIGJhY2t3YXJkXG4gICAqL1xuICBzaG93KGtleSA9IDAsIGZvcndhcmQgPSB0cnVlKSB7XG4gICAgY29uc3Qgc3RlcCA9IGlzU3RyaW5nKGtleSkgPyB0aGlzLmdldEJ5SWQoa2V5KSA6IHRoaXMuc3RlcHNba2V5XTtcblxuICAgIGlmIChzdGVwKSB7XG4gICAgICB0aGlzLl91cGRhdGVTdGF0ZUJlZm9yZVNob3coKTtcblxuICAgICAgY29uc3Qgc2hvdWxkU2tpcFN0ZXAgPVxuICAgICAgICBpc0Z1bmN0aW9uKHN0ZXAub3B0aW9ucy5zaG93T24pICYmICFzdGVwLm9wdGlvbnMuc2hvd09uKCk7XG5cbiAgICAgIC8vIElmIGBzaG93T25gIHJldHVybnMgZmFsc2UsIHdlIHdhbnQgdG8gc2tpcCB0aGUgc3RlcCwgb3RoZXJ3aXNlLCBzaG93IHRoZSBzdGVwIGxpa2Ugbm9ybWFsXG4gICAgICBpZiAoc2hvdWxkU2tpcFN0ZXApIHtcbiAgICAgICAgdGhpcy5fc2tpcFN0ZXAoc3RlcCwgZm9yd2FyZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ3Nob3cnLCB7XG4gICAgICAgICAgc3RlcCxcbiAgICAgICAgICBwcmV2aW91czogdGhpcy5jdXJyZW50U3RlcFxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmN1cnJlbnRTdGVwID0gc3RlcDtcbiAgICAgICAgc3RlcC5zaG93KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHRoZSB0b3VyXG4gICAqL1xuICBzdGFydCgpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ3N0YXJ0Jyk7XG5cbiAgICAvLyBTYXZlIHRoZSBmb2N1c2VkIGVsZW1lbnQgYmVmb3JlIHRoZSB0b3VyIG9wZW5zXG4gICAgdGhpcy5mb2N1c2VkRWxCZWZvcmVPcGVuID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblxuICAgIHRoaXMuY3VycmVudFN0ZXAgPSBudWxsO1xuXG4gICAgdGhpcy5fc2V0dXBNb2RhbCgpO1xuXG4gICAgdGhpcy5fc2V0dXBBY3RpdmVUb3VyKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW5ldmVyIHRoZSB0b3VyIGlzIGNhbmNlbGxlZCBvciBjb21wbGV0ZWQsIGJhc2ljYWxseSBhbnl0aW1lIHdlIGV4aXQgdGhlIHRvdXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IFRoZSBldmVudCBuYW1lIHRvIHRyaWdnZXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kb25lKGV2ZW50KSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnN0ZXBzLmluZGV4T2YodGhpcy5jdXJyZW50U3RlcCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5zdGVwcykpIHtcbiAgICAgIHRoaXMuc3RlcHMuZm9yRWFjaCgoc3RlcCkgPT4gc3RlcC5kZXN0cm95KCkpO1xuICAgIH1cblxuICAgIGNsZWFudXBTdGVwcyh0aGlzKTtcblxuICAgIHRoaXMudHJpZ2dlcihldmVudCwgeyBpbmRleCB9KTtcblxuICAgIFNoZXBoZXJkLmFjdGl2ZVRvdXIgPSBudWxsO1xuICAgIHRoaXMudHJpZ2dlcignaW5hY3RpdmUnLCB7IHRvdXI6IHRoaXMgfSk7XG5cbiAgICBpZiAodGhpcy5tb2RhbCkge1xuICAgICAgdGhpcy5tb2RhbC5oaWRlKCk7XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50ID09PSAnY2FuY2VsJyB8fCBldmVudCA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgaWYgKHRoaXMubW9kYWwpIHtcbiAgICAgICAgY29uc3QgbW9kYWxDb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgICcuc2hlcGhlcmQtbW9kYWwtb3ZlcmxheS1jb250YWluZXInXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKG1vZGFsQ29udGFpbmVyKSB7XG4gICAgICAgICAgbW9kYWxDb250YWluZXIucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGb2N1cyB0aGUgZWxlbWVudCB0aGF0IHdhcyBmb2N1c2VkIGJlZm9yZSB0aGUgdG91ciBzdGFydGVkXG4gICAgaWYgKGlzSFRNTEVsZW1lbnQodGhpcy5mb2N1c2VkRWxCZWZvcmVPcGVuKSkge1xuICAgICAgdGhpcy5mb2N1c2VkRWxCZWZvcmVPcGVuLmZvY3VzKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1ha2UgdGhpcyB0b3VyIFwiYWN0aXZlXCJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXR1cEFjdGl2ZVRvdXIoKSB7XG4gICAgdGhpcy50cmlnZ2VyKCdhY3RpdmUnLCB7IHRvdXI6IHRoaXMgfSk7XG5cbiAgICBTaGVwaGVyZC5hY3RpdmVUb3VyID0gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBfc2V0dXBNb2RhbCBjcmVhdGUgdGhlIG1vZGFsIGNvbnRhaW5lciBhbmQgaW5zdGFuY2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXR1cE1vZGFsKCkge1xuICAgIHRoaXMubW9kYWwgPSBuZXcgU2hlcGhlcmRNb2RhbCh7XG4gICAgICB0YXJnZXQ6IHRoaXMub3B0aW9ucy5tb2RhbENvbnRhaW5lciB8fCBkb2N1bWVudC5ib2R5LFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgY2xhc3NQcmVmaXg6IHRoaXMuY2xhc3NQcmVmaXgsXG4gICAgICAgIHN0eWxlczogdGhpcy5zdHlsZXNcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBgc2hvd09uYCBldmFsdWF0ZXMgdG8gZmFsc2UsIHRvIHNraXAgdGhlIHN0ZXAgb3IgY29tcGxldGUgdGhlIHRvdXIgaWYgaXQncyB0aGUgbGFzdCBzdGVwXG4gICAqIEBwYXJhbSB7U3RlcH0gc3RlcCBUaGUgc3RlcCB0byBza2lwXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yd2FyZCBUcnVlIGlmIHdlIGFyZSBnb2luZyBmb3J3YXJkLCBmYWxzZSBpZiBiYWNrd2FyZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NraXBTdGVwKHN0ZXAsIGZvcndhcmQpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuc3RlcHMuaW5kZXhPZihzdGVwKTtcblxuICAgIGlmIChpbmRleCA9PT0gdGhpcy5zdGVwcy5sZW5ndGggLSAxKSB7XG4gICAgICB0aGlzLmNvbXBsZXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5leHRJbmRleCA9IGZvcndhcmQgPyBpbmRleCArIDEgOiBpbmRleCAtIDE7XG4gICAgICB0aGlzLnNob3cobmV4dEluZGV4LCBmb3J3YXJkKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQmVmb3JlIHNob3dpbmcsIGhpZGUgdGhlIGN1cnJlbnQgc3RlcCBhbmQgaWYgdGhlIHRvdXIgaXMgbm90XG4gICAqIGFscmVhZHkgYWN0aXZlLCBjYWxsIGB0aGlzLl9zZXR1cEFjdGl2ZVRvdXJgLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VwZGF0ZVN0YXRlQmVmb3JlU2hvdygpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50U3RlcCkge1xuICAgICAgdGhpcy5jdXJyZW50U3RlcC5oaWRlKCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmlzQWN0aXZlKCkpIHtcbiAgICAgIHRoaXMuX3NldHVwQWN0aXZlVG91cigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoaXMuaWQgdG8gYCR7dG91ck5hbWV9LS0ke3V1aWR9YFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldFRvdXJJRCgpIHtcbiAgICBjb25zdCB0b3VyTmFtZSA9IHRoaXMub3B0aW9ucy50b3VyTmFtZSB8fCAndG91cic7XG5cbiAgICB0aGlzLmlkID0gYCR7dG91ck5hbWV9LS0ke3V1aWQoKX1gO1xuICB9XG59XG5cbmV4cG9ydCB7IFNoZXBoZXJkIH07XG4iLCJpbXBvcnQgeyBTdGVwIH0gZnJvbSAnLi9zdGVwLmpzJztcbmltcG9ydCB7IFNoZXBoZXJkLCBUb3VyIH0gZnJvbSAnLi90b3VyLmpzJztcblxuY29uc3QgaXNTZXJ2ZXJTaWRlID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCc7XG5cbmNsYXNzIE5vT3Age1xuICBjb25zdHJ1Y3RvcigpIHt9XG59XG5cbmlmIChpc1NlcnZlclNpZGUpIHtcbiAgT2JqZWN0LmFzc2lnbihTaGVwaGVyZCwgeyBUb3VyOiBOb09wLCBTdGVwOiBOb09wIH0pO1xufSBlbHNlIHtcbiAgT2JqZWN0LmFzc2lnbihTaGVwaGVyZCwgeyBUb3VyLCBTdGVwIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBTaGVwaGVyZDtcbiJdLCJuYW1lcyI6WyJpc01lcmdlYWJsZU9iamVjdCIsInZhbHVlIiwiaXNOb25OdWxsT2JqZWN0IiwiaXNTcGVjaWFsIiwiX3R5cGVvZiIsInN0cmluZ1ZhbHVlIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwiaXNSZWFjdEVsZW1lbnQiLCJjYW5Vc2VTeW1ib2wiLCJTeW1ib2wiLCJmb3IiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCIkJHR5cGVvZiIsImVtcHR5VGFyZ2V0IiwidmFsIiwiQXJyYXkiLCJpc0FycmF5IiwiY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQiLCJvcHRpb25zIiwiY2xvbmUiLCJkZWVwbWVyZ2UiLCJkZWZhdWx0QXJyYXlNZXJnZSIsInRhcmdldCIsInNvdXJjZSIsImNvbmNhdCIsIm1hcCIsImVsZW1lbnQiLCJnZXRNZXJnZUZ1bmN0aW9uIiwia2V5IiwiY3VzdG9tTWVyZ2UiLCJnZXRFbnVtZXJhYmxlT3duUHJvcGVydHlTeW1ib2xzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZmlsdGVyIiwic3ltYm9sIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJnZXRLZXlzIiwia2V5cyIsInByb3BlcnR5SXNPbk9iamVjdCIsIm9iamVjdCIsInByb3BlcnR5IiwiXyIsInByb3BlcnR5SXNVbnNhZmUiLCJoYXNPd25Qcm9wZXJ0eSIsIm1lcmdlT2JqZWN0IiwiZGVzdGluYXRpb24iLCJmb3JFYWNoIiwiYXJyYXlNZXJnZSIsInNvdXJjZUlzQXJyYXkiLCJ0YXJnZXRJc0FycmF5Iiwic291cmNlQW5kVGFyZ2V0VHlwZXNNYXRjaCIsImFsbCIsImRlZXBtZXJnZUFsbCIsImFycmF5IiwiRXJyb3IiLCJyZWR1Y2UiLCJwcmV2IiwibmV4dCIsImRlZXBtZXJnZV8xIiwiY2pzIiwiaXNFbGVtZW50JDEiLCJFbGVtZW50IiwiaXNIVE1MRWxlbWVudCQxIiwiSFRNTEVsZW1lbnQiLCJpc0Z1bmN0aW9uIiwiaXNTdHJpbmciLCJpc1VuZGVmaW5lZCIsInVuZGVmaW5lZCIsIkV2ZW50ZWQiLCJfY2xhc3NDYWxsQ2hlY2siLCJfY3JlYXRlQ2xhc3MiLCJvbiIsImV2ZW50IiwiaGFuZGxlciIsImN0eCIsIm9uY2UiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJiaW5kaW5ncyIsInB1c2giLCJvZmYiLCJfdGhpcyIsImJpbmRpbmciLCJpbmRleCIsInNwbGljZSIsInRyaWdnZXIiLCJfdGhpczIiLCJfbGVuIiwiYXJncyIsIl9rZXkiLCJjb250ZXh0IiwiYXBwbHkiLCJhdXRvQmluZCIsInNlbGYiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiY29uc3RydWN0b3IiLCJpIiwiYmluZCIsIl9zZXR1cEFkdmFuY2VPbkhhbmRsZXIiLCJzZWxlY3RvciIsInN0ZXAiLCJpc09wZW4iLCJ0YXJnZXRJc0VsIiwiZWwiLCJjdXJyZW50VGFyZ2V0IiwidGFyZ2V0SXNTZWxlY3RvciIsIm1hdGNoZXMiLCJ0b3VyIiwiYmluZEFkdmFuY2UiLCJfcmVmMiIsImFkdmFuY2VPbiIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsImUiLCJjb25zb2xlIiwiZXJyb3IiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImJvZHkiLCJub3JtYWxpemVQcmVmaXgiLCJwcmVmaXgiLCJjaGFyQXQiLCJwYXJzZUF0dGFjaFRvIiwiYXR0YWNoVG8iLCJyZXR1cm5PcHRzIiwiYXNzaWduIiwic2hvdWxkQ2VudGVyU3RlcCIsInJlc29sdmVkQXR0YWNoVG9PcHRpb25zIiwidXVpZCIsImQiLCJEYXRlIiwibm93IiwicmVwbGFjZSIsImMiLCJyIiwiTWF0aCIsInJhbmRvbSIsImZsb29yIiwibWluIiwibWF4Iiwicm91bmQiLCJjcmVhdGVDb29yZHMiLCJ2IiwieCIsInkiLCJvcHBvc2l0ZVNpZGVNYXAiLCJsZWZ0IiwicmlnaHQiLCJib3R0b20iLCJ0b3AiLCJvcHBvc2l0ZUFsaWdubWVudE1hcCIsInN0YXJ0IiwiZW5kIiwiY2xhbXAiLCJldmFsdWF0ZSIsInBhcmFtIiwiZ2V0U2lkZSIsInBsYWNlbWVudCIsInNwbGl0IiwiZ2V0QWxpZ25tZW50IiwiZ2V0T3Bwb3NpdGVBeGlzIiwiYXhpcyIsImdldEF4aXNMZW5ndGgiLCJnZXRTaWRlQXhpcyIsImluY2x1ZGVzIiwiZ2V0QWxpZ25tZW50QXhpcyIsImdldEFsaWdubWVudFNpZGVzIiwicmVjdHMiLCJydGwiLCJhbGlnbm1lbnQiLCJhbGlnbm1lbnRBeGlzIiwibWFpbkFsaWdubWVudFNpZGUiLCJyZWZlcmVuY2UiLCJmbG9hdGluZyIsImdldE9wcG9zaXRlUGxhY2VtZW50IiwiZ2V0RXhwYW5kZWRQbGFjZW1lbnRzIiwib3Bwb3NpdGVQbGFjZW1lbnQiLCJnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudCIsImdldFNpZGVMaXN0Iiwic2lkZSIsImlzU3RhcnQiLCJsciIsInJsIiwidGIiLCJidCIsImdldE9wcG9zaXRlQXhpc1BsYWNlbWVudHMiLCJmbGlwQWxpZ25tZW50IiwiZGlyZWN0aW9uIiwibGlzdCIsImV4cGFuZFBhZGRpbmdPYmplY3QiLCJwYWRkaW5nIiwiX2V4dGVuZHMiLCJnZXRQYWRkaW5nT2JqZWN0IiwicmVjdFRvQ2xpZW50UmVjdCIsInJlY3QiLCJ3aWR0aCIsImhlaWdodCIsImNvbXB1dGVDb29yZHNGcm9tUGxhY2VtZW50IiwiX3JlZiIsInNpZGVBeGlzIiwiYWxpZ25MZW5ndGgiLCJpc1ZlcnRpY2FsIiwiY29tbW9uWCIsImNvbW1vblkiLCJjb21tb25BbGlnbiIsImNvb3JkcyIsImNvbXB1dGVQb3NpdGlvbiQxIiwiX3JlZjMiLCJfYXN5bmNUb0dlbmVyYXRvciIsIl9yZWdlbmVyYXRvclJ1bnRpbWUiLCJtYXJrIiwiX2NhbGxlZSIsImNvbmZpZyIsIl9jb25maWckcGxhY2VtZW50IiwiX2NvbmZpZyRzdHJhdGVneSIsInN0cmF0ZWd5IiwiX2NvbmZpZyRtaWRkbGV3YXJlIiwibWlkZGxld2FyZSIsInBsYXRmb3JtIiwidmFsaWRNaWRkbGV3YXJlIiwiX2NvbXB1dGVDb29yZHNGcm9tUGxhIiwic3RhdGVmdWxQbGFjZW1lbnQiLCJtaWRkbGV3YXJlRGF0YSIsInJlc2V0Q291bnQiLCJfdmFsaWRNaWRkbGV3YXJlJGkiLCJuYW1lIiwiZm4iLCJfeWllbGQkZm4iLCJuZXh0WCIsIm5leHRZIiwiZGF0YSIsInJlc2V0IiwiX2NvbXB1dGVDb29yZHNGcm9tUGxhMiIsIndyYXAiLCJfY2FsbGVlJCIsIl9jb250ZXh0IiwiQm9vbGVhbiIsImlzUlRMIiwic2VudCIsImdldEVsZW1lbnRSZWN0cyIsImluaXRpYWxQbGFjZW1lbnQiLCJlbGVtZW50cyIsIl9kZWZpbmVQcm9wZXJ0eSIsInQwIiwiYWJydXB0Iiwic3RvcCIsImNvbXB1dGVQb3NpdGlvbiIsIl94IiwiX3gyIiwiX3gzIiwiZGV0ZWN0T3ZlcmZsb3ciLCJfeDQiLCJfeDUiLCJfZGV0ZWN0T3ZlcmZsb3ciLCJfY2FsbGVlNyIsInN0YXRlIiwiX2F3YWl0JHBsYXRmb3JtJGlzRWxlIiwiX2V2YWx1YXRlMyIsIl9ldmFsdWF0ZTMkYm91bmRhcnkiLCJib3VuZGFyeSIsIl9ldmFsdWF0ZTMkcm9vdEJvdW5kYSIsInJvb3RCb3VuZGFyeSIsIl9ldmFsdWF0ZTMkZWxlbWVudENvbiIsImVsZW1lbnRDb250ZXh0IiwiX2V2YWx1YXRlMyRhbHRCb3VuZGFyIiwiYWx0Qm91bmRhcnkiLCJfZXZhbHVhdGUzJHBhZGRpbmciLCJwYWRkaW5nT2JqZWN0IiwiYWx0Q29udGV4dCIsImNsaXBwaW5nQ2xpZW50UmVjdCIsIm9mZnNldFBhcmVudCIsIm9mZnNldFNjYWxlIiwiZWxlbWVudENsaWVudFJlY3QiLCJfY2FsbGVlNyQiLCJfY29udGV4dDciLCJ0MSIsImlzRWxlbWVudCIsInQyIiwidDMiLCJ0NCIsInQ1IiwiY29udGV4dEVsZW1lbnQiLCJnZXREb2N1bWVudEVsZW1lbnQiLCJ0NiIsInQ3IiwidDgiLCJ0OSIsInQxMCIsImdldENsaXBwaW5nUmVjdCIsInQxMSIsImdldE9mZnNldFBhcmVudCIsImdldFNjYWxlIiwidDEzIiwidDEyIiwidDE0IiwiY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3QiLCJ0MTUiLCJ0MTYiLCJhcnJvdyIsIl9jYWxsZWUyIiwiX3JlZjQiLCJfcmVmNCRwYWRkaW5nIiwiYXJyb3dEaW1lbnNpb25zIiwiaXNZQXhpcyIsIm1pblByb3AiLCJtYXhQcm9wIiwiY2xpZW50UHJvcCIsImVuZERpZmYiLCJzdGFydERpZmYiLCJhcnJvd09mZnNldFBhcmVudCIsImNsaWVudFNpemUiLCJjZW50ZXJUb1JlZmVyZW5jZSIsImxhcmdlc3RQb3NzaWJsZVBhZGRpbmciLCJtaW5QYWRkaW5nIiwibWF4UGFkZGluZyIsIm1pbiQxIiwiY2VudGVyIiwib2Zmc2V0Iiwic2hvdWxkQWRkT2Zmc2V0IiwiYWxpZ25tZW50T2Zmc2V0IiwiX2NhbGxlZTIkIiwiX2NvbnRleHQyIiwiZ2V0RGltZW5zaW9ucyIsImZsaXAiLCJfY2FsbGVlMyIsIl9taWRkbGV3YXJlRGF0YSRmbGlwIiwiX2V2YWx1YXRlMiIsIl9ldmFsdWF0ZTIkbWFpbkF4aXMiLCJjaGVja01haW5BeGlzIiwiX2V2YWx1YXRlMiRjcm9zc0F4aXMiLCJjaGVja0Nyb3NzQXhpcyIsInNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyIsIl9ldmFsdWF0ZTIkZmFsbGJhY2tTdCIsImZhbGxiYWNrU3RyYXRlZ3kiLCJfZXZhbHVhdGUyJGZhbGxiYWNrQXgiLCJmYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uIiwiX2V2YWx1YXRlMiRmbGlwQWxpZ25tIiwiZGV0ZWN0T3ZlcmZsb3dPcHRpb25zIiwiaXNCYXNlUGxhY2VtZW50IiwiZmFsbGJhY2tQbGFjZW1lbnRzIiwicGxhY2VtZW50cyIsIm92ZXJmbG93Iiwib3ZlcmZsb3dzIiwib3ZlcmZsb3dzRGF0YSIsInNpZGVzIiwiX21pZGRsZXdhcmVEYXRhJGZsaXAyIiwiX292ZXJmbG93c0RhdGEkZmlsdGVyIiwibmV4dEluZGV4IiwibmV4dFBsYWNlbWVudCIsInJlc2V0UGxhY2VtZW50IiwiX292ZXJmbG93c0RhdGEkbWFwJHNvIiwiX3BsYWNlbWVudCIsIl9jYWxsZWUzJCIsIl9jb250ZXh0MyIsIm1haW5BeGlzIiwiY3Jvc3NBeGlzIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJfZXhjbHVkZWQyIiwiX3RvQ29uc3VtYWJsZUFycmF5IiwiZXZlcnkiLCJzb3J0IiwiYSIsImIiLCJhY2MiLCJzaGlmdCIsIl9jYWxsZWU0IiwiX2V2YWx1YXRlNCIsIl9ldmFsdWF0ZTQkbWFpbkF4aXMiLCJfZXZhbHVhdGU0JGNyb3NzQXhpcyIsIl9ldmFsdWF0ZTQkbGltaXRlciIsImxpbWl0ZXIiLCJtYWluQXhpc0Nvb3JkIiwiY3Jvc3NBeGlzQ29vcmQiLCJtaW5TaWRlIiwibWF4U2lkZSIsIl9taW4iLCJfbWF4IiwiX21pblNpZGUiLCJfbWF4U2lkZSIsIl9taW4yIiwiX21heDIiLCJsaW1pdGVkQ29vcmRzIiwiX2NhbGxlZTQkIiwiX2NvbnRleHQ0IiwiX2V4Y2x1ZGVkNCIsImxpbWl0U2hpZnQiLCJfZXZhbHVhdGUiLCJfZXZhbHVhdGUkb2Zmc2V0IiwiX2V2YWx1YXRlJG1haW5BeGlzIiwiX2V2YWx1YXRlJGNyb3NzQXhpcyIsInJhd09mZnNldCIsImNvbXB1dGVkT2Zmc2V0IiwibGVuIiwibGltaXRNaW4iLCJsaW1pdE1heCIsIl9taWRkbGV3YXJlRGF0YSRvZmZzZSIsIl9taWRkbGV3YXJlRGF0YSRvZmZzZTIiLCJpc09yaWdpblNpZGUiLCJnZXROb2RlTmFtZSIsIm5vZGUiLCJpc05vZGUiLCJub2RlTmFtZSIsInRvTG93ZXJDYXNlIiwiZ2V0V2luZG93IiwiX25vZGUkb3duZXJEb2N1bWVudCIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsIndpbmRvdyIsImRvY3VtZW50RWxlbWVudCIsIk5vZGUiLCJpc0hUTUxFbGVtZW50IiwiaXNTaGFkb3dSb290IiwiU2hhZG93Um9vdCIsImlzT3ZlcmZsb3dFbGVtZW50IiwiX2dldENvbXB1dGVkU3R5bGUiLCJnZXRDb21wdXRlZFN0eWxlIiwib3ZlcmZsb3dYIiwib3ZlcmZsb3dZIiwiZGlzcGxheSIsInRlc3QiLCJpc1RhYmxlRWxlbWVudCIsImlzQ29udGFpbmluZ0Jsb2NrIiwid2Via2l0IiwiaXNXZWJLaXQiLCJjc3MiLCJ0cmFuc2Zvcm0iLCJwZXJzcGVjdGl2ZSIsImNvbnRhaW5lclR5cGUiLCJiYWNrZHJvcEZpbHRlciIsInNvbWUiLCJ3aWxsQ2hhbmdlIiwiY29udGFpbiIsImdldENvbnRhaW5pbmdCbG9jayIsImN1cnJlbnROb2RlIiwiZ2V0UGFyZW50Tm9kZSIsImlzTGFzdFRyYXZlcnNhYmxlTm9kZSIsIkNTUyIsInN1cHBvcnRzIiwiZ2V0Tm9kZVNjcm9sbCIsInNjcm9sbExlZnQiLCJzY3JvbGxUb3AiLCJwYWdlWE9mZnNldCIsInBhZ2VZT2Zmc2V0IiwicmVzdWx0IiwiYXNzaWduZWRTbG90IiwicGFyZW50Tm9kZSIsImhvc3QiLCJnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3RvciIsImdldE92ZXJmbG93QW5jZXN0b3JzIiwiX25vZGUkb3duZXJEb2N1bWVudDIiLCJzY3JvbGxhYmxlQW5jZXN0b3IiLCJpc0JvZHkiLCJ3aW4iLCJ2aXN1YWxWaWV3cG9ydCIsImdldENzc0RpbWVuc2lvbnMiLCJwYXJzZUZsb2F0IiwiaGFzT2Zmc2V0Iiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJzaG91bGRGYWxsYmFjayIsIiQiLCJ1bndyYXBFbGVtZW50IiwiZG9tRWxlbWVudCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIl9nZXRDc3NEaW1lbnNpb25zIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJub09mZnNldHMiLCJnZXRWaXN1YWxPZmZzZXRzIiwib2Zmc2V0TGVmdCIsIm9mZnNldFRvcCIsInNob3VsZEFkZFZpc3VhbE9mZnNldHMiLCJpc0ZpeGVkIiwiZmxvYXRpbmdPZmZzZXRQYXJlbnQiLCJpbmNsdWRlU2NhbGUiLCJpc0ZpeGVkU3RyYXRlZ3kiLCJjbGllbnRSZWN0Iiwic2NhbGUiLCJ2aXN1YWxPZmZzZXRzIiwib2Zmc2V0V2luIiwiY3VycmVudElGcmFtZSIsImZyYW1lRWxlbWVudCIsImlmcmFtZVNjYWxlIiwiaWZyYW1lUmVjdCIsImNsaWVudExlZnQiLCJwYWRkaW5nTGVmdCIsImNsaWVudFRvcCIsInBhZGRpbmdUb3AiLCJpc09mZnNldFBhcmVudEFuRWxlbWVudCIsInNjcm9sbCIsIm9mZnNldHMiLCJvZmZzZXRSZWN0IiwiZ2V0Q2xpZW50UmVjdHMiLCJmcm9tIiwiZ2V0V2luZG93U2Nyb2xsQmFyWCIsImdldERvY3VtZW50UmVjdCIsImh0bWwiLCJzY3JvbGxXaWR0aCIsImNsaWVudFdpZHRoIiwic2Nyb2xsSGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwiZ2V0Vmlld3BvcnRSZWN0IiwidmlzdWFsVmlld3BvcnRCYXNlZCIsImdldElubmVyQm91bmRpbmdDbGllbnRSZWN0IiwiZ2V0Q2xpZW50UmVjdEZyb21DbGlwcGluZ0FuY2VzdG9yIiwiY2xpcHBpbmdBbmNlc3RvciIsImhhc0ZpeGVkUG9zaXRpb25BbmNlc3RvciIsInN0b3BOb2RlIiwicG9zaXRpb24iLCJnZXRDbGlwcGluZ0VsZW1lbnRBbmNlc3RvcnMiLCJjYWNoZSIsImNhY2hlZFJlc3VsdCIsImdldCIsImN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlIiwiZWxlbWVudElzRml4ZWQiLCJjb21wdXRlZFN0eWxlIiwiY3VycmVudE5vZGVJc0NvbnRhaW5pbmciLCJzaG91bGREcm9wQ3VycmVudE5vZGUiLCJhbmNlc3RvciIsInNldCIsImVsZW1lbnRDbGlwcGluZ0FuY2VzdG9ycyIsIl9jIiwiY2xpcHBpbmdBbmNlc3RvcnMiLCJmaXJzdENsaXBwaW5nQW5jZXN0b3IiLCJjbGlwcGluZ1JlY3QiLCJhY2NSZWN0IiwiZ2V0UmVjdFJlbGF0aXZlVG9PZmZzZXRQYXJlbnQiLCJnZXRUcnVlT2Zmc2V0UGFyZW50IiwicG9seWZpbGwiLCJfZ2V0RWxlbWVudFJlY3RzIiwiX2NhbGxlZTUiLCJnZXRPZmZzZXRQYXJlbnRGbiIsImdldERpbWVuc2lvbnNGbiIsIl9jYWxsZWU1JCIsIl9jb250ZXh0NSIsIl94NiIsIm9ic2VydmVNb3ZlIiwib25Nb3ZlIiwiaW8iLCJ0aW1lb3V0SWQiLCJyb290IiwiY2xlYW51cCIsImNsZWFyVGltZW91dCIsImRpc2Nvbm5lY3QiLCJyZWZyZXNoIiwic2tpcCIsInRocmVzaG9sZCIsIl9lbGVtZW50JGdldEJvdW5kaW5nQyIsImluc2V0VG9wIiwiaW5zZXRSaWdodCIsImluc2V0Qm90dG9tIiwiaW5zZXRMZWZ0Iiwicm9vdE1hcmdpbiIsImlzRmlyc3RVcGRhdGUiLCJoYW5kbGVPYnNlcnZlIiwiZW50cmllcyIsInJhdGlvIiwiaW50ZXJzZWN0aW9uUmF0aW8iLCJzZXRUaW1lb3V0IiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJvYnNlcnZlIiwiYXV0b1VwZGF0ZSIsInVwZGF0ZSIsIl9vcHRpb25zIiwiX29wdGlvbnMkYW5jZXN0b3JTY3JvIiwiYW5jZXN0b3JTY3JvbGwiLCJfb3B0aW9ucyRhbmNlc3RvclJlc2kiLCJhbmNlc3RvclJlc2l6ZSIsIl9vcHRpb25zJGVsZW1lbnRSZXNpeiIsImVsZW1lbnRSZXNpemUiLCJSZXNpemVPYnNlcnZlciIsIl9vcHRpb25zJGxheW91dFNoaWZ0IiwibGF5b3V0U2hpZnQiLCJfb3B0aW9ucyRhbmltYXRpb25GcmEiLCJhbmltYXRpb25GcmFtZSIsInJlZmVyZW5jZUVsIiwiYW5jZXN0b3JzIiwicGFzc2l2ZSIsImNsZWFudXBJbyIsInJlb2JzZXJ2ZUZyYW1lIiwicmVzaXplT2JzZXJ2ZXIiLCJfcmVmNyIsIl9zbGljZWRUb0FycmF5IiwiZmlyc3RFbnRyeSIsInVub2JzZXJ2ZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiZnJhbWVJZCIsInByZXZSZWZSZWN0IiwiZnJhbWVMb29wIiwibmV4dFJlZlJlY3QiLCJNYXAiLCJtZXJnZWRPcHRpb25zIiwicGxhdGZvcm1XaXRoQ2FjaGUiLCJzZXR1cFRvb2x0aXAiLCJhdHRhY2hUb09wdGlvbnMiLCJfZ2V0UmVzb2x2ZWRBdHRhY2hUb09wdGlvbnMiLCJmbG9hdGluZ1VJT3B0aW9ucyIsImdldEZsb2F0aW5nVUlPcHRpb25zIiwic2hvdWxkQ2VudGVyIiwiY29udGVudCIsInNoZXBoZXJkRWxlbWVudENvbXBvbmVudCIsImdldEVsZW1lbnQiLCJjbGFzc0xpc3QiLCJhZGQiLCJzZXRQb3NpdGlvbiIsIm1lcmdlVG9vbHRpcENvbmZpZyIsInRvdXJPcHRpb25zIiwiZGVzdHJveVRvb2x0aXAiLCJ0aGVuIiwiZmxvYXRpbmdVSXBvc2l0aW9uIiwiUHJvbWlzZSIsInJlc29sdmUiLCJmb2N1cyIsInByZXZlbnRTY3JvbGwiLCJfcmVmOCIsInN0eWxlIiwiZGF0YXNldCIsInBvcHBlclBsYWNlbWVudCIsInBsYWNlQXJyb3ciLCJhcnJvd0VsIiwiX21pZGRsZXdhcmVEYXRhJGFycm93IiwiYXJyb3dYIiwiYXJyb3dZIiwiYWRkQXJyb3ciLCJub29wIiwidGFyIiwic3JjIiwiayIsInJ1biIsImJsYW5rX29iamVjdCIsImNyZWF0ZSIsInJ1bl9hbGwiLCJmbnMiLCJpc19mdW5jdGlvbiIsInRoaW5nIiwic2FmZV9ub3RfZXF1YWwiLCJpc19lbXB0eSIsIm9iaiIsImFwcGVuZCIsImFwcGVuZENoaWxkIiwiaW5zZXJ0IiwiYW5jaG9yIiwiaW5zZXJ0QmVmb3JlIiwiZGV0YWNoIiwicmVtb3ZlQ2hpbGQiLCJkZXN0cm95X2VhY2giLCJpdGVyYXRpb25zIiwiZGV0YWNoaW5nIiwiY3JlYXRlRWxlbWVudCIsInN2Z19lbGVtZW50IiwiY3JlYXRlRWxlbWVudE5TIiwidGV4dCIsImNyZWF0ZVRleHROb2RlIiwic3BhY2UiLCJlbXB0eSIsImxpc3RlbiIsImF0dHIiLCJhdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJnZXRBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGUiLCJhbHdheXNfc2V0X3Rocm91Z2hfc2V0X2F0dHJpYnV0ZSIsInNldF9hdHRyaWJ1dGVzIiwiYXR0cmlidXRlcyIsImRlc2NyaXB0b3JzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsIl9fcHJvdG9fXyIsImNzc1RleHQiLCJpbmRleE9mIiwiY2hpbGRyZW4iLCJjaGlsZE5vZGVzIiwidG9nZ2xlX2NsYXNzIiwidG9nZ2xlIiwiY3VycmVudF9jb21wb25lbnQiLCJzZXRfY3VycmVudF9jb21wb25lbnQiLCJjb21wb25lbnQiLCJnZXRfY3VycmVudF9jb21wb25lbnQiLCJvbk1vdW50IiwiJCQiLCJvbl9tb3VudCIsImFmdGVyVXBkYXRlIiwiYWZ0ZXJfdXBkYXRlIiwiZGlydHlfY29tcG9uZW50cyIsImJpbmRpbmdfY2FsbGJhY2tzIiwicmVuZGVyX2NhbGxiYWNrcyIsImZsdXNoX2NhbGxiYWNrcyIsInJlc29sdmVkX3Byb21pc2UiLCJ1cGRhdGVfc2NoZWR1bGVkIiwic2NoZWR1bGVfdXBkYXRlIiwiZmx1c2giLCJhZGRfcmVuZGVyX2NhbGxiYWNrIiwic2Vlbl9jYWxsYmFja3MiLCJTZXQiLCJmbHVzaGlkeCIsInNhdmVkX2NvbXBvbmVudCIsInBvcCIsImNhbGxiYWNrIiwiaGFzIiwiY2xlYXIiLCJmcmFnbWVudCIsImJlZm9yZV91cGRhdGUiLCJkaXJ0eSIsInAiLCJmbHVzaF9yZW5kZXJfY2FsbGJhY2tzIiwiZmlsdGVyZWQiLCJ0YXJnZXRzIiwib3V0cm9pbmciLCJvdXRyb3MiLCJncm91cF9vdXRyb3MiLCJjaGVja19vdXRyb3MiLCJ0cmFuc2l0aW9uX2luIiwiYmxvY2siLCJsb2NhbCIsImRlbGV0ZSIsInRyYW5zaXRpb25fb3V0IiwibyIsImdldF9zcHJlYWRfdXBkYXRlIiwibGV2ZWxzIiwidXBkYXRlcyIsInRvX251bGxfb3V0IiwiYWNjb3VudGVkX2ZvciIsIiQkc2NvcGUiLCJuIiwiY3JlYXRlX2NvbXBvbmVudCIsIm1vdW50X2NvbXBvbmVudCIsImN1c3RvbUVsZW1lbnQiLCJfY29tcG9uZW50JCQkIiwibSIsIm5ld19vbl9kZXN0cm95Iiwib25fZGVzdHJveSIsIl9jb21wb25lbnQkJCQkb25fZGVzdCIsImRlc3Ryb3lfY29tcG9uZW50IiwibWFrZV9kaXJ0eSIsImZpbGwiLCJpbml0IiwiaW5zdGFuY2UiLCJjcmVhdGVfZnJhZ21lbnQiLCJub3RfZXF1YWwiLCJwcm9wcyIsImFwcGVuZF9zdHlsZXMiLCJwYXJlbnRfY29tcG9uZW50IiwiYm91bmQiLCJvbl9kaXNjb25uZWN0IiwiY2FsbGJhY2tzIiwic2tpcF9ib3VuZCIsInJlYWR5IiwicmV0IiwiaHlkcmF0ZSIsIm5vZGVzIiwibCIsImludHJvIiwiU3ZlbHRlQ29tcG9uZW50IiwiJGRlc3Ryb3kiLCIkb24iLCJ0eXBlIiwiJHNldCIsIiQkcHJvcHMiLCIkJHNldCIsImJ1dHRvbiIsImJ1dHRvbl9jbGFzc192YWx1ZSIsImFjdGlvbiIsImNsYXNzZXMiLCJkaXNhYmxlZCIsImxhYmVsIiwic2Vjb25kYXJ5IiwiZ2V0Q29uZmlnT3B0aW9uIiwib3B0aW9uIiwiJCRpbnZhbGlkYXRlIiwiZWFjaF9ibG9ja3MiLCJjcmVhdGVfaWZfYmxvY2skMyIsImZvb3RlciIsImJ1dHRvbnMiLCJidXR0b25fYXJpYV9sYWJlbF92YWx1ZSIsInNwYW4iLCJjYW5jZWxJY29uIiwiaGFuZGxlQ2FuY2VsQ2xpY2siLCJwcmV2ZW50RGVmYXVsdCIsImNhbmNlbCIsImgzIiwibGFiZWxJZCIsInRpdGxlIiwiaW5uZXJIVE1MIiwiJCR2YWx1ZSIsImNyZWF0ZV9pZl9ibG9ja18xJDEiLCJlbmFibGVkIiwiY3JlYXRlX2lmX2Jsb2NrJDIiLCJoZWFkZXIiLCJkaXYiLCJkZXNjcmlwdGlvbklkIiwic2hvd19pZl8yIiwic2hvd19pZl8xIiwic2hvd19pZiIsImNyZWF0ZV9pZl9ibG9jayIsImRpdl9hcmlhX2Rlc2NyaWJlZGJ5X3ZhbHVlIiwiY3VycmVudCIsIktFWV9UQUIiLCJLRVlfRVNDIiwiTEVGVF9BUlJPVyIsIlJJR0hUX0FSUk9XIiwiZ2V0Q2xhc3Nlc0FycmF5IiwiY2xhc3NOYW1lIiwiY2xhc3NQcmVmaXgiLCJmaXJzdEZvY3VzYWJsZUVsZW1lbnQiLCJmb2N1c2FibGVFbGVtZW50cyIsImxhc3RGb2N1c2FibGVFbGVtZW50IiwiZGF0YVN0ZXBJZCIsImhhc0NhbmNlbEljb24iLCJoYXNUaXRsZSIsImlkIiwicXVlcnlTZWxlY3RvckFsbCIsInVwZGF0ZUR5bmFtaWNDbGFzc2VzIiwicmVtb3ZlQ2xhc3NlcyIsImFkZENsYXNzZXMiLCJvbGRDbGFzc2VzIiwiX2VsZW1lbnQkY2xhc3NMaXN0IiwicmVtb3ZlIiwibmV3Q2xhc3NlcyIsIl9lbGVtZW50JGNsYXNzTGlzdDIiLCJoYW5kbGVLZXlEb3duIiwiX3N0ZXAiLCJrZXlDb2RlIiwic2hpZnRLZXkiLCJhY3RpdmVFbGVtZW50IiwiY29udGFpbnMiLCJleGl0T25Fc2MiLCJzdG9wUHJvcGFnYXRpb24iLCJrZXlib2FyZE5hdmlnYXRpb24iLCJiYWNrIiwiU3RlcCIsIl9FdmVudGVkIiwiX2luaGVyaXRzIiwiX3RoaXMxMSIsIl9jYWxsU3VwZXIiLCJzdHlsZXMiLCJfcmVzb2x2ZWRBdHRhY2hUbyIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJfc2V0T3B0aW9ucyIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiY29tcGxldGUiLCJkZXN0cm95IiwiX3VwZGF0ZVN0ZXBUYXJnZXRPbkhpZGUiLCJnZXRUb3VyIiwiaGlkZSIsIm1vZGFsIiwiaGlkZGVuIiwiX3Jlc29sdmVBdHRhY2hUb09wdGlvbnMiLCJzaG93IiwiX3RoaXMxMiIsImJlZm9yZVNob3dQcm9taXNlIiwiX3Nob3ciLCJ1cGRhdGVTdGVwT3B0aW9ucyIsImdldFRhcmdldCIsIl9jcmVhdGVUb29sdGlwQ29udGVudCIsIlNoZXBoZXJkX2VsZW1lbnQiLCJzdGVwc0NvbnRhaW5lciIsIl9zY3JvbGxUbyIsInNjcm9sbFRvT3B0aW9ucyIsIl90aGlzJF9nZXRSZXNvbHZlZEF0dCIsInNjcm9sbFRvSGFuZGxlciIsInNjcm9sbEludG9WaWV3IiwiX2dldENsYXNzT3B0aW9ucyIsInN0ZXBPcHRpb25zIiwiZGVmYXVsdFN0ZXBPcHRpb25zIiwic3RlcENsYXNzZXMiLCJkZWZhdWx0U3RlcE9wdGlvbnNDbGFzc2VzIiwiYWxsQ2xhc3NlcyIsInVuaXFDbGFzc2VzIiwiam9pbiIsInRyaW0iLCJfdGhpczEzIiwid2hlbiIsIl9zZXR1cEVsZW1lbnRzIiwiX3RoaXMxNCIsIl9zZXR1cE1vZGFsIiwic2V0dXBGb3JTdGVwIiwiX3N0eWxlVGFyZ2V0RWxlbWVudEZvclN0ZXAiLCJzY3JvbGxUbyIsInRhcmdldEVsZW1lbnQiLCJoaWdobGlnaHRDbGFzcyIsImNhbkNsaWNrVGFyZ2V0IiwiY2xlYW51cFN0ZXBzIiwic3RlcHMiLCJtYWtlT3ZlcmxheVBhdGgiLCJfcmVmMjUiLCJfcmVmMjUkeCIsIl9yZWYyNSR5IiwiX3JlZjI1JHIiLCJfd2luZG93IiwidyIsImlubmVyV2lkdGgiLCJoIiwiaW5uZXJIZWlnaHQiLCJfcmVmMjYiLCJ0b3BMZWZ0IiwidG9wUmlnaHQiLCJib3R0b21SaWdodCIsImJvdHRvbUxlZnQiLCJfcmVmMjYkdG9wTGVmdCIsIl9yZWYyNiR0b3BSaWdodCIsIl9yZWYyNiRib3R0b21SaWdodCIsIl9yZWYyNiRib3R0b21MZWZ0Iiwic3ZnIiwicGF0aCIsIl9nZXRTY3JvbGxQYXJlbnQiLCJpc0h0bWxFbGVtZW50IiwiaXNTY3JvbGxhYmxlIiwicGFyZW50RWxlbWVudCIsIl9nZXRWaXNpYmxlSGVpZ2h0Iiwic2Nyb2xsUGFyZW50IiwiZWxlbWVudFJlY3QiLCJzY3JvbGxSZWN0Iiwic2Nyb2xsQm90dG9tIiwib3BlbmluZ1Byb3BlcnRpZXMiLCJtb2RhbElzVmlzaWJsZSIsInJhZklkIiwicGF0aERlZmluaXRpb24iLCJjbG9zZU1vZGFsT3BlbmluZyIsIl9jbGVhbnVwU3RlcEV2ZW50TGlzdGVuZXJzIiwicG9zaXRpb25Nb2RhbCIsIm1vZGFsT3ZlcmxheU9wZW5pbmdQYWRkaW5nIiwibW9kYWxPdmVybGF5T3BlbmluZ1JhZGl1cyIsIl9nZXRWaXNpYmxlSGVpZ2h0MiIsIl90YXJnZXRFbGVtZW50JGdldEJvdSIsInVzZU1vZGFsT3ZlcmxheSIsIl9zdHlsZUZvclN0ZXAiLCJfcHJldmVudE1vZGFsQm9keVRvdWNoIiwiX3ByZXZlbnRNb2RhbE92ZXJsYXlUb3VjaCIsIl9hZGRTdGVwRXZlbnRMaXN0ZW5lcnMiLCJfc3RlcCRvcHRpb25zIiwicmFmTG9vcCIsIlNoZXBoZXJkIiwiVG91ciIsIl9FdmVudGVkMiIsIl90aGlzMTYiLCJkZWZhdWx0VG91ck9wdGlvbnMiLCJhZGRTdGVwcyIsImV2ZW50cyIsIm9wdHMiLCJfc2V0VG91cklEIiwiYWRkU3RlcCIsIl90aGlzMTciLCJjdXJyZW50U3RlcCIsIl9jYW5jZWwiLCJfY2FsbGVlNiIsImNvbmZpcm1DYW5jZWxJc0Z1bmN0aW9uIiwiY2FuY2VsTWVzc2FnZSIsInN0b3BUb3VyIiwiX2NhbGxlZTYkIiwiX2NvbnRleHQ2IiwiY29uZmlybUNhbmNlbCIsImNvbmZpcm1DYW5jZWxNZXNzYWdlIiwiY29uZmlybSIsIl9kb25lIiwiZ2V0QnlJZCIsImZpbmQiLCJnZXRDdXJyZW50U3RlcCIsImlzQWN0aXZlIiwiYWN0aXZlVG91ciIsInJlbW92ZVN0ZXAiLCJfdGhpczE4IiwiZm9yd2FyZCIsIl91cGRhdGVTdGF0ZUJlZm9yZVNob3ciLCJzaG91bGRTa2lwU3RlcCIsInNob3dPbiIsIl9za2lwU3RlcCIsInByZXZpb3VzIiwiZm9jdXNlZEVsQmVmb3JlT3BlbiIsIl9zZXR1cEFjdGl2ZVRvdXIiLCJtb2RhbENvbnRhaW5lciIsIlNoZXBoZXJkX21vZGFsIiwidG91ck5hbWUiLCJpc1NlcnZlclNpZGUiLCJOb09wIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/shepherd.js/dist/js/shepherd.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./libs/shepherd/shepherd.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});